<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.forecasting API documentation</title>
<meta name="description" content="Provide forecasting capabilities for financial statement graphs …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.forecasting</code></h1>
</header>
<section id="section-intro">
<p>Provide forecasting capabilities for financial statement graphs.</p>
<p>This sub-module offers:
- Multiple forecast methods (simple, curve, statistical, average, historical_growth)
- Mutating and non-mutating forecast operations on graphs
- Extensible registry for custom forecast methods
- Utilities for period management and validation</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
&gt;&gt;&gt; forecaster = StatementForecaster(graph)
&gt;&gt;&gt;
&gt;&gt;&gt; # Mutating forecast - modifies the graph
&gt;&gt;&gt; forecaster.create_forecast(
...     forecast_periods=[&quot;2024&quot;, &quot;2025&quot;],
...     node_configs={
...         &quot;revenue&quot;: {&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05},
...         &quot;costs&quot;: {&quot;method&quot;: &quot;curve&quot;, &quot;config&quot;: [0.03, 0.04]}
...     }
... )
&gt;&gt;&gt;
&gt;&gt;&gt; # Non-mutating forecast - returns values without modifying graph
&gt;&gt;&gt; values = forecaster.forecast_value(
...     &quot;revenue&quot;,
...     forecast_periods=[&quot;2024&quot;, &quot;2025&quot;],
...     forecast_config={&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05}
... )
</code></pre>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.forecasting.errors" href="errors.html">fin_statement_model.forecasting.errors</a></code></dt>
<dd>
<div class="desc"><p>Define custom exceptions for forecasting operations …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.forecaster" href="forecaster.html">fin_statement_model.forecasting.forecaster</a></code></dt>
<dd>
<div class="desc"><p>Provide forecasting operations for financial statement graphs …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.methods" href="methods/index.html">fin_statement_model.forecasting.methods</a></code></dt>
<dd>
<div class="desc"><p>Provide built-in forecast method implementations …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.period_manager" href="period_manager.html">fin_statement_model.forecasting.period_manager</a></code></dt>
<dd>
<div class="desc"><p>Provide utilities for inferring and managing periods in forecasting …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.strategies" href="strategies.html">fin_statement_model.forecasting.strategies</a></code></dt>
<dd>
<div class="desc"><p>Provide a registry and selection strategies for forecast methods …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.types" href="types.html">fin_statement_model.forecasting.types</a></code></dt>
<dd>
<div class="desc"><p>Define types and data structures for the forecasting module …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.validators" href="validators.html">fin_statement_model.forecasting.validators</a></code></dt>
<dd>
<div class="desc"><p>Validate inputs for forecasting operations …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.forecasting.get_forecast_method"><code class="name flex">
<span>def <span class="ident">get_forecast_method</span></span>(<span>name: str) ‑> <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forecast_method(name: str) -&gt; ForecastMethod:
    &#34;&#34;&#34;Retrieve a forecast method from the global registry.

    Args:
        name: The name of the method to retrieve.

    Returns:
        The requested forecast method.

    Raises:
        ValueError: If the method is not registered.
    &#34;&#34;&#34;
    return forecast_registry.get_method(name)</code></pre>
</details>
<div class="desc"><p>Retrieve a forecast method from the global registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested forecast method.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the method is not registered.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.register_forecast_method"><code class="name flex">
<span>def <span class="ident">register_forecast_method</span></span>(<span>method: <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_forecast_method(method: ForecastMethod) -&gt; None:
    &#34;&#34;&#34;Register a custom forecast method in the global registry.

    Args:
        method: The forecast method to register.

    Raises:
        ValueError: If a method with the same name is already registered.
    &#34;&#34;&#34;
    forecast_registry.register(method)</code></pre>
</details>
<div class="desc"><p>Register a custom forecast method in the global registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The forecast method to register.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a method with the same name is already registered.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.forecasting.AverageForecastMethod"><code class="flex name class">
<span>class <span class="ident">AverageForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AverageForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values as the historical average of available data.

    This method calculates forecast values as the historical average of available
    data points. Useful for stable metrics or when expecting mean reversion.

    Configuration:
        - Not required (pass None or 0)

    Example:
        &gt;&gt;&gt; method = AverageForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; # Returns: {&#34;forecast_type&#34;: &#34;average&#34;, &#34;growth_params&#34;: None}
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        return &#34;average&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;
        return &#34;average&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for average method.

        Args:
            config: Not used for average method, can be None or 0.

        Note:
            Average method doesn&#39;t require configuration as it uses
            historical data automatically.
        &#34;&#34;&#34;
        # Average method doesn&#39;t need specific configuration
        # Accept None, 0, or any placeholder value

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Not used for average method.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            For average method, growth_params is None.
        &#34;&#34;&#34;
        return {
            &#34;forecast_type&#34;: self.internal_type,
            &#34;growth_params&#34;: None,  # Average method doesn&#39;t use growth params
        }

    def prepare_historical_data(
        self, node: Node, historical_periods: list[str]
    ) -&gt; Optional[list[float]]:
        &#34;&#34;&#34;Prepare historical data for average calculation.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of valid historical values.

        Raises:
            ValueError: If no valid historical data is available.
        &#34;&#34;&#34;
        if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
            raise ValueError(
                f&#34;Node {node.name} cannot be calculated for average method&#34;
            )

        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ValueError(
                f&#34;Node {node.name} does not have values dictionary for average method&#34;
            )

        # Extract historical values
        historical_values = []
        for period in historical_periods:
            if period in node.values:
                try:
                    value = node.calculate(period)
                    if (
                        value is not None
                        and not np.isnan(value)
                        and not np.isinf(value)
                    ):
                        historical_values.append(float(value))
                except Exception as e:
                    # Log the exception and skip this period
                    logger.debug(
                        f&#34;Skipping period {period} for node {node.name} in average calculation: {e}&#34;
                    )
                    continue

        if not historical_values:
            raise ValueError(
                f&#34;No valid historical data available for node {node.name} to compute average&#34;
            )

        return historical_values</code></pre>
</details>
<div class="desc"><p>Forecast future values as the historical average of available data.</p>
<p>This method calculates forecast values as the historical average of available
data points. Useful for stable metrics or when expecting mean reversion.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Not required (pass None or 0)</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = AverageForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(None, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;average&quot;, &quot;growth_params&quot;: None}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Not used for average method.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        For average method, growth_params is None.
    &#34;&#34;&#34;
    return {
        &#34;forecast_type&#34;: self.internal_type,
        &#34;growth_params&#34;: None,  # Average method doesn&#39;t use growth params
    }</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for average method.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
For average method, growth_params is None.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(
    self, node: Node, historical_periods: list[str]
) -&gt; Optional[list[float]]:
    &#34;&#34;&#34;Prepare historical data for average calculation.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of valid historical values.

    Raises:
        ValueError: If no valid historical data is available.
    &#34;&#34;&#34;
    if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
        raise ValueError(
            f&#34;Node {node.name} cannot be calculated for average method&#34;
        )

    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ValueError(
            f&#34;Node {node.name} does not have values dictionary for average method&#34;
        )

    # Extract historical values
    historical_values = []
    for period in historical_periods:
        if period in node.values:
            try:
                value = node.calculate(period)
                if (
                    value is not None
                    and not np.isnan(value)
                    and not np.isinf(value)
                ):
                    historical_values.append(float(value))
            except Exception as e:
                # Log the exception and skip this period
                logger.debug(
                    f&#34;Skipping period {period} for node {node.name} in average calculation: {e}&#34;
                )
                continue

    if not historical_values:
        raise ValueError(
            f&#34;No valid historical data available for node {node.name} to compute average&#34;
        )

    return historical_values</code></pre>
</details>
<div class="desc"><p>Prepare historical data for average calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of valid historical values.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no valid historical data is available.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for average method.

    Args:
        config: Not used for average method, can be None or 0.

    Note:
        Average method doesn&#39;t require configuration as it uses
        historical data automatically.
    &#34;&#34;&#34;
    # Average method doesn&#39;t need specific configuration
    # Accept None, 0, or any placeholder value</code></pre>
</details>
<div class="desc"><p>Validate the configuration for average method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for average method, can be None or 0.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Average method doesn't require configuration as it uses
historical data automatically.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.name" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod"><code class="flex name class">
<span>class <span class="ident">BaseForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseForecastMethod(ABC):
    &#34;&#34;&#34;Provide an abstract base class for forecast methods.

    Enforces the forecast method interface and provides common functionality,
    including the get_forecast_params convenience method.
    &#34;&#34;&#34;

    @property
    @abstractmethod
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;

    @property
    @abstractmethod
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;

    @abstractmethod
    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for this method.&#34;&#34;&#34;

    @abstractmethod
    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.&#34;&#34;&#34;

    def prepare_historical_data(
        self, node: Node, historical_periods: list[str]
    ) -&gt; Optional[list[float]]:
        &#34;&#34;&#34;Prepare historical data for methods that need it.

        Default implementation returns None (not needed).
        Override in methods that require historical data.
        &#34;&#34;&#34;
        return None

    def get_forecast_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get complete forecast parameters.

        This is a convenience method that validates and normalizes in one call.

        Args:
            config: The method-specific configuration.
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

        Raises:
            ValueError: If configuration is invalid.
        &#34;&#34;&#34;
        self.validate_config(config)
        return self.normalize_params(config, forecast_periods)</code></pre>
</details>
<div class="desc"><p>Provide an abstract base class for forecast methods.</p>
<p>Enforces the forecast method interface and provides common functionality,
including the get_forecast_params convenience method.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.average.AverageForecastMethod" href="methods/average.html#fin_statement_model.forecasting.methods.average.AverageForecastMethod">AverageForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.curve.CurveForecastMethod" href="methods/curve.html#fin_statement_model.forecasting.methods.curve.CurveForecastMethod">CurveForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod" href="methods/historical_growth.html#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod">HistoricalGrowthForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.simple.SimpleForecastMethod" href="methods/simple.html#fin_statement_model.forecasting.methods.simple.SimpleForecastMethod">SimpleForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.statistical.StatisticalForecastMethod" href="methods/statistical.html#fin_statement_model.forecasting.methods.statistical.StatisticalForecastMethod">StatisticalForecastMethod</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type for NodeFactory.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.get_forecast_params"><code class="name flex">
<span>def <span class="ident">get_forecast_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forecast_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get complete forecast parameters.

    This is a convenience method that validates and normalizes in one call.

    Args:
        config: The method-specific configuration.
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

    Raises:
        ValueError: If configuration is invalid.
    &#34;&#34;&#34;
    self.validate_config(config)
    return self.normalize_params(config, forecast_periods)</code></pre>
</details>
<div class="desc"><p>Get complete forecast parameters.</p>
<p>This is a convenience method that validates and normalizes in one call.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is invalid.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(
    self, node: Node, historical_periods: list[str]
) -&gt; Optional[list[float]]:
    &#34;&#34;&#34;Prepare historical data for methods that need it.

    Default implementation returns None (not needed).
    Override in methods that require historical data.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
<div class="desc"><p>Prepare historical data for methods that need it.</p>
<p>Default implementation returns None (not needed).
Override in methods that require historical data.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for this method.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Validate the configuration for this method.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.CurveForecastMethod"><code class="flex name class">
<span>class <span class="ident">CurveForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurveForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values using variable growth rates per period.

    This method applies different growth rates for each forecast period,
    allowing non-linear growth patterns across periods.

    Configuration:
        - Single numeric value: Will be expanded to match forecast periods
        - List of numeric values: One growth rate per forecast period

    Example:
        &gt;&gt;&gt; method = CurveForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params([0.05, 0.04, 0.03], [&#34;2024&#34;, &#34;2025&#34;, &#34;2026&#34;])
        &gt;&gt;&gt; # Returns: {&#34;forecast_type&#34;: &#34;curve&#34;, &#34;growth_params&#34;: [0.05, 0.04, 0.03]}
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        return &#34;curve&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;
        return &#34;curve&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for curve method.

        Args:
            config: Should be a numeric value or a list of numeric values.

        Raises:
            ValueError: If config is empty list.
            TypeError: If config is not numeric or list of numerics.
        &#34;&#34;&#34;
        if isinstance(config, list):
            if not config:
                raise ValueError(&#34;Curve method: empty list provided&#34;)
            for i, value in enumerate(config):
                if not isinstance(value, int | float):
                    raise TypeError(
                        f&#34;Curve method: non-numeric value at index {i}: {type(value)}&#34;
                    )
        elif not isinstance(config, int | float):
            raise TypeError(
                f&#34;Curve method requires numeric or list of numeric values, got {type(config)}&#34;
            )

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Growth rates (single value or list).
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

        Raises:
            ValueError: If list length doesn&#39;t match forecast periods.
        &#34;&#34;&#34;
        if not isinstance(config, list):
            # Single value - expand to match forecast periods
            growth_rates = [float(config)] * len(forecast_periods)
        else:
            # List of values - must match forecast periods length
            if len(config) != len(forecast_periods):
                raise ValueError(
                    f&#34;Curve method: growth rate list length ({len(config)}) &#34;
                    f&#34;must match forecast periods ({len(forecast_periods)})&#34;
                )
            growth_rates = [float(x) for x in config]

        return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rates}</code></pre>
</details>
<div class="desc"><p>Forecast future values using variable growth rates per period.</p>
<p>This method applies different growth rates for each forecast period,
allowing non-linear growth patterns across periods.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Single numeric value: Will be expanded to match forecast periods</li>
<li>List of numeric values: One growth rate per forecast period</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = CurveForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params([0.05, 0.04, 0.03], [&quot;2024&quot;, &quot;2025&quot;, &quot;2026&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;curve&quot;, &quot;growth_params&quot;: [0.05, 0.04, 0.03]}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.CurveForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Growth rates (single value or list).
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

    Raises:
        ValueError: If list length doesn&#39;t match forecast periods.
    &#34;&#34;&#34;
    if not isinstance(config, list):
        # Single value - expand to match forecast periods
        growth_rates = [float(config)] * len(forecast_periods)
    else:
        # List of values - must match forecast periods length
        if len(config) != len(forecast_periods):
            raise ValueError(
                f&#34;Curve method: growth rate list length ({len(config)}) &#34;
                f&#34;must match forecast periods ({len(forecast_periods)})&#34;
            )
        growth_rates = [float(x) for x in config]

    return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rates}</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Growth rates (single value or list).</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If list length doesn't match forecast periods.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.CurveForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for curve method.

    Args:
        config: Should be a numeric value or a list of numeric values.

    Raises:
        ValueError: If config is empty list.
        TypeError: If config is not numeric or list of numerics.
    &#34;&#34;&#34;
    if isinstance(config, list):
        if not config:
            raise ValueError(&#34;Curve method: empty list provided&#34;)
        for i, value in enumerate(config):
            if not isinstance(value, int | float):
                raise TypeError(
                    f&#34;Curve method: non-numeric value at index {i}: {type(value)}&#34;
                )
    elif not isinstance(config, int | float):
        raise TypeError(
            f&#34;Curve method requires numeric or list of numeric values, got {type(config)}&#34;
        )</code></pre>
</details>
<div class="desc"><p>Validate the configuration for curve method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Should be a numeric value or a list of numeric values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If config is empty list.</dd>
<dt><code>TypeError</code></dt>
<dd>If config is not numeric or list of numerics.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.name" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfig"><code class="flex name class">
<span>class <span class="ident">ForecastConfig</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastConfig(BaseModel):
    &#34;&#34;&#34;Define configuration for a forecast operation.

    Enforces method selection and method-specific parameters.
    &#34;&#34;&#34;

    method: ForecastMethodType
    config: Any  # Method-specific configuration

    model_config = ConfigDict(extra=&#34;forbid&#34;)

    @model_validator(mode=&#34;after&#34;)  # type: ignore[arg-type]
    def _validate_config(cls, values: &#34;ForecastConfig&#34;) -&gt; &#34;ForecastConfig&#34;:
        method = values.method
        cfg = values.config or {}

        valid_methods = {
            &#34;simple&#34;,
            &#34;curve&#34;,
            &#34;statistical&#34;,
            &#34;average&#34;,
            &#34;historical_growth&#34;,
        }

        if method not in valid_methods:
            raise ForecastMethodError(
                &#34;Invalid forecast method&#34;,
                method=method,
                supported_methods=list(valid_methods),
            )

        if method == &#34;statistical&#34;:
            # Delegate validation to StatisticalConfig for detailed checks
            try:
                (
                    StatisticalConfig(**cfg)
                    if isinstance(cfg, dict)
                    else StatisticalConfig.model_validate(cfg)
                )
            except (ForecastConfigurationError, ValidationError) as exc:
                # Re-raise as ForecastConfigurationError for consistency
                raise ForecastConfigurationError(
                    &#34;Invalid statistical configuration&#34;,
                    config=cfg,
                ) from exc

        return values</code></pre>
</details>
<div class="desc"><p>Define configuration for a forecast operation.</p>
<p>Enforces method selection and method-specific parameters.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastConfig.config"><code class="name">var <span class="ident">config</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfig.method"><code class="name">var <span class="ident">method</span> : Literal['simple', 'curve', 'statistical', 'average', 'historical_growth']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfig.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfigurationError"><code class="flex name class">
<span>class <span class="ident">ForecastConfigurationError</span></span>
<span>(</span><span>message: str,<br>config: dict[str, typing.Any] | None = None,<br>missing_params: list[str] | None = None,<br>invalid_params: dict[str, str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastConfigurationError(ForecastingError):
    &#34;&#34;&#34;Exception raised for invalid forecast configuration.

    This includes missing required parameters, invalid parameter values,
    or incompatible configuration combinations.
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        config: Optional[dict[str, Any]] = None,
        missing_params: Optional[list[str]] = None,
        invalid_params: Optional[dict[str, str]] = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastConfigurationError.

        Args:
            message: The primary error message.
            config: Optional configuration dictionary that caused the error.
            missing_params: Optional list of missing required parameters.
            invalid_params: Optional dict of parameter names to error descriptions.
        &#34;&#34;&#34;
        self.config = config
        self.missing_params = missing_params or []
        self.invalid_params = invalid_params or {}

        details = []
        if missing_params:
            details.append(f&#34;Missing parameters: {&#39;, &#39;.join(missing_params)}&#34;)
        if invalid_params:
            param_errors = [f&#34;{k}: {v}&#34; for k, v in invalid_params.items()]
            details.append(f&#34;Invalid parameters: {&#39;; &#39;.join(param_errors)}&#34;)

        full_message = message
        if details:
            full_message = f&#34;{message} - {&#39; | &#39;.join(details)}&#34;

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for invalid forecast configuration.</p>
<p>This includes missing required parameters, invalid parameter values,
or incompatible configuration combinations.</p>
<p>Initialize a ForecastConfigurationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Optional configuration dictionary that caused the error.</dd>
<dt><strong><code>missing_params</code></strong></dt>
<dd>Optional list of missing required parameters.</dd>
<dt><strong><code>invalid_params</code></strong></dt>
<dd>Optional dict of parameter names to error descriptions.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethod"><code class="flex name class">
<span>class <span class="ident">ForecastMethod</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class ForecastMethod(Protocol):
    &#34;&#34;&#34;Protocol for forecast methods to implement.

    All forecast methods must provide a name property and implement
    validate_config and normalize_params, optionally prepare_historical_data.
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        ...

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for this method.

        Args:
            config: The method-specific configuration to validate.

        Raises:
            ValueError: If configuration is invalid.
        &#34;&#34;&#34;
        ...

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: The method-specific configuration.
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        &#34;&#34;&#34;
        ...

    def prepare_historical_data(
        self, node: Node, historical_periods: list[str]
    ) -&gt; Optional[list[float]]:
        &#34;&#34;&#34;Prepare historical data for methods that need it.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of historical values or None if not needed.
        &#34;&#34;&#34;
        ...</code></pre>
</details>
<div class="desc"><p>Protocol for forecast methods to implement.</p>
<p>All forecast methods must provide a name property and implement
validate_config and normalize_params, optionally prepare_historical_data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Return the method name.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: The method-specific configuration.
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(
    self, node: Node, historical_periods: list[str]
) -&gt; Optional[list[float]]:
    &#34;&#34;&#34;Prepare historical data for methods that need it.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of historical values or None if not needed.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Prepare historical data for methods that need it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of historical values or None if not needed.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for this method.

    Args:
        config: The method-specific configuration to validate.

    Raises:
        ValueError: If configuration is invalid.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Validate the configuration for this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration to validate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is invalid.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodError"><code class="flex name class">
<span>class <span class="ident">ForecastMethodError</span></span>
<span>(</span><span>message: str,<br>method: str | None = None,<br>supported_methods: list[str] | None = None,<br>node_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastMethodError(ForecastingError):
    &#34;&#34;&#34;Exception raised for invalid or unsupported forecast methods.

    This includes unknown method names, invalid method parameters,
    or methods incompatible with the data type.
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        method: Optional[str] = None,
        supported_methods: Optional[list[str]] = None,
        node_id: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastMethodError.

        Args:
            message: The primary error message.
            method: Optional name of the invalid method.
            supported_methods: Optional list of supported methods.
            node_id: Optional ID of the node being forecasted.
        &#34;&#34;&#34;
        self.method = method
        self.supported_methods = supported_methods or []
        self.node_id = node_id

        full_message = message
        if method:
            full_message = f&#34;{message}: &#39;{method}&#39;&#34;
        if node_id:
            full_message = f&#34;{full_message} for node &#39;{node_id}&#39;&#34;
        if supported_methods:
            full_message = (
                f&#34;{full_message}. Supported methods: {&#39;, &#39;.join(supported_methods)}&#34;
            )

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for invalid or unsupported forecast methods.</p>
<p>This includes unknown method names, invalid method parameters,
or methods incompatible with the data type.</p>
<p>Initialize a ForecastMethodError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Optional name of the invalid method.</dd>
<dt><strong><code>supported_methods</code></strong></dt>
<dd>Optional list of supported methods.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node being forecasted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry"><code class="flex name class">
<span>class <span class="ident">ForecastMethodRegistry</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastMethodRegistry:
    &#34;&#34;&#34;Manage forecast methods in a registry.

    Provides methods to register, unregister, retrieve, and list available
    forecast methods. Supports querying method metadata.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; method = registry.get_method(&#39;simple&#39;)
        &gt;&gt;&gt; print(registry.list_methods())
        [&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;, &#39;average&#39;, &#39;historical_growth&#39;]
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize the registry with built-in methods.&#34;&#34;&#34;
        self._methods: dict[str, ForecastMethod] = {}
        self._register_builtin_methods()

    def _register_builtin_methods(self) -&gt; None:
        &#34;&#34;&#34;Register all built-in forecast methods.&#34;&#34;&#34;
        builtin_methods = [
            SimpleForecastMethod(),
            CurveForecastMethod(),
            StatisticalForecastMethod(),
            AverageForecastMethod(),
            HistoricalGrowthForecastMethod(),
        ]

        for method in builtin_methods:
            self.register(method)
            logger.debug(f&#34;Registered built-in forecast method: {method.name}&#34;)

    def register(self, method: ForecastMethod) -&gt; None:
        &#34;&#34;&#34;Register a new forecast method.

        Args:
            method: The forecast method to register.

        Raises:
            ValueError: If a method with the same name is already registered.
        &#34;&#34;&#34;
        if method.name in self._methods:
            raise ValueError(f&#34;Forecast method &#39;{method.name}&#39; is already registered&#34;)

        self._methods[method.name] = method
        logger.info(f&#34;Registered forecast method: {method.name}&#34;)

    def unregister(self, name: str) -&gt; None:
        &#34;&#34;&#34;Unregister a forecast method.

        Args:
            name: The name of the method to unregister.

        Raises:
            KeyError: If the method is not registered.
        &#34;&#34;&#34;
        if name not in self._methods:
            raise KeyError(f&#34;Forecast method &#39;{name}&#39; is not registered&#34;)

        del self._methods[name]
        logger.info(f&#34;Unregistered forecast method: {name}&#34;)

    def get_method(self, name: str) -&gt; ForecastMethod:
        &#34;&#34;&#34;Get a forecast method by name.

        Args:
            name: The name of the method to retrieve.

        Returns:
            The requested forecast method.

        Raises:
            ValueError: If the method is not registered.
        &#34;&#34;&#34;
        if name not in self._methods:
            available = &#34;, &#34;.join(sorted(self._methods.keys()))
            raise ValueError(
                f&#34;Unknown forecast method: &#39;{name}&#39;. Available methods: {available}&#34;
            )

        return self._methods[name]

    def list_methods(self) -&gt; list[str]:
        &#34;&#34;&#34;List all available forecast methods.

        Returns:
            Sorted list of registered method names.
        &#34;&#34;&#34;
        return sorted(self._methods.keys())

    def has_method(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Check if a method is registered.

        Args:
            name: The name of the method to check.

        Returns:
            True if the method is registered, False otherwise.
        &#34;&#34;&#34;
        return name in self._methods

    def get_method_info(self, name: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get information about a forecast method.

        Args:
            name: The name of the method.

        Returns:
            Dictionary with method information including docstring.

        Raises:
            ValueError: If the method is not registered.
        &#34;&#34;&#34;
        method = self.get_method(name)
        return {
            &#34;name&#34;: method.name,
            &#34;class&#34;: method.__class__.__name__,
            &#34;description&#34;: method.__class__.__doc__ or &#34;No description available&#34;,
            &#34;module&#34;: method.__class__.__module__,
        }</code></pre>
</details>
<div class="desc"><p>Manage forecast methods in a registry.</p>
<p>Provides methods to register, unregister, retrieve, and list available
forecast methods. Supports querying method metadata.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; method = registry.get_method('simple')
&gt;&gt;&gt; print(registry.list_methods())
['simple', 'curve', 'statistical', 'average', 'historical_growth']
</code></pre>
<p>Initialize the registry with built-in methods.</p></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.get_method"><code class="name flex">
<span>def <span class="ident">get_method</span></span>(<span>self, name: str) ‑> <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method(self, name: str) -&gt; ForecastMethod:
    &#34;&#34;&#34;Get a forecast method by name.

    Args:
        name: The name of the method to retrieve.

    Returns:
        The requested forecast method.

    Raises:
        ValueError: If the method is not registered.
    &#34;&#34;&#34;
    if name not in self._methods:
        available = &#34;, &#34;.join(sorted(self._methods.keys()))
        raise ValueError(
            f&#34;Unknown forecast method: &#39;{name}&#39;. Available methods: {available}&#34;
        )

    return self._methods[name]</code></pre>
</details>
<div class="desc"><p>Get a forecast method by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested forecast method.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the method is not registered.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.get_method_info"><code class="name flex">
<span>def <span class="ident">get_method_info</span></span>(<span>self, name: str) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method_info(self, name: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get information about a forecast method.

    Args:
        name: The name of the method.

    Returns:
        Dictionary with method information including docstring.

    Raises:
        ValueError: If the method is not registered.
    &#34;&#34;&#34;
    method = self.get_method(name)
    return {
        &#34;name&#34;: method.name,
        &#34;class&#34;: method.__class__.__name__,
        &#34;description&#34;: method.__class__.__doc__ or &#34;No description available&#34;,
        &#34;module&#34;: method.__class__.__module__,
    }</code></pre>
</details>
<div class="desc"><p>Get information about a forecast method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with method information including docstring.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the method is not registered.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.has_method"><code class="name flex">
<span>def <span class="ident">has_method</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_method(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Check if a method is registered.

    Args:
        name: The name of the method to check.

    Returns:
        True if the method is registered, False otherwise.
    &#34;&#34;&#34;
    return name in self._methods</code></pre>
</details>
<div class="desc"><p>Check if a method is registered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the method is registered, False otherwise.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.list_methods"><code class="name flex">
<span>def <span class="ident">list_methods</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_methods(self) -&gt; list[str]:
    &#34;&#34;&#34;List all available forecast methods.

    Returns:
        Sorted list of registered method names.
    &#34;&#34;&#34;
    return sorted(self._methods.keys())</code></pre>
</details>
<div class="desc"><p>List all available forecast methods.</p>
<h2 id="returns">Returns</h2>
<p>Sorted list of registered method names.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self,<br>method: <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, method: ForecastMethod) -&gt; None:
    &#34;&#34;&#34;Register a new forecast method.

    Args:
        method: The forecast method to register.

    Raises:
        ValueError: If a method with the same name is already registered.
    &#34;&#34;&#34;
    if method.name in self._methods:
        raise ValueError(f&#34;Forecast method &#39;{method.name}&#39; is already registered&#34;)

    self._methods[method.name] = method
    logger.info(f&#34;Registered forecast method: {method.name}&#34;)</code></pre>
</details>
<div class="desc"><p>Register a new forecast method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The forecast method to register.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a method with the same name is already registered.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, name: str) -&gt; None:
    &#34;&#34;&#34;Unregister a forecast method.

    Args:
        name: The name of the method to unregister.

    Raises:
        KeyError: If the method is not registered.
    &#34;&#34;&#34;
    if name not in self._methods:
        raise KeyError(f&#34;Forecast method &#39;{name}&#39; is not registered&#34;)

    del self._methods[name]
    logger.info(f&#34;Unregistered forecast method: {name}&#34;)</code></pre>
</details>
<div class="desc"><p>Unregister a forecast method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to unregister.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If the method is not registered.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastNodeError"><code class="flex name class">
<span>class <span class="ident">ForecastNodeError</span></span>
<span>(</span><span>message: str,<br>node_id: str | None,<br>available_nodes: list[str] | None = None,<br>reason: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastNodeError(ForecastingError):
    &#34;&#34;&#34;Exception raised for node-related forecast errors.

    This includes nodes not found in the graph, nodes without historical data,
    or nodes that cannot be forecasted.
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        node_id: Optional[str],
        available_nodes: Optional[list[str]] = None,
        reason: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastNodeError.

        Args:
            message: The primary error message.
            node_id: The ID of the problematic node.
            available_nodes: Optional list of available node IDs.
            reason: Optional specific reason why the node cannot be forecasted.
        &#34;&#34;&#34;
        self.node_id = node_id
        self.available_nodes = available_nodes or []
        self.reason = reason

        full_message = f&#34;{message} for node &#39;{node_id}&#39;&#34;
        if reason:
            full_message = f&#34;{full_message}: {reason}&#34;
        if available_nodes and len(available_nodes) &lt; 10:  # Only show if list is small
            full_message = (
                f&#34;{full_message}. Available nodes: {&#39;, &#39;.join(available_nodes)}&#34;
            )

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for node-related forecast errors.</p>
<p>This includes nodes not found in the graph, nodes without historical data,
or nodes that cannot be forecasted.</p>
<p>Initialize a ForecastNodeError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>The ID of the problematic node.</dd>
<dt><strong><code>available_nodes</code></strong></dt>
<dd>Optional list of available node IDs.</dd>
<dt><strong><code>reason</code></strong></dt>
<dd>Optional specific reason why the node cannot be forecasted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult"><code class="flex name class">
<span>class <span class="ident">ForecastResult</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastResult(BaseModel):
    &#34;&#34;&#34;Represent forecast results for a node.

    Contains the node name, forecast periods, result values, method, and base period.
    &#34;&#34;&#34;

    node_name: str
    periods: list[str]
    values: PeriodValue
    method: ForecastMethodType
    base_period: str

    model_config = ConfigDict(extra=&#34;forbid&#34;)

    def get_value(self, period: str) -&gt; float:
        &#34;&#34;&#34;Get the forecast value for a specific period.&#34;&#34;&#34;
        if period not in self.values:
            raise ForecastResultError(
                f&#34;Period {period} not found in forecast results&#34;,
                period=period,
                available_periods=list(self.values.keys()),
            )
        return self.values[period]</code></pre>
</details>
<div class="desc"><p>Represent forecast results for a node.</p>
<p>Contains the node name, forecast periods, result values, method, and base period.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastResult.base_period"><code class="name">var <span class="ident">base_period</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.method"><code class="name">var <span class="ident">method</span> : Literal['simple', 'curve', 'statistical', 'average', 'historical_growth']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.node_name"><code class="name">var <span class="ident">node_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.periods"><code class="name">var <span class="ident">periods</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastResult.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, period: str) -&gt; float:
    &#34;&#34;&#34;Get the forecast value for a specific period.&#34;&#34;&#34;
    if period not in self.values:
        raise ForecastResultError(
            f&#34;Period {period} not found in forecast results&#34;,
            period=period,
            available_periods=list(self.values.keys()),
        )
    return self.values[period]</code></pre>
</details>
<div class="desc"><p>Get the forecast value for a specific period.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResultError"><code class="flex name class">
<span>class <span class="ident">ForecastResultError</span></span>
<span>(</span><span>message: str,<br>period: str | None = None,<br>available_periods: list[str] | None = None,<br>node_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastResultError(ForecastingError):
    &#34;&#34;&#34;Exception raised for forecast result access or manipulation errors.

    This includes accessing results for non-existent periods, invalid result
    formats, or result validation failures.
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        period: Optional[str] = None,
        available_periods: Optional[list[str]] = None,
        node_id: Optional[str] = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastResultError.

        Args:
            message: The primary error message.
            period: Optional period that caused the error.
            available_periods: Optional list of available periods.
            node_id: Optional ID of the node whose results are being accessed.
        &#34;&#34;&#34;
        self.period = period
        self.available_periods = available_periods or []
        self.node_id = node_id

        context = []
        if node_id:
            context.append(f&#34;node &#39;{node_id}&#39;&#34;)
        if period:
            context.append(f&#34;period &#39;{period}&#39;&#34;)

        full_message = message
        if context:
            full_message = f&#34;{message} for {&#39; and &#39;.join(context)}&#34;
        if available_periods and len(available_periods) &lt; 10:
            full_message = (
                f&#34;{full_message}. Available periods: {&#39;, &#39;.join(available_periods)}&#34;
            )

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for forecast result access or manipulation errors.</p>
<p>This includes accessing results for non-existent periods, invalid result
formats, or result validation failures.</p>
<p>Initialize a ForecastResultError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Optional period that caused the error.</dd>
<dt><strong><code>available_periods</code></strong></dt>
<dd>Optional list of available periods.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node whose results are being accessed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator"><code class="flex name class">
<span>class <span class="ident">ForecastValidator</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastValidator:
    &#34;&#34;&#34;Validate input parameters for forecasting operations.

    Contains methods to validate periods, node configurations, forecast configs,
    and forecast results before executing forecasting logic.
    &#34;&#34;&#34;

    @staticmethod
    def validate_forecast_inputs(
        historical_periods: list[str],
        forecast_periods: list[str],
        node_configs: Optional[dict[str, dict[str, Any]]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Validate basic forecast inputs.

        Args:
            historical_periods: List of historical periods.
            forecast_periods: List of periods to forecast.
            node_configs: Optional node configuration mapping.

        Raises:
            ValueError: If inputs are logically invalid.
            TypeError: If inputs are of wrong type.
        &#34;&#34;&#34;
        # Validate historical periods
        if not historical_periods:
            raise ValueError(&#34;No historical periods provided for forecasting&#34;)

        if not isinstance(historical_periods, list):
            raise TypeError(
                f&#34;Historical periods must be a list, got {type(historical_periods)}&#34;
            )

        # Validate forecast periods
        if not forecast_periods:
            raise ValueError(&#34;No forecast periods provided&#34;)

        if not isinstance(forecast_periods, list):
            raise TypeError(
                f&#34;Forecast periods must be a list, got {type(forecast_periods)}&#34;
            )

        # Check for overlapping periods
        historical_set = set(historical_periods)
        forecast_set = set(forecast_periods)
        overlap = historical_set &amp; forecast_set
        if overlap:
            logger.warning(
                f&#34;Forecast periods overlap with historical periods: {overlap}. &#34;
                f&#34;This may overwrite historical data.&#34;
            )

        # Validate node configs if provided
        if node_configs is not None:
            if not isinstance(node_configs, dict):
                raise TypeError(
                    f&#34;Node configs must be a dict, got {type(node_configs)}&#34;
                )

            for node_name, config in node_configs.items():
                ForecastValidator.validate_node_config(node_name, config)

    @staticmethod
    def validate_node_config(node_name: str, config: dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;Validate configuration for a single node.

        Args:
            node_name: Name of the node being configured.
            config: Configuration dictionary for the node.

        Raises:
            ValueError: If configuration is logically invalid.
            TypeError: If configuration is of wrong type.
        &#34;&#34;&#34;
        if not isinstance(config, dict):
            raise TypeError(
                f&#34;Configuration for node &#39;{node_name}&#39; must be a dict, got {type(config)}&#34;
            )

        # Validate method
        if &#34;method&#34; not in config:
            raise ValueError(
                f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;method&#39; key&#34;
            )

        method = config[&#34;method&#34;]
        valid_methods: list[ForecastMethodType] = [
            &#34;simple&#34;,
            &#34;curve&#34;,
            &#34;statistical&#34;,
            &#34;average&#34;,
            &#34;historical_growth&#34;,
        ]
        if method not in valid_methods:
            raise ValueError(
                f&#34;Invalid forecast method &#39;{method}&#39; for node &#39;{node_name}&#39;. &#34;
                f&#34;Valid methods: {valid_methods}&#34;
            )

        # Validate config exists (can be None for some methods)
        if &#34;config&#34; not in config:
            raise ValueError(
                f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;config&#39; key&#34;
            )

    @staticmethod
    def validate_node_for_forecast(node: Node, method: str) -&gt; None:
        &#34;&#34;&#34;Validate that a node can be forecasted with the given method.

        Args:
            node: The node to validate.
            method: The forecast method to use.

        Raises:
            ValueError: If node cannot be forecasted.
        &#34;&#34;&#34;
        # Check if node has values dictionary
        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ValueError(
                f&#34;Node &#39;{node.name}&#39; cannot be forecasted: missing or invalid &#34;
                f&#34;&#39;values&#39; attribute. Only nodes with values dictionaries can &#34;
                f&#34;be forecasted.&#34;
            )

        # Check if node has calculate method for certain forecast types
        if method in [&#34;average&#34;, &#34;historical_growth&#34;] and (
            not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate)
        ):
            raise ValueError(
                f&#34;Node &#39;{node.name}&#39; cannot use &#39;{method}&#39; forecast method: &#34;
                f&#34;missing calculate() method&#34;
            )

    @staticmethod
    def validate_forecast_config(config: dict[str, Any]) -&gt; ForecastConfig:
        &#34;&#34;&#34;Validate and convert a forecast configuration dictionary.

        Args:
            config: Raw configuration dictionary.

        Returns:
            Validated ForecastConfig instance.

        Raises:
            ValueError: If configuration is logically invalid.
            TypeError: If configuration is of wrong type.
        &#34;&#34;&#34;
        if not isinstance(config, dict):
            raise TypeError(f&#34;Forecast config must be a dict, got {type(config)}&#34;)

        if &#34;method&#34; not in config:
            raise ValueError(&#34;Forecast config missing required &#39;method&#39; key&#34;)

        if &#34;config&#34; not in config:
            raise ValueError(&#34;Forecast config missing required &#39;config&#39; key&#34;)

        # Create and validate using dataclass
        return ForecastConfig(method=config[&#34;method&#34;], config=config[&#34;config&#34;])

    @staticmethod
    def validate_base_period(
        base_period: str, available_periods: list[str], node_name: str
    ) -&gt; None:
        &#34;&#34;&#34;Validate that a base period is valid for forecasting.

        Args:
            base_period: The proposed base period.
            available_periods: List of available periods.
            node_name: Name of the node (for error messages).

        Raises:
            ValueError: If base period is invalid.
        &#34;&#34;&#34;
        if not base_period:
            raise ValueError(f&#34;No base period determined for node &#39;{node_name}&#39;&#34;)

        if base_period not in available_periods:
            raise ValueError(
                f&#34;Base period &#39;{base_period}&#39; for node &#39;{node_name}&#39; not found in available periods&#34;
            )

    @staticmethod
    def validate_forecast_result(
        result: dict[str, float], expected_periods: list[str], node_name: str
    ) -&gt; None:
        &#34;&#34;&#34;Validate forecast results.

        Args:
            result: Dictionary of period -&gt; value mappings.
            expected_periods: List of expected forecast periods.
            node_name: Name of the node (for error messages).

        Raises:
            ValueError: If results are logically invalid or incomplete.
            TypeError: If results are of wrong type.
        &#34;&#34;&#34;
        if not isinstance(result, dict):
            raise TypeError(
                f&#34;Forecast result for node &#39;{node_name}&#39; must be a dict, got {type(result)}&#34;
            )

        # Check all expected periods are present
        missing_periods = set(expected_periods) - set(result.keys())
        if missing_periods:
            raise ValueError(
                f&#34;Forecast result for node &#39;{node_name}&#39; missing periods: {missing_periods}&#34;
            )

        # Validate all values are numeric
        for period, value in result.items():
            if not isinstance(value, int | float):
                raise TypeError(
                    f&#34;Forecast value for node &#39;{node_name}&#39; period &#39;{period}&#39; &#34;
                    f&#34;must be numeric, got {type(value)}&#34;
                )</code></pre>
</details>
<div class="desc"><p>Validate input parameters for forecasting operations.</p>
<p>Contains methods to validate periods, node configurations, forecast configs,
and forecast results before executing forecasting logic.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_base_period"><code class="name flex">
<span>def <span class="ident">validate_base_period</span></span>(<span>base_period: str, available_periods: list[str], node_name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_base_period(
    base_period: str, available_periods: list[str], node_name: str
) -&gt; None:
    &#34;&#34;&#34;Validate that a base period is valid for forecasting.

    Args:
        base_period: The proposed base period.
        available_periods: List of available periods.
        node_name: Name of the node (for error messages).

    Raises:
        ValueError: If base period is invalid.
    &#34;&#34;&#34;
    if not base_period:
        raise ValueError(f&#34;No base period determined for node &#39;{node_name}&#39;&#34;)

    if base_period not in available_periods:
        raise ValueError(
            f&#34;Base period &#39;{base_period}&#39; for node &#39;{node_name}&#39; not found in available periods&#34;
        )</code></pre>
</details>
<div class="desc"><p>Validate that a base period is valid for forecasting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_period</code></strong></dt>
<dd>The proposed base period.</dd>
<dt><strong><code>available_periods</code></strong></dt>
<dd>List of available periods.</dd>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node (for error messages).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If base period is invalid.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_forecast_config"><code class="name flex">
<span>def <span class="ident">validate_forecast_config</span></span>(<span>config: dict[str, typing.Any]) ‑> <a title="fin_statement_model.forecasting.types.ForecastConfig" href="types.html#fin_statement_model.forecasting.types.ForecastConfig">ForecastConfig</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_forecast_config(config: dict[str, Any]) -&gt; ForecastConfig:
    &#34;&#34;&#34;Validate and convert a forecast configuration dictionary.

    Args:
        config: Raw configuration dictionary.

    Returns:
        Validated ForecastConfig instance.

    Raises:
        ValueError: If configuration is logically invalid.
        TypeError: If configuration is of wrong type.
    &#34;&#34;&#34;
    if not isinstance(config, dict):
        raise TypeError(f&#34;Forecast config must be a dict, got {type(config)}&#34;)

    if &#34;method&#34; not in config:
        raise ValueError(&#34;Forecast config missing required &#39;method&#39; key&#34;)

    if &#34;config&#34; not in config:
        raise ValueError(&#34;Forecast config missing required &#39;config&#39; key&#34;)

    # Create and validate using dataclass
    return ForecastConfig(method=config[&#34;method&#34;], config=config[&#34;config&#34;])</code></pre>
</details>
<div class="desc"><p>Validate and convert a forecast configuration dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Raw configuration dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Validated ForecastConfig instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is logically invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If configuration is of wrong type.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_forecast_inputs"><code class="name flex">
<span>def <span class="ident">validate_forecast_inputs</span></span>(<span>historical_periods: list[str],<br>forecast_periods: list[str],<br>node_configs: dict[str, dict[str, typing.Any]] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_forecast_inputs(
    historical_periods: list[str],
    forecast_periods: list[str],
    node_configs: Optional[dict[str, dict[str, Any]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Validate basic forecast inputs.

    Args:
        historical_periods: List of historical periods.
        forecast_periods: List of periods to forecast.
        node_configs: Optional node configuration mapping.

    Raises:
        ValueError: If inputs are logically invalid.
        TypeError: If inputs are of wrong type.
    &#34;&#34;&#34;
    # Validate historical periods
    if not historical_periods:
        raise ValueError(&#34;No historical periods provided for forecasting&#34;)

    if not isinstance(historical_periods, list):
        raise TypeError(
            f&#34;Historical periods must be a list, got {type(historical_periods)}&#34;
        )

    # Validate forecast periods
    if not forecast_periods:
        raise ValueError(&#34;No forecast periods provided&#34;)

    if not isinstance(forecast_periods, list):
        raise TypeError(
            f&#34;Forecast periods must be a list, got {type(forecast_periods)}&#34;
        )

    # Check for overlapping periods
    historical_set = set(historical_periods)
    forecast_set = set(forecast_periods)
    overlap = historical_set &amp; forecast_set
    if overlap:
        logger.warning(
            f&#34;Forecast periods overlap with historical periods: {overlap}. &#34;
            f&#34;This may overwrite historical data.&#34;
        )

    # Validate node configs if provided
    if node_configs is not None:
        if not isinstance(node_configs, dict):
            raise TypeError(
                f&#34;Node configs must be a dict, got {type(node_configs)}&#34;
            )

        for node_name, config in node_configs.items():
            ForecastValidator.validate_node_config(node_name, config)</code></pre>
</details>
<div class="desc"><p>Validate basic forecast inputs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
<dt><strong><code>node_configs</code></strong></dt>
<dd>Optional node configuration mapping.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If inputs are logically invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If inputs are of wrong type.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_forecast_result"><code class="name flex">
<span>def <span class="ident">validate_forecast_result</span></span>(<span>result: dict[str, float], expected_periods: list[str], node_name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_forecast_result(
    result: dict[str, float], expected_periods: list[str], node_name: str
) -&gt; None:
    &#34;&#34;&#34;Validate forecast results.

    Args:
        result: Dictionary of period -&gt; value mappings.
        expected_periods: List of expected forecast periods.
        node_name: Name of the node (for error messages).

    Raises:
        ValueError: If results are logically invalid or incomplete.
        TypeError: If results are of wrong type.
    &#34;&#34;&#34;
    if not isinstance(result, dict):
        raise TypeError(
            f&#34;Forecast result for node &#39;{node_name}&#39; must be a dict, got {type(result)}&#34;
        )

    # Check all expected periods are present
    missing_periods = set(expected_periods) - set(result.keys())
    if missing_periods:
        raise ValueError(
            f&#34;Forecast result for node &#39;{node_name}&#39; missing periods: {missing_periods}&#34;
        )

    # Validate all values are numeric
    for period, value in result.items():
        if not isinstance(value, int | float):
            raise TypeError(
                f&#34;Forecast value for node &#39;{node_name}&#39; period &#39;{period}&#39; &#34;
                f&#34;must be numeric, got {type(value)}&#34;
            )</code></pre>
</details>
<div class="desc"><p>Validate forecast results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>result</code></strong></dt>
<dd>Dictionary of period -&gt; value mappings.</dd>
<dt><strong><code>expected_periods</code></strong></dt>
<dd>List of expected forecast periods.</dd>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node (for error messages).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If results are logically invalid or incomplete.</dd>
<dt><code>TypeError</code></dt>
<dd>If results are of wrong type.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_node_config"><code class="name flex">
<span>def <span class="ident">validate_node_config</span></span>(<span>node_name: str, config: dict[str, typing.Any]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_node_config(node_name: str, config: dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Validate configuration for a single node.

    Args:
        node_name: Name of the node being configured.
        config: Configuration dictionary for the node.

    Raises:
        ValueError: If configuration is logically invalid.
        TypeError: If configuration is of wrong type.
    &#34;&#34;&#34;
    if not isinstance(config, dict):
        raise TypeError(
            f&#34;Configuration for node &#39;{node_name}&#39; must be a dict, got {type(config)}&#34;
        )

    # Validate method
    if &#34;method&#34; not in config:
        raise ValueError(
            f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;method&#39; key&#34;
        )

    method = config[&#34;method&#34;]
    valid_methods: list[ForecastMethodType] = [
        &#34;simple&#34;,
        &#34;curve&#34;,
        &#34;statistical&#34;,
        &#34;average&#34;,
        &#34;historical_growth&#34;,
    ]
    if method not in valid_methods:
        raise ValueError(
            f&#34;Invalid forecast method &#39;{method}&#39; for node &#39;{node_name}&#39;. &#34;
            f&#34;Valid methods: {valid_methods}&#34;
        )

    # Validate config exists (can be None for some methods)
    if &#34;config&#34; not in config:
        raise ValueError(
            f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;config&#39; key&#34;
        )</code></pre>
</details>
<div class="desc"><p>Validate configuration for a single node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node being configured.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Configuration dictionary for the node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is logically invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If configuration is of wrong type.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_node_for_forecast"><code class="name flex">
<span>def <span class="ident">validate_node_for_forecast</span></span>(<span>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>method: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_node_for_forecast(node: Node, method: str) -&gt; None:
    &#34;&#34;&#34;Validate that a node can be forecasted with the given method.

    Args:
        node: The node to validate.
        method: The forecast method to use.

    Raises:
        ValueError: If node cannot be forecasted.
    &#34;&#34;&#34;
    # Check if node has values dictionary
    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ValueError(
            f&#34;Node &#39;{node.name}&#39; cannot be forecasted: missing or invalid &#34;
            f&#34;&#39;values&#39; attribute. Only nodes with values dictionaries can &#34;
            f&#34;be forecasted.&#34;
        )

    # Check if node has calculate method for certain forecast types
    if method in [&#34;average&#34;, &#34;historical_growth&#34;] and (
        not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate)
    ):
        raise ValueError(
            f&#34;Node &#39;{node.name}&#39; cannot use &#39;{method}&#39; forecast method: &#34;
            f&#34;missing calculate() method&#34;
        )</code></pre>
</details>
<div class="desc"><p>Validate that a node can be forecasted with the given method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to validate.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>The forecast method to use.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If node cannot be forecasted.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastingError"><code class="flex name class">
<span>class <span class="ident">ForecastingError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastingError(FinancialModelError):
    &#34;&#34;&#34;Base exception for all forecasting-related errors.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Base exception for all forecasting-related errors.</p>
<p>Initialize the FinancialModelError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>A human-readable description of the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastConfigurationError" href="errors.html#fin_statement_model.forecasting.errors.ForecastConfigurationError">ForecastConfigurationError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastMethodError" href="errors.html#fin_statement_model.forecasting.errors.ForecastMethodError">ForecastMethodError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastNodeError" href="errors.html#fin_statement_model.forecasting.errors.ForecastNodeError">ForecastNodeError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastResultError" href="errors.html#fin_statement_model.forecasting.errors.ForecastResultError">ForecastResultError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod"><code class="flex name class">
<span>class <span class="ident">HistoricalGrowthForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HistoricalGrowthForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values based on average historical growth patterns.

    This method calculates the average historical growth rate and applies it to
    forecast future values. Useful when past growth patterns are expected to
    continue.

    Configuration:
        - Not required (pass None or 0)
        - Automatically calculates growth from historical data requiring at least
          cfg(&#34;forecasting.min_historical_periods&#34;) data points

    Example:
        &gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; # Returns: {&#34;forecast_type&#34;: &#34;historical_growth&#34;, &#34;growth_params&#34;: None}
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        return &#34;historical_growth&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;
        return &#34;historical_growth&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for historical growth method.

        Args:
            config: Not used for historical growth method, can be None or 0.

        Note:
            Historical growth method doesn&#39;t require configuration as it
            calculates growth from historical data automatically.
        &#34;&#34;&#34;
        # Historical growth method doesn&#39;t need specific configuration
        # Accept None, 0, or any placeholder value

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Not used for historical growth method.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            For historical growth method, growth_params is None.
        &#34;&#34;&#34;
        return {
            &#34;forecast_type&#34;: self.internal_type,
            &#34;growth_params&#34;: None,  # Historical growth method calculates internally
        }

    def prepare_historical_data(
        self, node: Node, historical_periods: list[str]
    ) -&gt; Optional[list[float]]:
        &#34;&#34;&#34;Prepare historical data for growth calculation.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of valid historical values (at least 2 needed for growth).

        Raises:
            ValueError: If insufficient historical data is available.
        &#34;&#34;&#34;
        if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
            raise ValueError(
                f&#34;Node {node.name} cannot be calculated for historical growth method&#34;
            )

        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ValueError(
                f&#34;Node {node.name} does not have values dictionary for historical growth method&#34;
            )

        # Extract historical values in chronological order
        historical_values = []
        for period in historical_periods:
            if period in node.values:
                try:
                    value = node.calculate(period)
                    if (
                        value is not None
                        and not np.isnan(value)
                        and not np.isinf(value)
                    ):
                        historical_values.append(float(value))
                except Exception as e:
                    # Log the exception and skip this period
                    logger.debug(
                        f&#34;Skipping period {period} for node {node.name} in historical growth calculation: {e}&#34;
                    )
                    continue

        min_periods = cfg(&#34;forecasting.min_historical_periods&#34;)
        if len(historical_values) &lt; min_periods:
            raise ValueError(
                f&#34;Need at least {min_periods} historical data points for node {node.name} &#34;
                f&#34;to compute growth rate, found {len(historical_values)}&#34;
            )

        return historical_values

    def calculate_average_growth_rate(self, historical_values: list[float]) -&gt; float:
        &#34;&#34;&#34;Calculate the average growth rate from historical values.

        Args:
            historical_values: List of historical values in chronological order.

        Returns:
            Average growth rate.

        Note:
            This is a helper method that can be used by the forecast node
            implementation to calculate the growth rate.
        &#34;&#34;&#34;
        # Calculate period-over-period growth rates
        if len(historical_values) &lt; 2:
            return 0.0

        growth_rates: list[float] = []
        for i in range(1, len(historical_values)):
            previous_value = historical_values[i - 1]
            if previous_value != 0:
                growth_rates.append(
                    (historical_values[i] - previous_value) / previous_value
                )

        if not growth_rates:
            return 0.0

        # Determine aggregation method: &#39;mean&#39; or &#39;median&#39;
        agg_method = cfg(&#34;forecasting.historical_growth_aggregation&#34;)
        if agg_method == &#34;median&#34;:
            try:
                return float(np.median(growth_rates))
            except (ValueError, TypeError) as e:
                logger.warning(
                    f&#34;Failed to calculate median growth rate, falling back to mean: {e}&#34;
                )
                return float(np.mean(growth_rates))
        # Default to mean
        return float(np.mean(growth_rates))</code></pre>
</details>
<div class="desc"><p>Forecast future values based on average historical growth patterns.</p>
<p>This method calculates the average historical growth rate and applies it to
forecast future values. Useful when past growth patterns are expected to
continue.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Not required (pass None or 0)</li>
<li>Automatically calculates growth from historical data requiring at least
cfg("forecasting.min_historical_periods") data points</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(None, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;historical_growth&quot;, &quot;growth_params&quot;: None}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.calculate_average_growth_rate"><code class="name flex">
<span>def <span class="ident">calculate_average_growth_rate</span></span>(<span>self, historical_values: list[float]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_average_growth_rate(self, historical_values: list[float]) -&gt; float:
    &#34;&#34;&#34;Calculate the average growth rate from historical values.

    Args:
        historical_values: List of historical values in chronological order.

    Returns:
        Average growth rate.

    Note:
        This is a helper method that can be used by the forecast node
        implementation to calculate the growth rate.
    &#34;&#34;&#34;
    # Calculate period-over-period growth rates
    if len(historical_values) &lt; 2:
        return 0.0

    growth_rates: list[float] = []
    for i in range(1, len(historical_values)):
        previous_value = historical_values[i - 1]
        if previous_value != 0:
            growth_rates.append(
                (historical_values[i] - previous_value) / previous_value
            )

    if not growth_rates:
        return 0.0

    # Determine aggregation method: &#39;mean&#39; or &#39;median&#39;
    agg_method = cfg(&#34;forecasting.historical_growth_aggregation&#34;)
    if agg_method == &#34;median&#34;:
        try:
            return float(np.median(growth_rates))
        except (ValueError, TypeError) as e:
            logger.warning(
                f&#34;Failed to calculate median growth rate, falling back to mean: {e}&#34;
            )
            return float(np.mean(growth_rates))
    # Default to mean
    return float(np.mean(growth_rates))</code></pre>
</details>
<div class="desc"><p>Calculate the average growth rate from historical values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>historical_values</code></strong></dt>
<dd>List of historical values in chronological order.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Average growth rate.</p>
<h2 id="note">Note</h2>
<p>This is a helper method that can be used by the forecast node
implementation to calculate the growth rate.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Not used for historical growth method.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        For historical growth method, growth_params is None.
    &#34;&#34;&#34;
    return {
        &#34;forecast_type&#34;: self.internal_type,
        &#34;growth_params&#34;: None,  # Historical growth method calculates internally
    }</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for historical growth method.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
For historical growth method, growth_params is None.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(
    self, node: Node, historical_periods: list[str]
) -&gt; Optional[list[float]]:
    &#34;&#34;&#34;Prepare historical data for growth calculation.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of valid historical values (at least 2 needed for growth).

    Raises:
        ValueError: If insufficient historical data is available.
    &#34;&#34;&#34;
    if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
        raise ValueError(
            f&#34;Node {node.name} cannot be calculated for historical growth method&#34;
        )

    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ValueError(
            f&#34;Node {node.name} does not have values dictionary for historical growth method&#34;
        )

    # Extract historical values in chronological order
    historical_values = []
    for period in historical_periods:
        if period in node.values:
            try:
                value = node.calculate(period)
                if (
                    value is not None
                    and not np.isnan(value)
                    and not np.isinf(value)
                ):
                    historical_values.append(float(value))
            except Exception as e:
                # Log the exception and skip this period
                logger.debug(
                    f&#34;Skipping period {period} for node {node.name} in historical growth calculation: {e}&#34;
                )
                continue

    min_periods = cfg(&#34;forecasting.min_historical_periods&#34;)
    if len(historical_values) &lt; min_periods:
        raise ValueError(
            f&#34;Need at least {min_periods} historical data points for node {node.name} &#34;
            f&#34;to compute growth rate, found {len(historical_values)}&#34;
        )

    return historical_values</code></pre>
</details>
<div class="desc"><p>Prepare historical data for growth calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of valid historical values (at least 2 needed for growth).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If insufficient historical data is available.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for historical growth method.

    Args:
        config: Not used for historical growth method, can be None or 0.

    Note:
        Historical growth method doesn&#39;t require configuration as it
        calculates growth from historical data automatically.
    &#34;&#34;&#34;
    # Historical growth method doesn&#39;t need specific configuration
    # Accept None, 0, or any placeholder value</code></pre>
</details>
<div class="desc"><p>Validate the configuration for historical growth method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for historical growth method, can be None or 0.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Historical growth method doesn't require configuration as it
calculates growth from historical data automatically.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.name" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager"><code class="flex name class">
<span>class <span class="ident">PeriodManager</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PeriodManager:
    &#34;&#34;&#34;Infer and manage forecasting periods.

    Provides utilities to infer historical periods, determine base periods,
    validate period sequences, and manage period transitions on the graph.
    &#34;&#34;&#34;

    @staticmethod
    def infer_historical_periods(  # type: ignore
        graph: Any,
        forecast_periods: list[str],
        provided_periods: Optional[list[str]] = None,
    ) -&gt; list[str]:
        &#34;&#34;&#34;Infer historical periods from graph state.

        Args:
            graph: The financial statement graph instance.
            forecast_periods: List of periods to forecast.
            provided_periods: Optional explicitly provided historical periods.

        Returns:
            List of historical periods.

        Raises:
            ValueError: If historical periods cannot be determined.
        &#34;&#34;&#34;
        # If explicitly provided, use them
        if provided_periods is not None:
            logger.debug(
                f&#34;Using explicitly provided historical periods: {provided_periods}&#34;
            )
            return provided_periods

        # Infer from graph periods and forecast periods
        if not hasattr(graph, &#34;periods&#34;) or not graph.periods:
            raise ValueError(
                &#34;Cannot infer historical periods: graph has no periods attribute&#34;
            )

        if not forecast_periods:
            raise ValueError(
                &#34;Cannot infer historical periods: no forecast periods provided&#34;
            )

        # Try to find where forecast periods start
        first_forecast = forecast_periods[0]
        try:
            idx = graph.periods.index(first_forecast)
            historical_periods = graph.periods[:idx]
            logger.debug(
                f&#34;Inferred historical periods by splitting at {first_forecast}: &#34;
                f&#34;{historical_periods}&#34;
            )
        except ValueError:
            # First forecast period not in graph periods
            # Assume all current periods are historical
            historical_periods = list(graph.periods)
            logger.warning(
                f&#34;First forecast period {first_forecast} not found in graph periods. &#34;
                f&#34;Using all existing periods as historical: {historical_periods}&#34;
            )

        if not historical_periods:
            raise ValueError(
                &#34;No historical periods found. Ensure graph has periods before &#34;
                &#34;the first forecast period.&#34;
            )

        return historical_periods

    @staticmethod
    def determine_base_period(
        node: Node,
        historical_periods: list[str],
        preferred_period: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Determine the base period for forecasting a node.

        Args:
            node: The node to forecast.
            historical_periods: List of available historical periods.
            preferred_period: Optional preferred base period.

        Returns:
            The base period to use for forecasting.

        Raises:
            ValueError: If no valid base period can be determined.
        &#34;&#34;&#34;
        if not historical_periods:
            raise ValueError(&#34;No historical periods provided&#34;)

        # Determine strategy for selecting base period
        strategy = cfg(&#34;forecasting.base_period_strategy&#34;)

        # Validate strategy
        valid_strategies = {
            &#34;preferred_then_most_recent&#34;,
            &#34;most_recent&#34;,
            &#34;last_historical&#34;,
        }
        if strategy not in valid_strategies:
            logger.warning(
                f&#34;Unknown base period strategy &#39;{strategy}&#39;, falling back to &#39;preferred_then_most_recent&#39;&#34;
            )
            strategy = &#34;preferred_then_most_recent&#34;

        # 1. preferred_then_most_recent: check preferred first
        if strategy == &#34;preferred_then_most_recent&#34; and preferred_period:
            if preferred_period in historical_periods and hasattr(node, &#34;values&#34;):
                values = getattr(node, &#34;values&#34;, {})
                if isinstance(values, dict) and preferred_period in values:
                    return preferred_period

        # 2. most_recent: pick most recent available data
        if strategy in (&#34;preferred_then_most_recent&#34;, &#34;most_recent&#34;):
            if hasattr(node, &#34;values&#34;) and isinstance(
                getattr(node, &#34;values&#34;, None), dict
            ):
                values_dict = node.values
                available_periods = [p for p in historical_periods if p in values_dict]
                if available_periods:
                    return available_periods[-1]

        # 3. last_historical: always use last in historical_periods
        if strategy == &#34;last_historical&#34;:
            return historical_periods[-1]

        # Final fallback: use last historical period
        base_period = historical_periods[-1]
        logger.info(
            f&#34;Using last historical period as base for {node.name}: {base_period} &#34;
            &#34;(node may lack values)&#34;
        )
        return base_period

    @staticmethod
    def validate_period_sequence(periods: list[str]) -&gt; None:
        &#34;&#34;&#34;Validate that a period sequence is valid.

        Args:
            periods: List of periods to validate.

        Raises:
            ValueError: If the period sequence is invalid.
        &#34;&#34;&#34;
        if not periods:
            raise ValueError(&#34;Period sequence cannot be empty&#34;)

        if len(periods) != len(set(periods)):
            duplicates = [p for p in periods if periods.count(p) &gt; 1]
            raise ValueError(f&#34;Period sequence contains duplicates: {set(duplicates)}&#34;)

    @staticmethod
    def get_period_index(period: str, periods: list[str]) -&gt; int:
        &#34;&#34;&#34;Get the index of a period in a period list.

        Args:
            period: The period to find.
            periods: List of periods.

        Returns:
            The index of the period.

        Raises:
            ValueError: If period not found in list.
        &#34;&#34;&#34;
        try:
            return periods.index(period)
        except ValueError:
            raise ValueError(f&#34;Period &#39;{period}&#39; not found in period list&#34;) from None

    @staticmethod
    def ensure_periods_exist(
        graph: Any, periods: list[str], add_missing: bool = True
    ) -&gt; list[str]:
        &#34;&#34;&#34;Ensure periods exist in the graph.

        Args:
            graph: The financial statement graph instance.
            periods: List of periods that should exist.
            add_missing: Whether to add missing periods to the graph.

        Returns:
            List of periods that were added (empty if none).

        Raises:
            ValueError: If add_missing is False and periods are missing.
        &#34;&#34;&#34;
        if not hasattr(graph, &#34;periods&#34;):
            raise ValueError(&#34;Graph does not have a periods attribute&#34;)

        existing_periods = set(graph.periods)
        missing_periods = [p for p in periods if p not in existing_periods]

        if missing_periods:
            if add_missing:
                # Add missing periods to graph
                if hasattr(graph, &#34;add_periods&#34;) and callable(graph.add_periods):
                    graph.add_periods(missing_periods)
                    logger.info(f&#34;Added missing periods to graph: {missing_periods}&#34;)
                else:
                    raise ValueError(
                        f&#34;Graph is missing periods {missing_periods} but has no add_periods method&#34;
                    )
            else:
                raise ValueError(
                    f&#34;The following periods do not exist in the graph: {missing_periods}&#34;
                )

        return missing_periods</code></pre>
</details>
<div class="desc"><p>Infer and manage forecasting periods.</p>
<p>Provides utilities to infer historical periods, determine base periods,
validate period sequences, and manage period transitions on the graph.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.PeriodManager.determine_base_period"><code class="name flex">
<span>def <span class="ident">determine_base_period</span></span>(<span>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str],<br>preferred_period: str | None = None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def determine_base_period(
    node: Node,
    historical_periods: list[str],
    preferred_period: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;Determine the base period for forecasting a node.

    Args:
        node: The node to forecast.
        historical_periods: List of available historical periods.
        preferred_period: Optional preferred base period.

    Returns:
        The base period to use for forecasting.

    Raises:
        ValueError: If no valid base period can be determined.
    &#34;&#34;&#34;
    if not historical_periods:
        raise ValueError(&#34;No historical periods provided&#34;)

    # Determine strategy for selecting base period
    strategy = cfg(&#34;forecasting.base_period_strategy&#34;)

    # Validate strategy
    valid_strategies = {
        &#34;preferred_then_most_recent&#34;,
        &#34;most_recent&#34;,
        &#34;last_historical&#34;,
    }
    if strategy not in valid_strategies:
        logger.warning(
            f&#34;Unknown base period strategy &#39;{strategy}&#39;, falling back to &#39;preferred_then_most_recent&#39;&#34;
        )
        strategy = &#34;preferred_then_most_recent&#34;

    # 1. preferred_then_most_recent: check preferred first
    if strategy == &#34;preferred_then_most_recent&#34; and preferred_period:
        if preferred_period in historical_periods and hasattr(node, &#34;values&#34;):
            values = getattr(node, &#34;values&#34;, {})
            if isinstance(values, dict) and preferred_period in values:
                return preferred_period

    # 2. most_recent: pick most recent available data
    if strategy in (&#34;preferred_then_most_recent&#34;, &#34;most_recent&#34;):
        if hasattr(node, &#34;values&#34;) and isinstance(
            getattr(node, &#34;values&#34;, None), dict
        ):
            values_dict = node.values
            available_periods = [p for p in historical_periods if p in values_dict]
            if available_periods:
                return available_periods[-1]

    # 3. last_historical: always use last in historical_periods
    if strategy == &#34;last_historical&#34;:
        return historical_periods[-1]

    # Final fallback: use last historical period
    base_period = historical_periods[-1]
    logger.info(
        f&#34;Using last historical period as base for {node.name}: {base_period} &#34;
        &#34;(node may lack values)&#34;
    )
    return base_period</code></pre>
</details>
<div class="desc"><p>Determine the base period for forecasting a node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to forecast.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of available historical periods.</dd>
<dt><strong><code>preferred_period</code></strong></dt>
<dd>Optional preferred base period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The base period to use for forecasting.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no valid base period can be determined.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.ensure_periods_exist"><code class="name flex">
<span>def <span class="ident">ensure_periods_exist</span></span>(<span>graph: Any, periods: list[str], add_missing: bool = True) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ensure_periods_exist(
    graph: Any, periods: list[str], add_missing: bool = True
) -&gt; list[str]:
    &#34;&#34;&#34;Ensure periods exist in the graph.

    Args:
        graph: The financial statement graph instance.
        periods: List of periods that should exist.
        add_missing: Whether to add missing periods to the graph.

    Returns:
        List of periods that were added (empty if none).

    Raises:
        ValueError: If add_missing is False and periods are missing.
    &#34;&#34;&#34;
    if not hasattr(graph, &#34;periods&#34;):
        raise ValueError(&#34;Graph does not have a periods attribute&#34;)

    existing_periods = set(graph.periods)
    missing_periods = [p for p in periods if p not in existing_periods]

    if missing_periods:
        if add_missing:
            # Add missing periods to graph
            if hasattr(graph, &#34;add_periods&#34;) and callable(graph.add_periods):
                graph.add_periods(missing_periods)
                logger.info(f&#34;Added missing periods to graph: {missing_periods}&#34;)
            else:
                raise ValueError(
                    f&#34;Graph is missing periods {missing_periods} but has no add_periods method&#34;
                )
        else:
            raise ValueError(
                f&#34;The following periods do not exist in the graph: {missing_periods}&#34;
            )

    return missing_periods</code></pre>
</details>
<div class="desc"><p>Ensure periods exist in the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The financial statement graph instance.</dd>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods that should exist.</dd>
<dt><strong><code>add_missing</code></strong></dt>
<dd>Whether to add missing periods to the graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of periods that were added (empty if none).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If add_missing is False and periods are missing.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.get_period_index"><code class="name flex">
<span>def <span class="ident">get_period_index</span></span>(<span>period: str, periods: list[str]) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_period_index(period: str, periods: list[str]) -&gt; int:
    &#34;&#34;&#34;Get the index of a period in a period list.

    Args:
        period: The period to find.
        periods: List of periods.

    Returns:
        The index of the period.

    Raises:
        ValueError: If period not found in list.
    &#34;&#34;&#34;
    try:
        return periods.index(period)
    except ValueError:
        raise ValueError(f&#34;Period &#39;{period}&#39; not found in period list&#34;) from None</code></pre>
</details>
<div class="desc"><p>Get the index of a period in a period list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong></dt>
<dd>The period to find.</dd>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The index of the period.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If period not found in list.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.infer_historical_periods"><code class="name flex">
<span>def <span class="ident">infer_historical_periods</span></span>(<span>graph: Any,<br>forecast_periods: list[str],<br>provided_periods: list[str] | None = None) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def infer_historical_periods(  # type: ignore
    graph: Any,
    forecast_periods: list[str],
    provided_periods: Optional[list[str]] = None,
) -&gt; list[str]:
    &#34;&#34;&#34;Infer historical periods from graph state.

    Args:
        graph: The financial statement graph instance.
        forecast_periods: List of periods to forecast.
        provided_periods: Optional explicitly provided historical periods.

    Returns:
        List of historical periods.

    Raises:
        ValueError: If historical periods cannot be determined.
    &#34;&#34;&#34;
    # If explicitly provided, use them
    if provided_periods is not None:
        logger.debug(
            f&#34;Using explicitly provided historical periods: {provided_periods}&#34;
        )
        return provided_periods

    # Infer from graph periods and forecast periods
    if not hasattr(graph, &#34;periods&#34;) or not graph.periods:
        raise ValueError(
            &#34;Cannot infer historical periods: graph has no periods attribute&#34;
        )

    if not forecast_periods:
        raise ValueError(
            &#34;Cannot infer historical periods: no forecast periods provided&#34;
        )

    # Try to find where forecast periods start
    first_forecast = forecast_periods[0]
    try:
        idx = graph.periods.index(first_forecast)
        historical_periods = graph.periods[:idx]
        logger.debug(
            f&#34;Inferred historical periods by splitting at {first_forecast}: &#34;
            f&#34;{historical_periods}&#34;
        )
    except ValueError:
        # First forecast period not in graph periods
        # Assume all current periods are historical
        historical_periods = list(graph.periods)
        logger.warning(
            f&#34;First forecast period {first_forecast} not found in graph periods. &#34;
            f&#34;Using all existing periods as historical: {historical_periods}&#34;
        )

    if not historical_periods:
        raise ValueError(
            &#34;No historical periods found. Ensure graph has periods before &#34;
            &#34;the first forecast period.&#34;
        )

    return historical_periods</code></pre>
</details>
<div class="desc"><p>Infer historical periods from graph state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The financial statement graph instance.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
<dt><strong><code>provided_periods</code></strong></dt>
<dd>Optional explicitly provided historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of historical periods.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If historical periods cannot be determined.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.validate_period_sequence"><code class="name flex">
<span>def <span class="ident">validate_period_sequence</span></span>(<span>periods: list[str]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_period_sequence(periods: list[str]) -&gt; None:
    &#34;&#34;&#34;Validate that a period sequence is valid.

    Args:
        periods: List of periods to validate.

    Raises:
        ValueError: If the period sequence is invalid.
    &#34;&#34;&#34;
    if not periods:
        raise ValueError(&#34;Period sequence cannot be empty&#34;)

    if len(periods) != len(set(periods)):
        duplicates = [p for p in periods if periods.count(p) &gt; 1]
        raise ValueError(f&#34;Period sequence contains duplicates: {set(duplicates)}&#34;)</code></pre>
</details>
<div class="desc"><p>Validate that a period sequence is valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods to validate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the period sequence is invalid.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod"><code class="flex name class">
<span>class <span class="ident">SimpleForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values using a constant growth rate.

    This method applies a constant growth rate to the base value for all forecast
    periods.

    Configuration:
        - Single numeric value: The growth rate (e.g., 0.05 for 5% growth)
        - List with single value: Will use the first value

    Example:
        &gt;&gt;&gt; method = SimpleForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(0.05, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; # Returns: {&#34;forecast_type&#34;: &#34;simple&#34;, &#34;growth_params&#34;: 0.05}
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        return &#34;simple&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;
        return &#34;simple&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for simple method.

        Args:
            config: Should be a numeric value or a list containing a numeric value.

        Raises:
            ValueError: If config is empty list.
            TypeError: If config is not numeric or a list with numeric value.
        &#34;&#34;&#34;
        if isinstance(config, list):
            if not config:
                raise ValueError(&#34;Simple method: empty list provided&#34;)
            if not isinstance(config[0], int | float):
                raise TypeError(
                    f&#34;Simple method requires numeric growth rate, got {type(config[0])}&#34;
                )
        elif not isinstance(config, int | float):
            raise TypeError(
                f&#34;Simple method requires numeric growth rate, got {type(config)}&#34;
            )

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: The growth rate (numeric or list with numeric).
            forecast_periods: List of periods to forecast (not used for simple method).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        &#34;&#34;&#34;
        # Handle list input - take first value
        growth_rate = float(config[0]) if isinstance(config, list) else float(config)

        return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rate}</code></pre>
</details>
<div class="desc"><p>Forecast future values using a constant growth rate.</p>
<p>This method applies a constant growth rate to the base value for all forecast
periods.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Single numeric value: The growth rate (e.g., 0.05 for 5% growth)</li>
<li>List with single value: Will use the first value</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = SimpleForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(0.05, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;simple&quot;, &quot;growth_params&quot;: 0.05}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: The growth rate (numeric or list with numeric).
        forecast_periods: List of periods to forecast (not used for simple method).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
    &#34;&#34;&#34;
    # Handle list input - take first value
    growth_rate = float(config[0]) if isinstance(config, list) else float(config)

    return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rate}</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The growth rate (numeric or list with numeric).</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used for simple method).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for simple method.

    Args:
        config: Should be a numeric value or a list containing a numeric value.

    Raises:
        ValueError: If config is empty list.
        TypeError: If config is not numeric or a list with numeric value.
    &#34;&#34;&#34;
    if isinstance(config, list):
        if not config:
            raise ValueError(&#34;Simple method: empty list provided&#34;)
        if not isinstance(config[0], int | float):
            raise TypeError(
                f&#34;Simple method requires numeric growth rate, got {type(config[0])}&#34;
            )
    elif not isinstance(config, int | float):
        raise TypeError(
            f&#34;Simple method requires numeric growth rate, got {type(config)}&#34;
        )</code></pre>
</details>
<div class="desc"><p>Validate the configuration for simple method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Should be a numeric value or a list containing a numeric value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If config is empty list.</dd>
<dt><code>TypeError</code></dt>
<dd>If config is not numeric or a list with numeric value.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.name" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster"><code class="flex name class">
<span>class <span class="ident">StatementForecaster</span></span>
<span>(</span><span>fsg: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementForecaster:
    &#34;&#34;&#34;Perform forecasting operations on a financial statement graph.
    
    This class supports both mutating and non-mutating forecasts:
    
    - Mutating forecasts (`create_forecast`): adds forecast periods and updates node values.
    - Non-mutating forecasts (`forecast_value`): computes and returns forecast values without modifying the graph.
    
    Supported forecasting methods: simple, curve, statistical, average, historical_growth.
    &#34;&#34;&#34;

    def __init__(self, fsg: Any) -&gt; None:
        &#34;&#34;&#34;Initialize the forecaster.

        Args:
            fsg: The FinancialStatementGraph instance this forecaster will operate on.
        &#34;&#34;&#34;
        self.fsg = fsg

    def create_forecast(
        self,
        forecast_periods: list[str],
        node_configs: Optional[dict[str, dict[str, Any]]] = None,
        historical_periods: Optional[list[str]] = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Create forecasts for financial statement items on the graph.

        **IMPORTANT**: This method MUTATES the graph by:
        - Adding new periods to the graph if they don&#39;t exist
        - Updating node values with forecast data
        - Clearing node caches after updates

        Use `forecast_value` instead if you need forecast values without
        modifying the graph.

        Args:
            forecast_periods: List of future periods to forecast.
            node_configs: Mapping of node names to their forecast configurations.
                Each config should contain:
                - &#39;method&#39;: Forecasting method (&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;,
                           &#39;average&#39;, &#39;historical_growth&#39;)
                - &#39;config&#39;: Method-specific parameters (growth rate, distribution, etc.)
            historical_periods: Optional list of historical periods to use as base.
                If not provided, will be inferred from the graph&#39;s existing periods.
            **kwargs: Additional arguments passed to the forecasting logic:
                add_missing_periods (bool): Whether to add missing forecast periods to the graph.

        Returns:
            None (modifies the graph in-place)

        Raises:
            ForecastNodeError: If no historical periods found, no forecast periods provided,
                              or invalid forecasting method/configuration.
        &#34;&#34;&#34;
        logger.info(
            f&#34;StatementForecaster: Creating forecast for periods {forecast_periods}&#34;
        )
        try:
            # Use PeriodManager to infer historical periods
            historical_periods = PeriodManager.infer_historical_periods(
                self.fsg, forecast_periods, historical_periods
            )

            # Validate inputs using ForecastValidator
            ForecastValidator.validate_forecast_inputs(
                historical_periods, forecast_periods, node_configs
            )

            # Ensure forecast periods exist in the graph (override via add_missing_periods)
            add_missing = kwargs.get(
                &#34;add_missing_periods&#34;, cfg(&#34;forecasting.add_missing_periods&#34;)
            )
            PeriodManager.ensure_periods_exist(
                self.fsg, forecast_periods, add_missing=add_missing
            )

            if node_configs is None:
                node_configs = {}

            for node_name, config in node_configs.items():
                node = self.fsg.get_node(node_name)
                if node is None:
                    raise ForecastNodeError(
                        f&#34;Node {node_name} not found in graph&#34;,
                        node_id=node_name,
                        available_nodes=list(self.fsg.nodes.keys()),
                    )

                # Validate node can be forecasted
                forecast_config = ForecastValidator.validate_forecast_config(config)
                ForecastValidator.validate_node_for_forecast(
                    node, forecast_config.method
                )

                self._forecast_node(
                    node, historical_periods, forecast_periods, forecast_config
                )

            logger.info(
                f&#34;Created forecast for {len(forecast_periods)} periods and {len(node_configs)} nodes&#34;
            )
        except Exception as e:
            logger.error(f&#34;Error creating forecast: {e}&#34;, exc_info=True)
            raise ForecastNodeError(
                f&#34;Error creating forecast: {e}&#34;, node_id=None, reason=str(e)
            )

    def _forecast_node(
        self,
        node: Node,
        historical_periods: list[str],
        forecast_periods: list[str],
        forecast_config: ForecastConfig,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Calculate forecast values and update the original node.

        **IMPORTANT**: This is an internal MUTATING method that:
        - Creates a temporary forecast node for calculations
        - Updates the original node&#39;s values dictionary with forecast results
        - Clears the original node&#39;s cache after updates

        This method should not be called directly. Use `create_forecast` for
        mutating operations or `forecast_value` for non-mutating operations.

        Args:
            node: The graph node to forecast. Must have a &#39;values&#39; dictionary.
            historical_periods: List of historical periods for base values.
            forecast_periods: List of periods for which to calculate forecasts.
            forecast_config: Validated forecast configuration.
            **kwargs: Additional arguments passed to growth logic.

        Returns:
            None (modifies the node in-place)

        Raises:
            ForecastNodeError: If no historical periods provided or invalid method.
        &#34;&#34;&#34;
        logger.debug(
            f&#34;StatementForecaster: Forecasting node {node.name} using method {forecast_config.method}&#34;
        )

        # Determine base period using PeriodManager
        base_period = PeriodManager.determine_base_period(node, historical_periods)

        # Get the forecast method from registry
        method = get_forecast_method(forecast_config.method)

        # Get normalized parameters for NodeFactory
        # All built-in methods extend BaseForecastMethod which has get_forecast_params
        base_method = cast(BaseForecastMethod, method)
        params = base_method.get_forecast_params(
            forecast_config.config, forecast_periods
        )

        # Create a temporary node to perform calculations
        tmp_node = NodeFactory.create_forecast_node(
            name=f&#34;{node.name}_forecast_temp&#34;,
            base_node=node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            forecast_type=params[&#34;forecast_type&#34;],
            growth_params=params[&#34;growth_params&#34;],
        )

        # Ensure the original node has a values dictionary
        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            logger.error(
                f&#34;Cannot store forecast for node {node.name}: node does not have a &#39;values&#39; dictionary.&#34;
            )
            return  # Cannot proceed

        # Calculate and update original node&#39;s values
        for period in forecast_periods:
            try:
                val = tmp_node.calculate(period)
                # Default fallback for bad forecasts, overrideable via bad_forecast_value kwarg
                bad_value = kwargs.get(
                    &#34;bad_forecast_value&#34;, cfg(&#34;forecasting.default_bad_forecast_value&#34;)
                )
                if np.isnan(val) or np.isinf(val):
                    logger.warning(
                        f&#34;Bad forecast {val} for {node.name}@{period}; defaulting to {bad_value}&#34;
                    )
                    val = bad_value
                # Clamp negative values if disallowed
                allow_neg = kwargs.get(
                    &#34;allow_negative_forecasts&#34;,
                    cfg(&#34;forecasting.allow_negative_forecasts&#34;),
                )
                if not allow_neg and val &lt; 0:
                    # Ensure bad_value is non-negative when clamping negative values
                    if bad_value &lt; 0:
                        logger.warning(
                            f&#34;bad_forecast_value ({bad_value}) is negative but allow_negative_forecasts is False. Using 0.0 instead.&#34;
                        )
                        bad_value = 0.0
                    logger.warning(
                        f&#34;Negative forecast {val} for {node.name}@{period}; clamping to {bad_value}&#34;
                    )
                    val = bad_value
                node.values[period] = float(val)  # Update the original node
            except Exception as e:
                logger.error(
                    f&#34;Error forecasting {node.name}@{period}: {e}&#34;, exc_info=True
                )
                node.values[period] = bad_value  # Set default on error

        # Clear cache of the original node as its values have changed
        if hasattr(node, &#34;clear_cache&#34;) and callable(node.clear_cache):
            node.clear_cache()
            logger.debug(f&#34;Cleared cache for node {node.name} after forecast update.&#34;)

    def forecast_value(
        self,
        node_name: str,
        forecast_periods: list[str],
        base_period: Optional[str] = None,
        forecast_config: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Forecast and return values for a node without mutating the graph.

        **IMPORTANT**: This is a NON-MUTATING method that:
        - Does NOT add periods to the graph
        - Does NOT modify any node values
        - Does NOT affect the graph state in any way
        - Returns forecast values as a separate dictionary

        This method is ideal for:
        - What-if analysis
        - Comparing different forecast scenarios
        - Getting forecast values without committing them to the graph
        - API responses where you don&#39;t want to modify server state

        Args:
            node_name: Name of the node to forecast.
            forecast_periods: List of future periods to forecast.
            base_period: Optional base period to use for forecasting.
                        If omitted, will be inferred from the node&#39;s historical data.
            forecast_config: Forecast configuration dict with:
                - &#39;method&#39;: Forecasting method (&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;,
                           &#39;average&#39;, &#39;historical_growth&#39;)
                - &#39;config&#39;: Method-specific parameters
                If not provided, uses global forecasting defaults.
            **kwargs: Additional arguments passed to the internal forecasting logic.
                bad_forecast_value (float): Default to use for NaN/Inf or errors (overrides config)
                allow_negative_forecasts (bool): Whether to allow negative forecast values (overrides config)

        Returns:
            A dictionary mapping forecast periods to their calculated values.
            Example: {&#39;2024&#39;: 1050.0, &#39;2025&#39;: 1102.5}

        Raises:
            ForecastNodeError: If node not found, no historical periods available,
                              or invalid forecast configuration.
        &#34;&#34;&#34;
        # Optional override for bad forecast fallback
        bad_value = kwargs.get(
            &#34;bad_forecast_value&#34;, cfg(&#34;forecasting.default_bad_forecast_value&#34;)
        )
        # Locate the node
        node = self.fsg.get_node(node_name)
        if node is None:
            raise ForecastNodeError(
                f&#34;Node {node_name} not found in graph&#34;,
                node_id=node_name,
                available_nodes=list(self.fsg.nodes.keys()),
            )

        # Determine historical periods
        if base_period:
            historical_periods = [base_period]
        else:
            historical_periods = PeriodManager.infer_historical_periods(
                self.fsg, forecast_periods
            )

        # Validate inputs
        ForecastValidator.validate_forecast_inputs(historical_periods, forecast_periods)

        # Set default config if not provided, using global forecasting defaults
        if forecast_config is None:
            default_method = cfg(&#34;forecasting.default_method&#34;)
            # Use method-appropriate default config
            if default_method == &#34;simple&#34;:
                forecast_config = {
                    &#34;method&#34;: default_method,
                    &#34;config&#34;: cfg(&#34;forecasting.default_growth_rate&#34;),
                }
            else:
                # For other methods, use empty config and let the method handle defaults
                forecast_config = {&#34;method&#34;: default_method, &#34;config&#34;: {}}

        # Validate and create ForecastConfig
        validated_config = ForecastValidator.validate_forecast_config(forecast_config)
        ForecastValidator.validate_node_for_forecast(node, validated_config.method)

        # Determine base period
        calc_base_period = PeriodManager.determine_base_period(
            node, historical_periods, base_period
        )

        # Get the forecast method from registry
        method = get_forecast_method(validated_config.method)

        # Get normalized parameters for NodeFactory
        # All built-in methods extend BaseForecastMethod which has get_forecast_params
        base_method = cast(BaseForecastMethod, method)
        params = base_method.get_forecast_params(
            validated_config.config, forecast_periods
        )

        # Create a temporary forecast node (DO NOT add to graph)
        try:
            temp_forecast_node = NodeFactory.create_forecast_node(
                name=f&#34;{node_name}_temp_forecast&#34;,
                base_node=node,
                base_period=calc_base_period,
                forecast_periods=forecast_periods,
                forecast_type=params[&#34;forecast_type&#34;],
                growth_params=params[&#34;growth_params&#34;],
            )
        except Exception as e:
            logger.error(
                f&#34;Failed to create temporary forecast node for &#39;{node_name}&#39;: {e}&#34;,
                exc_info=True,
            )
            raise ForecastNodeError(
                f&#34;Could not create temporary forecast node: {e}&#34;,
                node_id=node_name,
                reason=str(e),
            )

        # Calculate results using the temporary node
        results: dict[str, float] = {}
        for period in forecast_periods:
            try:
                value = temp_forecast_node.calculate(period)
                # Handle potential NaN/Inf results from calculation
                results[period] = bad_value if not np.isfinite(value) else float(value)
                # Clamp negative values if disallowed
                allow_neg = kwargs.get(
                    &#34;allow_negative_forecasts&#34;,
                    cfg(&#34;forecasting.allow_negative_forecasts&#34;),
                )
                if not allow_neg and results[period] &lt; 0:
                    logger.warning(
                        f&#34;Negative forecast {results[period]} for {node_name}@{period}; clamping to {bad_value}&#34;
                    )
                    results[period] = bad_value
            except Exception as e:
                logger.warning(
                    f&#34;Error calculating temporary forecast for {node_name}@{period}: {e}. Returning {bad_value}&#34;
                )
                results[period] = bad_value

        # Validate results before returning
        ForecastValidator.validate_forecast_result(results, forecast_periods, node_name)

        return results

    def forecast_multiple(
        self,
        node_names: list[str],
        forecast_periods: list[str],
        forecast_configs: Optional[dict[str, dict[str, Any]]] = None,
        base_period: Optional[str] = None,
        **kwargs: Any,
    ) -&gt; dict[str, ForecastResult]:
        &#34;&#34;&#34;Forecast multiple nodes without mutating the graph.

        This is a convenience method that forecasts multiple nodes at once
        and returns structured results.

        Args:
            node_names: List of node names to forecast.
            forecast_periods: List of future periods to forecast.
            forecast_configs: Optional mapping of node names to their forecast configs.
                             If not provided, uses simple method with 0% growth for all.
            base_period: Optional base period to use for all nodes.
            **kwargs: Additional arguments passed to forecast_value.

        Returns:
            Dictionary mapping node names to ForecastResult objects.

        Example:
            &gt;&gt;&gt; results = forecaster.forecast_multiple(
            ...     [&#39;revenue&#39;, &#39;costs&#39;],
            ...     [&#39;2024&#39;, &#39;2025&#39;],
            ...     {&#39;revenue&#39;: {&#39;method&#39;: &#39;simple&#39;, &#39;config&#39;: 0.05}}
            ... )
            &gt;&gt;&gt; print(results[&#39;revenue&#39;].get_value(&#39;2024&#39;))
        &#34;&#34;&#34;
        # Determine error propagation strategy (override via continue_on_error kwarg)
        continue_on_err = kwargs.get(
            &#34;continue_on_error&#34;, cfg(&#34;forecasting.continue_on_error&#34;)
        )
        results: dict[str, ForecastResult] = {}
        configs = forecast_configs or {}

        for node_name in node_names:
            try:
                # Get config for this node or use default
                node_config = configs.get(node_name)

                # Forecast the node
                values = self.forecast_value(
                    node_name, forecast_periods, base_period, node_config, **kwargs
                )

                # Determine actual base period used
                node = self.fsg.get_node(node_name)
                historical_periods = PeriodManager.infer_historical_periods(
                    self.fsg, forecast_periods
                )
                actual_base_period = PeriodManager.determine_base_period(
                    node, historical_periods, base_period
                )

                # Create ForecastResult
                default_method = cfg(&#34;forecasting.default_method&#34;)
                config = ForecastValidator.validate_forecast_config(
                    node_config
                    or {
                        &#34;method&#34;: default_method,
                        &#34;config&#34;: cfg(&#34;forecasting.default_growth_rate&#34;),
                    }
                )

                results[node_name] = ForecastResult(
                    node_name=node_name,
                    periods=forecast_periods,
                    values=values,
                    method=config.method,
                    base_period=actual_base_period,
                )
            except Exception as e:
                logger.exception(f&#34;Error forecasting node {node_name}&#34;)
                if continue_on_err:
                    continue
                raise ForecastNodeError(
                    f&#34;Error forecasting node {node_name}: {e}&#34;,
                    node_id=node_name,
                    reason=str(e),
                )

        return results

    def forecast_node(
        self,
        node_name: str,
        config: ForecastConfig,
        historical_periods: Optional[int] = None,
    ) -&gt; ForecastResult:
        &#34;&#34;&#34;Forecast values for a specific node.

        Args:
            node_name: Name of the node to forecast
            config: Forecast configuration
            historical_periods: Number of historical periods to use

        Returns:
            ForecastResult containing the forecasted values

        Raises:
            ForecastNodeError: If node not found in graph
        &#34;&#34;&#34;
        if node_name not in self.fsg.nodes:
            raise ForecastNodeError(
                f&#34;Node {node_name} not found in graph&#34;,
                node_id=node_name,
                available_nodes=list(self.fsg.nodes.keys()),
            )
        # TODO: implement detailed forecasting logic for a single node
        raise NotImplementedError(&#34;forecast_node is not implemented&#34;)

    def forecast_all(
        self,
        default_config: ForecastConfig,
        node_configs: Optional[dict[str, ForecastConfig]] = None,
    ) -&gt; dict[str, ForecastResult]:
        &#34;&#34;&#34;Forecast all forecastable nodes in the graph.

        Args:
            default_config: Default configuration for nodes without specific config
            node_configs: Optional node-specific configurations

        Returns:
            Dictionary mapping node names to forecast results

        Raises:
            ForecastNodeError: If node not found in graph
        &#34;&#34;&#34;
        node_configs = node_configs or {}
        results = {}

        for node_name, node in self.fsg.nodes.items():
            if self._is_forecastable(node):
                config = node_configs.get(node_name, default_config)
                try:
                    results[node_name] = self.forecast_node(node_name, config)
                except Exception as e:
                    logger.warning(f&#34;Failed to forecast {node_name}: {e}&#34;)
                    continue

        return results

    def _is_forecastable(self, node: Node) -&gt; bool:
        &#34;&#34;&#34;Determine if a node is forecastable (has a &#39;values&#39; dictionary).&#34;&#34;&#34;
        return hasattr(node, &#34;values&#34;) and isinstance(node.values, dict)

    def create_forecast_node(
        self,
        base_node_name: str,
        forecast_name: str,
        config: ForecastConfig,
    ) -&gt; str:
        &#34;&#34;&#34;Create a new forecast node based on an existing node.

        Args:
            base_node_name: Name of the node to base forecast on
            forecast_name: Name for the new forecast node
            config: Forecast configuration

        Returns:
            Name of the created forecast node

        Raises:
            ForecastNodeError: If base node not found or forecast node creation fails
        &#34;&#34;&#34;
        if base_node_name not in self.fsg.nodes:
            raise ForecastNodeError(
                f&#34;Node {base_node_name} not found in graph&#34;,
                node_id=base_node_name,
                available_nodes=list(self.fsg.nodes.keys()),
            )

        base_node = self.fsg.nodes[base_node_name]

        # Create forecast node
        try:
            forecast_node = NodeFactory.create_forecast_node(  # type: ignore[call-arg]
                name=forecast_name,
                base_node=base_node,
                forecast_config=config,
            )
            self.fsg.add_node(forecast_node)
            return forecast_name
        except Exception as e:
            raise ForecastNodeError(
                f&#34;Could not create temporary forecast node: {e}&#34;,
                node_id=forecast_name,
                reason=str(e),
            ) from e</code></pre>
</details>
<div class="desc"><p>Perform forecasting operations on a financial statement graph.</p>
<p>This class supports both mutating and non-mutating forecasts:</p>
<ul>
<li>Mutating forecasts (<code>create_forecast</code>): adds forecast periods and updates node values.</li>
<li>Non-mutating forecasts (<code>forecast_value</code>): computes and returns forecast values without modifying the graph.</li>
</ul>
<p>Supported forecasting methods: simple, curve, statistical, average, historical_growth.</p>
<p>Initialize the forecaster.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fsg</code></strong></dt>
<dd>The FinancialStatementGraph instance this forecaster will operate on.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatementForecaster.create_forecast"><code class="name flex">
<span>def <span class="ident">create_forecast</span></span>(<span>self,<br>forecast_periods: list[str],<br>node_configs: dict[str, dict[str, typing.Any]] | None = None,<br>historical_periods: list[str] | None = None,<br>**kwargs: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_forecast(
    self,
    forecast_periods: list[str],
    node_configs: Optional[dict[str, dict[str, Any]]] = None,
    historical_periods: Optional[list[str]] = None,
    **kwargs: Any,
) -&gt; None:
    &#34;&#34;&#34;Create forecasts for financial statement items on the graph.

    **IMPORTANT**: This method MUTATES the graph by:
    - Adding new periods to the graph if they don&#39;t exist
    - Updating node values with forecast data
    - Clearing node caches after updates

    Use `forecast_value` instead if you need forecast values without
    modifying the graph.

    Args:
        forecast_periods: List of future periods to forecast.
        node_configs: Mapping of node names to their forecast configurations.
            Each config should contain:
            - &#39;method&#39;: Forecasting method (&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;,
                       &#39;average&#39;, &#39;historical_growth&#39;)
            - &#39;config&#39;: Method-specific parameters (growth rate, distribution, etc.)
        historical_periods: Optional list of historical periods to use as base.
            If not provided, will be inferred from the graph&#39;s existing periods.
        **kwargs: Additional arguments passed to the forecasting logic:
            add_missing_periods (bool): Whether to add missing forecast periods to the graph.

    Returns:
        None (modifies the graph in-place)

    Raises:
        ForecastNodeError: If no historical periods found, no forecast periods provided,
                          or invalid forecasting method/configuration.
    &#34;&#34;&#34;
    logger.info(
        f&#34;StatementForecaster: Creating forecast for periods {forecast_periods}&#34;
    )
    try:
        # Use PeriodManager to infer historical periods
        historical_periods = PeriodManager.infer_historical_periods(
            self.fsg, forecast_periods, historical_periods
        )

        # Validate inputs using ForecastValidator
        ForecastValidator.validate_forecast_inputs(
            historical_periods, forecast_periods, node_configs
        )

        # Ensure forecast periods exist in the graph (override via add_missing_periods)
        add_missing = kwargs.get(
            &#34;add_missing_periods&#34;, cfg(&#34;forecasting.add_missing_periods&#34;)
        )
        PeriodManager.ensure_periods_exist(
            self.fsg, forecast_periods, add_missing=add_missing
        )

        if node_configs is None:
            node_configs = {}

        for node_name, config in node_configs.items():
            node = self.fsg.get_node(node_name)
            if node is None:
                raise ForecastNodeError(
                    f&#34;Node {node_name} not found in graph&#34;,
                    node_id=node_name,
                    available_nodes=list(self.fsg.nodes.keys()),
                )

            # Validate node can be forecasted
            forecast_config = ForecastValidator.validate_forecast_config(config)
            ForecastValidator.validate_node_for_forecast(
                node, forecast_config.method
            )

            self._forecast_node(
                node, historical_periods, forecast_periods, forecast_config
            )

        logger.info(
            f&#34;Created forecast for {len(forecast_periods)} periods and {len(node_configs)} nodes&#34;
        )
    except Exception as e:
        logger.error(f&#34;Error creating forecast: {e}&#34;, exc_info=True)
        raise ForecastNodeError(
            f&#34;Error creating forecast: {e}&#34;, node_id=None, reason=str(e)
        )</code></pre>
</details>
<div class="desc"><p>Create forecasts for financial statement items on the graph.</p>
<p><strong>IMPORTANT</strong>: This method MUTATES the graph by:
- Adding new periods to the graph if they don't exist
- Updating node values with forecast data
- Clearing node caches after updates</p>
<p>Use <code>forecast_value</code> instead if you need forecast values without
modifying the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of future periods to forecast.</dd>
<dt><strong><code>node_configs</code></strong></dt>
<dd>Mapping of node names to their forecast configurations.
Each config should contain:
- 'method': Forecasting method ('simple', 'curve', 'statistical',
'average', 'historical_growth')
- 'config': Method-specific parameters (growth rate, distribution, etc.)</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>Optional list of historical periods to use as base.
If not provided, will be inferred from the graph's existing periods.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to the forecasting logic:
add_missing_periods (bool): Whether to add missing forecast periods to the graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None (modifies the graph in-place)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If no historical periods found, no forecast periods provided,
or invalid forecasting method/configuration.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.create_forecast_node"><code class="name flex">
<span>def <span class="ident">create_forecast_node</span></span>(<span>self,<br>base_node_name: str,<br>forecast_name: str,<br>config: <a title="fin_statement_model.forecasting.types.ForecastConfig" href="types.html#fin_statement_model.forecasting.types.ForecastConfig">ForecastConfig</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_forecast_node(
    self,
    base_node_name: str,
    forecast_name: str,
    config: ForecastConfig,
) -&gt; str:
    &#34;&#34;&#34;Create a new forecast node based on an existing node.

    Args:
        base_node_name: Name of the node to base forecast on
        forecast_name: Name for the new forecast node
        config: Forecast configuration

    Returns:
        Name of the created forecast node

    Raises:
        ForecastNodeError: If base node not found or forecast node creation fails
    &#34;&#34;&#34;
    if base_node_name not in self.fsg.nodes:
        raise ForecastNodeError(
            f&#34;Node {base_node_name} not found in graph&#34;,
            node_id=base_node_name,
            available_nodes=list(self.fsg.nodes.keys()),
        )

    base_node = self.fsg.nodes[base_node_name]

    # Create forecast node
    try:
        forecast_node = NodeFactory.create_forecast_node(  # type: ignore[call-arg]
            name=forecast_name,
            base_node=base_node,
            forecast_config=config,
        )
        self.fsg.add_node(forecast_node)
        return forecast_name
    except Exception as e:
        raise ForecastNodeError(
            f&#34;Could not create temporary forecast node: {e}&#34;,
            node_id=forecast_name,
            reason=str(e),
        ) from e</code></pre>
</details>
<div class="desc"><p>Create a new forecast node based on an existing node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_node_name</code></strong></dt>
<dd>Name of the node to base forecast on</dd>
<dt><strong><code>forecast_name</code></strong></dt>
<dd>Name for the new forecast node</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Forecast configuration</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Name of the created forecast node</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If base node not found or forecast node creation fails</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.forecast_all"><code class="name flex">
<span>def <span class="ident">forecast_all</span></span>(<span>self,<br>default_config: <a title="fin_statement_model.forecasting.types.ForecastConfig" href="types.html#fin_statement_model.forecasting.types.ForecastConfig">ForecastConfig</a>,<br>node_configs: dict[str, <a title="fin_statement_model.forecasting.types.ForecastConfig" href="types.html#fin_statement_model.forecasting.types.ForecastConfig">ForecastConfig</a>] | None = None) ‑> dict[str, <a title="fin_statement_model.forecasting.types.ForecastResult" href="types.html#fin_statement_model.forecasting.types.ForecastResult">ForecastResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_all(
    self,
    default_config: ForecastConfig,
    node_configs: Optional[dict[str, ForecastConfig]] = None,
) -&gt; dict[str, ForecastResult]:
    &#34;&#34;&#34;Forecast all forecastable nodes in the graph.

    Args:
        default_config: Default configuration for nodes without specific config
        node_configs: Optional node-specific configurations

    Returns:
        Dictionary mapping node names to forecast results

    Raises:
        ForecastNodeError: If node not found in graph
    &#34;&#34;&#34;
    node_configs = node_configs or {}
    results = {}

    for node_name, node in self.fsg.nodes.items():
        if self._is_forecastable(node):
            config = node_configs.get(node_name, default_config)
            try:
                results[node_name] = self.forecast_node(node_name, config)
            except Exception as e:
                logger.warning(f&#34;Failed to forecast {node_name}: {e}&#34;)
                continue

    return results</code></pre>
</details>
<div class="desc"><p>Forecast all forecastable nodes in the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default_config</code></strong></dt>
<dd>Default configuration for nodes without specific config</dd>
<dt><strong><code>node_configs</code></strong></dt>
<dd>Optional node-specific configurations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping node names to forecast results</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If node not found in graph</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.forecast_multiple"><code class="name flex">
<span>def <span class="ident">forecast_multiple</span></span>(<span>self,<br>node_names: list[str],<br>forecast_periods: list[str],<br>forecast_configs: dict[str, dict[str, typing.Any]] | None = None,<br>base_period: str | None = None,<br>**kwargs: Any) ‑> dict[str, <a title="fin_statement_model.forecasting.types.ForecastResult" href="types.html#fin_statement_model.forecasting.types.ForecastResult">ForecastResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_multiple(
    self,
    node_names: list[str],
    forecast_periods: list[str],
    forecast_configs: Optional[dict[str, dict[str, Any]]] = None,
    base_period: Optional[str] = None,
    **kwargs: Any,
) -&gt; dict[str, ForecastResult]:
    &#34;&#34;&#34;Forecast multiple nodes without mutating the graph.

    This is a convenience method that forecasts multiple nodes at once
    and returns structured results.

    Args:
        node_names: List of node names to forecast.
        forecast_periods: List of future periods to forecast.
        forecast_configs: Optional mapping of node names to their forecast configs.
                         If not provided, uses simple method with 0% growth for all.
        base_period: Optional base period to use for all nodes.
        **kwargs: Additional arguments passed to forecast_value.

    Returns:
        Dictionary mapping node names to ForecastResult objects.

    Example:
        &gt;&gt;&gt; results = forecaster.forecast_multiple(
        ...     [&#39;revenue&#39;, &#39;costs&#39;],
        ...     [&#39;2024&#39;, &#39;2025&#39;],
        ...     {&#39;revenue&#39;: {&#39;method&#39;: &#39;simple&#39;, &#39;config&#39;: 0.05}}
        ... )
        &gt;&gt;&gt; print(results[&#39;revenue&#39;].get_value(&#39;2024&#39;))
    &#34;&#34;&#34;
    # Determine error propagation strategy (override via continue_on_error kwarg)
    continue_on_err = kwargs.get(
        &#34;continue_on_error&#34;, cfg(&#34;forecasting.continue_on_error&#34;)
    )
    results: dict[str, ForecastResult] = {}
    configs = forecast_configs or {}

    for node_name in node_names:
        try:
            # Get config for this node or use default
            node_config = configs.get(node_name)

            # Forecast the node
            values = self.forecast_value(
                node_name, forecast_periods, base_period, node_config, **kwargs
            )

            # Determine actual base period used
            node = self.fsg.get_node(node_name)
            historical_periods = PeriodManager.infer_historical_periods(
                self.fsg, forecast_periods
            )
            actual_base_period = PeriodManager.determine_base_period(
                node, historical_periods, base_period
            )

            # Create ForecastResult
            default_method = cfg(&#34;forecasting.default_method&#34;)
            config = ForecastValidator.validate_forecast_config(
                node_config
                or {
                    &#34;method&#34;: default_method,
                    &#34;config&#34;: cfg(&#34;forecasting.default_growth_rate&#34;),
                }
            )

            results[node_name] = ForecastResult(
                node_name=node_name,
                periods=forecast_periods,
                values=values,
                method=config.method,
                base_period=actual_base_period,
            )
        except Exception as e:
            logger.exception(f&#34;Error forecasting node {node_name}&#34;)
            if continue_on_err:
                continue
            raise ForecastNodeError(
                f&#34;Error forecasting node {node_name}: {e}&#34;,
                node_id=node_name,
                reason=str(e),
            )

    return results</code></pre>
</details>
<div class="desc"><p>Forecast multiple nodes without mutating the graph.</p>
<p>This is a convenience method that forecasts multiple nodes at once
and returns structured results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_names</code></strong></dt>
<dd>List of node names to forecast.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of future periods to forecast.</dd>
<dt><strong><code>forecast_configs</code></strong></dt>
<dd>Optional mapping of node names to their forecast configs.
If not provided, uses simple method with 0% growth for all.</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>Optional base period to use for all nodes.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to forecast_value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping node names to ForecastResult objects.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; results = forecaster.forecast_multiple(
...     ['revenue', 'costs'],
...     ['2024', '2025'],
...     {'revenue': {'method': 'simple', 'config': 0.05}}
... )
&gt;&gt;&gt; print(results['revenue'].get_value('2024'))
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.forecast_node"><code class="name flex">
<span>def <span class="ident">forecast_node</span></span>(<span>self,<br>node_name: str,<br>config: <a title="fin_statement_model.forecasting.types.ForecastConfig" href="types.html#fin_statement_model.forecasting.types.ForecastConfig">ForecastConfig</a>,<br>historical_periods: int | None = None) ‑> <a title="fin_statement_model.forecasting.types.ForecastResult" href="types.html#fin_statement_model.forecasting.types.ForecastResult">ForecastResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_node(
    self,
    node_name: str,
    config: ForecastConfig,
    historical_periods: Optional[int] = None,
) -&gt; ForecastResult:
    &#34;&#34;&#34;Forecast values for a specific node.

    Args:
        node_name: Name of the node to forecast
        config: Forecast configuration
        historical_periods: Number of historical periods to use

    Returns:
        ForecastResult containing the forecasted values

    Raises:
        ForecastNodeError: If node not found in graph
    &#34;&#34;&#34;
    if node_name not in self.fsg.nodes:
        raise ForecastNodeError(
            f&#34;Node {node_name} not found in graph&#34;,
            node_id=node_name,
            available_nodes=list(self.fsg.nodes.keys()),
        )
    # TODO: implement detailed forecasting logic for a single node
    raise NotImplementedError(&#34;forecast_node is not implemented&#34;)</code></pre>
</details>
<div class="desc"><p>Forecast values for a specific node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node to forecast</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Forecast configuration</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>Number of historical periods to use</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ForecastResult containing the forecasted values</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If node not found in graph</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.forecast_value"><code class="name flex">
<span>def <span class="ident">forecast_value</span></span>(<span>self,<br>node_name: str,<br>forecast_periods: list[str],<br>base_period: str | None = None,<br>forecast_config: dict[str, typing.Any] | None = None,<br>**kwargs: Any) ‑> dict[str, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_value(
    self,
    node_name: str,
    forecast_periods: list[str],
    base_period: Optional[str] = None,
    forecast_config: Optional[dict[str, Any]] = None,
    **kwargs: Any,
) -&gt; dict[str, float]:
    &#34;&#34;&#34;Forecast and return values for a node without mutating the graph.

    **IMPORTANT**: This is a NON-MUTATING method that:
    - Does NOT add periods to the graph
    - Does NOT modify any node values
    - Does NOT affect the graph state in any way
    - Returns forecast values as a separate dictionary

    This method is ideal for:
    - What-if analysis
    - Comparing different forecast scenarios
    - Getting forecast values without committing them to the graph
    - API responses where you don&#39;t want to modify server state

    Args:
        node_name: Name of the node to forecast.
        forecast_periods: List of future periods to forecast.
        base_period: Optional base period to use for forecasting.
                    If omitted, will be inferred from the node&#39;s historical data.
        forecast_config: Forecast configuration dict with:
            - &#39;method&#39;: Forecasting method (&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;,
                       &#39;average&#39;, &#39;historical_growth&#39;)
            - &#39;config&#39;: Method-specific parameters
            If not provided, uses global forecasting defaults.
        **kwargs: Additional arguments passed to the internal forecasting logic.
            bad_forecast_value (float): Default to use for NaN/Inf or errors (overrides config)
            allow_negative_forecasts (bool): Whether to allow negative forecast values (overrides config)

    Returns:
        A dictionary mapping forecast periods to their calculated values.
        Example: {&#39;2024&#39;: 1050.0, &#39;2025&#39;: 1102.5}

    Raises:
        ForecastNodeError: If node not found, no historical periods available,
                          or invalid forecast configuration.
    &#34;&#34;&#34;
    # Optional override for bad forecast fallback
    bad_value = kwargs.get(
        &#34;bad_forecast_value&#34;, cfg(&#34;forecasting.default_bad_forecast_value&#34;)
    )
    # Locate the node
    node = self.fsg.get_node(node_name)
    if node is None:
        raise ForecastNodeError(
            f&#34;Node {node_name} not found in graph&#34;,
            node_id=node_name,
            available_nodes=list(self.fsg.nodes.keys()),
        )

    # Determine historical periods
    if base_period:
        historical_periods = [base_period]
    else:
        historical_periods = PeriodManager.infer_historical_periods(
            self.fsg, forecast_periods
        )

    # Validate inputs
    ForecastValidator.validate_forecast_inputs(historical_periods, forecast_periods)

    # Set default config if not provided, using global forecasting defaults
    if forecast_config is None:
        default_method = cfg(&#34;forecasting.default_method&#34;)
        # Use method-appropriate default config
        if default_method == &#34;simple&#34;:
            forecast_config = {
                &#34;method&#34;: default_method,
                &#34;config&#34;: cfg(&#34;forecasting.default_growth_rate&#34;),
            }
        else:
            # For other methods, use empty config and let the method handle defaults
            forecast_config = {&#34;method&#34;: default_method, &#34;config&#34;: {}}

    # Validate and create ForecastConfig
    validated_config = ForecastValidator.validate_forecast_config(forecast_config)
    ForecastValidator.validate_node_for_forecast(node, validated_config.method)

    # Determine base period
    calc_base_period = PeriodManager.determine_base_period(
        node, historical_periods, base_period
    )

    # Get the forecast method from registry
    method = get_forecast_method(validated_config.method)

    # Get normalized parameters for NodeFactory
    # All built-in methods extend BaseForecastMethod which has get_forecast_params
    base_method = cast(BaseForecastMethod, method)
    params = base_method.get_forecast_params(
        validated_config.config, forecast_periods
    )

    # Create a temporary forecast node (DO NOT add to graph)
    try:
        temp_forecast_node = NodeFactory.create_forecast_node(
            name=f&#34;{node_name}_temp_forecast&#34;,
            base_node=node,
            base_period=calc_base_period,
            forecast_periods=forecast_periods,
            forecast_type=params[&#34;forecast_type&#34;],
            growth_params=params[&#34;growth_params&#34;],
        )
    except Exception as e:
        logger.error(
            f&#34;Failed to create temporary forecast node for &#39;{node_name}&#39;: {e}&#34;,
            exc_info=True,
        )
        raise ForecastNodeError(
            f&#34;Could not create temporary forecast node: {e}&#34;,
            node_id=node_name,
            reason=str(e),
        )

    # Calculate results using the temporary node
    results: dict[str, float] = {}
    for period in forecast_periods:
        try:
            value = temp_forecast_node.calculate(period)
            # Handle potential NaN/Inf results from calculation
            results[period] = bad_value if not np.isfinite(value) else float(value)
            # Clamp negative values if disallowed
            allow_neg = kwargs.get(
                &#34;allow_negative_forecasts&#34;,
                cfg(&#34;forecasting.allow_negative_forecasts&#34;),
            )
            if not allow_neg and results[period] &lt; 0:
                logger.warning(
                    f&#34;Negative forecast {results[period]} for {node_name}@{period}; clamping to {bad_value}&#34;
                )
                results[period] = bad_value
        except Exception as e:
            logger.warning(
                f&#34;Error calculating temporary forecast for {node_name}@{period}: {e}. Returning {bad_value}&#34;
            )
            results[period] = bad_value

    # Validate results before returning
    ForecastValidator.validate_forecast_result(results, forecast_periods, node_name)

    return results</code></pre>
</details>
<div class="desc"><p>Forecast and return values for a node without mutating the graph.</p>
<p><strong>IMPORTANT</strong>: This is a NON-MUTATING method that:
- Does NOT add periods to the graph
- Does NOT modify any node values
- Does NOT affect the graph state in any way
- Returns forecast values as a separate dictionary</p>
<p>This method is ideal for:
- What-if analysis
- Comparing different forecast scenarios
- Getting forecast values without committing them to the graph
- API responses where you don't want to modify server state</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node to forecast.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of future periods to forecast.</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>Optional base period to use for forecasting.
If omitted, will be inferred from the node's historical data.</dd>
<dt><strong><code>forecast_config</code></strong></dt>
<dd>Forecast configuration dict with:
- 'method': Forecasting method ('simple', 'curve', 'statistical',
'average', 'historical_growth')
- 'config': Method-specific parameters
If not provided, uses global forecasting defaults.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to the internal forecasting logic.
bad_forecast_value (float): Default to use for NaN/Inf or errors (overrides config)
allow_negative_forecasts (bool): Whether to allow negative forecast values (overrides config)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>A dictionary mapping forecast periods to their calculated values.</dt>
<dt><code>Example</code></dt>
<dd>{'2024': 1050.0, '2025': 1102.5}</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If node not found, no historical periods available,
or invalid forecast configuration.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalConfig"><code class="flex name class">
<span>class <span class="ident">StatisticalConfig</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatisticalConfig(BaseModel):
    &#34;&#34;&#34;Define configuration schema for statistical forecasting method.

    Validates &#39;distribution&#39; and &#39;params&#39; based on the distribution type.
    &#34;&#34;&#34;

    distribution: str
    params: dict[str, float]

    model_config = ConfigDict(extra=&#34;forbid&#34;)

    @model_validator(mode=&#34;after&#34;)  # type: ignore[arg-type]
    def _validate_distribution(cls, values: &#34;StatisticalConfig&#34;) -&gt; &#34;StatisticalConfig&#34;:
        distribution = values.distribution
        params = values.params

        if distribution == &#34;normal&#34;:
            required = {&#34;mean&#34;, &#34;std&#34;}
            missing = required - params.keys()
            if missing:
                raise ForecastConfigurationError(
                    &#34;Normal distribution requires &#39;mean&#39; and &#39;std&#39; parameters&#34;,
                    config=params,
                    missing_params=list(missing),
                )
        elif distribution == &#34;uniform&#34;:
            required = {&#34;low&#34;, &#34;high&#34;}
            missing = required - params.keys()
            if missing:
                raise ForecastConfigurationError(
                    &#34;Uniform distribution requires &#39;low&#39; and &#39;high&#39; parameters&#34;,
                    config=params,
                    missing_params=list(missing),
                )
        else:
            raise ForecastConfigurationError(
                f&#34;Unsupported distribution: {distribution}&#34;,
                config=params,
                invalid_params={&#34;distribution&#34;: f&#34;&#39;{distribution}&#39; is not supported&#34;},
            )

        return values</code></pre>
</details>
<div class="desc"><p>Define configuration schema for statistical forecasting method.</p>
<p>Validates 'distribution' and 'params' based on the distribution type.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatisticalConfig.distribution"><code class="name">var <span class="ident">distribution</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalConfig.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalConfig.params"><code class="name">var <span class="ident">params</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod"><code class="flex name class">
<span>class <span class="ident">StatisticalForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatisticalForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values by sampling from statistical distributions.

    This method generates forecast values by sampling from specified statistical
    distributions, useful for Monte Carlo simulations and uncertainty analysis.

    Configuration:
        - &#39;distribution&#39;: &#39;normal&#39; or &#39;uniform&#39;
        - &#39;params&#39;: Distribution-specific parameters
            - For &#39;normal&#39;: {&#39;mean&#39;: float, &#39;std&#39;: float}
            - For &#39;uniform&#39;: {&#39;low&#39;: float, &#39;high&#39;: float}

    Example:
        &gt;&gt;&gt; method = StatisticalForecastMethod()
        &gt;&gt;&gt; config = {
        ...     &#34;distribution&#34;: &#34;normal&#34;,
        ...     &#34;params&#34;: {&#34;mean&#34;: 0.05, &#34;std&#34;: 0.02}
        ... }
        &gt;&gt;&gt; params = method.get_forecast_params(config, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; # Returns: {&#34;forecast_type&#34;: &#34;statistical&#34;, &#34;growth_params&#34;: &lt;callable&gt;}
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        return &#34;statistical&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;
        return &#34;statistical&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for statistical method.

        Args:
            config: Should be a dict with &#39;distribution&#39; and &#39;params&#39; keys.

        Raises:
            TypeError: If config is invalid.
        &#34;&#34;&#34;
        if not isinstance(config, dict):
            raise TypeError(
                f&#34;Statistical method requires dict configuration, got {type(config)}&#34;
            )

        if &#34;distribution&#34; not in config:
            raise ValueError(&#34;Statistical method requires &#39;distribution&#39; key&#34;)

        if &#34;params&#34; not in config:
            raise ValueError(&#34;Statistical method requires &#39;params&#39; key&#34;)

        # Validate using StatisticalConfig model (raises ValidationError or ForecastConfigurationError)
        try:
            StatisticalConfig(
                distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;]
            )
        except (ValueError, TypeError, ValidationError) as e:
            raise ValueError(f&#34;Invalid statistical configuration: {e}&#34;) from e

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Statistical distribution configuration.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            The &#39;growth_params&#39; value is a callable that generates random values.
        &#34;&#34;&#34;
        # Create validated config
        stat_config = StatisticalConfig(
            distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;]
        )

        # Seed RNG if configured
        seed = cfg(&#34;forecasting.random_seed&#34;)
        if seed is not None:
            rng = np.random.RandomState(seed)
        else:
            rng = np.random.RandomState()

        # Create generator function based on distribution
        def generator() -&gt; float:
            &#34;&#34;&#34;Generate a random growth rate from the specified distribution.&#34;&#34;&#34;
            if stat_config.distribution == &#34;normal&#34;:
                return float(
                    rng.normal(stat_config.params[&#34;mean&#34;], stat_config.params[&#34;std&#34;])
                )
            elif stat_config.distribution == &#34;uniform&#34;:
                return float(
                    rng.uniform(stat_config.params[&#34;low&#34;], stat_config.params[&#34;high&#34;])
                )
            else:
                # This shouldn&#39;t happen due to validation, but just in case
                raise ValueError(
                    f&#34;Unsupported distribution: {stat_config.distribution}&#34;
                )

        return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: generator}</code></pre>
</details>
<div class="desc"><p>Forecast future values by sampling from statistical distributions.</p>
<p>This method generates forecast values by sampling from specified statistical
distributions, useful for Monte Carlo simulations and uncertainty analysis.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>'distribution': 'normal' or 'uniform'</li>
<li>'params': Distribution-specific parameters<ul>
<li>For 'normal': {'mean': float, 'std': float}</li>
<li>For 'uniform': {'low': float, 'high': float}</li>
</ul>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = StatisticalForecastMethod()
&gt;&gt;&gt; config = {
...     &quot;distribution&quot;: &quot;normal&quot;,
...     &quot;params&quot;: {&quot;mean&quot;: 0.05, &quot;std&quot;: 0.02}
... }
&gt;&gt;&gt; params = method.get_forecast_params(config, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;statistical&quot;, &quot;growth_params&quot;: &lt;callable&gt;}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Statistical distribution configuration.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        The &#39;growth_params&#39; value is a callable that generates random values.
    &#34;&#34;&#34;
    # Create validated config
    stat_config = StatisticalConfig(
        distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;]
    )

    # Seed RNG if configured
    seed = cfg(&#34;forecasting.random_seed&#34;)
    if seed is not None:
        rng = np.random.RandomState(seed)
    else:
        rng = np.random.RandomState()

    # Create generator function based on distribution
    def generator() -&gt; float:
        &#34;&#34;&#34;Generate a random growth rate from the specified distribution.&#34;&#34;&#34;
        if stat_config.distribution == &#34;normal&#34;:
            return float(
                rng.normal(stat_config.params[&#34;mean&#34;], stat_config.params[&#34;std&#34;])
            )
        elif stat_config.distribution == &#34;uniform&#34;:
            return float(
                rng.uniform(stat_config.params[&#34;low&#34;], stat_config.params[&#34;high&#34;])
            )
        else:
            # This shouldn&#39;t happen due to validation, but just in case
            raise ValueError(
                f&#34;Unsupported distribution: {stat_config.distribution}&#34;
            )

    return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: generator}</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Statistical distribution configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
The 'growth_params' value is a callable that generates random values.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for statistical method.

    Args:
        config: Should be a dict with &#39;distribution&#39; and &#39;params&#39; keys.

    Raises:
        TypeError: If config is invalid.
    &#34;&#34;&#34;
    if not isinstance(config, dict):
        raise TypeError(
            f&#34;Statistical method requires dict configuration, got {type(config)}&#34;
        )

    if &#34;distribution&#34; not in config:
        raise ValueError(&#34;Statistical method requires &#39;distribution&#39; key&#34;)

    if &#34;params&#34; not in config:
        raise ValueError(&#34;Statistical method requires &#39;params&#39; key&#34;)

    # Validate using StatisticalConfig model (raises ValidationError or ForecastConfigurationError)
    try:
        StatisticalConfig(
            distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;]
        )
    except (ValueError, TypeError, ValidationError) as e:
        raise ValueError(f&#34;Invalid statistical configuration: {e}&#34;) from e</code></pre>
</details>
<div class="desc"><p>Validate the configuration for statistical method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Should be a dict with 'distribution' and 'params' keys.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If config is invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.name" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model" href="../index.html">fin_statement_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.forecasting.errors" href="errors.html">fin_statement_model.forecasting.errors</a></code></li>
<li><code><a title="fin_statement_model.forecasting.forecaster" href="forecaster.html">fin_statement_model.forecasting.forecaster</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods" href="methods/index.html">fin_statement_model.forecasting.methods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.period_manager" href="period_manager.html">fin_statement_model.forecasting.period_manager</a></code></li>
<li><code><a title="fin_statement_model.forecasting.strategies" href="strategies.html">fin_statement_model.forecasting.strategies</a></code></li>
<li><code><a title="fin_statement_model.forecasting.types" href="types.html">fin_statement_model.forecasting.types</a></code></li>
<li><code><a title="fin_statement_model.forecasting.validators" href="validators.html">fin_statement_model.forecasting.validators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.get_forecast_method" href="#fin_statement_model.forecasting.get_forecast_method">get_forecast_method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.register_forecast_method" href="#fin_statement_model.forecasting.register_forecast_method">register_forecast_method</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.forecasting.AverageForecastMethod" href="#fin_statement_model.forecasting.AverageForecastMethod">AverageForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.normalize_params" href="#fin_statement_model.forecasting.AverageForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.AverageForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.validate_config" href="#fin_statement_model.forecasting.AverageForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.BaseForecastMethod" href="#fin_statement_model.forecasting.BaseForecastMethod">BaseForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.get_forecast_params" href="#fin_statement_model.forecasting.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.internal_type" href="#fin_statement_model.forecasting.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.name" href="#fin_statement_model.forecasting.BaseForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.normalize_params" href="#fin_statement_model.forecasting.BaseForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.validate_config" href="#fin_statement_model.forecasting.BaseForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.CurveForecastMethod" href="#fin_statement_model.forecasting.CurveForecastMethod">CurveForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.CurveForecastMethod.normalize_params" href="#fin_statement_model.forecasting.CurveForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.CurveForecastMethod.validate_config" href="#fin_statement_model.forecasting.CurveForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastConfig" href="#fin_statement_model.forecasting.ForecastConfig">ForecastConfig</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.ForecastConfig.config" href="#fin_statement_model.forecasting.ForecastConfig.config">config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastConfig.method" href="#fin_statement_model.forecasting.ForecastConfig.method">method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastConfig.model_config" href="#fin_statement_model.forecasting.ForecastConfig.model_config">model_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastConfigurationError" href="#fin_statement_model.forecasting.ForecastConfigurationError">ForecastConfigurationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastMethod" href="#fin_statement_model.forecasting.ForecastMethod">ForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.name" href="#fin_statement_model.forecasting.ForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.normalize_params" href="#fin_statement_model.forecasting.ForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.ForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.validate_config" href="#fin_statement_model.forecasting.ForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastMethodError" href="#fin_statement_model.forecasting.ForecastMethodError">ForecastMethodError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry" href="#fin_statement_model.forecasting.ForecastMethodRegistry">ForecastMethodRegistry</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.get_method" href="#fin_statement_model.forecasting.ForecastMethodRegistry.get_method">get_method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.get_method_info" href="#fin_statement_model.forecasting.ForecastMethodRegistry.get_method_info">get_method_info</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.has_method" href="#fin_statement_model.forecasting.ForecastMethodRegistry.has_method">has_method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.list_methods" href="#fin_statement_model.forecasting.ForecastMethodRegistry.list_methods">list_methods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.register" href="#fin_statement_model.forecasting.ForecastMethodRegistry.register">register</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.unregister" href="#fin_statement_model.forecasting.ForecastMethodRegistry.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastResult" href="#fin_statement_model.forecasting.ForecastResult">ForecastResult</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.forecasting.ForecastResult.base_period" href="#fin_statement_model.forecasting.ForecastResult.base_period">base_period</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.get_value" href="#fin_statement_model.forecasting.ForecastResult.get_value">get_value</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.method" href="#fin_statement_model.forecasting.ForecastResult.method">method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.model_config" href="#fin_statement_model.forecasting.ForecastResult.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.node_name" href="#fin_statement_model.forecasting.ForecastResult.node_name">node_name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.periods" href="#fin_statement_model.forecasting.ForecastResult.periods">periods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.values" href="#fin_statement_model.forecasting.ForecastResult.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastResultError" href="#fin_statement_model.forecasting.ForecastResultError">ForecastResultError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastValidator" href="#fin_statement_model.forecasting.ForecastValidator">ForecastValidator</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_base_period" href="#fin_statement_model.forecasting.ForecastValidator.validate_base_period">validate_base_period</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_forecast_config" href="#fin_statement_model.forecasting.ForecastValidator.validate_forecast_config">validate_forecast_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_forecast_inputs" href="#fin_statement_model.forecasting.ForecastValidator.validate_forecast_inputs">validate_forecast_inputs</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_forecast_result" href="#fin_statement_model.forecasting.ForecastValidator.validate_forecast_result">validate_forecast_result</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_node_config" href="#fin_statement_model.forecasting.ForecastValidator.validate_node_config">validate_node_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_node_for_forecast" href="#fin_statement_model.forecasting.ForecastValidator.validate_node_for_forecast">validate_node_for_forecast</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastingError" href="#fin_statement_model.forecasting.ForecastingError">ForecastingError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod">HistoricalGrowthForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.calculate_average_growth_rate" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.calculate_average_growth_rate">calculate_average_growth_rate</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.normalize_params" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.validate_config" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.PeriodManager" href="#fin_statement_model.forecasting.PeriodManager">PeriodManager</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.PeriodManager.determine_base_period" href="#fin_statement_model.forecasting.PeriodManager.determine_base_period">determine_base_period</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.ensure_periods_exist" href="#fin_statement_model.forecasting.PeriodManager.ensure_periods_exist">ensure_periods_exist</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.get_period_index" href="#fin_statement_model.forecasting.PeriodManager.get_period_index">get_period_index</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.infer_historical_periods" href="#fin_statement_model.forecasting.PeriodManager.infer_historical_periods">infer_historical_periods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.validate_period_sequence" href="#fin_statement_model.forecasting.PeriodManager.validate_period_sequence">validate_period_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.SimpleForecastMethod" href="#fin_statement_model.forecasting.SimpleForecastMethod">SimpleForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.SimpleForecastMethod.normalize_params" href="#fin_statement_model.forecasting.SimpleForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.SimpleForecastMethod.validate_config" href="#fin_statement_model.forecasting.SimpleForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.StatementForecaster" href="#fin_statement_model.forecasting.StatementForecaster">StatementForecaster</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.create_forecast" href="#fin_statement_model.forecasting.StatementForecaster.create_forecast">create_forecast</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.create_forecast_node" href="#fin_statement_model.forecasting.StatementForecaster.create_forecast_node">create_forecast_node</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.forecast_all" href="#fin_statement_model.forecasting.StatementForecaster.forecast_all">forecast_all</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.forecast_multiple" href="#fin_statement_model.forecasting.StatementForecaster.forecast_multiple">forecast_multiple</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.forecast_node" href="#fin_statement_model.forecasting.StatementForecaster.forecast_node">forecast_node</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.forecast_value" href="#fin_statement_model.forecasting.StatementForecaster.forecast_value">forecast_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.StatisticalConfig" href="#fin_statement_model.forecasting.StatisticalConfig">StatisticalConfig</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.StatisticalConfig.distribution" href="#fin_statement_model.forecasting.StatisticalConfig.distribution">distribution</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalConfig.model_config" href="#fin_statement_model.forecasting.StatisticalConfig.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalConfig.params" href="#fin_statement_model.forecasting.StatisticalConfig.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod" href="#fin_statement_model.forecasting.StatisticalForecastMethod">StatisticalForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod.normalize_params" href="#fin_statement_model.forecasting.StatisticalForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod.validate_config" href="#fin_statement_model.forecasting.StatisticalForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
