<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.forecasting.methods.historical_growth API documentation</title>
<meta name="description" content="Forecast future values based on average historical growth patterns â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.forecasting.methods.historical_growth</code></h1>
</header>
<section id="section-intro">
<p>Forecast future values based on average historical growth patterns.</p>
<p>This method calculates future values by determining the average historical
growth rate and applying it to the base value for forecast periods.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Not required (pass None or 0)</li>
<li>Automatically calculates growth from historical data based on minimum periods configured</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(None, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;historical_growth&quot;, &quot;growth_params&quot;: None}
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod"><code class="flex name class">
<span>class <span class="ident">HistoricalGrowthForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HistoricalGrowthForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values based on average historical growth patterns.

    This method calculates the average historical growth rate and applies it to
    forecast future values. Useful when past growth patterns are expected to
    continue.

    Configuration:
        - Not required (pass None or 0)
        - Automatically calculates growth from historical data requiring at least
          cfg(&#34;forecasting.min_historical_periods&#34;) data points

    Example:
        &gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; # Returns: {&#34;forecast_type&#34;: &#34;historical_growth&#34;, &#34;growth_params&#34;: None}
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.&#34;&#34;&#34;
        return &#34;historical_growth&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.&#34;&#34;&#34;
        return &#34;historical_growth&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for historical growth method.

        Args:
            config: Not used for historical growth method, can be None or 0.

        Note:
            Historical growth method doesn&#39;t require configuration as it
            calculates growth from historical data automatically.
        &#34;&#34;&#34;
        # Historical growth method doesn&#39;t need specific configuration
        # Accept None, 0, or any placeholder value

    def normalize_params(
        self, config: Any, forecast_periods: list[str]
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Not used for historical growth method.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            For historical growth method, growth_params is None.
        &#34;&#34;&#34;
        return {
            &#34;forecast_type&#34;: self.internal_type,
            &#34;growth_params&#34;: None,  # Historical growth method calculates internally
        }

    def prepare_historical_data(
        self, node: Node, historical_periods: list[str]
    ) -&gt; Optional[list[float]]:
        &#34;&#34;&#34;Prepare historical data for growth calculation.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of valid historical values (at least 2 needed for growth).

        Raises:
            ValueError: If insufficient historical data is available.
        &#34;&#34;&#34;
        if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
            raise ValueError(
                f&#34;Node {node.name} cannot be calculated for historical growth method&#34;
            )

        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ValueError(
                f&#34;Node {node.name} does not have values dictionary for historical growth method&#34;
            )

        # Extract historical values in chronological order
        historical_values = []
        for period in historical_periods:
            if period in node.values:
                try:
                    value = node.calculate(period)
                    if (
                        value is not None
                        and not np.isnan(value)
                        and not np.isinf(value)
                    ):
                        historical_values.append(float(value))
                except Exception as e:
                    # Log the exception and skip this period
                    logger.debug(
                        f&#34;Skipping period {period} for node {node.name} in historical growth calculation: {e}&#34;
                    )
                    continue

        min_periods = cfg(&#34;forecasting.min_historical_periods&#34;)
        if len(historical_values) &lt; min_periods:
            raise ValueError(
                f&#34;Need at least {min_periods} historical data points for node {node.name} &#34;
                f&#34;to compute growth rate, found {len(historical_values)}&#34;
            )

        return historical_values

    def calculate_average_growth_rate(self, historical_values: list[float]) -&gt; float:
        &#34;&#34;&#34;Calculate the average growth rate from historical values.

        Args:
            historical_values: List of historical values in chronological order.

        Returns:
            Average growth rate.

        Note:
            This is a helper method that can be used by the forecast node
            implementation to calculate the growth rate.
        &#34;&#34;&#34;
        # Calculate period-over-period growth rates
        if len(historical_values) &lt; 2:
            return 0.0

        growth_rates: list[float] = []
        for i in range(1, len(historical_values)):
            previous_value = historical_values[i - 1]
            if previous_value != 0:
                growth_rates.append(
                    (historical_values[i] - previous_value) / previous_value
                )

        if not growth_rates:
            return 0.0

        # Determine aggregation method: &#39;mean&#39; or &#39;median&#39;
        agg_method = cfg(&#34;forecasting.historical_growth_aggregation&#34;)
        if agg_method == &#34;median&#34;:
            try:
                return float(np.median(growth_rates))
            except (ValueError, TypeError) as e:
                logger.warning(
                    f&#34;Failed to calculate median growth rate, falling back to mean: {e}&#34;
                )
                return float(np.mean(growth_rates))
        # Default to mean
        return float(np.mean(growth_rates))</code></pre>
</details>
<div class="desc"><p>Forecast future values based on average historical growth patterns.</p>
<p>This method calculates the average historical growth rate and applies it to
forecast future values. Useful when past growth patterns are expected to
continue.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Not required (pass None or 0)</li>
<li>Automatically calculates growth from historical data requiring at least
cfg("forecasting.min_historical_periods") data points</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(None, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; # Returns: {&quot;forecast_type&quot;: &quot;historical_growth&quot;, &quot;growth_params&quot;: None}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.calculate_average_growth_rate"><code class="name flex">
<span>def <span class="ident">calculate_average_growth_rate</span></span>(<span>self, historical_values:Â list[float]) â€‘>Â float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_average_growth_rate(self, historical_values: list[float]) -&gt; float:
    &#34;&#34;&#34;Calculate the average growth rate from historical values.

    Args:
        historical_values: List of historical values in chronological order.

    Returns:
        Average growth rate.

    Note:
        This is a helper method that can be used by the forecast node
        implementation to calculate the growth rate.
    &#34;&#34;&#34;
    # Calculate period-over-period growth rates
    if len(historical_values) &lt; 2:
        return 0.0

    growth_rates: list[float] = []
    for i in range(1, len(historical_values)):
        previous_value = historical_values[i - 1]
        if previous_value != 0:
            growth_rates.append(
                (historical_values[i] - previous_value) / previous_value
            )

    if not growth_rates:
        return 0.0

    # Determine aggregation method: &#39;mean&#39; or &#39;median&#39;
    agg_method = cfg(&#34;forecasting.historical_growth_aggregation&#34;)
    if agg_method == &#34;median&#34;:
        try:
            return float(np.median(growth_rates))
        except (ValueError, TypeError) as e:
            logger.warning(
                f&#34;Failed to calculate median growth rate, falling back to mean: {e}&#34;
            )
            return float(np.mean(growth_rates))
    # Default to mean
    return float(np.mean(growth_rates))</code></pre>
</details>
<div class="desc"><p>Calculate the average growth rate from historical values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>historical_values</code></strong></dt>
<dd>List of historical values in chronological order.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Average growth rate.</p>
<h2 id="note">Note</h2>
<p>This is a helper method that can be used by the forecast node
implementation to calculate the growth rate.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config:Â Any, forecast_periods:Â list[str]) â€‘>Â dict[str,Â typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(
    self, config: Any, forecast_periods: list[str]
) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Not used for historical growth method.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        For historical growth method, growth_params is None.
    &#34;&#34;&#34;
    return {
        &#34;forecast_type&#34;: self.internal_type,
        &#34;growth_params&#34;: None,  # Historical growth method calculates internally
    }</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for historical growth method.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
For historical growth method, growth_params is None.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node:Â <a title="fin_statement_model.core.nodes.base.Node" href="../../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods:Â list[str]) â€‘>Â list[float]Â |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(
    self, node: Node, historical_periods: list[str]
) -&gt; Optional[list[float]]:
    &#34;&#34;&#34;Prepare historical data for growth calculation.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of valid historical values (at least 2 needed for growth).

    Raises:
        ValueError: If insufficient historical data is available.
    &#34;&#34;&#34;
    if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
        raise ValueError(
            f&#34;Node {node.name} cannot be calculated for historical growth method&#34;
        )

    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ValueError(
            f&#34;Node {node.name} does not have values dictionary for historical growth method&#34;
        )

    # Extract historical values in chronological order
    historical_values = []
    for period in historical_periods:
        if period in node.values:
            try:
                value = node.calculate(period)
                if (
                    value is not None
                    and not np.isnan(value)
                    and not np.isinf(value)
                ):
                    historical_values.append(float(value))
            except Exception as e:
                # Log the exception and skip this period
                logger.debug(
                    f&#34;Skipping period {period} for node {node.name} in historical growth calculation: {e}&#34;
                )
                continue

    min_periods = cfg(&#34;forecasting.min_historical_periods&#34;)
    if len(historical_values) &lt; min_periods:
        raise ValueError(
            f&#34;Need at least {min_periods} historical data points for node {node.name} &#34;
            f&#34;to compute growth rate, found {len(historical_values)}&#34;
        )

    return historical_values</code></pre>
</details>
<div class="desc"><p>Prepare historical data for growth calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of valid historical values (at least 2 needed for growth).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If insufficient historical data is available.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for historical growth method.

    Args:
        config: Not used for historical growth method, can be None or 0.

    Note:
        Historical growth method doesn&#39;t require configuration as it
        calculates growth from historical data automatically.
    &#34;&#34;&#34;
    # Historical growth method doesn&#39;t need specific configuration
    # Accept None, 0, or any placeholder value</code></pre>
</details>
<div class="desc"><p>Validate the configuration for historical growth method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for historical growth method, can be None or 0.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Historical growth method doesn't require configuration as it
calculates growth from historical data automatically.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type" href="base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.name" href="base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.forecasting.methods" href="index.html">fin_statement_model.forecasting.methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod" href="#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod">HistoricalGrowthForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.calculate_average_growth_rate" href="#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.calculate_average_growth_rate">calculate_average_growth_rate</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.normalize_params" href="#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.validate_config" href="#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
