<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.core.calculations.calculation API documentation</title>
<meta name="description" content="Calculation for the Financial Statement Model …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.core.calculations.calculation</code></h1>
</header>
<section id="section-intro">
<p>Calculation for the Financial Statement Model.</p>
<p>This module provides the Calculation Pattern implementation for calculations,
allowing different calculation types to be encapsulated in calculation classes.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.AdditionCalculation"><code class="flex name class">
<span>class <span class="ident">AdditionCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdditionCalculation(Calculation):
    &#34;&#34;&#34;Implements an addition calculation, summing values from multiple input nodes.

    This calculation sums the values obtained from calling
    the `calculate` method on each of the provided input nodes for a given period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Sums the calculated values from all input nodes for the specified period.

        Args:
            inputs: A list of Node objects.
            period: The time period string (e.g., &#34;2023Q4&#34;) for the calculation.

        Returns:
            The total sum of the values calculated from the input nodes. Returns
            0.0 if the input list is empty.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value): self._value = value
            ...     def calculate(self, period): return self._value
            &gt;&gt;&gt; strategy = AdditionCalculation()
            &gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(5)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            35.0
            &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
            0.0
        &#34;&#34;&#34;
        logger.debug(f&#34;Applying addition calculation for period {period}&#34;)
        # Using a generator expression for potentially better memory efficiency
        return sum(input_node.calculate(period) for input_node in inputs)

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the addition calculation.&#34;&#34;&#34;
        return &#34;Addition (sum of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements an addition calculation, summing values from multiple input nodes.</p>
<p>This calculation sums the values obtained from calling
the <code>calculate</code> method on each of the provided input nodes for a given period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.AdditionCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the addition calculation.&#34;&#34;&#34;
    return &#34;Addition (sum of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the addition calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.AdditionCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Sums the calculated values from all input nodes for the specified period.

    Args:
        inputs: A list of Node objects.
        period: The time period string (e.g., &#34;2023Q4&#34;) for the calculation.

    Returns:
        The total sum of the values calculated from the input nodes. Returns
        0.0 if the input list is empty.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value): self._value = value
        ...     def calculate(self, period): return self._value
        &gt;&gt;&gt; strategy = AdditionCalculation()
        &gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(5)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        35.0
        &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
        0.0
    &#34;&#34;&#34;
    logger.debug(f&#34;Applying addition calculation for period {period}&#34;)
    # Using a generator expression for potentially better memory efficiency
    return sum(input_node.calculate(period) for input_node in inputs)</code></pre>
</details>
<div class="desc"><p>Sums the calculated values from all input nodes for the specified period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2023Q4") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The total sum of the values calculated from the input nodes. Returns
0.0 if the input list is empty.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value): self._value = value
...     def calculate(self, period): return self._value
&gt;&gt;&gt; strategy = AdditionCalculation()
&gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(5)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
35.0
&gt;&gt;&gt; strategy.calculate([], &quot;2023&quot;)
0.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.Calculation"><code class="flex name class">
<span>class <span class="ident">Calculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Calculation(ABC):
    &#34;&#34;&#34;Abstract base class for all calculations.

    This class defines the interface that all concrete calculation classes must
    implement. It employs a calculation pattern, allowing the algorithm
    used by a CalculationNode to be selected at runtime.

    Each concrete calculation encapsulates a specific method for computing a
    financial value based on a list of input nodes and a given time period.
    &#34;&#34;&#34;

    @abstractmethod
    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculate a value based on input nodes for a specific period.

        This abstract method must be implemented by all concrete calculation classes.
        It defines the core logic for the calculation.

        Args:
            inputs: A list of input Node objects whose values will be used in
                the calculation.
            period: The time period string (e.g., &#34;2023Q1&#34;) for which the
                calculation should be performed.

        Returns:
            The calculated numerical value as a float.

        Raises:
            NotImplementedError: If the method is not implemented by a subclass.
            ValueError: If the inputs are invalid for the specific calculation
                (e.g., wrong number of inputs, incompatible types).
            ZeroDivisionError: If the calculation involves division and a divisor
                is zero.
            Exception: Other exceptions depending on the calculation logic.
        &#34;&#34;&#34;
        # pragma: no cover

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Provides a human-readable description of the calculation.

        This is useful for documentation, debugging, and for user interfaces
        that need to explain how a value is derived.

        Returns:
            A string describing the calculation.
        &#34;&#34;&#34;
        # Default implementation returns the class name. Subclasses should override
        # for more specific descriptions.
        class_name = self.__class__.__name__  # pragma: no cover
        return class_name</code></pre>
</details>
<div class="desc"><p>Abstract base class for all calculations.</p>
<p>This class defines the interface that all concrete calculation classes must
implement. It employs a calculation pattern, allowing the algorithm
used by a CalculationNode to be selected at runtime.</p>
<p>Each concrete calculation encapsulates a specific method for computing a
financial value based on a list of input nodes and a given time period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.AdditionCalculation" href="#fin_statement_model.core.calculations.calculation.AdditionCalculation">AdditionCalculation</a></li>
<li><a title="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation" href="#fin_statement_model.core.calculations.calculation.CustomFormulaCalculation">CustomFormulaCalculation</a></li>
<li><a title="fin_statement_model.core.calculations.calculation.DivisionCalculation" href="#fin_statement_model.core.calculations.calculation.DivisionCalculation">DivisionCalculation</a></li>
<li><a title="fin_statement_model.core.calculations.calculation.FormulaCalculation" href="#fin_statement_model.core.calculations.calculation.FormulaCalculation">FormulaCalculation</a></li>
<li><a title="fin_statement_model.core.calculations.calculation.MultiplicationCalculation" href="#fin_statement_model.core.calculations.calculation.MultiplicationCalculation">MultiplicationCalculation</a></li>
<li><a title="fin_statement_model.core.calculations.calculation.SubtractionCalculation" href="#fin_statement_model.core.calculations.calculation.SubtractionCalculation">SubtractionCalculation</a></li>
<li><a title="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation" href="#fin_statement_model.core.calculations.calculation.WeightedAverageCalculation">WeightedAverageCalculation</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.Calculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Provides a human-readable description of the calculation.

    This is useful for documentation, debugging, and for user interfaces
    that need to explain how a value is derived.

    Returns:
        A string describing the calculation.
    &#34;&#34;&#34;
    # Default implementation returns the class name. Subclasses should override
    # for more specific descriptions.
    class_name = self.__class__.__name__  # pragma: no cover
    return class_name</code></pre>
</details>
<div class="desc"><p>Provides a human-readable description of the calculation.</p>
<p>This is useful for documentation, debugging, and for user interfaces
that need to explain how a value is derived.</p>
<h2 id="returns">Returns</h2>
<p>A string describing the calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.Calculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculate a value based on input nodes for a specific period.

    This abstract method must be implemented by all concrete calculation classes.
    It defines the core logic for the calculation.

    Args:
        inputs: A list of input Node objects whose values will be used in
            the calculation.
        period: The time period string (e.g., &#34;2023Q1&#34;) for which the
            calculation should be performed.

    Returns:
        The calculated numerical value as a float.

    Raises:
        NotImplementedError: If the method is not implemented by a subclass.
        ValueError: If the inputs are invalid for the specific calculation
            (e.g., wrong number of inputs, incompatible types).
        ZeroDivisionError: If the calculation involves division and a divisor
            is zero.
        Exception: Other exceptions depending on the calculation logic.
    &#34;&#34;&#34;
    # pragma: no cover</code></pre>
</details>
<div class="desc"><p>Calculate a value based on input nodes for a specific period.</p>
<p>This abstract method must be implemented by all concrete calculation classes.
It defines the core logic for the calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of input Node objects whose values will be used in
the calculation.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2023Q1") for which the
calculation should be performed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The calculated numerical value as a float.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If the method is not implemented by a subclass.</dd>
<dt><code>ValueError</code></dt>
<dd>If the inputs are invalid for the specific calculation
(e.g., wrong number of inputs, incompatible types).</dd>
<dt><code>ZeroDivisionError</code></dt>
<dd>If the calculation involves division and a divisor
is zero.</dd>
<dt><code>Exception</code></dt>
<dd>Other exceptions depending on the calculation logic.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation"><code class="flex name class">
<span>class <span class="ident">CustomFormulaCalculation</span></span>
<span>(</span><span>formula_function: Callable[[dict[str, float]], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomFormulaCalculation(Calculation):
    &#34;&#34;&#34;Executes a user-defined Python function to calculate a value.

    This calculation provides maximum flexibility by allowing any custom Python
    function to be used for calculation. The function receives a dictionary
    mapping input node names (or fallback names) to their calculated values
    for the period and should return a single float result.
    &#34;&#34;&#34;

    def __init__(self, formula_function: FormulaFunc):
        &#34;&#34;&#34;Initializes the CustomFormulaCalculation with a calculation function.

        Args:
            formula_function: A callable (function, lambda, etc.) that accepts
                a single argument: a dictionary mapping string keys (input node
                names or `input_&lt;i&gt;`) to their float values for the period.
                It must return a float.

        Raises:
            TypeError: If `formula_function` is not callable.
        &#34;&#34;&#34;
        if not callable(formula_function):
            raise StrategyError(
                &#34;formula_function must be callable&#34;,
                strategy_type=&#34;CustomFormulaCalculation&#34;,
            )
        self.formula_function = formula_function
        logger.info(
            f&#34;Initialized CustomFormulaCalculation with function: {formula_function.__name__}&#34;
        )

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Applies the custom formula function to the calculated input values.

        Args:
            inputs: A list of Node objects.
            period: The time period string (e.g., &#34;2025M1&#34;) for the calculation.

        Returns:
            The float result returned by the `formula_function`.

        Raises:
            CalculationError: If the `formula_function` encounters an error during execution
                (e.g., incorrect input keys, calculation errors). Wraps the original exception.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, name, value): self.name = name; self._value = value
            ...     def calculate(self, period): return self._value
            &gt;&gt;&gt; def my_formula(data):
            ...     # Example: Gross Profit Margin
            ...     return (data[&#39;revenue&#39;] - data[&#39;cogs&#39;]) / data[&#39;revenue&#39;] * 100
            &gt;&gt;&gt; strategy = CustomFormulaCalculation(my_formula)
            &gt;&gt;&gt; nodes = [MockNode(&#39;revenue&#39;, 1000), MockNode(&#39;cogs&#39;, 600)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            40.0
            &gt;&gt;&gt; # Example with unnamed nodes
            &gt;&gt;&gt; def simple_sum(data):
            ...     return data[&#39;input_0&#39;] + data[&#39;input_1&#39;]
            &gt;&gt;&gt; strategy_unnamed = CustomFormulaCalculation(simple_sum)
            &gt;&gt;&gt; nodes_unnamed = [MockNode(None, 10), MockNode(None, 20)] # No names
            &gt;&gt;&gt; strategy_unnamed.calculate(nodes_unnamed, &#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        # Prepare input values dictionary, using names if available
        input_values: dict[str, float] = {}
        for i, node in enumerate(inputs):
            # Prefer node.name if it exists and is a non-empty string
            key = getattr(node, &#34;name&#34;, None)
            if not isinstance(key, str) or not key:
                key = f&#34;input_{i}&#34;
            input_values[key] = node.calculate(period)

        logger.debug(
            f&#34;Applying custom formula calculation for period {period} with inputs: {input_values}&#34;
        )
        try:
            # Execute the user-provided function
            result = self.formula_function(input_values)
            if not isinstance(result, int | float):
                logger.warning(
                    f&#34;Custom formula function {self.formula_function.__name__} &#34;
                    f&#34;returned non-numeric type: {type(result)}. Attempting cast.&#34;
                )
                # Attempt conversion, but be aware this might fail or be lossy
                try:
                    return float(result)
                except (ValueError, TypeError) as cast_err:
                    raise CalculationError(
                        f&#34;Custom formula {self.formula_function.__name__} result &#34;
                        f&#34;({result!r}) could not be cast to float.&#34;,
                        period=period,
                        details={
                            &#34;result&#34;: result,
                            &#34;result_type&#34;: type(result).__name__,
                        },
                    ) from cast_err
            return float(result)  # Ensure result is float
        except Exception as e:
            # Catch any exception from the custom function and wrap it
            logger.error(
                f&#34;Error executing custom formula &#39;{self.formula_function.__name__}&#39;: {e}&#34;,
                exc_info=True,
            )
            raise CalculationError(
                f&#34;Error in custom formula &#39;{self.formula_function.__name__}&#39;: {e}&#34;,
                period=period,
                details={&#34;original_error&#34;: str(e)},
            ) from e

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the custom formula calculation.&#34;&#34;&#34;
        func_name = getattr(self.formula_function, &#34;__name__&#34;, &#34;[anonymous function]&#34;)
        return f&#34;Custom Formula (using function: {func_name})&#34;</code></pre>
</details>
<div class="desc"><p>Executes a user-defined Python function to calculate a value.</p>
<p>This calculation provides maximum flexibility by allowing any custom Python
function to be used for calculation. The function receives a dictionary
mapping input node names (or fallback names) to their calculated values
for the period and should return a single float result.</p>
<p>Initializes the CustomFormulaCalculation with a calculation function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula_function</code></strong></dt>
<dd>A callable (function, lambda, etc.) that accepts
a single argument: a dictionary mapping string keys (input node
names or <code>input_&lt;i&gt;</code>) to their float values for the period.
It must return a float.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>formula_function</code> is not callable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the custom formula calculation.&#34;&#34;&#34;
    func_name = getattr(self.formula_function, &#34;__name__&#34;, &#34;[anonymous function]&#34;)
    return f&#34;Custom Formula (using function: {func_name})&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the custom formula calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Applies the custom formula function to the calculated input values.

    Args:
        inputs: A list of Node objects.
        period: The time period string (e.g., &#34;2025M1&#34;) for the calculation.

    Returns:
        The float result returned by the `formula_function`.

    Raises:
        CalculationError: If the `formula_function` encounters an error during execution
            (e.g., incorrect input keys, calculation errors). Wraps the original exception.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, name, value): self.name = name; self._value = value
        ...     def calculate(self, period): return self._value
        &gt;&gt;&gt; def my_formula(data):
        ...     # Example: Gross Profit Margin
        ...     return (data[&#39;revenue&#39;] - data[&#39;cogs&#39;]) / data[&#39;revenue&#39;] * 100
        &gt;&gt;&gt; strategy = CustomFormulaCalculation(my_formula)
        &gt;&gt;&gt; nodes = [MockNode(&#39;revenue&#39;, 1000), MockNode(&#39;cogs&#39;, 600)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        40.0
        &gt;&gt;&gt; # Example with unnamed nodes
        &gt;&gt;&gt; def simple_sum(data):
        ...     return data[&#39;input_0&#39;] + data[&#39;input_1&#39;]
        &gt;&gt;&gt; strategy_unnamed = CustomFormulaCalculation(simple_sum)
        &gt;&gt;&gt; nodes_unnamed = [MockNode(None, 10), MockNode(None, 20)] # No names
        &gt;&gt;&gt; strategy_unnamed.calculate(nodes_unnamed, &#34;2023&#34;)
        30.0
    &#34;&#34;&#34;
    # Prepare input values dictionary, using names if available
    input_values: dict[str, float] = {}
    for i, node in enumerate(inputs):
        # Prefer node.name if it exists and is a non-empty string
        key = getattr(node, &#34;name&#34;, None)
        if not isinstance(key, str) or not key:
            key = f&#34;input_{i}&#34;
        input_values[key] = node.calculate(period)

    logger.debug(
        f&#34;Applying custom formula calculation for period {period} with inputs: {input_values}&#34;
    )
    try:
        # Execute the user-provided function
        result = self.formula_function(input_values)
        if not isinstance(result, int | float):
            logger.warning(
                f&#34;Custom formula function {self.formula_function.__name__} &#34;
                f&#34;returned non-numeric type: {type(result)}. Attempting cast.&#34;
            )
            # Attempt conversion, but be aware this might fail or be lossy
            try:
                return float(result)
            except (ValueError, TypeError) as cast_err:
                raise CalculationError(
                    f&#34;Custom formula {self.formula_function.__name__} result &#34;
                    f&#34;({result!r}) could not be cast to float.&#34;,
                    period=period,
                    details={
                        &#34;result&#34;: result,
                        &#34;result_type&#34;: type(result).__name__,
                    },
                ) from cast_err
        return float(result)  # Ensure result is float
    except Exception as e:
        # Catch any exception from the custom function and wrap it
        logger.error(
            f&#34;Error executing custom formula &#39;{self.formula_function.__name__}&#39;: {e}&#34;,
            exc_info=True,
        )
        raise CalculationError(
            f&#34;Error in custom formula &#39;{self.formula_function.__name__}&#39;: {e}&#34;,
            period=period,
            details={&#34;original_error&#34;: str(e)},
        ) from e</code></pre>
</details>
<div class="desc"><p>Applies the custom formula function to the calculated input values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2025M1") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The float result returned by the <code>formula_function</code>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If the <code>formula_function</code> encounters an error during execution
(e.g., incorrect input keys, calculation errors). Wraps the original exception.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, name, value): self.name = name; self._value = value
...     def calculate(self, period): return self._value
&gt;&gt;&gt; def my_formula(data):
...     # Example: Gross Profit Margin
...     return (data['revenue'] - data['cogs']) / data['revenue'] * 100
&gt;&gt;&gt; strategy = CustomFormulaCalculation(my_formula)
&gt;&gt;&gt; nodes = [MockNode('revenue', 1000), MockNode('cogs', 600)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
40.0
&gt;&gt;&gt; # Example with unnamed nodes
&gt;&gt;&gt; def simple_sum(data):
...     return data['input_0'] + data['input_1']
&gt;&gt;&gt; strategy_unnamed = CustomFormulaCalculation(simple_sum)
&gt;&gt;&gt; nodes_unnamed = [MockNode(None, 10), MockNode(None, 20)] # No names
&gt;&gt;&gt; strategy_unnamed.calculate(nodes_unnamed, &quot;2023&quot;)
30.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.DivisionCalculation"><code class="flex name class">
<span>class <span class="ident">DivisionCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DivisionCalculation(Calculation):
    &#34;&#34;&#34;Implements a division calculation: first input divided by the product of the rest.

    This calculation takes the calculated value of the first node (numerator) and
    divides it by the product of the calculated values of all subsequent nodes
    (denominator) for a specific period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculates the division: first input / (product of subsequent inputs).

        Args:
            inputs: A list of Node objects. Must contain at least two nodes.
            period: The time period string (e.g., &#34;2024Q2&#34;) for the calculation.

        Returns:
            The result of the division.

        Raises:
            CalculationError: If the `inputs` list contains fewer than two nodes or if the denominator product is zero.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value): self._value = value
            ...     def calculate(self, period): return self._value
            &gt;&gt;&gt; strategy = DivisionCalculation()
            &gt;&gt;&gt; nodes = [MockNode(100), MockNode(5), MockNode(2)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            10.0
            &gt;&gt;&gt; nodes_zero_denom = [MockNode(100), MockNode(5), MockNode(0)]
            &gt;&gt;&gt; try:
            ...     strategy.calculate(nodes_zero_denom, &#34;2023&#34;)
            ... except CalculationError as e:
            ...     # Example: logging the error instead of printing
            ...     logger.error(e)
            Division by zero: Denominator product is zero
        &#34;&#34;&#34;
        if len(inputs) &lt; 2:
            raise CalculationError(
                &#34;Division calculation requires at least two input nodes&#34;,
                details={&#34;strategy&#34;: &#34;DivisionCalculation&#34;, &#34;input_count&#34;: len(inputs)},
            )

        logger.debug(f&#34;Applying division calculation for period {period}&#34;)

        values = [node.calculate(period) for node in inputs]
        numerator = values[0]

        denominator = 1.0
        for val in values[1:]:
            denominator *= val

        if denominator == 0.0:
            raise CalculationError(
                &#34;Division by zero: Denominator product is zero&#34;,
                period=period,
                details={&#34;numerator&#34;: numerator, &#34;denominator&#34;: denominator},
            )

        return numerator / denominator

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the division calculation.&#34;&#34;&#34;
        return &#34;Division (first input / product of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements a division calculation: first input divided by the product of the rest.</p>
<p>This calculation takes the calculated value of the first node (numerator) and
divides it by the product of the calculated values of all subsequent nodes
(denominator) for a specific period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.DivisionCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the division calculation.&#34;&#34;&#34;
    return &#34;Division (first input / product of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the division calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.DivisionCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculates the division: first input / (product of subsequent inputs).

    Args:
        inputs: A list of Node objects. Must contain at least two nodes.
        period: The time period string (e.g., &#34;2024Q2&#34;) for the calculation.

    Returns:
        The result of the division.

    Raises:
        CalculationError: If the `inputs` list contains fewer than two nodes or if the denominator product is zero.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value): self._value = value
        ...     def calculate(self, period): return self._value
        &gt;&gt;&gt; strategy = DivisionCalculation()
        &gt;&gt;&gt; nodes = [MockNode(100), MockNode(5), MockNode(2)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        10.0
        &gt;&gt;&gt; nodes_zero_denom = [MockNode(100), MockNode(5), MockNode(0)]
        &gt;&gt;&gt; try:
        ...     strategy.calculate(nodes_zero_denom, &#34;2023&#34;)
        ... except CalculationError as e:
        ...     # Example: logging the error instead of printing
        ...     logger.error(e)
        Division by zero: Denominator product is zero
    &#34;&#34;&#34;
    if len(inputs) &lt; 2:
        raise CalculationError(
            &#34;Division calculation requires at least two input nodes&#34;,
            details={&#34;strategy&#34;: &#34;DivisionCalculation&#34;, &#34;input_count&#34;: len(inputs)},
        )

    logger.debug(f&#34;Applying division calculation for period {period}&#34;)

    values = [node.calculate(period) for node in inputs]
    numerator = values[0]

    denominator = 1.0
    for val in values[1:]:
        denominator *= val

    if denominator == 0.0:
        raise CalculationError(
            &#34;Division by zero: Denominator product is zero&#34;,
            period=period,
            details={&#34;numerator&#34;: numerator, &#34;denominator&#34;: denominator},
        )

    return numerator / denominator</code></pre>
</details>
<div class="desc"><p>Calculates the division: first input / (product of subsequent inputs).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects. Must contain at least two nodes.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2024Q2") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result of the division.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If the <code>inputs</code> list contains fewer than two nodes or if the denominator product is zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value): self._value = value
...     def calculate(self, period): return self._value
&gt;&gt;&gt; strategy = DivisionCalculation()
&gt;&gt;&gt; nodes = [MockNode(100), MockNode(5), MockNode(2)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
10.0
&gt;&gt;&gt; nodes_zero_denom = [MockNode(100), MockNode(5), MockNode(0)]
&gt;&gt;&gt; try:
...     strategy.calculate(nodes_zero_denom, &quot;2023&quot;)
... except CalculationError as e:
...     # Example: logging the error instead of printing
...     logger.error(e)
Division by zero: Denominator product is zero
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.FormulaCalculation"><code class="flex name class">
<span>class <span class="ident">FormulaCalculation</span></span>
<span>(</span><span>formula: str, input_variable_names: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormulaCalculation(Calculation):
    &#34;&#34;&#34;Evaluates a mathematical formula string as a calculation strategy.

    This calculation parses and evaluates simple mathematical expressions
    involving input nodes. Supports basic arithmetic operators (+, -, *, /)
    and unary negation.

    Attributes:
        formula: The mathematical expression string to evaluate.
        input_variable_names: List of variable names used in the formula,
            corresponding to the order of input nodes.
        _ast: The parsed Abstract Syntax Tree of the formula.
    &#34;&#34;&#34;

    # Supported AST operators mapping to Python operator functions
    OPERATORS: ClassVar[dict[Type[Any], Callable[..., float]]] = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        ast.USub: operator.neg,
    }

    def __init__(self, formula: str, input_variable_names: list[str]):
        &#34;&#34;&#34;Initialize the FormulaCalculation.

        Args:
            formula: The mathematical formula string (e.g., &#34;a + b / 2&#34;).
            input_variable_names: List of variable names used in the formula,
                in the same order as the input nodes that will be provided
                to the calculate method.

        Raises:
            ValueError: If the formula string has invalid syntax.
        &#34;&#34;&#34;
        self.formula = formula
        self.input_variable_names = input_variable_names
        try:
            # Parse the formula string into an AST expression
            self._ast = ast.parse(formula, mode=&#34;eval&#34;).body
        except SyntaxError as e:
            raise StrategyError(
                f&#34;Invalid formula syntax: {formula}&#34;,
                strategy_type=&#34;FormulaCalculation&#34;,
            ) from e
        logger.info(
            f&#34;Initialized FormulaCalculation with formula: {formula} and variables: {input_variable_names}&#34;
        )

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the value by evaluating the formula with input node values.

        Args:
            inputs: A list of Node objects, in the same order as input_variable_names.
            period: The time period string for the calculation.

        Returns:
            The result of the formula evaluation.

        Raises:
            StrategyError: If the number of inputs doesn&#39;t match number of variable names.
            CalculationError: If an error occurs during evaluation of the formula.
        &#34;&#34;&#34;
        if len(inputs) != len(self.input_variable_names):
            raise StrategyError(
                f&#34;Number of inputs ({len(inputs)}) must match number of variable names &#34;
                f&#34;({len(self.input_variable_names)})&#34;,
                strategy_type=&#34;FormulaCalculation&#34;,
            )

        # Create mapping of variable names to nodes
        variable_map = dict(zip(self.input_variable_names, inputs))

        logger.debug(f&#34;Applying formula calculation for period {period}&#34;)
        try:
            return self._evaluate(self._ast, period, variable_map)
        except (ValueError, TypeError, KeyError, ZeroDivisionError) as e:
            raise CalculationError(
                f&#34;Error evaluating formula: {self.formula}. Error: {e!s}&#34;,
                period=period,
                details={&#34;formula&#34;: self.formula, &#34;original_error&#34;: str(e)},
            ) from e

    def _evaluate(
        self, node: ast.AST, period: str, variable_map: dict[str, Node]
    ) -&gt; float:
        &#34;&#34;&#34;Recursively evaluate the parsed AST node for the formula.

        Args:
            node: The current AST node to evaluate.
            period: The time period context for the evaluation.
            variable_map: Mapping of variable names to Node objects.

        Returns:
            The result of evaluating the AST node.

        Raises:
            TypeError: If a non-numeric constant or input node value is encountered.
            ValueError: If an unknown variable or unsupported operator/syntax is found.
            ZeroDivisionError: If division by zero occurs.
        &#34;&#34;&#34;
        # Numeric literal (Constant in Python 3.8+)
        if isinstance(node, ast.Constant):
            if isinstance(node.value, int | float):
                return float(node.value)
            else:
                raise CalculationError(
                    f&#34;Unsupported constant type &#39;{type(node.value).__name__}&#39; in formula&#34;,
                    period=period,
                    details={&#34;constant_type&#34;: type(node.value).__name__},
                )

        # Variable reference
        elif isinstance(node, ast.Name):
            var_name = node.id
            if var_name not in variable_map:
                raise CalculationError(
                    f&#34;Unknown variable &#39;{var_name}&#39; in formula. Available: {list(variable_map.keys())}&#34;,
                    period=period,
                    details={
                        &#34;unknown_var&#34;: var_name,
                        &#34;available_vars&#34;: list(variable_map.keys()),
                    },
                )
            input_node = variable_map[var_name]
            # Recursively calculate the value of the input node
            value = input_node.calculate(period)
            if not isinstance(value, int | float):
                raise CalculationError(
                    f&#34;Input node &#39;{input_node.name}&#39; (variable &#39;{var_name}&#39;) did not return a numeric value for period &#39;{period}&#39;&#34;,
                    node_id=input_node.name,
                    period=period,
                    details={&#34;value_type&#34;: type(value).__name__},
                )
            return float(value)

        # Binary operation (e.g., a + b)
        elif isinstance(node, ast.BinOp):
            left_val = self._evaluate(node.left, period, variable_map)
            right_val = self._evaluate(node.right, period, variable_map)
            op_type = type(node.op)  # type: Type[Any]
            if op_type not in self.OPERATORS:
                raise StrategyError(
                    f&#34;Unsupported binary operator &#39;{op_type.__name__}&#39; in formula&#34;,
                    strategy_type=&#34;FormulaCalculation&#34;,
                )
            # Perform the operation
            return float(self.OPERATORS[op_type](left_val, right_val))

        # Unary operation (e.g., -a)
        elif isinstance(node, ast.UnaryOp):
            operand_val = self._evaluate(node.operand, period, variable_map)
            unary_op_type = type(node.op)
            if unary_op_type not in self.OPERATORS:
                raise StrategyError(
                    f&#34;Unsupported unary operator &#39;{unary_op_type.__name__}&#39; in formula&#34;,
                    strategy_type=&#34;FormulaCalculation&#34;,
                )
            # Perform the operation
            return float(self.OPERATORS[unary_op_type](operand_val))

        # If the node type is unsupported
        else:
            raise StrategyError(
                f&#34;Unsupported syntax node type &#39;{type(node).__name__}&#39; in formula: {ast.dump(node)}&#34;,
                strategy_type=&#34;FormulaCalculation&#34;,
            )

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the formula calculation.&#34;&#34;&#34;
        return f&#34;Formula: {self.formula}&#34;</code></pre>
</details>
<div class="desc"><p>Evaluates a mathematical formula string as a calculation strategy.</p>
<p>This calculation parses and evaluates simple mathematical expressions
involving input nodes. Supports basic arithmetic operators (+, -, *, /)
and unary negation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The mathematical expression string to evaluate.</dd>
<dt><strong><code>input_variable_names</code></strong></dt>
<dd>List of variable names used in the formula,
corresponding to the order of input nodes.</dd>
<dt><strong><code>_ast</code></strong></dt>
<dd>The parsed Abstract Syntax Tree of the formula.</dd>
</dl>
<p>Initialize the FormulaCalculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The mathematical formula string (e.g., "a + b / 2").</dd>
<dt><strong><code>input_variable_names</code></strong></dt>
<dd>List of variable names used in the formula,
in the same order as the input nodes that will be provided
to the calculate method.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the formula string has invalid syntax.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.FormulaCalculation.OPERATORS"><code class="name">var <span class="ident">OPERATORS</span> : ClassVar[dict[Type[Any], Callable[..., float]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.FormulaCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the formula calculation.&#34;&#34;&#34;
    return f&#34;Formula: {self.formula}&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the formula calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.FormulaCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the value by evaluating the formula with input node values.

    Args:
        inputs: A list of Node objects, in the same order as input_variable_names.
        period: The time period string for the calculation.

    Returns:
        The result of the formula evaluation.

    Raises:
        StrategyError: If the number of inputs doesn&#39;t match number of variable names.
        CalculationError: If an error occurs during evaluation of the formula.
    &#34;&#34;&#34;
    if len(inputs) != len(self.input_variable_names):
        raise StrategyError(
            f&#34;Number of inputs ({len(inputs)}) must match number of variable names &#34;
            f&#34;({len(self.input_variable_names)})&#34;,
            strategy_type=&#34;FormulaCalculation&#34;,
        )

    # Create mapping of variable names to nodes
    variable_map = dict(zip(self.input_variable_names, inputs))

    logger.debug(f&#34;Applying formula calculation for period {period}&#34;)
    try:
        return self._evaluate(self._ast, period, variable_map)
    except (ValueError, TypeError, KeyError, ZeroDivisionError) as e:
        raise CalculationError(
            f&#34;Error evaluating formula: {self.formula}. Error: {e!s}&#34;,
            period=period,
            details={&#34;formula&#34;: self.formula, &#34;original_error&#34;: str(e)},
        ) from e</code></pre>
</details>
<div class="desc"><p>Calculate the value by evaluating the formula with input node values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects, in the same order as input_variable_names.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result of the formula evaluation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StrategyError</code></dt>
<dd>If the number of inputs doesn't match number of variable names.</dd>
<dt><code>CalculationError</code></dt>
<dd>If an error occurs during evaluation of the formula.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.MultiplicationCalculation"><code class="flex name class">
<span>class <span class="ident">MultiplicationCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiplicationCalculation(Calculation):
    &#34;&#34;&#34;Implements a multiplication calculation, calculating the product of input values.

    This calculation multiplies the calculated values of all provided input nodes
    for a given period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculates the product of the values from all input nodes.

        Args:
            inputs: A list of Node objects.
            period: The time period string (e.g., &#34;2023FY&#34;) for the calculation.

        Returns:
            The product of all input values. Returns 1.0 (multiplicative identity)
            if the input list is empty.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value): self._value = value
            ...     def calculate(self, period): return self._value
            &gt;&gt;&gt; strategy = MultiplicationCalculation()
            &gt;&gt;&gt; nodes = [MockNode(2), MockNode(3), MockNode(4)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            24.0
            &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
            1.0
        &#34;&#34;&#34;
        # Multiplication calculation should ideally return 1.0 for empty inputs.
        # Raising error if empty seems less conventional for multiplication.
        if not inputs:
            logger.warning(
                &#34;Multiplication calculation called with empty inputs, returning 1.0&#34;
            )
            return 1.0

        logger.debug(f&#34;Applying multiplication calculation for period {period}&#34;)
        result = 1.0
        for input_node in inputs:
            result *= input_node.calculate(period)
        return result

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the multiplication calculation.&#34;&#34;&#34;
        return &#34;Multiplication (product of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements a multiplication calculation, calculating the product of input values.</p>
<p>This calculation multiplies the calculated values of all provided input nodes
for a given period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.MultiplicationCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the multiplication calculation.&#34;&#34;&#34;
    return &#34;Multiplication (product of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the multiplication calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.MultiplicationCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculates the product of the values from all input nodes.

    Args:
        inputs: A list of Node objects.
        period: The time period string (e.g., &#34;2023FY&#34;) for the calculation.

    Returns:
        The product of all input values. Returns 1.0 (multiplicative identity)
        if the input list is empty.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value): self._value = value
        ...     def calculate(self, period): return self._value
        &gt;&gt;&gt; strategy = MultiplicationCalculation()
        &gt;&gt;&gt; nodes = [MockNode(2), MockNode(3), MockNode(4)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        24.0
        &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
        1.0
    &#34;&#34;&#34;
    # Multiplication calculation should ideally return 1.0 for empty inputs.
    # Raising error if empty seems less conventional for multiplication.
    if not inputs:
        logger.warning(
            &#34;Multiplication calculation called with empty inputs, returning 1.0&#34;
        )
        return 1.0

    logger.debug(f&#34;Applying multiplication calculation for period {period}&#34;)
    result = 1.0
    for input_node in inputs:
        result *= input_node.calculate(period)
    return result</code></pre>
</details>
<div class="desc"><p>Calculates the product of the values from all input nodes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2023FY") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The product of all input values. Returns 1.0 (multiplicative identity)
if the input list is empty.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value): self._value = value
...     def calculate(self, period): return self._value
&gt;&gt;&gt; strategy = MultiplicationCalculation()
&gt;&gt;&gt; nodes = [MockNode(2), MockNode(3), MockNode(4)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
24.0
&gt;&gt;&gt; strategy.calculate([], &quot;2023&quot;)
1.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.SubtractionCalculation"><code class="flex name class">
<span>class <span class="ident">SubtractionCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubtractionCalculation(Calculation):
    &#34;&#34;&#34;Implements a subtraction calculation: first input minus the sum of the rest.

    This calculation takes the calculated value of the first node in the input list
    and subtracts the sum of the calculated values of all subsequent nodes for
    a specific period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculates the difference: value of the first input minus the sum of others.

        Args:
            inputs: A list of Node objects. Must contain at least one node.
            period: The time period string (e.g., &#34;2024Q1&#34;) for the calculation.

        Returns:
            The result of the subtraction. If only one input node is provided,
            its value is returned.

        Raises:
            CalculationError: If the `inputs` list is empty.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value): self._value = value
            ...     def calculate(self, period): return self._value
            &gt;&gt;&gt; strategy = SubtractionCalculation()
            &gt;&gt;&gt; nodes = [MockNode(100), MockNode(20), MockNode(30)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            50.0
            &gt;&gt;&gt; nodes_single = [MockNode(100)]
            &gt;&gt;&gt; strategy.calculate(nodes_single, &#34;2023&#34;)
            100.0
        &#34;&#34;&#34;
        if not inputs:
            raise CalculationError(
                &#34;Subtraction calculation requires at least one input node&#34;,
                details={&#34;strategy&#34;: &#34;SubtractionCalculation&#34;},
            )

        logger.debug(f&#34;Applying subtraction calculation for period {period}&#34;)
        # Calculate values first to avoid multiple calls if nodes are complex
        values = [node.calculate(period) for node in inputs]
        return values[0] - sum(values[1:])

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the subtraction calculation.&#34;&#34;&#34;
        return &#34;Subtraction (first input minus sum of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements a subtraction calculation: first input minus the sum of the rest.</p>
<p>This calculation takes the calculated value of the first node in the input list
and subtracts the sum of the calculated values of all subsequent nodes for
a specific period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.SubtractionCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the subtraction calculation.&#34;&#34;&#34;
    return &#34;Subtraction (first input minus sum of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the subtraction calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.SubtractionCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculates the difference: value of the first input minus the sum of others.

    Args:
        inputs: A list of Node objects. Must contain at least one node.
        period: The time period string (e.g., &#34;2024Q1&#34;) for the calculation.

    Returns:
        The result of the subtraction. If only one input node is provided,
        its value is returned.

    Raises:
        CalculationError: If the `inputs` list is empty.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value): self._value = value
        ...     def calculate(self, period): return self._value
        &gt;&gt;&gt; strategy = SubtractionCalculation()
        &gt;&gt;&gt; nodes = [MockNode(100), MockNode(20), MockNode(30)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        50.0
        &gt;&gt;&gt; nodes_single = [MockNode(100)]
        &gt;&gt;&gt; strategy.calculate(nodes_single, &#34;2023&#34;)
        100.0
    &#34;&#34;&#34;
    if not inputs:
        raise CalculationError(
            &#34;Subtraction calculation requires at least one input node&#34;,
            details={&#34;strategy&#34;: &#34;SubtractionCalculation&#34;},
        )

    logger.debug(f&#34;Applying subtraction calculation for period {period}&#34;)
    # Calculate values first to avoid multiple calls if nodes are complex
    values = [node.calculate(period) for node in inputs]
    return values[0] - sum(values[1:])</code></pre>
</details>
<div class="desc"><p>Calculates the difference: value of the first input minus the sum of others.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects. Must contain at least one node.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2024Q1") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result of the subtraction. If only one input node is provided,
its value is returned.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If the <code>inputs</code> list is empty.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value): self._value = value
...     def calculate(self, period): return self._value
&gt;&gt;&gt; strategy = SubtractionCalculation()
&gt;&gt;&gt; nodes = [MockNode(100), MockNode(20), MockNode(30)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
50.0
&gt;&gt;&gt; nodes_single = [MockNode(100)]
&gt;&gt;&gt; strategy.calculate(nodes_single, &quot;2023&quot;)
100.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation"><code class="flex name class">
<span>class <span class="ident">WeightedAverageCalculation</span></span>
<span>(</span><span>weights: list[float] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightedAverageCalculation(Calculation):
    &#34;&#34;&#34;Calculates the weighted average of input node values.

    This calculation computes the average of the values from input nodes, where each
    node&#39;s contribution is weighted. If no weights are provided during
    initialization, it defaults to an equal weighting (simple average).
    &#34;&#34;&#34;

    def __init__(self, weights: Optional[list[float]] = None):
        &#34;&#34;&#34;Initializes the WeightedAverageCalculation.

        Args:
            weights: An optional list of floats representing the weight for each
                corresponding input node. The length of this list must match the
                number of input nodes provided to the `calculate` method. If None,
                equal weights are assumed.
        &#34;&#34;&#34;
        # Validate weights if provided immediately? No, validation happens in calculate
        # as the number of inputs isn&#39;t known here.
        self.weights = weights
        logger.info(f&#34;Initialized WeightedAverageCalculation with weights: {weights}&#34;)

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Computes the weighted average of the input node values for the period.

        Args:
            inputs: A list of Node objects.
            period: The time period string (e.g., &#34;2023H1&#34;) for the calculation.

        Returns:
            The calculated weighted average as a float.

        Raises:
            CalculationError: If the `inputs` list is empty or if the sum of weights is zero.
            StrategyError: If `weights` were provided and length does not match number of inputs.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value): self._value = value
            ...     def calculate(self, period): return self._value
            &gt;&gt;&gt; # Equal weights (simple average)
            &gt;&gt;&gt; strategy_equal = WeightedAverageCalculation()
            &gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(30)]
            &gt;&gt;&gt; strategy_equal.calculate(nodes, &#34;2023&#34;)
            20.0
            &gt;&gt;&gt; # Custom weights
            &gt;&gt;&gt; strategy_custom = WeightedAverageCalculation(weights=[0.5, 0.3, 0.2])
            &gt;&gt;&gt; strategy_custom.calculate(nodes, &#34;2023&#34;)
            17.0
            &gt;&gt;&gt; # Mismatched weights
            &gt;&gt;&gt; strategy_mismatch = WeightedAverageCalculation(weights=[0.5, 0.5])
            &gt;&gt;&gt; try:
            ...     strategy_mismatch.calculate(nodes, &#34;2023&#34;)
            ... except StrategyError as e:
            ...     # Example: logging the error instead of printing
            ...     logger.error(e)
            Number of weights (2) must match number of inputs (3)
        &#34;&#34;&#34;
        if not inputs:
            raise CalculationError(
                &#34;Weighted average calculation requires at least one input node&#34;,
                details={&#34;strategy&#34;: &#34;WeightedAverageCalculation&#34;},
            )

        num_inputs = len(inputs)
        effective_weights: list[float]

        if self.weights is None:
            # Use equal weights if none provided
            if num_inputs == 0:  # Should be caught by the check above, but defensive
                return 0.0
            equal_weight = 1.0 / num_inputs
            effective_weights = [equal_weight] * num_inputs
            logger.debug(&#34;Using equal weights for weighted average.&#34;)
        elif len(self.weights) == num_inputs:
            effective_weights = self.weights
            logger.debug(f&#34;Using provided weights: {effective_weights}&#34;)
        else:
            raise StrategyError(
                f&#34;Number of weights ({len(self.weights)}) must match &#34;
                f&#34;number of inputs ({num_inputs})&#34;,
                strategy_type=&#34;WeightedAverageCalculation&#34;,
            )

        logger.debug(f&#34;Applying weighted average calculation for period {period}&#34;)
        weighted_sum = 0.0
        total_weight = sum(effective_weights)
        input_values = [node.calculate(period) for node in inputs]

        if total_weight == 0.0:
            # Avoid division by zero. If weights are all zero, the concept is ill-defined.
            # Returning 0 might be a reasonable default, or raising an error.
            # Let&#39;s raise ValueError for clarity.
            raise CalculationError(
                &#34;Total weight for weighted average cannot be zero.&#34;,
                period=period,
                details={&#34;weights&#34;: effective_weights},
            )

        for value, weight in zip(input_values, effective_weights):
            weighted_sum += value * weight

        # If weights don&#39;t sum to 1, this isn&#39;t a standard weighted average.
        # Decide whether to normalize or return the weighted sum directly.
        # Normalize by total weight for a true weighted average.
        return weighted_sum / total_weight

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the weighted average calculation.&#34;&#34;&#34;
        if self.weights:
            return f&#34;Weighted Average (using provided weights: {self.weights})&#34;
        else:
            return &#34;Weighted Average (using equal weights)&#34;</code></pre>
</details>
<div class="desc"><p>Calculates the weighted average of input node values.</p>
<p>This calculation computes the average of the values from input nodes, where each
node's contribution is weighted. If no weights are provided during
initialization, it defaults to an equal weighting (simple average).</p>
<p>Initializes the WeightedAverageCalculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>weights</code></strong></dt>
<dd>An optional list of floats representing the weight for each
corresponding input node. The length of this list must match the
number of input nodes provided to the <code>calculate</code> method. If None,
equal weights are assumed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the weighted average calculation.&#34;&#34;&#34;
    if self.weights:
        return f&#34;Weighted Average (using provided weights: {self.weights})&#34;
    else:
        return &#34;Weighted Average (using equal weights)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the weighted average calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="../nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Computes the weighted average of the input node values for the period.

    Args:
        inputs: A list of Node objects.
        period: The time period string (e.g., &#34;2023H1&#34;) for the calculation.

    Returns:
        The calculated weighted average as a float.

    Raises:
        CalculationError: If the `inputs` list is empty or if the sum of weights is zero.
        StrategyError: If `weights` were provided and length does not match number of inputs.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value): self._value = value
        ...     def calculate(self, period): return self._value
        &gt;&gt;&gt; # Equal weights (simple average)
        &gt;&gt;&gt; strategy_equal = WeightedAverageCalculation()
        &gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(30)]
        &gt;&gt;&gt; strategy_equal.calculate(nodes, &#34;2023&#34;)
        20.0
        &gt;&gt;&gt; # Custom weights
        &gt;&gt;&gt; strategy_custom = WeightedAverageCalculation(weights=[0.5, 0.3, 0.2])
        &gt;&gt;&gt; strategy_custom.calculate(nodes, &#34;2023&#34;)
        17.0
        &gt;&gt;&gt; # Mismatched weights
        &gt;&gt;&gt; strategy_mismatch = WeightedAverageCalculation(weights=[0.5, 0.5])
        &gt;&gt;&gt; try:
        ...     strategy_mismatch.calculate(nodes, &#34;2023&#34;)
        ... except StrategyError as e:
        ...     # Example: logging the error instead of printing
        ...     logger.error(e)
        Number of weights (2) must match number of inputs (3)
    &#34;&#34;&#34;
    if not inputs:
        raise CalculationError(
            &#34;Weighted average calculation requires at least one input node&#34;,
            details={&#34;strategy&#34;: &#34;WeightedAverageCalculation&#34;},
        )

    num_inputs = len(inputs)
    effective_weights: list[float]

    if self.weights is None:
        # Use equal weights if none provided
        if num_inputs == 0:  # Should be caught by the check above, but defensive
            return 0.0
        equal_weight = 1.0 / num_inputs
        effective_weights = [equal_weight] * num_inputs
        logger.debug(&#34;Using equal weights for weighted average.&#34;)
    elif len(self.weights) == num_inputs:
        effective_weights = self.weights
        logger.debug(f&#34;Using provided weights: {effective_weights}&#34;)
    else:
        raise StrategyError(
            f&#34;Number of weights ({len(self.weights)}) must match &#34;
            f&#34;number of inputs ({num_inputs})&#34;,
            strategy_type=&#34;WeightedAverageCalculation&#34;,
        )

    logger.debug(f&#34;Applying weighted average calculation for period {period}&#34;)
    weighted_sum = 0.0
    total_weight = sum(effective_weights)
    input_values = [node.calculate(period) for node in inputs]

    if total_weight == 0.0:
        # Avoid division by zero. If weights are all zero, the concept is ill-defined.
        # Returning 0 might be a reasonable default, or raising an error.
        # Let&#39;s raise ValueError for clarity.
        raise CalculationError(
            &#34;Total weight for weighted average cannot be zero.&#34;,
            period=period,
            details={&#34;weights&#34;: effective_weights},
        )

    for value, weight in zip(input_values, effective_weights):
        weighted_sum += value * weight

    # If weights don&#39;t sum to 1, this isn&#39;t a standard weighted average.
    # Decide whether to normalize or return the weighted sum directly.
    # Normalize by total weight for a true weighted average.
    return weighted_sum / total_weight</code></pre>
</details>
<div class="desc"><p>Computes the weighted average of the input node values for the period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2023H1") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The calculated weighted average as a float.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If the <code>inputs</code> list is empty or if the sum of weights is zero.</dd>
<dt><code>StrategyError</code></dt>
<dd>If <code>weights</code> were provided and length does not match number of inputs.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value): self._value = value
...     def calculate(self, period): return self._value
&gt;&gt;&gt; # Equal weights (simple average)
&gt;&gt;&gt; strategy_equal = WeightedAverageCalculation()
&gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(30)]
&gt;&gt;&gt; strategy_equal.calculate(nodes, &quot;2023&quot;)
20.0
&gt;&gt;&gt; # Custom weights
&gt;&gt;&gt; strategy_custom = WeightedAverageCalculation(weights=[0.5, 0.3, 0.2])
&gt;&gt;&gt; strategy_custom.calculate(nodes, &quot;2023&quot;)
17.0
&gt;&gt;&gt; # Mismatched weights
&gt;&gt;&gt; strategy_mismatch = WeightedAverageCalculation(weights=[0.5, 0.5])
&gt;&gt;&gt; try:
...     strategy_mismatch.calculate(nodes, &quot;2023&quot;)
... except StrategyError as e:
...     # Example: logging the error instead of printing
...     logger.error(e)
Number of weights (2) must match number of inputs (3)
</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.core.calculations" href="index.html">fin_statement_model.core.calculations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.AdditionCalculation" href="#fin_statement_model.core.calculations.calculation.AdditionCalculation">AdditionCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.AdditionCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.AdditionCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.AdditionCalculation.description" href="#fin_statement_model.core.calculations.calculation.AdditionCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.Calculation" href="#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.Calculation.calculate" href="#fin_statement_model.core.calculations.calculation.Calculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.Calculation.description" href="#fin_statement_model.core.calculations.calculation.Calculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation" href="#fin_statement_model.core.calculations.calculation.CustomFormulaCalculation">CustomFormulaCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.CustomFormulaCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.CustomFormulaCalculation.description" href="#fin_statement_model.core.calculations.calculation.CustomFormulaCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.DivisionCalculation" href="#fin_statement_model.core.calculations.calculation.DivisionCalculation">DivisionCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.DivisionCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.DivisionCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.DivisionCalculation.description" href="#fin_statement_model.core.calculations.calculation.DivisionCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.FormulaCalculation" href="#fin_statement_model.core.calculations.calculation.FormulaCalculation">FormulaCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.FormulaCalculation.OPERATORS" href="#fin_statement_model.core.calculations.calculation.FormulaCalculation.OPERATORS">OPERATORS</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.FormulaCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.FormulaCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.FormulaCalculation.description" href="#fin_statement_model.core.calculations.calculation.FormulaCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.MultiplicationCalculation" href="#fin_statement_model.core.calculations.calculation.MultiplicationCalculation">MultiplicationCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.MultiplicationCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.MultiplicationCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.MultiplicationCalculation.description" href="#fin_statement_model.core.calculations.calculation.MultiplicationCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.SubtractionCalculation" href="#fin_statement_model.core.calculations.calculation.SubtractionCalculation">SubtractionCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.SubtractionCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.SubtractionCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.SubtractionCalculation.description" href="#fin_statement_model.core.calculations.calculation.SubtractionCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation" href="#fin_statement_model.core.calculations.calculation.WeightedAverageCalculation">WeightedAverageCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation.calculate" href="#fin_statement_model.core.calculations.calculation.WeightedAverageCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.calculations.calculation.WeightedAverageCalculation.description" href="#fin_statement_model.core.calculations.calculation.WeightedAverageCalculation.description">description</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
