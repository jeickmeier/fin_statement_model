<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.statements.formatting.formatter API documentation</title>
<meta name="description" content="Formatter for financial statements …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.statements.formatting.formatter</code></h1>
</header>
<section id="section-intro">
<p>Formatter for financial statements.</p>
<p>This module provides functionality for formatting financial statements
for display or reporting, including applying formatting rules, adding subtotals,
and applying sign conventions with enhanced display control.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext"><code class="flex name class">
<span>class <span class="ident">FormattingContext</span></span>
<span>(</span><span>should_apply_signs: bool = True,<br>include_empty_items: bool = False,<br>number_format: str | None = None,<br>include_metadata_cols: bool = False,<br>adjustment_filter: <a title="fin_statement_model.core.adjustments.models.AdjustmentFilter" href="../../core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentFilter">AdjustmentFilter</a> | set[str] | Callable[..., bool] | None = None,<br>add_is_adjusted_column: bool = False,<br>include_units_column: bool = False,<br>include_css_classes: bool = False,<br>include_notes_column: bool = False,<br>apply_item_scaling: bool = True,<br>apply_item_formatting: bool = True,<br>respect_hide_flags: bool | None = None,<br>contra_display_style: str | None = None,<br>apply_contra_formatting: bool = True,<br>add_contra_indicator_column: bool = False,<br>all_periods: list[str] = &lt;factory&gt;,<br>items_to_hide: set[str] = &lt;factory&gt;,<br>default_formats: dict[str, typing.Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FormattingContext:
    &#34;&#34;&#34;Encapsulates all formatting configuration and state for statement generation.

    This dataclass holds all the configuration options and runtime state needed
    for formatting financial statements, providing a clean interface for passing
    formatting parameters between methods.
    &#34;&#34;&#34;

    # Core formatting options
    should_apply_signs: bool = True
    include_empty_items: bool = False
    number_format: Optional[str] = None
    include_metadata_cols: bool = False

    # Adjustment options
    adjustment_filter: Optional[AdjustmentFilterInput] = None
    add_is_adjusted_column: bool = False

    # Enhanced display options
    include_units_column: bool = False
    include_css_classes: bool = False
    include_notes_column: bool = False
    apply_item_scaling: bool = True
    apply_item_formatting: bool = True
    respect_hide_flags: Optional[bool] = None

    # Contra item options
    contra_display_style: Optional[str] = None
    apply_contra_formatting: bool = True
    add_contra_indicator_column: bool = False

    # Runtime state (populated during processing)
    all_periods: list[str] = field(default_factory=list)
    items_to_hide: set[str] = field(default_factory=set)
    default_formats: dict[str, Any] = field(default_factory=dict)

    # Derived flags (computed after initialization)
    should_include_enhanced_metadata: bool = field(init=False)

    def __post_init__(self) -&gt; None:
        &#34;&#34;&#34;Compute derived flags after initialization.&#34;&#34;&#34;
        self.should_include_enhanced_metadata = any(
            [
                self.include_units_column,
                self.include_css_classes,
                self.include_notes_column,
                self.add_contra_indicator_column,
            ]
        )</code></pre>
</details>
<div class="desc"><p>Encapsulates all formatting configuration and state for statement generation.</p>
<p>This dataclass holds all the configuration options and runtime state needed
for formatting financial statements, providing a clean interface for passing
formatting parameters between methods.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.add_contra_indicator_column"><code class="name">var <span class="ident">add_contra_indicator_column</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.add_is_adjusted_column"><code class="name">var <span class="ident">add_is_adjusted_column</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.adjustment_filter"><code class="name">var <span class="ident">adjustment_filter</span> : <a title="fin_statement_model.core.adjustments.models.AdjustmentFilter" href="../../core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentFilter">AdjustmentFilter</a> | set[str] | Callable[..., bool] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.all_periods"><code class="name">var <span class="ident">all_periods</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.apply_contra_formatting"><code class="name">var <span class="ident">apply_contra_formatting</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.apply_item_formatting"><code class="name">var <span class="ident">apply_item_formatting</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.apply_item_scaling"><code class="name">var <span class="ident">apply_item_scaling</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.contra_display_style"><code class="name">var <span class="ident">contra_display_style</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.default_formats"><code class="name">var <span class="ident">default_formats</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.include_css_classes"><code class="name">var <span class="ident">include_css_classes</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.include_empty_items"><code class="name">var <span class="ident">include_empty_items</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.include_metadata_cols"><code class="name">var <span class="ident">include_metadata_cols</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.include_notes_column"><code class="name">var <span class="ident">include_notes_column</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.include_units_column"><code class="name">var <span class="ident">include_units_column</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.items_to_hide"><code class="name">var <span class="ident">items_to_hide</span> : set[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.number_format"><code class="name">var <span class="ident">number_format</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.respect_hide_flags"><code class="name">var <span class="ident">respect_hide_flags</span> : bool | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.should_apply_signs"><code class="name">var <span class="ident">should_apply_signs</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.FormattingContext.should_include_enhanced_metadata"><code class="name">var <span class="ident">should_include_enhanced_metadata</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.StatementFormatter"><code class="flex name class">
<span>class <span class="ident">StatementFormatter</span></span>
<span>(</span><span>statement: <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="../structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementFormatter:
    &#34;&#34;&#34;Formats financial statements for display or reporting.

    This class provides methods to transform raw financial data into
    formatted financial statements with proper headers, indentation,
    subtotals, sign conventions, and enhanced display control.
    &#34;&#34;&#34;

    def __init__(self, statement: StatementStructure):
        &#34;&#34;&#34;Initialize a statement formatter.

        Args:
            statement: The statement structure to format
        &#34;&#34;&#34;
        self.statement = statement

        # --- Build default display formats from global config ---
        from fin_statement_model import get_config  # Local import to avoid circular dep

        cfg_display = get_config().display
        num_format = cfg_display.default_number_format or &#34;,.2f&#34;
        # Detect precision from format string like &#39;,.2f&#39; or &#39;.3f&#39;
        precision_match = re.search(r&#34;\.([0-9]+)f$&#34;, num_format)
        precision = int(precision_match.group(1)) if precision_match else 2
        use_thousands_sep = &#34;,&#34; in num_format.split(&#34;.&#34;)[0]

        self.default_formats = {
            &#34;precision&#34;: precision,
            &#34;use_thousands_separator&#34;: use_thousands_sep,
            &#34;show_zero_values&#34;: not cfg_display.hide_zero_rows,
            &#34;show_negative_sign&#34;: cfg_display.show_negative_sign,
            &#34;indent_character&#34;: cfg_display.indent_character,
            &#34;subtotal_style&#34;: cfg_display.subtotal_style,
            &#34;total_style&#34;: cfg_display.total_style,
            &#34;header_style&#34;: cfg_display.header_style,
            # Contra item display options
            &#34;contra_display_style&#34;: cfg_display.contra_display_style,
            &#34;contra_css_class&#34;: cfg_display.contra_css_class,
        }

    def _resolve_hierarchical_attribute(
        self,
        item: Union[StatementItem, Section],
        attribute_name: str,
        default_value: Any = None,
        config_path: Optional[str] = None,
        skip_default_check: Optional[Callable[[Any], bool]] = None,
    ) -&gt; Any:
        &#34;&#34;&#34;Resolve an attribute value using hierarchical lookup.

        Precedence: Item &gt; Parent Section &gt; Statement &gt; Config/Default

        Args:
            item: The item or section to resolve the attribute for
            attribute_name: Name of the attribute to look up
            default_value: Default value if not found anywhere
            config_path: Optional config path to check before using default_value
            skip_default_check: Optional function to determine if a value should be
                              considered &#34;default&#34; and skipped (e.g., scale_factor == 1.0)

        Returns:
            The resolved attribute value
        &#34;&#34;&#34;
        # Check item-specific attribute
        if hasattr(item, attribute_name):
            item_value = getattr(item, attribute_name)
            if skip_default_check is None or not skip_default_check(item_value):
                return item_value

        # Check if item is part of a section with the attribute
        if isinstance(item, StatementItem):
            parent_section = self._find_parent_section_for_item(item)
            if parent_section and hasattr(parent_section, attribute_name):
                section_value = getattr(parent_section, attribute_name)
                if skip_default_check is None or not skip_default_check(section_value):
                    return section_value

        # Check statement-level attribute
        if hasattr(self.statement, attribute_name):
            statement_value = getattr(self.statement, attribute_name)
            if skip_default_check is None or not skip_default_check(statement_value):
                return statement_value

        # Check config if path provided
        if config_path:
            from fin_statement_model.config.helpers import cfg

            return cfg(config_path, default_value)

        # Return default value
        return default_value

    def _resolve_display_scale_factor(
        self, item: Union[StatementItem, Section]
    ) -&gt; float:
        &#34;&#34;&#34;Resolve the display scale factor for an item, considering hierarchy.

        Precedence: Item &gt; Section &gt; Statement &gt; Default (from config)

        Args:
            item: The item or section to get the scale factor for

        Returns:
            The resolved scale factor
        &#34;&#34;&#34;
        result = self._resolve_hierarchical_attribute(
            item=item,
            attribute_name=&#34;display_scale_factor&#34;,
            default_value=1.0,
            config_path=&#34;display.scale_factor&#34;,
            skip_default_check=lambda x: x == 1.0,
        )
        return float(result)

    def _resolve_units(self, item: Union[StatementItem, Section]) -&gt; Optional[str]:
        &#34;&#34;&#34;Resolve the unit description for an item, considering hierarchy.

        Precedence: Item &gt; Section &gt; Statement &gt; None

        Args:
            item: The item or section to get the units for

        Returns:
            The resolved unit description or None
        &#34;&#34;&#34;
        result = self._resolve_hierarchical_attribute(
            item=item,
            attribute_name=&#34;units&#34;,
            default_value=None,
            skip_default_check=lambda x: not x,  # Skip empty strings/None
        )
        return result if result is not None else None

    def _find_parent_section_for_item(
        self, target_item: StatementItem
    ) -&gt; Optional[Section]:
        &#34;&#34;&#34;Find the parent section that contains the given item.

        Args:
            target_item: The item to find the parent section for.

        Returns:
            The parent Section object, or None if not found.
        &#34;&#34;&#34;

        def search_in_section(section: Section) -&gt; Optional[Section]:
            # Check direct items
            for item in section.items:
                if item is target_item or (
                    hasattr(item, &#34;id&#34;)
                    and hasattr(target_item, &#34;id&#34;)
                    and item.id == target_item.id
                ):
                    return section
                # Check nested sections
                if isinstance(item, Section):
                    result = search_in_section(item)
                    if result:
                        return result

            # Check subtotal
            if hasattr(section, &#34;subtotal&#34;) and section.subtotal is target_item:
                return section

            return None

        # Search through all top-level sections
        for section in self.statement.sections:
            result = search_in_section(section)
            if result:
                return result

        return None

    def _should_hide_item(
        self, item: Union[StatementItem, Section], values: dict[str, float]
    ) -&gt; bool:
        &#34;&#34;&#34;Check if an item should be hidden based on hide_if_all_zero setting.

        Args:
            item: The item to check
            values: Dictionary of period values for the item

        Returns:
            True if the item should be hidden
        &#34;&#34;&#34;
        # Check if the item has hide_if_all_zero enabled
        hide_if_zero = getattr(item, &#34;hide_if_all_zero&#34;, False)
        if not hide_if_zero:
            return False

        # Check if all values are zero or NaN
        return all(not (pd.notna(value) and value != 0) for value in values.values())

    def _apply_item_scaling(
        self, values: dict[str, float], scale_factor: float
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Apply scaling to item values.

        Args:
            values: Dictionary of period values
            scale_factor: Factor to scale by

        Returns:
            Dictionary of scaled values
        &#34;&#34;&#34;
        if scale_factor == 1.0:
            return values

        scaled_values = {}
        for period, value in values.items():
            if pd.notna(value):
                scaled_values[period] = value * scale_factor
            else:
                scaled_values[period] = value

        return scaled_values

    def _format_item_values(
        self,
        item: Union[StatementItem, Section],
        values: dict[str, float],
        period_columns: list[str],
    ) -&gt; dict[str, str]:
        &#34;&#34;&#34;Format values for an item using its specific display format if available.

        Args:
            item: The item to format values for
            values: Dictionary of period values
            period_columns: List of period column names

        Returns:
            Dictionary of formatted values
        &#34;&#34;&#34;
        # Get item-specific display format
        item_format = getattr(item, &#34;display_format&#34;, None)

        formatted_values = {}
        for period in period_columns:
            value = values.get(period, np.nan)

            if pd.notna(value):
                if item_format:
                    try:
                        formatted_values[period] = f&#34;{value:{item_format}}&#34;
                    except (ValueError, TypeError):
                        # Fall back to default if format is invalid
                        logger.warning(
                            f&#34;Invalid display format &#39;{item_format}&#39; for item &#39;{getattr(item, &#39;id&#39;, &#39;unknown&#39;)}&#39;, using default&#34;
                        )
                        formatted_values[period] = str(
                            value
                        )  # Convert to string for consistency
                else:
                    formatted_values[period] = str(
                        value
                    )  # Convert to string for consistency
            else:
                formatted_values[period] = &#34;&#34;

        return formatted_values

    def _format_contra_value(
        self, value: float, display_style: str | None = None
    ) -&gt; str:
        &#34;&#34;&#34;Format a contra item value according to the specified display style.

        Args:
            value: The numeric value to format
            display_style: Style for contra display (&#34;parentheses&#34;, &#34;negative_sign&#34;, &#34;brackets&#34;)

        Returns:
            Formatted string representation of the contra value
        &#34;&#34;&#34;
        if pd.isna(value) or value == 0:
            return &#34;&#34;

        # For contra items, we typically want to show the absolute value with special formatting
        # regardless of the underlying sign, since sign_convention handles calculation logic
        from fin_statement_model.config.helpers import cfg

        style = display_style or self.default_formats.get(
            &#34;contra_display_style&#34;, cfg(&#34;display.contra_display_style&#34;, &#34;parentheses&#34;)
        )
        abs_value = abs(value)

        # Use dictionary for style formatting
        style_formats = {
            &#34;parentheses&#34;: f&#34;({abs_value:,.2f})&#34;,
            &#34;negative_sign&#34;: f&#34;-{abs_value:,.2f}&#34;,
            &#34;brackets&#34;: f&#34;[{abs_value:,.2f}]&#34;,
        }

        if style and isinstance(style, str) and style in style_formats:
            return style_formats[style]
        return f&#34;({abs_value:,.2f})&#34;  # Default fallback

    def _apply_contra_formatting(
        self,
        item: Union[StatementItem, Section],
        values: dict[str, float],
        period_columns: list[str],
        display_style: str | None = None,
    ) -&gt; dict[str, str]:
        &#34;&#34;&#34;Apply contra-specific formatting to item values.

        Args:
            item: The item to format
            values: Dictionary of period values
            period_columns: List of period column names
            display_style: Optional override for contra display style

        Returns:
            Dictionary of formatted contra values
        &#34;&#34;&#34;
        contra_formatted = {}
        for period in period_columns:
            value = values.get(period, np.nan)
            contra_formatted[period] = self._format_contra_value(value, display_style)

        return contra_formatted

    def _prepare_formatting_context(self, **kwargs: Any) -&gt; FormattingContext:
        &#34;&#34;&#34;Prepare formatting context with config defaults.

        Args:
            **kwargs: All formatting parameters passed to generate_dataframe (overrides config)

        Returns:
            FormattingContext: Configured context object
        &#34;&#34;&#34;
        from fin_statement_model import get_config

        config = get_config()

        # Create context with provided kwargs
        context = FormattingContext(
            should_apply_signs=kwargs.get(
                &#34;should_apply_signs&#34;, config.display.apply_sign_conventions
            ),
            include_empty_items=kwargs.get(
                &#34;include_empty_items&#34;, config.display.include_empty_items
            ),
            number_format=kwargs.get(&#34;number_format&#34;),
            include_metadata_cols=kwargs.get(
                &#34;include_metadata_cols&#34;, config.display.include_metadata_cols
            ),
            adjustment_filter=kwargs.get(&#34;adjustment_filter&#34;),
            add_is_adjusted_column=kwargs.get(
                &#34;add_is_adjusted_column&#34;, config.display.add_is_adjusted_column
            ),
            include_units_column=kwargs.get(
                &#34;include_units_column&#34;, config.display.include_units_column
            ),
            include_css_classes=kwargs.get(
                &#34;include_css_classes&#34;, config.display.include_css_classes
            ),
            include_notes_column=kwargs.get(
                &#34;include_notes_column&#34;, config.display.include_notes_column
            ),
            apply_item_scaling=kwargs.get(
                &#34;apply_item_scaling&#34;, config.display.apply_item_scaling
            ),
            apply_item_formatting=kwargs.get(
                &#34;apply_item_formatting&#34;, config.display.apply_item_formatting
            ),
            respect_hide_flags=kwargs.get(&#34;respect_hide_flags&#34;),
            contra_display_style=kwargs.get(&#34;contra_display_style&#34;),
            apply_contra_formatting=kwargs.get(
                &#34;apply_contra_formatting&#34;, config.display.apply_contra_formatting
            ),
            add_contra_indicator_column=kwargs.get(
                &#34;add_contra_indicator_column&#34;,
                config.display.add_contra_indicator_column,
            ),
        )

        # Apply config defaults for None values
        if context.should_apply_signs is None:
            context.should_apply_signs = (
                True  # This is a calculation default, not display
            )
        if context.include_empty_items is None:
            context.include_empty_items = False  # Preserve historical default
        if context.respect_hide_flags is None:
            context.respect_hide_flags = config.display.hide_zero_rows
        if context.contra_display_style is None:
            context.contra_display_style = config.display.contra_display_style
        if context.number_format is None:
            context.number_format = config.display.default_number_format

        # Set default formats
        context.default_formats = self.default_formats

        return context

    def _fetch_statement_data(
        self, graph: Graph, context: FormattingContext
    ) -&gt; tuple[dict[str, dict[str, float]], Any]:
        &#34;&#34;&#34;Fetch data from graph using DataFetcher.

        Args:
            graph: The core.graph.Graph instance containing the data
            context: Formatting context with fetch parameters

        Returns:
            Tuple of (data dictionary, fetch errors)
        &#34;&#34;&#34;
        data_fetcher = DataFetcher(self.statement, graph)
        fetch_result = data_fetcher.fetch_all_data(
            adjustment_filter=context.adjustment_filter,
            include_missing=context.include_empty_items,
        )

        # Log any warnings/errors
        if fetch_result.errors.has_warnings() or fetch_result.errors.has_errors():
            fetch_result.errors.log_all(
                prefix=f&#34;Statement &#39;{self.statement.id}&#39; data fetch: &#34;
            )

        # Update context with periods from graph
        context.all_periods = graph.periods

        return fetch_result.data, fetch_result.errors

    def _create_empty_dataframe(self, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Create an empty DataFrame with appropriate columns.

        Args:
            context: Formatting context with column configuration

        Returns:
            Empty DataFrame with proper column structure
        &#34;&#34;&#34;
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;, *context.all_periods]
        if context.include_units_column:
            base_cols.append(&#34;units&#34;)
        return pd.DataFrame(columns=base_cols)

    def _build_row_data(
        self,
        graph: Graph,
        data: dict[str, dict[str, float]],
        context: FormattingContext,
    ) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Build row data recursively from statement structure.

        Args:
            graph: The core.graph.Graph instance
            data: Fetched data dictionary
            context: Formatting context

        Returns:
            List of row dictionaries
        &#34;&#34;&#34;
        rows: list[dict[str, Any]] = []
        id_resolver = IDResolver(self.statement, standard_node_registry)

        # Process all sections
        self._process_items_recursive(
            items=list(self.statement.sections),
            depth=0,
            data=data,
            rows=rows,
            context=context,
            id_resolver=id_resolver,
            graph=graph,
        )

        # Filter hidden items if needed
        if context.respect_hide_flags:
            rows = [row for row in rows if row[&#34;ID&#34;] not in context.items_to_hide]

        return rows

    def _process_items_recursive(
        self,
        items: list[Union[Section, StatementItem]],
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Recursively process items and sections.

        Args:
            items: List of items or sections to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        for item in items:
            if isinstance(item, Section):
                self._process_section(
                    item, depth, data, rows, context, id_resolver, graph
                )
            elif isinstance(item, StatementItem):
                self._process_item(item, depth, data, rows, context, id_resolver, graph)

    def _process_section(
        self,
        section: Section,
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Process a section and its items.

        Args:
            section: Section to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        # Process section items first to collect data for hide check
        self._process_items_recursive(
            section.items, depth + 1, data, rows, context, id_resolver, graph
        )

        # Process subtotal if it exists
        if hasattr(section, &#34;subtotal&#34;) and section.subtotal:
            self._process_items_recursive(
                [section.subtotal], depth + 1, data, rows, context, id_resolver, graph
            )

        # Check if section should be hidden
        if context.respect_hide_flags and getattr(section, &#34;hide_if_all_zero&#34;, False):
            # For sections, check if all contained items are hidden or zero
            section_has_data = False
            for section_item in section.items:
                node_id = id_resolver.resolve(section_item.id, graph)
                if node_id and node_id in data:
                    item_data = data[node_id]
                    if any(pd.notna(v) and v != 0 for v in item_data.values()):
                        section_has_data = True
                        break
            if not section_has_data:
                context.items_to_hide.add(section.id)

    def _process_item(
        self,
        item: StatementItem,
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Process a single statement item.

        Args:
            item: Statement item to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        # Use ID resolver to get the correct node ID
        node_id = id_resolver.resolve(item.id, graph)
        if not node_id:
            return

        item_data = data.get(node_id, {})
        numeric_values: dict[str, float] = {
            p: item_data.get(p, np.nan) for p in context.all_periods
        }

        # Apply item-specific scaling if enabled
        if context.apply_item_scaling:
            numeric_values = self._apply_scaling(numeric_values, context, item)

        # Check if item should be hidden
        if context.respect_hide_flags and self._should_hide_item(item, numeric_values):
            context.items_to_hide.add(item.id)
            return

        # Start with numeric values and add formatted strings as needed
        row_values: dict[str, Union[float, str]] = dict(numeric_values)

        # Apply item-specific formatting if enabled (but only if not using global format)
        if context.apply_item_formatting and not context.number_format:
            formatted_values = self._format_item_values(
                item, numeric_values, context.all_periods
            )
            # Only apply if we got actual formatted strings
            if any(isinstance(v, str) for v in formatted_values.values()):
                for period in context.all_periods:
                    if period in formatted_values and isinstance(
                        formatted_values[period], str
                    ):
                        # Keep numeric value for calculations, store formatted for display
                        row_values[f&#34;{period}_formatted&#34;] = formatted_values[period]

        # Apply contra formatting if enabled and item is marked as contra
        if context.apply_contra_formatting and getattr(item, &#34;is_contra&#34;, False):
            contra_formatted = self._apply_contra_formatting(
                item, numeric_values, context.all_periods, context.contra_display_style
            )
            # Store contra formatted values for later use
            for period in context.all_periods:
                if contra_formatted.get(period):
                    row_values[f&#34;{period}_contra&#34;] = contra_formatted[period]

        if context.include_empty_items or any(pd.notna(v) for v in row_values.values()):
            row = self._create_row_dict(item, node_id, row_values, depth, context)
            rows.append(row)

    def _create_row_dict(
        self,
        item: StatementItem,
        node_id: str,
        row_values: dict[str, Union[float, str]],
        depth: int,
        context: FormattingContext,
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Create a row dictionary for a statement item.

        Args:
            item: Statement item
            node_id: Resolved node ID
            row_values: Period values for the item
            depth: Indentation depth
            context: Formatting context

        Returns:
            Row dictionary
        &#34;&#34;&#34;
        indent_char = context.default_formats[&#34;indent_character&#34;]

        row = {
            &#34;Line Item&#34;: indent_char * depth + item.name,
            &#34;ID&#34;: item.id,
            **row_values,
            # Metadata
            &#34;line_type&#34;: self._get_item_type(item),
            &#34;node_id&#34;: node_id,
            &#34;sign_convention&#34;: getattr(item, &#34;sign_convention&#34;, 1),
            &#34;is_subtotal&#34;: isinstance(item, SubtotalLineItem),
            &#34;is_calculated&#34;: isinstance(item, CalculatedLineItem),
            &#34;is_contra&#34;: getattr(item, &#34;is_contra&#34;, False),
        }

        # Add enhanced metadata columns if requested
        if context.include_units_column:
            row[&#34;units&#34;] = self._resolve_units(item)

        if context.include_css_classes:
            # Get item&#39;s CSS class and add contra class if applicable
            item_css_class = getattr(item, &#34;css_class&#34;, None)
            if getattr(item, &#34;is_contra&#34;, False):
                contra_css = context.default_formats.get(
                    &#34;contra_css_class&#34;, &#34;contra-item&#34;
                )
                if item_css_class:
                    row[&#34;css_class&#34;] = f&#34;{item_css_class} {contra_css}&#34;
                else:
                    row[&#34;css_class&#34;] = contra_css
            else:
                row[&#34;css_class&#34;] = item_css_class

        if context.include_notes_column:
            notes = getattr(item, &#34;notes_references&#34;, [])
            row[&#34;notes&#34;] = &#34;; &#34;.join(notes) if notes else &#34;&#34;

        return row

    def _apply_scaling(
        self, values: dict[str, float], context: FormattingContext, item: StatementItem
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Apply item-specific scaling if enabled.

        Args:
            values: Dictionary of period values
            context: Formatting context
            item: Statement item

        Returns:
            Dictionary of scaled values
        &#34;&#34;&#34;
        if not context.apply_item_scaling:
            return values

        scale_factor = self._resolve_display_scale_factor(item)
        return self._apply_item_scaling(values, scale_factor)

    def _organize_dataframe_columns(
        self, df: pd.DataFrame, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Organize DataFrame columns in the correct order.

        Args:
            df: DataFrame to organize
            context: Formatting context

        Returns:
            DataFrame with organized columns
        &#34;&#34;&#34;
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;]
        metadata_cols = [
            &#34;line_type&#34;,
            &#34;node_id&#34;,
            &#34;sign_convention&#34;,
            &#34;is_subtotal&#34;,
            &#34;is_calculated&#34;,
            &#34;is_contra&#34;,
        ]

        # Enhanced metadata columns
        enhanced_cols = []
        if context.include_units_column:
            enhanced_cols.append(&#34;units&#34;)
        if context.include_css_classes:
            enhanced_cols.append(&#34;css_class&#34;)
        if context.include_notes_column:
            enhanced_cols.append(&#34;notes&#34;)
        if context.add_contra_indicator_column:
            enhanced_cols.append(&#34;is_contra&#34;)

        # Add adjustment columns if they exist
        adjusted_flag_cols = []
        if context.add_is_adjusted_column:
            adjusted_flag_cols = [
                f&#34;{period}_is_adjusted&#34; for period in context.all_periods
            ]

        final_cols = base_cols + context.all_periods
        if adjusted_flag_cols:
            final_cols += adjusted_flag_cols
        if enhanced_cols:
            final_cols += enhanced_cols
        if context.include_metadata_cols:
            # Add metadata cols (excluding adjustment flags if they are already added)
            final_cols += [
                m_col for m_col in metadata_cols if m_col not in adjusted_flag_cols
            ]

        # Ensure contra formatting columns are available temporarily (will be removed later)
        all_available_cols = final_cols.copy()
        if context.apply_contra_formatting:
            contra_formatted_cols = [
                f&#34;{period}_contra&#34; for period in context.all_periods
            ]
            all_available_cols += contra_formatted_cols

        for col in all_available_cols:
            if col not in df.columns:
                df[col] = (
                    np.nan
                    if col in context.all_periods
                    else (&#34;&#34; if col == &#34;Line Item&#34; else None)
                )

        return df[all_available_cols]

    def _add_adjustment_columns(
        self, df: pd.DataFrame, graph: Graph, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Add adjustment status columns to the DataFrame.

        Args:
            df: DataFrame to add columns to
            graph: Graph instance
            context: Formatting context

        Returns:
            DataFrame with adjustment columns added
        &#34;&#34;&#34;
        if not context.add_is_adjusted_column or not context.all_periods:
            return df

        # Get node IDs from the dataframe
        node_ids_to_check = []
        for _, row in df.iterrows():
            node_id = row.get(&#34;node_id&#34;)
            is_calc_or_subtotal = row.get(&#34;is_calculated&#34;, False) or row.get(
                &#34;is_subtotal&#34;, False
            )
            if node_id and not is_calc_or_subtotal:
                node_ids_to_check.append(node_id)

        # Use DataFetcher to check adjustments
        if node_ids_to_check:
            data_fetcher = DataFetcher(self.statement, graph)
            adjustment_status = data_fetcher.check_adjustments(
                node_ids_to_check, context.all_periods, context.adjustment_filter
            )
        else:
            adjustment_status = {}

        # Build adjustment columns
        is_adjusted_data = []
        for _, row in df.iterrows():
            node_id = row.get(&#34;node_id&#34;)
            is_calc_or_subtotal = row.get(&#34;is_calculated&#34;, False) or row.get(
                &#34;is_subtotal&#34;, False
            )

            if node_id and not is_calc_or_subtotal and node_id in adjustment_status:
                row_adj_flags = {
                    f&#34;{period}_is_adjusted&#34;: adjustment_status[node_id].get(
                        period, False
                    )
                    for period in context.all_periods
                }
            else:
                # For calculated/subtotal items or missing nodes, flags are False
                row_adj_flags = {
                    f&#34;{period}_is_adjusted&#34;: False for period in context.all_periods
                }
            is_adjusted_data.append(row_adj_flags)

        if is_adjusted_data:
            adj_df = pd.DataFrame(is_adjusted_data, index=df.index)
            df = pd.concat([df, adj_df], axis=1)

        return df

    def _cleanup_temporary_columns(
        self, df: pd.DataFrame, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Clean up temporary columns from the dataframe.

        Args:
            df: DataFrame to clean up
            context: Formatting context

        Returns:
            DataFrame with temporary columns removed
        &#34;&#34;&#34;
        # Remove the contra formatting columns from the final output
        if context.apply_contra_formatting:
            contra_cols_to_remove = [
                f&#34;{period}_contra&#34; for period in context.all_periods
            ]
            df = df.drop(
                columns=[col for col in contra_cols_to_remove if col in df.columns]
            )

        # Build final column list
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;]
        metadata_cols = [
            &#34;line_type&#34;,
            &#34;node_id&#34;,
            &#34;sign_convention&#34;,
            &#34;is_subtotal&#34;,
            &#34;is_calculated&#34;,
            &#34;is_contra&#34;,
        ]

        enhanced_cols = []
        if context.include_units_column:
            enhanced_cols.append(&#34;units&#34;)
        if context.include_css_classes:
            enhanced_cols.append(&#34;css_class&#34;)
        if context.include_notes_column:
            enhanced_cols.append(&#34;notes&#34;)
        if context.add_contra_indicator_column:
            enhanced_cols.append(&#34;is_contra&#34;)

        adjusted_flag_cols = []
        if context.add_is_adjusted_column:
            adjusted_flag_cols = [
                f&#34;{period}_is_adjusted&#34; for period in context.all_periods
            ]

        final_cols = base_cols + context.all_periods
        if context.add_is_adjusted_column:
            final_cols += adjusted_flag_cols
        if enhanced_cols:
            final_cols += enhanced_cols
        if context.include_metadata_cols:
            # Add metadata cols (excluding adjustment flags if they are already added)
            final_cols += [
                m_col for m_col in metadata_cols if m_col not in adjusted_flag_cols
            ]

        # Select only the final columns for output
        return df[final_cols]

    def _apply_all_formatting(
        self, df: pd.DataFrame, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Apply consolidated formatting in a single vectorized pass.&#34;&#34;&#34;
        # Combined sign, contra, and number formatting
        df = render_values(
            df=df,
            period_columns=context.all_periods,
            default_formats=context.default_formats,
            number_format=context.number_format,
            contra_display_style=context.contra_display_style,
        )
        # Clean up temporary columns
        df = self._cleanup_temporary_columns(df, context)
        return df

    def generate_dataframe(
        self,
        graph: Graph,
        context: Optional[FormattingContext] = None,
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Generate a formatted DataFrame for the statement.

        Args:
            graph: Graph instance containing the data to render.
            context: FormattingContext object containing all display / formatting
                configuration. If *None*, a context will be created from project
                configuration.

        Returns:
            A fully-formatted ``pandas.DataFrame`` representing the statement.
        &#34;&#34;&#34;
        if context is None:
            # Build context purely from project defaults (no legacy kwargs path).
            context = self._prepare_formatting_context()

        # 2. Fetch statement data -------------------------------------------------------------------
        data, _ = self._fetch_statement_data(graph, context)

        # 3. Build row dictionaries -----------------------------------------------------------------
        rows = self._build_row_data(graph, data, context)

        # 4. Assemble DataFrame ---------------------------------------------------------------------
        if not rows:
            return self._create_empty_dataframe(context)

        df = pd.DataFrame(rows)

        # 5. Adjustment columns (must precede column organisation)
        if context.add_is_adjusted_column:
            df = self._add_adjustment_columns(df, graph, context)

        # 6. Column ordering / injection ------------------------------------------------------------
        df = self._organize_dataframe_columns(df, context)

        # 7. Post-processing formatting -------------------------------------------------------------
        df = self._apply_all_formatting(df, context)

        return df

    def _get_item_type(self, item: StatementItem) -&gt; str:
        &#34;&#34;&#34;Get the type of a statement item.

        Args:
            item: Statement item to get type for

        Returns:
            str: Item type identifier
        &#34;&#34;&#34;
        if isinstance(item, Section):
            return &#34;section&#34;
        elif isinstance(item, SubtotalLineItem):
            return &#34;subtotal&#34;
        elif isinstance(item, CalculatedLineItem):
            return &#34;calculated&#34;
        else:
            return &#34;item&#34;

    def format_html(
        self,
        graph: Graph,
        should_apply_signs: Optional[bool] = None,
        include_empty_items: Optional[bool] = None,
        css_styles: Optional[dict[str, str]] = None,
        use_item_css_classes: Optional[bool] = None,
        **kwargs: Any,
    ) -&gt; str:
        &#34;&#34;&#34;Format the statement data as HTML with enhanced styling support.

        Args:
            graph: The core.graph.Graph instance containing the data.
            should_apply_signs: Whether to apply sign conventions (override config).
            include_empty_items: Whether to include items with no data (override config).
            css_styles: Optional dict of CSS styles for the HTML.
            use_item_css_classes: Whether to use item-specific CSS classes (override config).
            **kwargs: Additional arguments passed to generate_dataframe.

        Returns:
            str: HTML string representing the statement with enhanced styling.
        &#34;&#34;&#34;
        # Determine defaults for unspecified parameters -------------------------------------------
        from fin_statement_model import get_config

        cfg = get_config()

        should_apply_signs = (
            should_apply_signs
            if should_apply_signs is not None
            else cfg.display.apply_sign_conventions
        )
        include_empty_items = (
            include_empty_items
            if include_empty_items is not None
            else cfg.display.include_empty_items
        )
        use_item_css_classes = (
            use_item_css_classes
            if use_item_css_classes is not None
            else cfg.display.include_css_classes
        )

        # Ensure the correct flag for CSS class inclusion is propagated
        if use_item_css_classes:
            kwargs[&#34;include_css_classes&#34;] = True

        # Build a FormattingContext with the specified overrides and any additional
        # keyword arguments provided by the caller.
        context = self._prepare_formatting_context(
            should_apply_signs=should_apply_signs,
            include_empty_items=include_empty_items,
            **kwargs,
        )

        df = self.generate_dataframe(graph=graph, context=context)

        html: str = df.to_html(
            index=False, classes=&#34;statement-table&#34;, table_id=&#34;financial-statement&#34;
        )

        if css_styles or use_item_css_classes:
            style_str = &#34;&lt;style&gt;\n&#34;

            # Add default styles for statement tables
            style_str += &#34;&#34;&#34;
            .statement-table { border-collapse: collapse; width: 100%; }
            .statement-table th, .statement-table td { padding: 8px; text-align: right; border: 1px solid #ddd; }
            .statement-table th { background-color: #f2f2f2; font-weight: bold; }
            .statement-table .Line.Item { text-align: left; }
            .contra-item { font-style: italic; color: #666; }
            &#34;&#34;&#34;

            # Add custom styles
            if css_styles:
                for selector, style in css_styles.items():
                    style_str += f&#34;{selector} {{ {style} }}\n&#34;

            style_str += &#34;&lt;/style&gt;\n&#34;
            html = style_str + html

        return html</code></pre>
</details>
<div class="desc"><p>Formats financial statements for display or reporting.</p>
<p>This class provides methods to transform raw financial data into
formatted financial statements with proper headers, indentation,
subtotals, sign conventions, and enhanced display control.</p>
<p>Initialize a statement formatter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure to format</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.formatter.StatementFormatter.format_html"><code class="name flex">
<span>def <span class="ident">format_html</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>should_apply_signs: bool | None = None,<br>include_empty_items: bool | None = None,<br>css_styles: dict[str, str] | None = None,<br>use_item_css_classes: bool | None = None,<br>**kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_html(
    self,
    graph: Graph,
    should_apply_signs: Optional[bool] = None,
    include_empty_items: Optional[bool] = None,
    css_styles: Optional[dict[str, str]] = None,
    use_item_css_classes: Optional[bool] = None,
    **kwargs: Any,
) -&gt; str:
    &#34;&#34;&#34;Format the statement data as HTML with enhanced styling support.

    Args:
        graph: The core.graph.Graph instance containing the data.
        should_apply_signs: Whether to apply sign conventions (override config).
        include_empty_items: Whether to include items with no data (override config).
        css_styles: Optional dict of CSS styles for the HTML.
        use_item_css_classes: Whether to use item-specific CSS classes (override config).
        **kwargs: Additional arguments passed to generate_dataframe.

    Returns:
        str: HTML string representing the statement with enhanced styling.
    &#34;&#34;&#34;
    # Determine defaults for unspecified parameters -------------------------------------------
    from fin_statement_model import get_config

    cfg = get_config()

    should_apply_signs = (
        should_apply_signs
        if should_apply_signs is not None
        else cfg.display.apply_sign_conventions
    )
    include_empty_items = (
        include_empty_items
        if include_empty_items is not None
        else cfg.display.include_empty_items
    )
    use_item_css_classes = (
        use_item_css_classes
        if use_item_css_classes is not None
        else cfg.display.include_css_classes
    )

    # Ensure the correct flag for CSS class inclusion is propagated
    if use_item_css_classes:
        kwargs[&#34;include_css_classes&#34;] = True

    # Build a FormattingContext with the specified overrides and any additional
    # keyword arguments provided by the caller.
    context = self._prepare_formatting_context(
        should_apply_signs=should_apply_signs,
        include_empty_items=include_empty_items,
        **kwargs,
    )

    df = self.generate_dataframe(graph=graph, context=context)

    html: str = df.to_html(
        index=False, classes=&#34;statement-table&#34;, table_id=&#34;financial-statement&#34;
    )

    if css_styles or use_item_css_classes:
        style_str = &#34;&lt;style&gt;\n&#34;

        # Add default styles for statement tables
        style_str += &#34;&#34;&#34;
        .statement-table { border-collapse: collapse; width: 100%; }
        .statement-table th, .statement-table td { padding: 8px; text-align: right; border: 1px solid #ddd; }
        .statement-table th { background-color: #f2f2f2; font-weight: bold; }
        .statement-table .Line.Item { text-align: left; }
        .contra-item { font-style: italic; color: #666; }
        &#34;&#34;&#34;

        # Add custom styles
        if css_styles:
            for selector, style in css_styles.items():
                style_str += f&#34;{selector} {{ {style} }}\n&#34;

        style_str += &#34;&lt;/style&gt;\n&#34;
        html = style_str + html

    return html</code></pre>
</details>
<div class="desc"><p>Format the statement data as HTML with enhanced styling support.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The core.graph.Graph instance containing the data.</dd>
<dt><strong><code>should_apply_signs</code></strong></dt>
<dd>Whether to apply sign conventions (override config).</dd>
<dt><strong><code>include_empty_items</code></strong></dt>
<dd>Whether to include items with no data (override config).</dd>
<dt><strong><code>css_styles</code></strong></dt>
<dd>Optional dict of CSS styles for the HTML.</dd>
<dt><strong><code>use_item_css_classes</code></strong></dt>
<dd>Whether to use item-specific CSS classes (override config).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to generate_dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>HTML string representing the statement with enhanced styling.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.formatting.formatter.StatementFormatter.generate_dataframe"><code class="name flex">
<span>def <span class="ident">generate_dataframe</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>context: <a title="fin_statement_model.statements.formatting.formatter.FormattingContext" href="#fin_statement_model.statements.formatting.formatter.FormattingContext">FormattingContext</a> | None = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_dataframe(
    self,
    graph: Graph,
    context: Optional[FormattingContext] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a formatted DataFrame for the statement.

    Args:
        graph: Graph instance containing the data to render.
        context: FormattingContext object containing all display / formatting
            configuration. If *None*, a context will be created from project
            configuration.

    Returns:
        A fully-formatted ``pandas.DataFrame`` representing the statement.
    &#34;&#34;&#34;
    if context is None:
        # Build context purely from project defaults (no legacy kwargs path).
        context = self._prepare_formatting_context()

    # 2. Fetch statement data -------------------------------------------------------------------
    data, _ = self._fetch_statement_data(graph, context)

    # 3. Build row dictionaries -----------------------------------------------------------------
    rows = self._build_row_data(graph, data, context)

    # 4. Assemble DataFrame ---------------------------------------------------------------------
    if not rows:
        return self._create_empty_dataframe(context)

    df = pd.DataFrame(rows)

    # 5. Adjustment columns (must precede column organisation)
    if context.add_is_adjusted_column:
        df = self._add_adjustment_columns(df, graph, context)

    # 6. Column ordering / injection ------------------------------------------------------------
    df = self._organize_dataframe_columns(df, context)

    # 7. Post-processing formatting -------------------------------------------------------------
    df = self._apply_all_formatting(df, context)

    return df</code></pre>
</details>
<div class="desc"><p>Generate a formatted DataFrame for the statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>Graph instance containing the data to render.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>FormattingContext object containing all display / formatting
configuration. If <em>None</em>, a context will be created from project
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A fully-formatted <code>pandas.DataFrame</code> representing the statement.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.statements.formatting" href="index.html">fin_statement_model.statements.formatting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext" href="#fin_statement_model.statements.formatting.formatter.FormattingContext">FormattingContext</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.add_contra_indicator_column" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.add_contra_indicator_column">add_contra_indicator_column</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.add_is_adjusted_column" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.add_is_adjusted_column">add_is_adjusted_column</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.adjustment_filter" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.adjustment_filter">adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.all_periods" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.all_periods">all_periods</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.apply_contra_formatting" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.apply_contra_formatting">apply_contra_formatting</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.apply_item_formatting" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.apply_item_formatting">apply_item_formatting</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.apply_item_scaling" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.apply_item_scaling">apply_item_scaling</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.contra_display_style" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.contra_display_style">contra_display_style</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.default_formats" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.default_formats">default_formats</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.include_css_classes" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.include_css_classes">include_css_classes</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.include_empty_items" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.include_empty_items">include_empty_items</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.include_metadata_cols" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.include_metadata_cols">include_metadata_cols</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.include_notes_column" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.include_notes_column">include_notes_column</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.include_units_column" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.include_units_column">include_units_column</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.items_to_hide" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.items_to_hide">items_to_hide</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.number_format" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.number_format">number_format</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.respect_hide_flags" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.respect_hide_flags">respect_hide_flags</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.should_apply_signs" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.should_apply_signs">should_apply_signs</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.FormattingContext.should_include_enhanced_metadata" href="#fin_statement_model.statements.formatting.formatter.FormattingContext.should_include_enhanced_metadata">should_include_enhanced_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.formatting.formatter.StatementFormatter" href="#fin_statement_model.statements.formatting.formatter.StatementFormatter">StatementFormatter</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.formatting.formatter.StatementFormatter.format_html" href="#fin_statement_model.statements.formatting.formatter.StatementFormatter.format_html">format_html</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter.StatementFormatter.generate_dataframe" href="#fin_statement_model.statements.formatting.formatter.StatementFormatter.generate_dataframe">generate_dataframe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
