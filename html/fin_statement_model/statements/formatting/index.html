<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.statements.formatting API documentation</title>
<meta name="description" content="Formatting and data fetching for financial statements …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.statements.formatting</code></h1>
</header>
<section id="section-intro">
<p>Formatting and data fetching for financial statements.</p>
<p>This package provides tools for:
- Fetching data from graphs for statement display
- Formatting statements as DataFrames
- Applying formatting rules and conventions</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.statements.formatting.data_fetcher" href="data_fetcher.html">fin_statement_model.statements.formatting.data_fetcher</a></code></dt>
<dd>
<div class="desc"><p>Data fetching functionality for financial statements …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.formatting.formatter" href="formatter.html">fin_statement_model.statements.formatting.formatter</a></code></dt>
<dd>
<div class="desc"><p>Formatter for financial statements …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.statements.formatting.DataFetcher"><code class="flex name class">
<span>class <span class="ident">DataFetcher</span></span>
<span>(</span><span>statement: <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="../structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataFetcher:
    &#34;&#34;&#34;Fetches data from graph for statement formatting.

    This class encapsulates the logic for:
    - Resolving statement item IDs to graph node IDs
    - Fetching values from the graph with error handling
    - Applying adjustment filters if specified
    - Collecting errors and warnings during the process
    &#34;&#34;&#34;

    def __init__(self, statement: StatementStructure, graph: Graph):
        &#34;&#34;&#34;Initialize the data fetcher.

        Args:
            statement: The statement structure to fetch data for
            graph: The graph containing the data
        &#34;&#34;&#34;
        self.statement = statement
        self.graph = graph
        self.id_resolver = IDResolver(statement, standard_node_registry)

    def _resolve_adjustment_filter(
        self,
        item: StatementItem,
        global_filter: Optional[AdjustmentFilterInput] = None,
    ) -&gt; Optional[AdjustmentFilterInput]:
        &#34;&#34;&#34;Resolve which adjustment filter to use for an item.

        Precedence order:
        1. Global filter passed to fetch method (highest priority)
        2. Item&#39;s default adjustment filter
        3. Parent section&#39;s default adjustment filter
        4. None (no filter)

        Args:
            item: The statement item to get the filter for.
            global_filter: Optional global filter that overrides everything.

        Returns:
            The resolved adjustment filter to use, or None.
        &#34;&#34;&#34;
        # Global filter has highest priority
        if global_filter is not None:
            return global_filter

        # Check item&#39;s own default filter
        if (
            hasattr(item, &#34;default_adjustment_filter&#34;)
            and item.default_adjustment_filter is not None
        ):
            return cast(AdjustmentFilterInput, item.default_adjustment_filter)

        # Check parent section&#39;s default filter
        # We need to find which section contains this item
        parent_section = self._find_parent_section(item)
        if (
            parent_section
            and hasattr(parent_section, &#34;default_adjustment_filter&#34;)
            and parent_section.default_adjustment_filter is not None
        ):
            return cast(AdjustmentFilterInput, parent_section.default_adjustment_filter)

        # No filter
        return None

    def _find_parent_section(self, target_item: StatementItem) -&gt; Optional[Section]:
        &#34;&#34;&#34;Find the parent section that contains the given item.

        Args:
            target_item: The item to find the parent section for.

        Returns:
            The parent Section object, or None if not found.
        &#34;&#34;&#34;

        def search_in_section(section: Section) -&gt; Optional[Section]:
            # Check direct items
            for item in section.items:
                if item is target_item or (
                    hasattr(item, &#34;id&#34;)
                    and hasattr(target_item, &#34;id&#34;)
                    and item.id == target_item.id
                ):
                    return section
                # Check nested sections
                if isinstance(item, Section):
                    result = search_in_section(item)
                    if result:
                        return result

            # Check subtotal
            if hasattr(section, &#34;subtotal&#34;) and section.subtotal is target_item:
                return section

            return None

        # Search through all top-level sections
        for section in self.statement.sections:
            result = search_in_section(section)
            if result:
                return result

        return None

    def fetch_all_data(
        self,
        adjustment_filter: Optional[AdjustmentFilterInput] = None,
        include_missing: bool = False,
    ) -&gt; FetchResult:
        &#34;&#34;&#34;Fetch data for all items in the statement.

        Args:
            adjustment_filter: Optional global filter for adjustments (overrides item defaults)
            include_missing: If True, include nodes that don&#39;t exist in graph
                           with NaN values

        Returns:
            FetchResult containing the fetched data and any errors
        &#34;&#34;&#34;
        error_collector = ErrorCollector()
        data: dict[str, dict[str, float]] = {}
        missing_nodes: list[str] = []

        # Check if graph has periods
        periods = self.graph.periods
        if not periods:
            error_collector.add_error(
                code=&#34;no_periods&#34;,
                message=f&#34;Graph has no periods defined for statement &#39;{self.statement.id}&#39;&#34;,
                source=self.statement.id,
            )
            return FetchResult(
                data={}, errors=error_collector, node_count=0, missing_nodes=[]
            )

        logger.debug(
            f&#34;Fetching data for statement &#39;{self.statement.id}&#39; across {len(periods)} periods&#34;
        )

        # Get all items and resolve their node IDs
        all_items = self.statement.get_all_items()
        processed_node_ids = set()

        for item in all_items:
            # Resolve item ID to node ID
            node_id = self.id_resolver.resolve(item.id, self.graph)

            if not node_id:
                error_collector.add_warning(
                    code=&#34;unresolvable_item&#34;,
                    message=f&#34;Cannot resolve item &#39;{item.id}&#39; to a node ID&#34;,
                    source=item.id,
                    context=&#34;IDResolver.resolve&#34;,
                )
                continue

            if node_id in processed_node_ids:
                continue  # Skip already processed nodes

            processed_node_ids.add(node_id)

            # Resolve adjustment filter for this specific item
            item_filter = self._resolve_adjustment_filter(item, adjustment_filter)

            # Fetch data for this node
            node_result = self._fetch_node_data(
                node_id, periods, item_filter, item_id=item.id
            )

            if node_result.is_success():
                node_data = cast(NodeData, node_result.get_value())
                if node_data.has_data or include_missing:
                    data[node_id] = node_data.values

                # Add any warnings from node fetching
                for error in node_data.errors:
                    if error.severity == ErrorSeverity.WARNING:
                        error_collector.add_warning(
                            error.code,
                            error.message,
                            error.context,
                            error.source or item.id,
                        )
            else:
                # Node doesn&#39;t exist in graph
                missing_nodes.append(node_id)
                if include_missing:
                    # Fill with NaN values
                    data[node_id] = {period: np.nan for period in periods}

                error_collector.add_from_result(node_result, source=item.id)

        logger.info(
            f&#34;Fetched data for {len(data)} nodes from statement &#39;{self.statement.id}&#39;. &#34;
            f&#34;Missing: {len(missing_nodes)}, Warnings: {len(error_collector.get_warnings())}&#34;
        )

        return FetchResult(
            data=data,
            errors=error_collector,
            node_count=len(data),
            missing_nodes=missing_nodes,
        )

    def _fetch_node_data(
        self,
        node_id: str,
        periods: list[str],
        adjustment_filter: Optional[AdjustmentFilterInput],
        item_id: Optional[str] = None,
    ) -&gt; Result[NodeData]:
        &#34;&#34;&#34;Fetch data for a single node across all periods.

        Args:
            node_id: The graph node ID to fetch
            periods: List of periods to fetch
            adjustment_filter: Optional adjustment filter
            item_id: Optional statement item ID for error context

        Returns:
            Result containing NodeData or error details
        &#34;&#34;&#34;
        # Check if node exists
        if not self.graph.has_node(node_id):
            return Failure(
                [
                    ErrorDetail(
                        code=&#34;node_not_found&#34;,
                        message=f&#34;Node &#39;{node_id}&#39; not found in graph&#34;,
                        source=item_id or node_id,
                        severity=ErrorSeverity.WARNING,
                    )
                ]
            )

        values = {}
        is_adjusted = {}
        errors = []

        for period in periods:
            try:
                # Fetch value with optional adjustments
                value = self.graph.get_adjusted_value(
                    node_id,
                    period,
                    filter_input=adjustment_filter,
                    return_flag=False,  # Only need the value
                )
                # Ensure value is float or NaN
                values[period] = float(value) if pd.notna(value) else np.nan
                is_adjusted[period] = bool(value)

            except (NodeError, CalculationError) as e:
                # Expected errors - log as warning
                logger.warning(
                    f&#34;Error calculating node &#39;{node_id}&#39; for period &#39;{period}&#39;: {e}&#34;
                )
                values[period] = np.nan
                is_adjusted[period] = False
                errors.append(
                    ErrorDetail(
                        code=&#34;calculation_error&#34;,
                        message=f&#34;Failed to calculate value: {e}&#34;,
                        context=f&#34;period={period}&#34;,
                        severity=ErrorSeverity.WARNING,
                        source=item_id or node_id,
                    )
                )

            except TypeError as e:
                # Filter/adjustment errors
                logger.warning(
                    f&#34;Type error for node &#39;{node_id}&#39;, period &#39;{period}&#39;: {e}&#34;
                )
                values[period] = np.nan
                is_adjusted[period] = False
                errors.append(
                    ErrorDetail(
                        code=&#34;filter_error&#34;,
                        message=f&#34;Invalid adjustment filter: {e}&#34;,
                        context=f&#34;period={period}&#34;,
                        severity=ErrorSeverity.WARNING,
                        source=item_id or node_id,
                    )
                )

            except Exception as e:
                # Unexpected errors - log as error
                logger.error(
                    f&#34;Unexpected error for node &#39;{node_id}&#39;, period &#39;{period}&#39;: {e}&#34;,
                    exc_info=True,
                )
                values[period] = np.nan
                is_adjusted[period] = False
                errors.append(
                    ErrorDetail(
                        code=&#34;unexpected_error&#34;,
                        message=f&#34;Unexpected error: {e}&#34;,
                        context=f&#34;period={period}, error_type={type(e).__name__}&#34;,
                        severity=ErrorSeverity.ERROR,
                        source=item_id or node_id,
                    )
                )

        return Success(
            NodeData(
                node_id=node_id, values=values, is_adjusted=is_adjusted, errors=errors
            )
        )

    def check_adjustments(
        self,
        node_ids: list[str],
        periods: list[str],
        adjustment_filter: Optional[AdjustmentFilterInput] = None,
    ) -&gt; dict[str, dict[str, bool]]:
        &#34;&#34;&#34;Check which node/period combinations have adjustments.

        Args:
            node_ids: List of node IDs to check
            periods: List of periods to check
            adjustment_filter: Filter to check adjustments against

        Returns:
            Dict mapping node_id -&gt; period -&gt; was_adjusted boolean
        &#34;&#34;&#34;
        results = {}

        for node_id in node_ids:
            if not self.graph.has_node(node_id):
                results[node_id] = {period: False for period in periods}
                continue

            period_results = {}
            for period in periods:
                try:
                    was_adjusted = self.graph.was_adjusted(
                        node_id, period, adjustment_filter
                    )
                    period_results[period] = bool(was_adjusted)
                except Exception as e:
                    logger.warning(
                        f&#34;Error checking adjustments for {node_id}/{period}: {e}&#34;
                    )
                    period_results[period] = False

            results[node_id] = period_results

        return results</code></pre>
</details>
<div class="desc"><p>Fetches data from graph for statement formatting.</p>
<p>This class encapsulates the logic for:
- Resolving statement item IDs to graph node IDs
- Fetching values from the graph with error handling
- Applying adjustment filters if specified
- Collecting errors and warnings during the process</p>
<p>Initialize the data fetcher.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure to fetch data for</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph containing the data</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.DataFetcher.check_adjustments"><code class="name flex">
<span>def <span class="ident">check_adjustments</span></span>(<span>self,<br>node_ids: list[str],<br>periods: list[str],<br>adjustment_filter: <a title="fin_statement_model.core.adjustments.models.AdjustmentFilter" href="../../core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentFilter">AdjustmentFilter</a> | set[str] | Callable[..., bool] | None = None) ‑> dict[str, dict[str, bool]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_adjustments(
    self,
    node_ids: list[str],
    periods: list[str],
    adjustment_filter: Optional[AdjustmentFilterInput] = None,
) -&gt; dict[str, dict[str, bool]]:
    &#34;&#34;&#34;Check which node/period combinations have adjustments.

    Args:
        node_ids: List of node IDs to check
        periods: List of periods to check
        adjustment_filter: Filter to check adjustments against

    Returns:
        Dict mapping node_id -&gt; period -&gt; was_adjusted boolean
    &#34;&#34;&#34;
    results = {}

    for node_id in node_ids:
        if not self.graph.has_node(node_id):
            results[node_id] = {period: False for period in periods}
            continue

        period_results = {}
        for period in periods:
            try:
                was_adjusted = self.graph.was_adjusted(
                    node_id, period, adjustment_filter
                )
                period_results[period] = bool(was_adjusted)
            except Exception as e:
                logger.warning(
                    f&#34;Error checking adjustments for {node_id}/{period}: {e}&#34;
                )
                period_results[period] = False

        results[node_id] = period_results

    return results</code></pre>
</details>
<div class="desc"><p>Check which node/period combinations have adjustments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_ids</code></strong></dt>
<dd>List of node IDs to check</dd>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods to check</dd>
<dt><strong><code>adjustment_filter</code></strong></dt>
<dd>Filter to check adjustments against</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict mapping node_id -&gt; period -&gt; was_adjusted boolean</p></div>
</dd>
<dt id="fin_statement_model.statements.formatting.DataFetcher.fetch_all_data"><code class="name flex">
<span>def <span class="ident">fetch_all_data</span></span>(<span>self,<br>adjustment_filter: <a title="fin_statement_model.core.adjustments.models.AdjustmentFilter" href="../../core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentFilter">AdjustmentFilter</a> | set[str] | Callable[..., bool] | None = None,<br>include_missing: bool = False) ‑> <a title="fin_statement_model.statements.formatting.data_fetcher.FetchResult" href="data_fetcher.html#fin_statement_model.statements.formatting.data_fetcher.FetchResult">FetchResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_all_data(
    self,
    adjustment_filter: Optional[AdjustmentFilterInput] = None,
    include_missing: bool = False,
) -&gt; FetchResult:
    &#34;&#34;&#34;Fetch data for all items in the statement.

    Args:
        adjustment_filter: Optional global filter for adjustments (overrides item defaults)
        include_missing: If True, include nodes that don&#39;t exist in graph
                       with NaN values

    Returns:
        FetchResult containing the fetched data and any errors
    &#34;&#34;&#34;
    error_collector = ErrorCollector()
    data: dict[str, dict[str, float]] = {}
    missing_nodes: list[str] = []

    # Check if graph has periods
    periods = self.graph.periods
    if not periods:
        error_collector.add_error(
            code=&#34;no_periods&#34;,
            message=f&#34;Graph has no periods defined for statement &#39;{self.statement.id}&#39;&#34;,
            source=self.statement.id,
        )
        return FetchResult(
            data={}, errors=error_collector, node_count=0, missing_nodes=[]
        )

    logger.debug(
        f&#34;Fetching data for statement &#39;{self.statement.id}&#39; across {len(periods)} periods&#34;
    )

    # Get all items and resolve their node IDs
    all_items = self.statement.get_all_items()
    processed_node_ids = set()

    for item in all_items:
        # Resolve item ID to node ID
        node_id = self.id_resolver.resolve(item.id, self.graph)

        if not node_id:
            error_collector.add_warning(
                code=&#34;unresolvable_item&#34;,
                message=f&#34;Cannot resolve item &#39;{item.id}&#39; to a node ID&#34;,
                source=item.id,
                context=&#34;IDResolver.resolve&#34;,
            )
            continue

        if node_id in processed_node_ids:
            continue  # Skip already processed nodes

        processed_node_ids.add(node_id)

        # Resolve adjustment filter for this specific item
        item_filter = self._resolve_adjustment_filter(item, adjustment_filter)

        # Fetch data for this node
        node_result = self._fetch_node_data(
            node_id, periods, item_filter, item_id=item.id
        )

        if node_result.is_success():
            node_data = cast(NodeData, node_result.get_value())
            if node_data.has_data or include_missing:
                data[node_id] = node_data.values

            # Add any warnings from node fetching
            for error in node_data.errors:
                if error.severity == ErrorSeverity.WARNING:
                    error_collector.add_warning(
                        error.code,
                        error.message,
                        error.context,
                        error.source or item.id,
                    )
        else:
            # Node doesn&#39;t exist in graph
            missing_nodes.append(node_id)
            if include_missing:
                # Fill with NaN values
                data[node_id] = {period: np.nan for period in periods}

            error_collector.add_from_result(node_result, source=item.id)

    logger.info(
        f&#34;Fetched data for {len(data)} nodes from statement &#39;{self.statement.id}&#39;. &#34;
        f&#34;Missing: {len(missing_nodes)}, Warnings: {len(error_collector.get_warnings())}&#34;
    )

    return FetchResult(
        data=data,
        errors=error_collector,
        node_count=len(data),
        missing_nodes=missing_nodes,
    )</code></pre>
</details>
<div class="desc"><p>Fetch data for all items in the statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>adjustment_filter</code></strong></dt>
<dd>Optional global filter for adjustments (overrides item defaults)</dd>
<dt><strong><code>include_missing</code></strong></dt>
<dd>If True, include nodes that don't exist in graph
with NaN values</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>FetchResult containing the fetched data and any errors</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.formatting.FetchResult"><code class="flex name class">
<span>class <span class="ident">FetchResult</span></span>
<span>(</span><span>data: dict[str, dict[str, float]],<br>errors: <a title="fin_statement_model.statements.utilities.result_types.ErrorCollector" href="../utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorCollector">ErrorCollector</a>,<br>node_count: int,<br>missing_nodes: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FetchResult:
    &#34;&#34;&#34;Result of fetching data for a statement.

    Attributes:
        data: Dict mapping node_id to period values
        errors: ErrorCollector with any errors/warnings
        node_count: Number of nodes successfully fetched
        missing_nodes: List of node IDs that couldn&#39;t be found
    &#34;&#34;&#34;

    data: dict[str, dict[str, float]]
    errors: ErrorCollector
    node_count: int
    missing_nodes: list[str]

    def to_result(self) -&gt; Result[dict[str, dict[str, float]]]:
        &#34;&#34;&#34;Convert to Result type.&#34;&#34;&#34;
        if self.errors.has_errors():
            return Failure(errors=self.errors.get_errors())
        return Success(value=self.data)</code></pre>
</details>
<div class="desc"><p>Result of fetching data for a statement.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dict mapping node_id to period values</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>ErrorCollector with any errors/warnings</dd>
<dt><strong><code>node_count</code></strong></dt>
<dd>Number of nodes successfully fetched</dd>
<dt><strong><code>missing_nodes</code></strong></dt>
<dd>List of node IDs that couldn't be found</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.FetchResult.data"><code class="name">var <span class="ident">data</span> : dict[str, dict[str, float]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.FetchResult.errors"><code class="name">var <span class="ident">errors</span> : <a title="fin_statement_model.statements.utilities.result_types.ErrorCollector" href="../utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorCollector">ErrorCollector</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.FetchResult.missing_nodes"><code class="name">var <span class="ident">missing_nodes</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.FetchResult.node_count"><code class="name">var <span class="ident">node_count</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.FetchResult.to_result"><code class="name flex">
<span>def <span class="ident">to_result</span></span>(<span>self) ‑> <a title="fin_statement_model.statements.utilities.result_types.Result" href="../utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[dict[str, dict[str, float]]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_result(self) -&gt; Result[dict[str, dict[str, float]]]:
    &#34;&#34;&#34;Convert to Result type.&#34;&#34;&#34;
    if self.errors.has_errors():
        return Failure(errors=self.errors.get_errors())
    return Success(value=self.data)</code></pre>
</details>
<div class="desc"><p>Convert to Result type.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.formatting.NodeData"><code class="flex name class">
<span>class <span class="ident">NodeData</span></span>
<span>(</span><span>node_id: str,<br>values: dict[str, float],<br>is_adjusted: dict[str, bool],<br>errors: list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="../utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class NodeData:
    &#34;&#34;&#34;Data for a single node across all periods.

    Attributes:
        node_id: The graph node ID
        values: Dict mapping period to value
        is_adjusted: Dict mapping period to bool indicating if adjusted
        errors: Any errors encountered during fetching
    &#34;&#34;&#34;

    node_id: str
    values: dict[str, float]
    is_adjusted: dict[str, bool]
    errors: list[ErrorDetail]

    @property
    def has_data(self) -&gt; bool:
        &#34;&#34;&#34;Check if any non-NaN values exist.&#34;&#34;&#34;
        return any(pd.notna(v) for v in self.values.values())</code></pre>
</details>
<div class="desc"><p>Data for a single node across all periods.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The graph node ID</dd>
<dt><strong><code>values</code></strong></dt>
<dd>Dict mapping period to value</dd>
<dt><strong><code>is_adjusted</code></strong></dt>
<dd>Dict mapping period to bool indicating if adjusted</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>Any errors encountered during fetching</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.NodeData.errors"><code class="name">var <span class="ident">errors</span> : list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="../utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.NodeData.has_data"><code class="name">prop <span class="ident">has_data</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_data(self) -&gt; bool:
    &#34;&#34;&#34;Check if any non-NaN values exist.&#34;&#34;&#34;
    return any(pd.notna(v) for v in self.values.values())</code></pre>
</details>
<div class="desc"><p>Check if any non-NaN values exist.</p></div>
</dd>
<dt id="fin_statement_model.statements.formatting.NodeData.is_adjusted"><code class="name">var <span class="ident">is_adjusted</span> : dict[str, bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.NodeData.node_id"><code class="name">var <span class="ident">node_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.formatting.NodeData.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.formatting.StatementFormatter"><code class="flex name class">
<span>class <span class="ident">StatementFormatter</span></span>
<span>(</span><span>statement: <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="../structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementFormatter:
    &#34;&#34;&#34;Formats financial statements for display or reporting.

    This class provides methods to transform raw financial data into
    formatted financial statements with proper headers, indentation,
    subtotals, sign conventions, and enhanced display control.
    &#34;&#34;&#34;

    def __init__(self, statement: StatementStructure):
        &#34;&#34;&#34;Initialize a statement formatter.

        Args:
            statement: The statement structure to format
        &#34;&#34;&#34;
        self.statement = statement

        # --- Build default display formats from global config ---
        from fin_statement_model import get_config  # Local import to avoid circular dep

        cfg_display = get_config().display
        num_format = cfg_display.default_number_format or &#34;,.2f&#34;
        # Detect precision from format string like &#39;,.2f&#39; or &#39;.3f&#39;
        precision_match = re.search(r&#34;\.([0-9]+)f$&#34;, num_format)
        precision = int(precision_match.group(1)) if precision_match else 2
        use_thousands_sep = &#34;,&#34; in num_format.split(&#34;.&#34;)[0]

        self.default_formats = {
            &#34;precision&#34;: precision,
            &#34;use_thousands_separator&#34;: use_thousands_sep,
            &#34;show_zero_values&#34;: not cfg_display.hide_zero_rows,
            &#34;show_negative_sign&#34;: cfg_display.show_negative_sign,
            &#34;indent_character&#34;: cfg_display.indent_character,
            &#34;subtotal_style&#34;: cfg_display.subtotal_style,
            &#34;total_style&#34;: cfg_display.total_style,
            &#34;header_style&#34;: cfg_display.header_style,
            # Contra item display options
            &#34;contra_display_style&#34;: cfg_display.contra_display_style,
            &#34;contra_css_class&#34;: cfg_display.contra_css_class,
        }

    def _resolve_hierarchical_attribute(
        self,
        item: Union[StatementItem, Section],
        attribute_name: str,
        default_value: Any = None,
        config_path: Optional[str] = None,
        skip_default_check: Optional[Callable[[Any], bool]] = None,
    ) -&gt; Any:
        &#34;&#34;&#34;Resolve an attribute value using hierarchical lookup.

        Precedence: Item &gt; Parent Section &gt; Statement &gt; Config/Default

        Args:
            item: The item or section to resolve the attribute for
            attribute_name: Name of the attribute to look up
            default_value: Default value if not found anywhere
            config_path: Optional config path to check before using default_value
            skip_default_check: Optional function to determine if a value should be
                              considered &#34;default&#34; and skipped (e.g., scale_factor == 1.0)

        Returns:
            The resolved attribute value
        &#34;&#34;&#34;
        # Check item-specific attribute
        if hasattr(item, attribute_name):
            item_value = getattr(item, attribute_name)
            if skip_default_check is None or not skip_default_check(item_value):
                return item_value

        # Check if item is part of a section with the attribute
        if isinstance(item, StatementItem):
            parent_section = self._find_parent_section_for_item(item)
            if parent_section and hasattr(parent_section, attribute_name):
                section_value = getattr(parent_section, attribute_name)
                if skip_default_check is None or not skip_default_check(section_value):
                    return section_value

        # Check statement-level attribute
        if hasattr(self.statement, attribute_name):
            statement_value = getattr(self.statement, attribute_name)
            if skip_default_check is None or not skip_default_check(statement_value):
                return statement_value

        # Check config if path provided
        if config_path:
            from fin_statement_model.config.helpers import cfg

            return cfg(config_path, default_value)

        # Return default value
        return default_value

    def _resolve_display_scale_factor(
        self, item: Union[StatementItem, Section]
    ) -&gt; float:
        &#34;&#34;&#34;Resolve the display scale factor for an item, considering hierarchy.

        Precedence: Item &gt; Section &gt; Statement &gt; Default (from config)

        Args:
            item: The item or section to get the scale factor for

        Returns:
            The resolved scale factor
        &#34;&#34;&#34;
        result = self._resolve_hierarchical_attribute(
            item=item,
            attribute_name=&#34;display_scale_factor&#34;,
            default_value=1.0,
            config_path=&#34;display.scale_factor&#34;,
            skip_default_check=lambda x: x == 1.0,
        )
        return float(result)

    def _resolve_units(self, item: Union[StatementItem, Section]) -&gt; Optional[str]:
        &#34;&#34;&#34;Resolve the unit description for an item, considering hierarchy.

        Precedence: Item &gt; Section &gt; Statement &gt; None

        Args:
            item: The item or section to get the units for

        Returns:
            The resolved unit description or None
        &#34;&#34;&#34;
        result = self._resolve_hierarchical_attribute(
            item=item,
            attribute_name=&#34;units&#34;,
            default_value=None,
            skip_default_check=lambda x: not x,  # Skip empty strings/None
        )
        return result if result is not None else None

    def _find_parent_section_for_item(
        self, target_item: StatementItem
    ) -&gt; Optional[Section]:
        &#34;&#34;&#34;Find the parent section that contains the given item.

        Args:
            target_item: The item to find the parent section for.

        Returns:
            The parent Section object, or None if not found.
        &#34;&#34;&#34;

        def search_in_section(section: Section) -&gt; Optional[Section]:
            # Check direct items
            for item in section.items:
                if item is target_item or (
                    hasattr(item, &#34;id&#34;)
                    and hasattr(target_item, &#34;id&#34;)
                    and item.id == target_item.id
                ):
                    return section
                # Check nested sections
                if isinstance(item, Section):
                    result = search_in_section(item)
                    if result:
                        return result

            # Check subtotal
            if hasattr(section, &#34;subtotal&#34;) and section.subtotal is target_item:
                return section

            return None

        # Search through all top-level sections
        for section in self.statement.sections:
            result = search_in_section(section)
            if result:
                return result

        return None

    def _should_hide_item(
        self, item: Union[StatementItem, Section], values: dict[str, float]
    ) -&gt; bool:
        &#34;&#34;&#34;Check if an item should be hidden based on hide_if_all_zero setting.

        Args:
            item: The item to check
            values: Dictionary of period values for the item

        Returns:
            True if the item should be hidden
        &#34;&#34;&#34;
        # Check if the item has hide_if_all_zero enabled
        hide_if_zero = getattr(item, &#34;hide_if_all_zero&#34;, False)
        if not hide_if_zero:
            return False

        # Check if all values are zero or NaN
        return all(not (pd.notna(value) and value != 0) for value in values.values())

    def _apply_item_scaling(
        self, values: dict[str, float], scale_factor: float
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Apply scaling to item values.

        Args:
            values: Dictionary of period values
            scale_factor: Factor to scale by

        Returns:
            Dictionary of scaled values
        &#34;&#34;&#34;
        if scale_factor == 1.0:
            return values

        scaled_values = {}
        for period, value in values.items():
            if pd.notna(value):
                scaled_values[period] = value * scale_factor
            else:
                scaled_values[period] = value

        return scaled_values

    def _format_item_values(
        self,
        item: Union[StatementItem, Section],
        values: dict[str, float],
        period_columns: list[str],
    ) -&gt; dict[str, str]:
        &#34;&#34;&#34;Format values for an item using its specific display format if available.

        Args:
            item: The item to format values for
            values: Dictionary of period values
            period_columns: List of period column names

        Returns:
            Dictionary of formatted values
        &#34;&#34;&#34;
        # Get item-specific display format
        item_format = getattr(item, &#34;display_format&#34;, None)

        formatted_values = {}
        for period in period_columns:
            value = values.get(period, np.nan)

            if pd.notna(value):
                if item_format:
                    try:
                        formatted_values[period] = f&#34;{value:{item_format}}&#34;
                    except (ValueError, TypeError):
                        # Fall back to default if format is invalid
                        logger.warning(
                            f&#34;Invalid display format &#39;{item_format}&#39; for item &#39;{getattr(item, &#39;id&#39;, &#39;unknown&#39;)}&#39;, using default&#34;
                        )
                        formatted_values[period] = str(
                            value
                        )  # Convert to string for consistency
                else:
                    formatted_values[period] = str(
                        value
                    )  # Convert to string for consistency
            else:
                formatted_values[period] = &#34;&#34;

        return formatted_values

    def _format_contra_value(
        self, value: float, display_style: str | None = None
    ) -&gt; str:
        &#34;&#34;&#34;Format a contra item value according to the specified display style.

        Args:
            value: The numeric value to format
            display_style: Style for contra display (&#34;parentheses&#34;, &#34;negative_sign&#34;, &#34;brackets&#34;)

        Returns:
            Formatted string representation of the contra value
        &#34;&#34;&#34;
        if pd.isna(value) or value == 0:
            return &#34;&#34;

        # For contra items, we typically want to show the absolute value with special formatting
        # regardless of the underlying sign, since sign_convention handles calculation logic
        from fin_statement_model.config.helpers import cfg

        style = display_style or self.default_formats.get(
            &#34;contra_display_style&#34;, cfg(&#34;display.contra_display_style&#34;, &#34;parentheses&#34;)
        )
        abs_value = abs(value)

        # Use dictionary for style formatting
        style_formats = {
            &#34;parentheses&#34;: f&#34;({abs_value:,.2f})&#34;,
            &#34;negative_sign&#34;: f&#34;-{abs_value:,.2f}&#34;,
            &#34;brackets&#34;: f&#34;[{abs_value:,.2f}]&#34;,
        }

        if style and isinstance(style, str) and style in style_formats:
            return style_formats[style]
        return f&#34;({abs_value:,.2f})&#34;  # Default fallback

    def _apply_contra_formatting(
        self,
        item: Union[StatementItem, Section],
        values: dict[str, float],
        period_columns: list[str],
        display_style: str | None = None,
    ) -&gt; dict[str, str]:
        &#34;&#34;&#34;Apply contra-specific formatting to item values.

        Args:
            item: The item to format
            values: Dictionary of period values
            period_columns: List of period column names
            display_style: Optional override for contra display style

        Returns:
            Dictionary of formatted contra values
        &#34;&#34;&#34;
        contra_formatted = {}
        for period in period_columns:
            value = values.get(period, np.nan)
            contra_formatted[period] = self._format_contra_value(value, display_style)

        return contra_formatted

    def _prepare_formatting_context(self, **kwargs: Any) -&gt; FormattingContext:
        &#34;&#34;&#34;Prepare formatting context with config defaults.

        Args:
            **kwargs: All formatting parameters passed to generate_dataframe (overrides config)

        Returns:
            FormattingContext: Configured context object
        &#34;&#34;&#34;
        from fin_statement_model import get_config

        config = get_config()

        # Create context with provided kwargs
        context = FormattingContext(
            should_apply_signs=kwargs.get(
                &#34;should_apply_signs&#34;, config.display.apply_sign_conventions
            ),
            include_empty_items=kwargs.get(
                &#34;include_empty_items&#34;, config.display.include_empty_items
            ),
            number_format=kwargs.get(&#34;number_format&#34;),
            include_metadata_cols=kwargs.get(
                &#34;include_metadata_cols&#34;, config.display.include_metadata_cols
            ),
            adjustment_filter=kwargs.get(&#34;adjustment_filter&#34;),
            add_is_adjusted_column=kwargs.get(
                &#34;add_is_adjusted_column&#34;, config.display.add_is_adjusted_column
            ),
            include_units_column=kwargs.get(
                &#34;include_units_column&#34;, config.display.include_units_column
            ),
            include_css_classes=kwargs.get(
                &#34;include_css_classes&#34;, config.display.include_css_classes
            ),
            include_notes_column=kwargs.get(
                &#34;include_notes_column&#34;, config.display.include_notes_column
            ),
            apply_item_scaling=kwargs.get(
                &#34;apply_item_scaling&#34;, config.display.apply_item_scaling
            ),
            apply_item_formatting=kwargs.get(
                &#34;apply_item_formatting&#34;, config.display.apply_item_formatting
            ),
            respect_hide_flags=kwargs.get(&#34;respect_hide_flags&#34;),
            contra_display_style=kwargs.get(&#34;contra_display_style&#34;),
            apply_contra_formatting=kwargs.get(
                &#34;apply_contra_formatting&#34;, config.display.apply_contra_formatting
            ),
            add_contra_indicator_column=kwargs.get(
                &#34;add_contra_indicator_column&#34;,
                config.display.add_contra_indicator_column,
            ),
        )

        # Apply config defaults for None values
        if context.should_apply_signs is None:
            context.should_apply_signs = (
                True  # This is a calculation default, not display
            )
        if context.include_empty_items is None:
            context.include_empty_items = False  # Preserve historical default
        if context.respect_hide_flags is None:
            context.respect_hide_flags = config.display.hide_zero_rows
        if context.contra_display_style is None:
            context.contra_display_style = config.display.contra_display_style
        if context.number_format is None:
            context.number_format = config.display.default_number_format

        # Set default formats
        context.default_formats = self.default_formats

        return context

    def _fetch_statement_data(
        self, graph: Graph, context: FormattingContext
    ) -&gt; tuple[dict[str, dict[str, float]], Any]:
        &#34;&#34;&#34;Fetch data from graph using DataFetcher.

        Args:
            graph: The core.graph.Graph instance containing the data
            context: Formatting context with fetch parameters

        Returns:
            Tuple of (data dictionary, fetch errors)
        &#34;&#34;&#34;
        data_fetcher = DataFetcher(self.statement, graph)
        fetch_result = data_fetcher.fetch_all_data(
            adjustment_filter=context.adjustment_filter,
            include_missing=context.include_empty_items,
        )

        # Log any warnings/errors
        if fetch_result.errors.has_warnings() or fetch_result.errors.has_errors():
            fetch_result.errors.log_all(
                prefix=f&#34;Statement &#39;{self.statement.id}&#39; data fetch: &#34;
            )

        # Update context with periods from graph
        context.all_periods = graph.periods

        return fetch_result.data, fetch_result.errors

    def _create_empty_dataframe(self, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Create an empty DataFrame with appropriate columns.

        Args:
            context: Formatting context with column configuration

        Returns:
            Empty DataFrame with proper column structure
        &#34;&#34;&#34;
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;, *context.all_periods]
        if context.include_units_column:
            base_cols.append(&#34;units&#34;)
        return pd.DataFrame(columns=base_cols)

    def _build_row_data(
        self,
        graph: Graph,
        data: dict[str, dict[str, float]],
        context: FormattingContext,
    ) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Build row data recursively from statement structure.

        Args:
            graph: The core.graph.Graph instance
            data: Fetched data dictionary
            context: Formatting context

        Returns:
            List of row dictionaries
        &#34;&#34;&#34;
        rows: list[dict[str, Any]] = []
        id_resolver = IDResolver(self.statement, standard_node_registry)

        # Process all sections
        self._process_items_recursive(
            items=list(self.statement.sections),
            depth=0,
            data=data,
            rows=rows,
            context=context,
            id_resolver=id_resolver,
            graph=graph,
        )

        # Filter hidden items if needed
        if context.respect_hide_flags:
            rows = [row for row in rows if row[&#34;ID&#34;] not in context.items_to_hide]

        return rows

    def _process_items_recursive(
        self,
        items: list[Union[Section, StatementItem]],
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Recursively process items and sections.

        Args:
            items: List of items or sections to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        for item in items:
            if isinstance(item, Section):
                self._process_section(
                    item, depth, data, rows, context, id_resolver, graph
                )
            elif isinstance(item, StatementItem):
                self._process_item(item, depth, data, rows, context, id_resolver, graph)

    def _process_section(
        self,
        section: Section,
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Process a section and its items.

        Args:
            section: Section to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        # Process section items first to collect data for hide check
        self._process_items_recursive(
            section.items, depth + 1, data, rows, context, id_resolver, graph
        )

        # Process subtotal if it exists
        if hasattr(section, &#34;subtotal&#34;) and section.subtotal:
            self._process_items_recursive(
                [section.subtotal], depth + 1, data, rows, context, id_resolver, graph
            )

        # Check if section should be hidden
        if context.respect_hide_flags and getattr(section, &#34;hide_if_all_zero&#34;, False):
            # For sections, check if all contained items are hidden or zero
            section_has_data = False
            for section_item in section.items:
                node_id = id_resolver.resolve(section_item.id, graph)
                if node_id and node_id in data:
                    item_data = data[node_id]
                    if any(pd.notna(v) and v != 0 for v in item_data.values()):
                        section_has_data = True
                        break
            if not section_has_data:
                context.items_to_hide.add(section.id)

    def _process_item(
        self,
        item: StatementItem,
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Process a single statement item.

        Args:
            item: Statement item to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        # Use ID resolver to get the correct node ID
        node_id = id_resolver.resolve(item.id, graph)
        if not node_id:
            return

        item_data = data.get(node_id, {})
        numeric_values: dict[str, float] = {
            p: item_data.get(p, np.nan) for p in context.all_periods
        }

        # Apply item-specific scaling if enabled
        if context.apply_item_scaling:
            numeric_values = self._apply_scaling(numeric_values, context, item)

        # Check if item should be hidden
        if context.respect_hide_flags and self._should_hide_item(item, numeric_values):
            context.items_to_hide.add(item.id)
            return

        # Start with numeric values and add formatted strings as needed
        row_values: dict[str, Union[float, str]] = dict(numeric_values)

        # Apply item-specific formatting if enabled (but only if not using global format)
        if context.apply_item_formatting and not context.number_format:
            formatted_values = self._format_item_values(
                item, numeric_values, context.all_periods
            )
            # Only apply if we got actual formatted strings
            if any(isinstance(v, str) for v in formatted_values.values()):
                for period in context.all_periods:
                    if period in formatted_values and isinstance(
                        formatted_values[period], str
                    ):
                        # Keep numeric value for calculations, store formatted for display
                        row_values[f&#34;{period}_formatted&#34;] = formatted_values[period]

        # Apply contra formatting if enabled and item is marked as contra
        if context.apply_contra_formatting and getattr(item, &#34;is_contra&#34;, False):
            contra_formatted = self._apply_contra_formatting(
                item, numeric_values, context.all_periods, context.contra_display_style
            )
            # Store contra formatted values for later use
            for period in context.all_periods:
                if contra_formatted.get(period):
                    row_values[f&#34;{period}_contra&#34;] = contra_formatted[period]

        if context.include_empty_items or any(pd.notna(v) for v in row_values.values()):
            row = self._create_row_dict(item, node_id, row_values, depth, context)
            rows.append(row)

    def _create_row_dict(
        self,
        item: StatementItem,
        node_id: str,
        row_values: dict[str, Union[float, str]],
        depth: int,
        context: FormattingContext,
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Create a row dictionary for a statement item.

        Args:
            item: Statement item
            node_id: Resolved node ID
            row_values: Period values for the item
            depth: Indentation depth
            context: Formatting context

        Returns:
            Row dictionary
        &#34;&#34;&#34;
        indent_char = context.default_formats[&#34;indent_character&#34;]

        row = {
            &#34;Line Item&#34;: indent_char * depth + item.name,
            &#34;ID&#34;: item.id,
            **row_values,
            # Metadata
            &#34;line_type&#34;: self._get_item_type(item),
            &#34;node_id&#34;: node_id,
            &#34;sign_convention&#34;: getattr(item, &#34;sign_convention&#34;, 1),
            &#34;is_subtotal&#34;: isinstance(item, SubtotalLineItem),
            &#34;is_calculated&#34;: isinstance(item, CalculatedLineItem),
            &#34;is_contra&#34;: getattr(item, &#34;is_contra&#34;, False),
        }

        # Add enhanced metadata columns if requested
        if context.include_units_column:
            row[&#34;units&#34;] = self._resolve_units(item)

        if context.include_css_classes:
            # Get item&#39;s CSS class and add contra class if applicable
            item_css_class = getattr(item, &#34;css_class&#34;, None)
            if getattr(item, &#34;is_contra&#34;, False):
                contra_css = context.default_formats.get(
                    &#34;contra_css_class&#34;, &#34;contra-item&#34;
                )
                if item_css_class:
                    row[&#34;css_class&#34;] = f&#34;{item_css_class} {contra_css}&#34;
                else:
                    row[&#34;css_class&#34;] = contra_css
            else:
                row[&#34;css_class&#34;] = item_css_class

        if context.include_notes_column:
            notes = getattr(item, &#34;notes_references&#34;, [])
            row[&#34;notes&#34;] = &#34;; &#34;.join(notes) if notes else &#34;&#34;

        return row

    def _apply_scaling(
        self, values: dict[str, float], context: FormattingContext, item: StatementItem
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Apply item-specific scaling if enabled.

        Args:
            values: Dictionary of period values
            context: Formatting context
            item: Statement item

        Returns:
            Dictionary of scaled values
        &#34;&#34;&#34;
        if not context.apply_item_scaling:
            return values

        scale_factor = self._resolve_display_scale_factor(item)
        return self._apply_item_scaling(values, scale_factor)

    def _organize_dataframe_columns(
        self, df: pd.DataFrame, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Organize DataFrame columns in the correct order.

        Args:
            df: DataFrame to organize
            context: Formatting context

        Returns:
            DataFrame with organized columns
        &#34;&#34;&#34;
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;]
        metadata_cols = [
            &#34;line_type&#34;,
            &#34;node_id&#34;,
            &#34;sign_convention&#34;,
            &#34;is_subtotal&#34;,
            &#34;is_calculated&#34;,
            &#34;is_contra&#34;,
        ]

        # Enhanced metadata columns
        enhanced_cols = []
        if context.include_units_column:
            enhanced_cols.append(&#34;units&#34;)
        if context.include_css_classes:
            enhanced_cols.append(&#34;css_class&#34;)
        if context.include_notes_column:
            enhanced_cols.append(&#34;notes&#34;)
        if context.add_contra_indicator_column:
            enhanced_cols.append(&#34;is_contra&#34;)

        # Add adjustment columns if they exist
        adjusted_flag_cols = []
        if context.add_is_adjusted_column:
            adjusted_flag_cols = [
                f&#34;{period}_is_adjusted&#34; for period in context.all_periods
            ]

        final_cols = base_cols + context.all_periods
        if adjusted_flag_cols:
            final_cols += adjusted_flag_cols
        if enhanced_cols:
            final_cols += enhanced_cols
        if context.include_metadata_cols:
            # Add metadata cols (excluding adjustment flags if they are already added)
            final_cols += [
                m_col for m_col in metadata_cols if m_col not in adjusted_flag_cols
            ]

        # Ensure contra formatting columns are available temporarily (will be removed later)
        all_available_cols = final_cols.copy()
        if context.apply_contra_formatting:
            contra_formatted_cols = [
                f&#34;{period}_contra&#34; for period in context.all_periods
            ]
            all_available_cols += contra_formatted_cols

        for col in all_available_cols:
            if col not in df.columns:
                df[col] = (
                    np.nan
                    if col in context.all_periods
                    else (&#34;&#34; if col == &#34;Line Item&#34; else None)
                )

        return df[all_available_cols]

    def _add_adjustment_columns(
        self, df: pd.DataFrame, graph: Graph, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Add adjustment status columns to the DataFrame.

        Args:
            df: DataFrame to add columns to
            graph: Graph instance
            context: Formatting context

        Returns:
            DataFrame with adjustment columns added
        &#34;&#34;&#34;
        if not context.add_is_adjusted_column or not context.all_periods:
            return df

        # Get node IDs from the dataframe
        node_ids_to_check = []
        for _, row in df.iterrows():
            node_id = row.get(&#34;node_id&#34;)
            is_calc_or_subtotal = row.get(&#34;is_calculated&#34;, False) or row.get(
                &#34;is_subtotal&#34;, False
            )
            if node_id and not is_calc_or_subtotal:
                node_ids_to_check.append(node_id)

        # Use DataFetcher to check adjustments
        if node_ids_to_check:
            data_fetcher = DataFetcher(self.statement, graph)
            adjustment_status = data_fetcher.check_adjustments(
                node_ids_to_check, context.all_periods, context.adjustment_filter
            )
        else:
            adjustment_status = {}

        # Build adjustment columns
        is_adjusted_data = []
        for _, row in df.iterrows():
            node_id = row.get(&#34;node_id&#34;)
            is_calc_or_subtotal = row.get(&#34;is_calculated&#34;, False) or row.get(
                &#34;is_subtotal&#34;, False
            )

            if node_id and not is_calc_or_subtotal and node_id in adjustment_status:
                row_adj_flags = {
                    f&#34;{period}_is_adjusted&#34;: adjustment_status[node_id].get(
                        period, False
                    )
                    for period in context.all_periods
                }
            else:
                # For calculated/subtotal items or missing nodes, flags are False
                row_adj_flags = {
                    f&#34;{period}_is_adjusted&#34;: False for period in context.all_periods
                }
            is_adjusted_data.append(row_adj_flags)

        if is_adjusted_data:
            adj_df = pd.DataFrame(is_adjusted_data, index=df.index)
            df = pd.concat([df, adj_df], axis=1)

        return df

    def _cleanup_temporary_columns(
        self, df: pd.DataFrame, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Clean up temporary columns from the dataframe.

        Args:
            df: DataFrame to clean up
            context: Formatting context

        Returns:
            DataFrame with temporary columns removed
        &#34;&#34;&#34;
        # Remove the contra formatting columns from the final output
        if context.apply_contra_formatting:
            contra_cols_to_remove = [
                f&#34;{period}_contra&#34; for period in context.all_periods
            ]
            df = df.drop(
                columns=[col for col in contra_cols_to_remove if col in df.columns]
            )

        # Build final column list
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;]
        metadata_cols = [
            &#34;line_type&#34;,
            &#34;node_id&#34;,
            &#34;sign_convention&#34;,
            &#34;is_subtotal&#34;,
            &#34;is_calculated&#34;,
            &#34;is_contra&#34;,
        ]

        enhanced_cols = []
        if context.include_units_column:
            enhanced_cols.append(&#34;units&#34;)
        if context.include_css_classes:
            enhanced_cols.append(&#34;css_class&#34;)
        if context.include_notes_column:
            enhanced_cols.append(&#34;notes&#34;)
        if context.add_contra_indicator_column:
            enhanced_cols.append(&#34;is_contra&#34;)

        adjusted_flag_cols = []
        if context.add_is_adjusted_column:
            adjusted_flag_cols = [
                f&#34;{period}_is_adjusted&#34; for period in context.all_periods
            ]

        final_cols = base_cols + context.all_periods
        if context.add_is_adjusted_column:
            final_cols += adjusted_flag_cols
        if enhanced_cols:
            final_cols += enhanced_cols
        if context.include_metadata_cols:
            # Add metadata cols (excluding adjustment flags if they are already added)
            final_cols += [
                m_col for m_col in metadata_cols if m_col not in adjusted_flag_cols
            ]

        # Select only the final columns for output
        return df[final_cols]

    def _apply_all_formatting(
        self, df: pd.DataFrame, context: FormattingContext
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Apply consolidated formatting in a single vectorized pass.&#34;&#34;&#34;
        # Combined sign, contra, and number formatting
        df = render_values(
            df=df,
            period_columns=context.all_periods,
            default_formats=context.default_formats,
            number_format=context.number_format,
            contra_display_style=context.contra_display_style,
        )
        # Clean up temporary columns
        df = self._cleanup_temporary_columns(df, context)
        return df

    def generate_dataframe(
        self,
        graph: Graph,
        context: Optional[FormattingContext] = None,
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Generate a formatted DataFrame for the statement.

        Args:
            graph: Graph instance containing the data to render.
            context: FormattingContext object containing all display / formatting
                configuration. If *None*, a context will be created from project
                configuration.

        Returns:
            A fully-formatted ``pandas.DataFrame`` representing the statement.
        &#34;&#34;&#34;
        if context is None:
            # Build context purely from project defaults (no legacy kwargs path).
            context = self._prepare_formatting_context()

        # 2. Fetch statement data -------------------------------------------------------------------
        data, _ = self._fetch_statement_data(graph, context)

        # 3. Build row dictionaries -----------------------------------------------------------------
        rows = self._build_row_data(graph, data, context)

        # 4. Assemble DataFrame ---------------------------------------------------------------------
        if not rows:
            return self._create_empty_dataframe(context)

        df = pd.DataFrame(rows)

        # 5. Adjustment columns (must precede column organisation)
        if context.add_is_adjusted_column:
            df = self._add_adjustment_columns(df, graph, context)

        # 6. Column ordering / injection ------------------------------------------------------------
        df = self._organize_dataframe_columns(df, context)

        # 7. Post-processing formatting -------------------------------------------------------------
        df = self._apply_all_formatting(df, context)

        return df

    def _get_item_type(self, item: StatementItem) -&gt; str:
        &#34;&#34;&#34;Get the type of a statement item.

        Args:
            item: Statement item to get type for

        Returns:
            str: Item type identifier
        &#34;&#34;&#34;
        if isinstance(item, Section):
            return &#34;section&#34;
        elif isinstance(item, SubtotalLineItem):
            return &#34;subtotal&#34;
        elif isinstance(item, CalculatedLineItem):
            return &#34;calculated&#34;
        else:
            return &#34;item&#34;

    def format_html(
        self,
        graph: Graph,
        should_apply_signs: Optional[bool] = None,
        include_empty_items: Optional[bool] = None,
        css_styles: Optional[dict[str, str]] = None,
        use_item_css_classes: Optional[bool] = None,
        **kwargs: Any,
    ) -&gt; str:
        &#34;&#34;&#34;Format the statement data as HTML with enhanced styling support.

        Args:
            graph: The core.graph.Graph instance containing the data.
            should_apply_signs: Whether to apply sign conventions (override config).
            include_empty_items: Whether to include items with no data (override config).
            css_styles: Optional dict of CSS styles for the HTML.
            use_item_css_classes: Whether to use item-specific CSS classes (override config).
            **kwargs: Additional arguments passed to generate_dataframe.

        Returns:
            str: HTML string representing the statement with enhanced styling.
        &#34;&#34;&#34;
        # Determine defaults for unspecified parameters -------------------------------------------
        from fin_statement_model import get_config

        cfg = get_config()

        should_apply_signs = (
            should_apply_signs
            if should_apply_signs is not None
            else cfg.display.apply_sign_conventions
        )
        include_empty_items = (
            include_empty_items
            if include_empty_items is not None
            else cfg.display.include_empty_items
        )
        use_item_css_classes = (
            use_item_css_classes
            if use_item_css_classes is not None
            else cfg.display.include_css_classes
        )

        # Ensure the correct flag for CSS class inclusion is propagated
        if use_item_css_classes:
            kwargs[&#34;include_css_classes&#34;] = True

        # Build a FormattingContext with the specified overrides and any additional
        # keyword arguments provided by the caller.
        context = self._prepare_formatting_context(
            should_apply_signs=should_apply_signs,
            include_empty_items=include_empty_items,
            **kwargs,
        )

        df = self.generate_dataframe(graph=graph, context=context)

        html: str = df.to_html(
            index=False, classes=&#34;statement-table&#34;, table_id=&#34;financial-statement&#34;
        )

        if css_styles or use_item_css_classes:
            style_str = &#34;&lt;style&gt;\n&#34;

            # Add default styles for statement tables
            style_str += &#34;&#34;&#34;
            .statement-table { border-collapse: collapse; width: 100%; }
            .statement-table th, .statement-table td { padding: 8px; text-align: right; border: 1px solid #ddd; }
            .statement-table th { background-color: #f2f2f2; font-weight: bold; }
            .statement-table .Line.Item { text-align: left; }
            .contra-item { font-style: italic; color: #666; }
            &#34;&#34;&#34;

            # Add custom styles
            if css_styles:
                for selector, style in css_styles.items():
                    style_str += f&#34;{selector} {{ {style} }}\n&#34;

            style_str += &#34;&lt;/style&gt;\n&#34;
            html = style_str + html

        return html</code></pre>
</details>
<div class="desc"><p>Formats financial statements for display or reporting.</p>
<p>This class provides methods to transform raw financial data into
formatted financial statements with proper headers, indentation,
subtotals, sign conventions, and enhanced display control.</p>
<p>Initialize a statement formatter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure to format</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.formatting.StatementFormatter.format_html"><code class="name flex">
<span>def <span class="ident">format_html</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>should_apply_signs: bool | None = None,<br>include_empty_items: bool | None = None,<br>css_styles: dict[str, str] | None = None,<br>use_item_css_classes: bool | None = None,<br>**kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_html(
    self,
    graph: Graph,
    should_apply_signs: Optional[bool] = None,
    include_empty_items: Optional[bool] = None,
    css_styles: Optional[dict[str, str]] = None,
    use_item_css_classes: Optional[bool] = None,
    **kwargs: Any,
) -&gt; str:
    &#34;&#34;&#34;Format the statement data as HTML with enhanced styling support.

    Args:
        graph: The core.graph.Graph instance containing the data.
        should_apply_signs: Whether to apply sign conventions (override config).
        include_empty_items: Whether to include items with no data (override config).
        css_styles: Optional dict of CSS styles for the HTML.
        use_item_css_classes: Whether to use item-specific CSS classes (override config).
        **kwargs: Additional arguments passed to generate_dataframe.

    Returns:
        str: HTML string representing the statement with enhanced styling.
    &#34;&#34;&#34;
    # Determine defaults for unspecified parameters -------------------------------------------
    from fin_statement_model import get_config

    cfg = get_config()

    should_apply_signs = (
        should_apply_signs
        if should_apply_signs is not None
        else cfg.display.apply_sign_conventions
    )
    include_empty_items = (
        include_empty_items
        if include_empty_items is not None
        else cfg.display.include_empty_items
    )
    use_item_css_classes = (
        use_item_css_classes
        if use_item_css_classes is not None
        else cfg.display.include_css_classes
    )

    # Ensure the correct flag for CSS class inclusion is propagated
    if use_item_css_classes:
        kwargs[&#34;include_css_classes&#34;] = True

    # Build a FormattingContext with the specified overrides and any additional
    # keyword arguments provided by the caller.
    context = self._prepare_formatting_context(
        should_apply_signs=should_apply_signs,
        include_empty_items=include_empty_items,
        **kwargs,
    )

    df = self.generate_dataframe(graph=graph, context=context)

    html: str = df.to_html(
        index=False, classes=&#34;statement-table&#34;, table_id=&#34;financial-statement&#34;
    )

    if css_styles or use_item_css_classes:
        style_str = &#34;&lt;style&gt;\n&#34;

        # Add default styles for statement tables
        style_str += &#34;&#34;&#34;
        .statement-table { border-collapse: collapse; width: 100%; }
        .statement-table th, .statement-table td { padding: 8px; text-align: right; border: 1px solid #ddd; }
        .statement-table th { background-color: #f2f2f2; font-weight: bold; }
        .statement-table .Line.Item { text-align: left; }
        .contra-item { font-style: italic; color: #666; }
        &#34;&#34;&#34;

        # Add custom styles
        if css_styles:
            for selector, style in css_styles.items():
                style_str += f&#34;{selector} {{ {style} }}\n&#34;

        style_str += &#34;&lt;/style&gt;\n&#34;
        html = style_str + html

    return html</code></pre>
</details>
<div class="desc"><p>Format the statement data as HTML with enhanced styling support.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The core.graph.Graph instance containing the data.</dd>
<dt><strong><code>should_apply_signs</code></strong></dt>
<dd>Whether to apply sign conventions (override config).</dd>
<dt><strong><code>include_empty_items</code></strong></dt>
<dd>Whether to include items with no data (override config).</dd>
<dt><strong><code>css_styles</code></strong></dt>
<dd>Optional dict of CSS styles for the HTML.</dd>
<dt><strong><code>use_item_css_classes</code></strong></dt>
<dd>Whether to use item-specific CSS classes (override config).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to generate_dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>HTML string representing the statement with enhanced styling.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.formatting.StatementFormatter.generate_dataframe"><code class="name flex">
<span>def <span class="ident">generate_dataframe</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>context: <a title="fin_statement_model.statements.formatting.formatter.FormattingContext" href="formatter.html#fin_statement_model.statements.formatting.formatter.FormattingContext">FormattingContext</a> | None = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_dataframe(
    self,
    graph: Graph,
    context: Optional[FormattingContext] = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a formatted DataFrame for the statement.

    Args:
        graph: Graph instance containing the data to render.
        context: FormattingContext object containing all display / formatting
            configuration. If *None*, a context will be created from project
            configuration.

    Returns:
        A fully-formatted ``pandas.DataFrame`` representing the statement.
    &#34;&#34;&#34;
    if context is None:
        # Build context purely from project defaults (no legacy kwargs path).
        context = self._prepare_formatting_context()

    # 2. Fetch statement data -------------------------------------------------------------------
    data, _ = self._fetch_statement_data(graph, context)

    # 3. Build row dictionaries -----------------------------------------------------------------
    rows = self._build_row_data(graph, data, context)

    # 4. Assemble DataFrame ---------------------------------------------------------------------
    if not rows:
        return self._create_empty_dataframe(context)

    df = pd.DataFrame(rows)

    # 5. Adjustment columns (must precede column organisation)
    if context.add_is_adjusted_column:
        df = self._add_adjustment_columns(df, graph, context)

    # 6. Column ordering / injection ------------------------------------------------------------
    df = self._organize_dataframe_columns(df, context)

    # 7. Post-processing formatting -------------------------------------------------------------
    df = self._apply_all_formatting(df, context)

    return df</code></pre>
</details>
<div class="desc"><p>Generate a formatted DataFrame for the statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>Graph instance containing the data to render.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>FormattingContext object containing all display / formatting
configuration. If <em>None</em>, a context will be created from project
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A fully-formatted <code>pandas.DataFrame</code> representing the statement.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.statements" href="../index.html">fin_statement_model.statements</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.statements.formatting.data_fetcher" href="data_fetcher.html">fin_statement_model.statements.formatting.data_fetcher</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.formatter" href="formatter.html">fin_statement_model.statements.formatting.formatter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.statements.formatting.DataFetcher" href="#fin_statement_model.statements.formatting.DataFetcher">DataFetcher</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.formatting.DataFetcher.check_adjustments" href="#fin_statement_model.statements.formatting.DataFetcher.check_adjustments">check_adjustments</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.DataFetcher.fetch_all_data" href="#fin_statement_model.statements.formatting.DataFetcher.fetch_all_data">fetch_all_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.formatting.FetchResult" href="#fin_statement_model.statements.formatting.FetchResult">FetchResult</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.formatting.FetchResult.data" href="#fin_statement_model.statements.formatting.FetchResult.data">data</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.FetchResult.errors" href="#fin_statement_model.statements.formatting.FetchResult.errors">errors</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.FetchResult.missing_nodes" href="#fin_statement_model.statements.formatting.FetchResult.missing_nodes">missing_nodes</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.FetchResult.node_count" href="#fin_statement_model.statements.formatting.FetchResult.node_count">node_count</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.FetchResult.to_result" href="#fin_statement_model.statements.formatting.FetchResult.to_result">to_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.formatting.NodeData" href="#fin_statement_model.statements.formatting.NodeData">NodeData</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.formatting.NodeData.errors" href="#fin_statement_model.statements.formatting.NodeData.errors">errors</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.NodeData.has_data" href="#fin_statement_model.statements.formatting.NodeData.has_data">has_data</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.NodeData.is_adjusted" href="#fin_statement_model.statements.formatting.NodeData.is_adjusted">is_adjusted</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.NodeData.node_id" href="#fin_statement_model.statements.formatting.NodeData.node_id">node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.NodeData.values" href="#fin_statement_model.statements.formatting.NodeData.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.formatting.StatementFormatter" href="#fin_statement_model.statements.formatting.StatementFormatter">StatementFormatter</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.formatting.StatementFormatter.format_html" href="#fin_statement_model.statements.formatting.StatementFormatter.format_html">format_html</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting.StatementFormatter.generate_dataframe" href="#fin_statement_model.statements.formatting.StatementFormatter.generate_dataframe">generate_dataframe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
