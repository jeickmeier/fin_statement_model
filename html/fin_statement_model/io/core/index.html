<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.io.core API documentation</title>
<meta name="description" content="Core IO components including base classes, registry, and utilities.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.io.core</code></h1>
</header>
<section id="section-intro">
<p>Core IO components including base classes, registry, and utilities.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.io.core.base" href="base.html">fin_statement_model.io.core.base</a></code></dt>
<dd>
<div class="desc"><p>Base classes for data readers and writers.</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.io.core.facade" href="facade.html">fin_statement_model.io.core.facade</a></code></dt>
<dd>
<div class="desc"><p>Facade functions for simplified IO operations …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.io.core.mixins" href="mixins.html">fin_statement_model.io.core.mixins</a></code></dt>
<dd>
<div class="desc"><p>Reusable mixins and decorators for IO operations …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.io.core.registry" href="registry.html">fin_statement_model.io.core.registry</a></code></dt>
<dd>
<div class="desc"><p>Registry system for managing IO format handlers …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.io.core.utils" href="utils.html">fin_statement_model.io.core.utils</a></code></dt>
<dd>
<div class="desc"><p>Utility functions for IO operations.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.io.core.get_reader"><code class="name flex">
<span>def <span class="ident">get_reader</span></span>(<span>format_type: str, **kwargs: Any) ‑> <a title="fin_statement_model.io.core.base.DataReader" href="base.html#fin_statement_model.io.core.base.DataReader">DataReader</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reader(format_type: str, **kwargs: Any) -&gt; DataReader:
    &#34;&#34;&#34;Get an instance of the registered DataReader for the given format type.

    Args:
        format_type: The string identifier for the format.
        **kwargs: Keyword arguments to pass to the reader&#39;s constructor.

    Returns:
        An initialized DataReader instance.

    Raises:
        FormatNotSupportedError: If no reader is registered for the format type.
        ReadError: If validation fails for known reader types.
    &#34;&#34;&#34;
    return cast(
        DataReader,
        _get_handler(
            format_type=format_type,
            registry=_reader_registry,
            handler_type=&#34;read&#34;,
            error_class=ReadError,
            **kwargs,
        ),
    )</code></pre>
</details>
<div class="desc"><p>Get an instance of the registered DataReader for the given format type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The string identifier for the format.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to pass to the reader's constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An initialized DataReader instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FormatNotSupportedError</code></dt>
<dd>If no reader is registered for the format type.</dd>
<dt><code>ReadError</code></dt>
<dd>If validation fails for known reader types.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.get_writer"><code class="name flex">
<span>def <span class="ident">get_writer</span></span>(<span>format_type: str, **kwargs: Any) ‑> <a title="fin_statement_model.io.core.base.DataWriter" href="base.html#fin_statement_model.io.core.base.DataWriter">DataWriter</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_writer(format_type: str, **kwargs: Any) -&gt; DataWriter:
    &#34;&#34;&#34;Get an instance of the registered DataWriter for the given format type.

    Args:
        format_type: The string identifier for the format.
        **kwargs: Keyword arguments to pass to the writer&#39;s constructor.

    Returns:
        An initialized DataWriter instance.

    Raises:
        FormatNotSupportedError: If no writer is registered for the format type.
        WriteError: If validation fails for known writer types.
    &#34;&#34;&#34;
    return cast(
        DataWriter,
        _get_handler(
            format_type=format_type,
            registry=_writer_registry,
            handler_type=&#34;write&#34;,
            error_class=WriteError,
            **kwargs,
        ),
    )</code></pre>
</details>
<div class="desc"><p>Get an instance of the registered DataWriter for the given format type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The string identifier for the format.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to pass to the writer's constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An initialized DataWriter instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FormatNotSupportedError</code></dt>
<dd>If no writer is registered for the format type.</dd>
<dt><code>WriteError</code></dt>
<dd>If validation fails for known writer types.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.handle_read_errors"><code class="name flex">
<span>def <span class="ident">handle_read_errors</span></span>(<span>source_attr: str = 'source') ‑> Callable[[~F], ~F]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_read_errors(source_attr: str = &#34;source&#34;) -&gt; Callable[[F], F]:
    &#34;&#34;&#34;Decorator to standardize error handling for readers.

    This decorator catches common exceptions during read operations and
    converts them to appropriate ReadError instances with consistent
    error messages and context.

    Args:
        source_attr: Name of the attribute containing the source identifier.
                    Defaults to &#34;source&#34;.

    Returns:
        Decorated function that handles errors consistently.
    &#34;&#34;&#34;

    def decorator(func: F) -&gt; F:
        @functools.wraps(func)
        def wrapper(self: Any, source: Any, **kwargs: Any) -&gt; Any:
            try:
                return func(self, source, **kwargs)
            except ReadError:
                raise  # Re-raise our own errors without modification
            except FileNotFoundError as e:
                raise ReadError(
                    f&#34;File not found: {source}&#34;,
                    source=str(source),
                    reader_type=self.__class__.__name__,
                    original_error=e,
                )
            except ValueError as e:
                raise ReadError(
                    f&#34;Invalid value encountered: {e}&#34;,
                    source=str(source),
                    reader_type=self.__class__.__name__,
                    original_error=e,
                )
            except Exception as e:
                logger.error(f&#34;Failed to read from {source}: {e}&#34;, exc_info=True)
                raise ReadError(
                    f&#34;Failed to process source: {e}&#34;,
                    source=str(source),
                    reader_type=self.__class__.__name__,
                    original_error=e,
                ) from e

        return wrapper  # type: ignore

    return decorator</code></pre>
</details>
<div class="desc"><p>Decorator to standardize error handling for readers.</p>
<p>This decorator catches common exceptions during read operations and
converts them to appropriate ReadError instances with consistent
error messages and context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_attr</code></strong></dt>
<dd>Name of the attribute containing the source identifier.
Defaults to "source".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Decorated function that handles errors consistently.</p></div>
</dd>
<dt id="fin_statement_model.io.core.handle_write_errors"><code class="name flex">
<span>def <span class="ident">handle_write_errors</span></span>(<span>target_attr: str = 'target') ‑> Callable[[~F], ~F]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_write_errors(target_attr: str = &#34;target&#34;) -&gt; Callable[[F], F]:
    &#34;&#34;&#34;Decorator to standardize error handling for writers.

    Similar to handle_read_errors but for write operations.

    Args:
        target_attr: Name of the attribute containing the target identifier.
                    Defaults to &#34;target&#34;.

    Returns:
        Decorated function that handles errors consistently.
    &#34;&#34;&#34;

    def decorator(func: F) -&gt; F:
        @functools.wraps(func)
        def wrapper(self: Any, graph: Any, target: Any = None, **kwargs: Any) -&gt; Any:
            try:
                return func(self, graph, target, **kwargs)
            except WriteError:
                raise  # Re-raise our own errors without modification
            except Exception as e:
                logger.error(f&#34;Failed to write to {target}: {e}&#34;, exc_info=True)
                raise WriteError(
                    f&#34;Failed to write data: {e}&#34;,
                    target=str(target) if target else &#34;unknown&#34;,
                    writer_type=self.__class__.__name__,
                    original_error=e,
                ) from e

        return wrapper  # type: ignore

    return decorator</code></pre>
</details>
<div class="desc"><p>Decorator to standardize error handling for writers.</p>
<p>Similar to handle_read_errors but for write operations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_attr</code></strong></dt>
<dd>Name of the attribute containing the target identifier.
Defaults to "target".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Decorated function that handles errors consistently.</p></div>
</dd>
<dt id="fin_statement_model.io.core.list_readers"><code class="name flex">
<span>def <span class="ident">list_readers</span></span>(<span>) ‑> dict[str, type[<a title="fin_statement_model.io.core.base.DataReader" href="base.html#fin_statement_model.io.core.base.DataReader">DataReader</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_readers() -&gt; dict[str, type[DataReader]]:
    &#34;&#34;&#34;Return a copy of the registered reader classes.&#34;&#34;&#34;
    return _reader_registry.list_formats()</code></pre>
</details>
<div class="desc"><p>Return a copy of the registered reader classes.</p></div>
</dd>
<dt id="fin_statement_model.io.core.list_writers"><code class="name flex">
<span>def <span class="ident">list_writers</span></span>(<span>) ‑> dict[str, type[<a title="fin_statement_model.io.core.base.DataWriter" href="base.html#fin_statement_model.io.core.base.DataWriter">DataWriter</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_writers() -&gt; dict[str, type[DataWriter]]:
    &#34;&#34;&#34;Return a copy of the registered writer classes.&#34;&#34;&#34;
    return _writer_registry.list_formats()</code></pre>
</details>
<div class="desc"><p>Return a copy of the registered writer classes.</p></div>
</dd>
<dt id="fin_statement_model.io.core.read_data"><code class="name flex">
<span>def <span class="ident">read_data</span></span>(<span>format_type: str, source: Any, **kwargs: dict[str, str | int | float | bool]) ‑> <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_data(
    format_type: str, source: Any, **kwargs: dict[str, Union[str, int, float, bool]]
) -&gt; Graph:
    &#34;&#34;&#34;Reads data from a source using the specified format.

    This function acts as a facade for the underlying reader implementations.
    It uses the `format_type` to look up the appropriate reader class in the registry.
    The `source` and `**kwargs` are combined and validated against the specific
    reader&#39;s Pydantic configuration model (e.g., `CsvReaderConfig`).

    The validated configuration is used to initialize the reader instance.
    The `source` (which might be the original object for dict/dataframe formats, or
    the validated string path/ticker otherwise) and the original `**kwargs` are then
    passed to the reader instance&#39;s `.read()` method, which handles format-specific
    read-time options.

    Args:
        format_type (str): The format identifier (e.g., &#39;excel&#39;, &#39;csv&#39;, &#39;fmp&#39;, &#39;dict&#39;).
        source (Any): The data source. Its type depends on `format_type`:
            - `str`: file path (for &#39;excel&#39;, &#39;csv&#39;), ticker symbol (for &#39;fmp&#39;).
            - `pd.DataFrame`: for &#39;dataframe&#39;.
            - `dict`: for &#39;dict&#39;.
        **kwargs: Additional keyword arguments used for reader configuration (e.g.,
            `api_key`, `delimiter`, `sheet_name`, `mapping_config`) and potentially
            passed to the reader&#39;s `.read()` method (e.g., `periods`). Consult the
            specific reader&#39;s Pydantic config model and `.read()` docstring.

    Returns:
        Graph: A new Graph object populated with the read data.

    Raises:
        ReadError: If reading fails.
        FormatNotSupportedError: If the format_type is not registered.
        Exception: Other errors during reader initialization or reading.
    &#34;&#34;&#34;
    logger.info(
        f&#34;Attempting to read data using format &#39;{format_type}&#39; from source type &#39;{type(source).__name__}&#39;&#34;
    )

    # Prepare kwargs for registry validation (includes source and format_type)
    config_kwargs = {**kwargs, &#34;source&#34;: source, &#34;format_type&#34;: format_type}
    # Keep separate kwargs for the read method itself (e.g., &#39;periods&#39;)
    # This assumes Pydantic configs *don&#39;t* capture read-time args.

    try:
        # Pass the config kwargs directly to get_reader
        reader = get_reader(**config_kwargs)

        # Determine the actual source object for the read method
        actual_source = (
            source if format_type in (&#34;dict&#34;, &#34;dataframe&#34;) else config_kwargs[&#34;source&#34;]
        )

        # Pass the determined source and the original kwargs (excluding config keys potentially)
        # to the read method. Specific readers handle relevant kwargs.
        return reader.read(actual_source, **kwargs)
    except (IOError, FormatNotSupportedError):
        logger.exception(&#34;IO Error reading data&#34;)
        raise  # Re-raise specific IO errors
    except Exception as e:
        logger.exception(f&#34;Unexpected error reading data with format &#39;{format_type}&#39;&#34;)
        # Wrap unexpected errors in ReadError for consistency?
        raise ReadError(
            &#34;Unexpected error during read&#34;,
            source=str(source),
            reader_type=format_type,
            original_error=e,
        ) from e</code></pre>
</details>
<div class="desc"><p>Reads data from a source using the specified format.</p>
<p>This function acts as a facade for the underlying reader implementations.
It uses the <code>format_type</code> to look up the appropriate reader class in the registry.
The <code>source</code> and <code>**kwargs</code> are combined and validated against the specific
reader's Pydantic configuration model (e.g., <code>CsvReaderConfig</code>).</p>
<p>The validated configuration is used to initialize the reader instance.
The <code>source</code> (which might be the original object for dict/dataframe formats, or
the validated string path/ticker otherwise) and the original <code>**kwargs</code> are then
passed to the reader instance's <code>.read()</code> method, which handles format-specific
read-time options.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The format identifier (e.g., 'excel', 'csv', 'fmp', 'dict').</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>Any</code></dt>
<dd>The data source. Its type depends on <code>format_type</code>:
- <code>str</code>: file path (for 'excel', 'csv'), ticker symbol (for 'fmp').
- <code>pd.DataFrame</code>: for 'dataframe'.
- <code>dict</code>: for 'dict'.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments used for reader configuration (e.g.,
<code>api_key</code>, <code>delimiter</code>, <code>sheet_name</code>, <code>mapping_config</code>) and potentially
passed to the reader's <code>.read()</code> method (e.g., <code>periods</code>). Consult the
specific reader's Pydantic config model and <code>.read()</code> docstring.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Graph</code></dt>
<dd>A new Graph object populated with the read data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ReadError</code></dt>
<dd>If reading fails.</dd>
<dt><code>FormatNotSupportedError</code></dt>
<dd>If the format_type is not registered.</dd>
<dt><code>Exception</code></dt>
<dd>Other errors during reader initialization or reading.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.register_reader"><code class="name flex">
<span>def <span class="ident">register_reader</span></span>(<span>format_type: str, *, schema: Type[pydantic.main.BaseModel] | None = None) ‑> Callable[[type[<a title="fin_statement_model.io.core.base.DataReader" href="base.html#fin_statement_model.io.core.base.DataReader">DataReader</a>]], type[<a title="fin_statement_model.io.core.base.DataReader" href="base.html#fin_statement_model.io.core.base.DataReader">DataReader</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_reader(
    format_type: str,
    *,
    schema: Type[BaseModel] | None = None,
) -&gt; Callable[[type[DataReader]], type[DataReader]]:
    &#34;&#34;&#34;Decorator to register a DataReader class for a specific format type.

    Args:
        format_type: The string identifier for the format (e.g., &#39;excel&#39;, &#39;csv&#39;).
        schema: Optional Pydantic schema class for configuration validation.

    Returns:
        A decorator function that registers the class and returns it unmodified.

    Raises:
        ValueError: If the format_type is already registered for a reader.
    &#34;&#34;&#34;
    # Require schema at registration time (legacy schema-less removed)
    if schema is None:
        raise ValueError(
            f&#34;Schema required for reader &#39;{format_type}&#39;; legacy schema-less mode removed.&#34;
        )
    return _reader_registry.register(format_type, schema=schema)</code></pre>
</details>
<div class="desc"><p>Decorator to register a DataReader class for a specific format type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The string identifier for the format (e.g., 'excel', 'csv').</dd>
<dt><strong><code>schema</code></strong></dt>
<dd>Optional Pydantic schema class for configuration validation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A decorator function that registers the class and returns it unmodified.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the format_type is already registered for a reader.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.register_writer"><code class="name flex">
<span>def <span class="ident">register_writer</span></span>(<span>format_type: str, *, schema: Type[pydantic.main.BaseModel] | None = None) ‑> Callable[[type[<a title="fin_statement_model.io.core.base.DataWriter" href="base.html#fin_statement_model.io.core.base.DataWriter">DataWriter</a>]], type[<a title="fin_statement_model.io.core.base.DataWriter" href="base.html#fin_statement_model.io.core.base.DataWriter">DataWriter</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_writer(
    format_type: str,
    *,
    schema: Type[BaseModel] | None = None,
) -&gt; Callable[[type[DataWriter]], type[DataWriter]]:
    &#34;&#34;&#34;Decorator to register a DataWriter class for a specific format type.

    Args:
        format_type: The string identifier for the format (e.g., &#39;excel&#39;, &#39;json&#39;).
        schema: Optional Pydantic schema class for configuration validation.

    Returns:
        A decorator function that registers the class and returns it unmodified.

    Raises:
        ValueError: If the format_type is already registered for a writer.
    &#34;&#34;&#34;
    # Require schema at registration time (legacy schema-less removed)
    if schema is None:
        raise ValueError(
            f&#34;Schema required for writer &#39;{format_type}&#39;; legacy schema-less mode removed.&#34;
        )
    return _writer_registry.register(format_type, schema=schema)</code></pre>
</details>
<div class="desc"><p>Decorator to register a DataWriter class for a specific format type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The string identifier for the format (e.g., 'excel', 'json').</dd>
<dt><strong><code>schema</code></strong></dt>
<dd>Optional Pydantic schema class for configuration validation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A decorator function that registers the class and returns it unmodified.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the format_type is already registered for a writer.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.write_data"><code class="name flex">
<span>def <span class="ident">write_data</span></span>(<span>format_type: str,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>target: Any,<br>**kwargs: dict[str, str | int | float | bool]) ‑> object</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_data(
    format_type: str,
    graph: Graph,
    target: Any,
    **kwargs: dict[str, Union[str, int, float, bool]],
) -&gt; object:
    &#34;&#34;&#34;Writes graph data to a target using the specified format.

    Similar to `read_data`, this acts as a facade for writer implementations.
    It uses `format_type` to find the writer class in the registry.
    The `target` and `**kwargs` are combined and validated against the specific
    writer&#39;s Pydantic configuration model (e.g., `ExcelWriterConfig`).

    The validated configuration initializes the writer instance.
    The original `graph`, `target`, and `**kwargs` are then passed to the writer
    instance&#39;s `.write()` method for format-specific write-time options.

    Args:
        format_type (str): The format identifier (e.g., &#39;excel&#39;, &#39;dataframe&#39;, &#39;dict&#39;).
        graph (Graph): The graph object containing data to write.
        target (Any): The destination target. Its type depends on `format_type`:
            - `str`: file path (usually required for file-based writers like &#39;excel&#39;).
            - Ignored: for writers that return objects (like &#39;dataframe&#39;, &#39;dict&#39;).
        **kwargs: Additional keyword arguments used for writer configuration (e.g.,
            `sheet_name`, `recalculate`) and potentially passed to the writer&#39;s
            `.write()` method. Consult the specific writer&#39;s Pydantic config model
            and `.write()` docstring.

    Returns:
        object: The result of the write operation. For writers like DataFrameWriter
                or DictWriter, this is the created object. For file writers, it&#39;s None.

    Raises:
        WriteError: If writing fails.
        FormatNotSupportedError: If the format_type is not registered.
        Exception: Other errors during writer initialization or writing.
    &#34;&#34;&#34;
    logger.info(
        f&#34;Attempting to write graph data using format &#39;{format_type}&#39; to target type &#39;{type(target).__name__}&#39;&#34;
    )

    # Prepare kwargs for registry validation (includes target and format_type)
    config_kwargs = {**kwargs, &#34;target&#34;: target, &#34;format_type&#34;: format_type}

    # Pass the config kwargs directly to get_writer
    writer = get_writer(**config_kwargs)
    # Now call write with all writer-specific kwargs
    try:
        # Pass original graph, target, and non-config kwargs to write()
        result = writer.write(graph, target, **kwargs)

        # If the writer returns a string and target is a path, write it to the file.
        if isinstance(result, str) and isinstance(target, str):
            try:
                # Ensure target directory exists
                dir_path = os.path.dirname(target)
                if dir_path:
                    os.makedirs(dir_path, exist_ok=True)
                logger.debug(
                    f&#34;Writing string result from writer &#39;{type(writer).__name__}&#39; to file: {target}&#34;
                )
                with open(target, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
                    f.write(result)
                return None  # Consistent return for file writers
            except OSError as e:
                logger.exception(
                    f&#34;Failed to write writer output to target file: {target}&#34;
                )
                raise WriteError(
                    f&#34;Failed to write writer output to file: {target}&#34;,
                    target=target,
                    writer_type=format_type,
                    original_error=e,
                ) from e
        else:
            # Otherwise, return the original result (e.g., DataFrame, dict)
            return result
    except (IOError, FormatNotSupportedError):
        logger.exception(&#34;IO Error writing data&#34;)
        raise  # Re-raise specific IO errors
    except Exception as e:
        logger.exception(f&#34;Unexpected error writing data with format &#39;{format_type}&#39;&#34;)
        # Wrap unexpected errors
        raise WriteError(
            &#34;Unexpected error during write&#34;,
            target=str(target),
            writer_type=format_type,
            original_error=e,
        ) from e</code></pre>
</details>
<div class="desc"><p>Writes graph data to a target using the specified format.</p>
<p>Similar to <code><a title="fin_statement_model.io.core.read_data" href="#fin_statement_model.io.core.read_data">read_data()</a></code>, this acts as a facade for writer implementations.
It uses <code>format_type</code> to find the writer class in the registry.
The <code>target</code> and <code>**kwargs</code> are combined and validated against the specific
writer's Pydantic configuration model (e.g., <code>ExcelWriterConfig</code>).</p>
<p>The validated configuration initializes the writer instance.
The original <code>graph</code>, <code>target</code>, and <code>**kwargs</code> are then passed to the writer
instance's <code>.write()</code> method for format-specific write-time options.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The format identifier (e.g., 'excel', 'dataframe', 'dict').</dd>
<dt><strong><code>graph</code></strong> :&ensp;<code>Graph</code></dt>
<dd>The graph object containing data to write.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>Any</code></dt>
<dd>The destination target. Its type depends on <code>format_type</code>:
- <code>str</code>: file path (usually required for file-based writers like 'excel').
- Ignored: for writers that return objects (like 'dataframe', 'dict').</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments used for writer configuration (e.g.,
<code>sheet_name</code>, <code>recalculate</code>) and potentially passed to the writer's
<code>.write()</code> method. Consult the specific writer's Pydantic config model
and <code>.write()</code> docstring.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The result of the write operation. For writers like DataFrameWriter
or DictWriter, this is the created object. For file writers, it's None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>WriteError</code></dt>
<dd>If writing fails.</dd>
<dt><code>FormatNotSupportedError</code></dt>
<dd>If the format_type is not registered.</dd>
<dt><code>Exception</code></dt>
<dd>Other errors during writer initialization or writing.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.io.core.ConfigurationMixin"><code class="flex name class">
<span>class <span class="ident">ConfigurationMixin</span></span>
<span>(</span><span>*args: Any, **kwargs: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationMixin:
    &#34;&#34;&#34;Enhanced mixin for readers that use configuration objects.

    Provides comprehensive configuration management including:
    - Safe configuration value access with defaults
    - Configuration validation and type checking
    - Configuration inheritance and merging
    - Environment variable integration
    - Configuration context tracking
    &#34;&#34;&#34;

    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Initialize configuration mixin.&#34;&#34;&#34;
        super().__init__(*args, **kwargs)
        self._config_context: dict[str, Any] = {}
        self._config_overrides: dict[str, Any] = {}

    def set_config_context(self, **context: Any) -&gt; None:
        &#34;&#34;&#34;Set configuration context for enhanced error reporting.

        Args:
            **context: Key-value pairs to store as configuration context.
        &#34;&#34;&#34;
        self._config_context.update(context)

    def get_config_context(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get current configuration context.

        Returns:
            Dictionary containing current configuration context.
        &#34;&#34;&#34;
        return self._config_context.copy()

    def set_config_override(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Set a configuration override for runtime customization.

        Args:
            key: Configuration key to override.
            value: Override value.
        &#34;&#34;&#34;
        self._config_overrides[key] = value

    def clear_config_overrides(self) -&gt; None:
        &#34;&#34;&#34;Clear all configuration overrides.&#34;&#34;&#34;
        self._config_overrides.clear()

    def get_config_value(
        self,
        key: str,
        default: Any = None,
        required: bool = False,
        value_type: Optional[type] = None,
        validator: Optional[Callable[[Any], bool]] = None,
    ) -&gt; Any:
        &#34;&#34;&#34;Get a configuration value with comprehensive validation and fallback.

        Args:
            key: Configuration key to retrieve.
            default: Default value if key is not found.
            required: Whether the configuration value is required.
            value_type: Expected type for the configuration value.
            validator: Optional validation function that takes the value and returns bool.

        Returns:
            Configuration value, override, or default.

        Raises:
            ReadError: If required value is missing or validation fails.
        &#34;&#34;&#34;
        # Check for runtime overrides first
        if key in self._config_overrides:
            value = self._config_overrides[key]
        # Then check configuration object
        elif hasattr(self, &#34;cfg&#34;) and self.cfg:
            value = getattr(self.cfg, key, default)
        else:
            value = default

        # Handle required values
        if required and value is None:
            raise ReadError(
                f&#34;Required configuration value &#39;{key}&#39; is missing&#34;,
                reader_type=self.__class__.__name__,
            )

        # Type validation
        if (
            value is not None
            and value_type is not None
            and not isinstance(value, value_type)
        ):
            try:
                # Attempt type conversion
                value = value_type(value)
            except (ValueError, TypeError) as e:
                raise ReadError(
                    f&#34;Configuration value &#39;{key}&#39; has invalid type. &#34;
                    f&#34;Expected {value_type.__name__}, got {type(value).__name__}&#34;,
                    reader_type=self.__class__.__name__,
                    original_error=e,
                )

        # Custom validation
        if value is not None and validator is not None:
            try:
                if not validator(value):
                    raise ReadError(
                        f&#34;Configuration value &#39;{key}&#39; failed validation&#34;,
                        reader_type=self.__class__.__name__,
                    )
            except Exception as e:
                raise ReadError(
                    f&#34;Configuration validation error for &#39;{key}&#39;: {e}&#34;,
                    reader_type=self.__class__.__name__,
                    original_error=e,
                )

        return value

    def require_config_value(
        self,
        key: str,
        value_type: Optional[type] = None,
        validator: Optional[Callable[[Any], bool]] = None,
    ) -&gt; Any:
        &#34;&#34;&#34;Get a required configuration value with validation.

        Args:
            key: Configuration key to retrieve.
            value_type: Expected type for the configuration value.
            validator: Optional validation function.

        Returns:
            Configuration value.

        Raises:
            ReadError: If the configuration value is missing or invalid.
        &#34;&#34;&#34;
        return self.get_config_value(
            key, required=True, value_type=value_type, validator=validator
        )

    def get_config_with_env_fallback(
        self,
        key: str,
        env_var: str,
        default: Any = None,
        value_type: Optional[type] = None,
    ) -&gt; Any:
        &#34;&#34;&#34;Get configuration value with environment variable fallback.

        Args:
            key: Configuration key to retrieve.
            env_var: Environment variable name to check as fallback.
            default: Default value if neither config nor env var is found.
            value_type: Expected type for the value.

        Returns:
            Configuration value, environment variable value, or default.
        &#34;&#34;&#34;
        import os

        # First try configuration
        value = self.get_config_value(key)

        # If not found, try environment variable
        if value is None:
            env_value = os.getenv(env_var)
            if env_value is not None:
                value = env_value

        # Use default if still None
        if value is None:
            value = default

        # Type conversion if needed
        if (
            value is not None
            and value_type is not None
            and not isinstance(value, value_type)
        ):
            try:
                value = value_type(value)
            except (ValueError, TypeError):
                logger.warning(
                    f&#34;Failed to convert {key} value &#39;{value}&#39; to {value_type.__name__}, using as-is&#34;
                )

        return value

    def validate_configuration(self) -&gt; &#34;ValidationResultCollector&#34;:
        &#34;&#34;&#34;Validate the entire configuration object.

        Returns:
            ValidationResultCollector with validation results.
        &#34;&#34;&#34;
        validator = ValidationResultCollector(context=self._config_context)

        if not hasattr(self, &#34;cfg&#34;) or not self.cfg:
            validator.add_result(
                &#34;configuration&#34;, False, &#34;Missing configuration object&#34;, &#34;structure&#34;
            )
            return validator

        # Validate configuration object using Pydantic if available
        try:
            if hasattr(self.cfg, &#34;model_validate&#34;):
                # It&#39;s a Pydantic model, validation already happened during creation
                validator.add_result(
                    &#34;configuration&#34;, True, &#34;Configuration object is valid&#34;, &#34;structure&#34;
                )
            else:
                validator.add_result(
                    &#34;configuration&#34;,
                    True,
                    &#34;Configuration object exists (non-Pydantic)&#34;,
                    &#34;structure&#34;,
                )
        except Exception as e:
            validator.add_result(
                &#34;configuration&#34;,
                False,
                f&#34;Configuration validation failed: {e}&#34;,
                &#34;validation&#34;,
            )

        return validator

    def get_effective_configuration(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get the effective configuration including overrides.

        Returns:
            Dictionary containing all configuration values with overrides applied.
        &#34;&#34;&#34;
        config_dict = {}

        # Start with base configuration
        if hasattr(self, &#34;cfg&#34;) and self.cfg:
            if hasattr(self.cfg, &#34;model_dump&#34;):
                # Pydantic model
                config_dict = self.cfg.model_dump()
            elif hasattr(self.cfg, &#34;__dict__&#34;):
                # Regular object
                config_dict = vars(self.cfg).copy()

        # Apply overrides
        config_dict.update(self._config_overrides)

        return config_dict

    def merge_configurations(self, *configs: Any) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Merge multiple configuration objects with precedence.

        Args:
            *configs: Configuration objects to merge (later ones take precedence).

        Returns:
            Merged configuration dictionary.
        &#34;&#34;&#34;
        merged = {}

        for config in configs:
            if config is None:
                continue

            if hasattr(config, &#34;model_dump&#34;):
                # Pydantic model
                config_dict = config.model_dump()
            elif hasattr(config, &#34;__dict__&#34;):
                # Regular object
                config_dict = vars(config).copy()
            elif isinstance(config, dict):
                # Dictionary
                config_dict = config.copy()
            else:
                logger.warning(f&#34;Unsupported configuration type: {type(config)}&#34;)
                continue

            merged.update(config_dict)

        return merged</code></pre>
</details>
<div class="desc"><p>Enhanced mixin for readers that use configuration objects.</p>
<p>Provides comprehensive configuration management including:
- Safe configuration value access with defaults
- Configuration validation and type checking
- Configuration inheritance and merging
- Environment variable integration
- Configuration context tracking</p>
<p>Initialize configuration mixin.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.formats.api.fmp.FmpReader" href="../formats/api/fmp.html#fin_statement_model.io.formats.api.fmp.FmpReader">FmpReader</a></li>
<li><a title="fin_statement_model.io.formats.csv.reader.CsvReader" href="../formats/csv/reader.html#fin_statement_model.io.formats.csv.reader.CsvReader">CsvReader</a></li>
<li><a title="fin_statement_model.io.formats.dataframe.writer.DataFrameWriter" href="../formats/dataframe/writer.html#fin_statement_model.io.formats.dataframe.writer.DataFrameWriter">DataFrameWriter</a></li>
<li><a title="fin_statement_model.io.formats.dict.writer.DictWriter" href="../formats/dict/writer.html#fin_statement_model.io.formats.dict.writer.DictWriter">DictWriter</a></li>
<li><a title="fin_statement_model.io.formats.excel.reader.ExcelReader" href="../formats/excel/reader.html#fin_statement_model.io.formats.excel.reader.ExcelReader">ExcelReader</a></li>
<li><a title="fin_statement_model.io.formats.excel.writer.ExcelWriter" href="../formats/excel/writer.html#fin_statement_model.io.formats.excel.writer.ExcelWriter">ExcelWriter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.ConfigurationMixin.clear_config_overrides"><code class="name flex">
<span>def <span class="ident">clear_config_overrides</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_config_overrides(self) -&gt; None:
    &#34;&#34;&#34;Clear all configuration overrides.&#34;&#34;&#34;
    self._config_overrides.clear()</code></pre>
</details>
<div class="desc"><p>Clear all configuration overrides.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.get_config_context"><code class="name flex">
<span>def <span class="ident">get_config_context</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config_context(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get current configuration context.

    Returns:
        Dictionary containing current configuration context.
    &#34;&#34;&#34;
    return self._config_context.copy()</code></pre>
</details>
<div class="desc"><p>Get current configuration context.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing current configuration context.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.get_config_value"><code class="name flex">
<span>def <span class="ident">get_config_value</span></span>(<span>self,<br>key: str,<br>default: Any = None,<br>required: bool = False,<br>value_type: type | None = None,<br>validator: Callable[[typing.Any], bool] | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config_value(
    self,
    key: str,
    default: Any = None,
    required: bool = False,
    value_type: Optional[type] = None,
    validator: Optional[Callable[[Any], bool]] = None,
) -&gt; Any:
    &#34;&#34;&#34;Get a configuration value with comprehensive validation and fallback.

    Args:
        key: Configuration key to retrieve.
        default: Default value if key is not found.
        required: Whether the configuration value is required.
        value_type: Expected type for the configuration value.
        validator: Optional validation function that takes the value and returns bool.

    Returns:
        Configuration value, override, or default.

    Raises:
        ReadError: If required value is missing or validation fails.
    &#34;&#34;&#34;
    # Check for runtime overrides first
    if key in self._config_overrides:
        value = self._config_overrides[key]
    # Then check configuration object
    elif hasattr(self, &#34;cfg&#34;) and self.cfg:
        value = getattr(self.cfg, key, default)
    else:
        value = default

    # Handle required values
    if required and value is None:
        raise ReadError(
            f&#34;Required configuration value &#39;{key}&#39; is missing&#34;,
            reader_type=self.__class__.__name__,
        )

    # Type validation
    if (
        value is not None
        and value_type is not None
        and not isinstance(value, value_type)
    ):
        try:
            # Attempt type conversion
            value = value_type(value)
        except (ValueError, TypeError) as e:
            raise ReadError(
                f&#34;Configuration value &#39;{key}&#39; has invalid type. &#34;
                f&#34;Expected {value_type.__name__}, got {type(value).__name__}&#34;,
                reader_type=self.__class__.__name__,
                original_error=e,
            )

    # Custom validation
    if value is not None and validator is not None:
        try:
            if not validator(value):
                raise ReadError(
                    f&#34;Configuration value &#39;{key}&#39; failed validation&#34;,
                    reader_type=self.__class__.__name__,
                )
        except Exception as e:
            raise ReadError(
                f&#34;Configuration validation error for &#39;{key}&#39;: {e}&#34;,
                reader_type=self.__class__.__name__,
                original_error=e,
            )

    return value</code></pre>
</details>
<div class="desc"><p>Get a configuration value with comprehensive validation and fallback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>Configuration key to retrieve.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>Default value if key is not found.</dd>
<dt><strong><code>required</code></strong></dt>
<dd>Whether the configuration value is required.</dd>
<dt><strong><code>value_type</code></strong></dt>
<dd>Expected type for the configuration value.</dd>
<dt><strong><code>validator</code></strong></dt>
<dd>Optional validation function that takes the value and returns bool.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Configuration value, override, or default.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ReadError</code></dt>
<dd>If required value is missing or validation fails.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.get_config_with_env_fallback"><code class="name flex">
<span>def <span class="ident">get_config_with_env_fallback</span></span>(<span>self, key: str, env_var: str, default: Any = None, value_type: type | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config_with_env_fallback(
    self,
    key: str,
    env_var: str,
    default: Any = None,
    value_type: Optional[type] = None,
) -&gt; Any:
    &#34;&#34;&#34;Get configuration value with environment variable fallback.

    Args:
        key: Configuration key to retrieve.
        env_var: Environment variable name to check as fallback.
        default: Default value if neither config nor env var is found.
        value_type: Expected type for the value.

    Returns:
        Configuration value, environment variable value, or default.
    &#34;&#34;&#34;
    import os

    # First try configuration
    value = self.get_config_value(key)

    # If not found, try environment variable
    if value is None:
        env_value = os.getenv(env_var)
        if env_value is not None:
            value = env_value

    # Use default if still None
    if value is None:
        value = default

    # Type conversion if needed
    if (
        value is not None
        and value_type is not None
        and not isinstance(value, value_type)
    ):
        try:
            value = value_type(value)
        except (ValueError, TypeError):
            logger.warning(
                f&#34;Failed to convert {key} value &#39;{value}&#39; to {value_type.__name__}, using as-is&#34;
            )

    return value</code></pre>
</details>
<div class="desc"><p>Get configuration value with environment variable fallback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>Configuration key to retrieve.</dd>
<dt><strong><code>env_var</code></strong></dt>
<dd>Environment variable name to check as fallback.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>Default value if neither config nor env var is found.</dd>
<dt><strong><code>value_type</code></strong></dt>
<dd>Expected type for the value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Configuration value, environment variable value, or default.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.get_effective_configuration"><code class="name flex">
<span>def <span class="ident">get_effective_configuration</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_effective_configuration(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get the effective configuration including overrides.

    Returns:
        Dictionary containing all configuration values with overrides applied.
    &#34;&#34;&#34;
    config_dict = {}

    # Start with base configuration
    if hasattr(self, &#34;cfg&#34;) and self.cfg:
        if hasattr(self.cfg, &#34;model_dump&#34;):
            # Pydantic model
            config_dict = self.cfg.model_dump()
        elif hasattr(self.cfg, &#34;__dict__&#34;):
            # Regular object
            config_dict = vars(self.cfg).copy()

    # Apply overrides
    config_dict.update(self._config_overrides)

    return config_dict</code></pre>
</details>
<div class="desc"><p>Get the effective configuration including overrides.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing all configuration values with overrides applied.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.merge_configurations"><code class="name flex">
<span>def <span class="ident">merge_configurations</span></span>(<span>self, *configs: Any) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_configurations(self, *configs: Any) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Merge multiple configuration objects with precedence.

    Args:
        *configs: Configuration objects to merge (later ones take precedence).

    Returns:
        Merged configuration dictionary.
    &#34;&#34;&#34;
    merged = {}

    for config in configs:
        if config is None:
            continue

        if hasattr(config, &#34;model_dump&#34;):
            # Pydantic model
            config_dict = config.model_dump()
        elif hasattr(config, &#34;__dict__&#34;):
            # Regular object
            config_dict = vars(config).copy()
        elif isinstance(config, dict):
            # Dictionary
            config_dict = config.copy()
        else:
            logger.warning(f&#34;Unsupported configuration type: {type(config)}&#34;)
            continue

        merged.update(config_dict)

    return merged</code></pre>
</details>
<div class="desc"><p>Merge multiple configuration objects with precedence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*configs</code></strong></dt>
<dd>Configuration objects to merge (later ones take precedence).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Merged configuration dictionary.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.require_config_value"><code class="name flex">
<span>def <span class="ident">require_config_value</span></span>(<span>self,<br>key: str,<br>value_type: type | None = None,<br>validator: Callable[[typing.Any], bool] | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def require_config_value(
    self,
    key: str,
    value_type: Optional[type] = None,
    validator: Optional[Callable[[Any], bool]] = None,
) -&gt; Any:
    &#34;&#34;&#34;Get a required configuration value with validation.

    Args:
        key: Configuration key to retrieve.
        value_type: Expected type for the configuration value.
        validator: Optional validation function.

    Returns:
        Configuration value.

    Raises:
        ReadError: If the configuration value is missing or invalid.
    &#34;&#34;&#34;
    return self.get_config_value(
        key, required=True, value_type=value_type, validator=validator
    )</code></pre>
</details>
<div class="desc"><p>Get a required configuration value with validation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>Configuration key to retrieve.</dd>
<dt><strong><code>value_type</code></strong></dt>
<dd>Expected type for the configuration value.</dd>
<dt><strong><code>validator</code></strong></dt>
<dd>Optional validation function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Configuration value.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ReadError</code></dt>
<dd>If the configuration value is missing or invalid.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.set_config_context"><code class="name flex">
<span>def <span class="ident">set_config_context</span></span>(<span>self, **context: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_config_context(self, **context: Any) -&gt; None:
    &#34;&#34;&#34;Set configuration context for enhanced error reporting.

    Args:
        **context: Key-value pairs to store as configuration context.
    &#34;&#34;&#34;
    self._config_context.update(context)</code></pre>
</details>
<div class="desc"><p>Set configuration context for enhanced error reporting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**context</code></strong></dt>
<dd>Key-value pairs to store as configuration context.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.set_config_override"><code class="name flex">
<span>def <span class="ident">set_config_override</span></span>(<span>self, key: str, value: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_config_override(self, key: str, value: Any) -&gt; None:
    &#34;&#34;&#34;Set a configuration override for runtime customization.

    Args:
        key: Configuration key to override.
        value: Override value.
    &#34;&#34;&#34;
    self._config_overrides[key] = value</code></pre>
</details>
<div class="desc"><p>Set a configuration override for runtime customization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>Configuration key to override.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Override value.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.ConfigurationMixin.validate_configuration"><code class="name flex">
<span>def <span class="ident">validate_configuration</span></span>(<span>self) ‑> <a title="fin_statement_model.io.core.mixins.ValidationResultCollector" href="mixins.html#fin_statement_model.io.core.mixins.ValidationResultCollector">ValidationResultCollector</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_configuration(self) -&gt; &#34;ValidationResultCollector&#34;:
    &#34;&#34;&#34;Validate the entire configuration object.

    Returns:
        ValidationResultCollector with validation results.
    &#34;&#34;&#34;
    validator = ValidationResultCollector(context=self._config_context)

    if not hasattr(self, &#34;cfg&#34;) or not self.cfg:
        validator.add_result(
            &#34;configuration&#34;, False, &#34;Missing configuration object&#34;, &#34;structure&#34;
        )
        return validator

    # Validate configuration object using Pydantic if available
    try:
        if hasattr(self.cfg, &#34;model_validate&#34;):
            # It&#39;s a Pydantic model, validation already happened during creation
            validator.add_result(
                &#34;configuration&#34;, True, &#34;Configuration object is valid&#34;, &#34;structure&#34;
            )
        else:
            validator.add_result(
                &#34;configuration&#34;,
                True,
                &#34;Configuration object exists (non-Pydantic)&#34;,
                &#34;structure&#34;,
            )
    except Exception as e:
        validator.add_result(
            &#34;configuration&#34;,
            False,
            f&#34;Configuration validation failed: {e}&#34;,
            &#34;validation&#34;,
        )

    return validator</code></pre>
</details>
<div class="desc"><p>Validate the entire configuration object.</p>
<h2 id="returns">Returns</h2>
<p>ValidationResultCollector with validation results.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.io.core.DataFrameBasedWriter"><code class="flex name class">
<span>class <span class="ident">DataFrameBasedWriter</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataFrameBasedWriter(ValueExtractionMixin):
    &#34;&#34;&#34;Base class for writers that convert to DataFrame format.

    This base class provides common functionality for writers that
    need to extract data from a graph into a tabular format.

    Note: Subclasses should apply the @handle_write_errors() decorator
    to their write() method implementation for consistent error handling.
    &#34;&#34;&#34;

    def extract_graph_data(
        self,
        graph: Graph,
        include_nodes: Optional[list[str]] = None,
        calculate: bool = True,
    ) -&gt; dict[str, dict[str, float]]:
        &#34;&#34;&#34;Extract data from graph nodes into a dictionary format.

        Args:
            graph: The graph to extract data from.
            include_nodes: Optional list of node names to include.
                          If None, includes all nodes.
            calculate: Whether to calculate values or just use stored values.

        Returns:
            Dictionary mapping node names to period-value dictionaries.
        &#34;&#34;&#34;
        import numpy as np

        periods = sorted(graph.periods) if graph.periods else []
        data: dict[str, dict[str, float]] = {}

        # Determine which nodes to process
        nodes_to_process = include_nodes if include_nodes else list(graph.nodes.keys())

        # Validate requested nodes exist
        if include_nodes:
            missing_nodes = [n for n in include_nodes if n not in graph.nodes]
            if missing_nodes:
                logger.warning(f&#34;Requested nodes not found in graph: {missing_nodes}&#34;)
                nodes_to_process = [n for n in include_nodes if n in graph.nodes]

        # Extract data for each node
        for node_id in nodes_to_process:
            node = graph.nodes[node_id]
            row: dict[str, float] = {}

            for period in periods:
                # Use the mixin&#39;s extract method for consistent value extraction
                value = self.extract_node_value(node, period, calculate=calculate)

                # Convert None to NaN for DataFrame compatibility
                if (
                    value is None
                    or not isinstance(value, int | float | np.number)
                    or not np.isfinite(value)
                ):
                    value = np.nan

                row[period] = float(value)

            data[node_id] = row

        return data

    @abstractmethod
    def write(self, graph: Graph, target: Any = None, **kwargs: Any) -&gt; Any:
        &#34;&#34;&#34;Write graph data to target.

        Subclasses must implement this method with their specific
        writing logic. It&#39;s recommended to apply the @handle_write_errors()
        decorator to the implementation.

        Args:
            graph: Graph containing data to write.
            target: Target for the output (file path, etc.).
            **kwargs: Additional writer-specific options.

        Returns:
            Writer-specific return value.
        &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Base class for writers that convert to DataFrame format.</p>
<p>This base class provides common functionality for writers that
need to extract data from a graph into a tabular format.</p>
<p>Note: Subclasses should apply the @handle_write_errors() decorator
to their write() method implementation for consistent error handling.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.core.mixins.ValueExtractionMixin" href="mixins.html#fin_statement_model.io.core.mixins.ValueExtractionMixin">ValueExtractionMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.formats.dataframe.writer.DataFrameWriter" href="../formats/dataframe/writer.html#fin_statement_model.io.formats.dataframe.writer.DataFrameWriter">DataFrameWriter</a></li>
<li><a title="fin_statement_model.io.formats.dict.writer.DictWriter" href="../formats/dict/writer.html#fin_statement_model.io.formats.dict.writer.DictWriter">DictWriter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.DataFrameBasedWriter.extract_graph_data"><code class="name flex">
<span>def <span class="ident">extract_graph_data</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>include_nodes: list[str] | None = None,<br>calculate: bool = True) ‑> dict[str, dict[str, float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_graph_data(
    self,
    graph: Graph,
    include_nodes: Optional[list[str]] = None,
    calculate: bool = True,
) -&gt; dict[str, dict[str, float]]:
    &#34;&#34;&#34;Extract data from graph nodes into a dictionary format.

    Args:
        graph: The graph to extract data from.
        include_nodes: Optional list of node names to include.
                      If None, includes all nodes.
        calculate: Whether to calculate values or just use stored values.

    Returns:
        Dictionary mapping node names to period-value dictionaries.
    &#34;&#34;&#34;
    import numpy as np

    periods = sorted(graph.periods) if graph.periods else []
    data: dict[str, dict[str, float]] = {}

    # Determine which nodes to process
    nodes_to_process = include_nodes if include_nodes else list(graph.nodes.keys())

    # Validate requested nodes exist
    if include_nodes:
        missing_nodes = [n for n in include_nodes if n not in graph.nodes]
        if missing_nodes:
            logger.warning(f&#34;Requested nodes not found in graph: {missing_nodes}&#34;)
            nodes_to_process = [n for n in include_nodes if n in graph.nodes]

    # Extract data for each node
    for node_id in nodes_to_process:
        node = graph.nodes[node_id]
        row: dict[str, float] = {}

        for period in periods:
            # Use the mixin&#39;s extract method for consistent value extraction
            value = self.extract_node_value(node, period, calculate=calculate)

            # Convert None to NaN for DataFrame compatibility
            if (
                value is None
                or not isinstance(value, int | float | np.number)
                or not np.isfinite(value)
            ):
                value = np.nan

            row[period] = float(value)

        data[node_id] = row

    return data</code></pre>
</details>
<div class="desc"><p>Extract data from graph nodes into a dictionary format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph to extract data from.</dd>
<dt><strong><code>include_nodes</code></strong></dt>
<dd>Optional list of node names to include.
If None, includes all nodes.</dd>
<dt><strong><code>calculate</code></strong></dt>
<dd>Whether to calculate values or just use stored values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping node names to period-value dictionaries.</p></div>
</dd>
<dt id="fin_statement_model.io.core.DataFrameBasedWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>target: Any = None,<br>**kwargs: Any) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, graph: Graph, target: Any = None, **kwargs: Any) -&gt; Any:
    &#34;&#34;&#34;Write graph data to target.

    Subclasses must implement this method with their specific
    writing logic. It&#39;s recommended to apply the @handle_write_errors()
    decorator to the implementation.

    Args:
        graph: Graph containing data to write.
        target: Target for the output (file path, etc.).
        **kwargs: Additional writer-specific options.

    Returns:
        Writer-specific return value.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Write graph data to target.</p>
<p>Subclasses must implement this method with their specific
writing logic. It's recommended to apply the @handle_write_errors()
decorator to the implementation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>Graph containing data to write.</dd>
<dt><strong><code>target</code></strong></dt>
<dd>Target for the output (file path, etc.).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional writer-specific options.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Writer-specific return value.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.io.core.mixins.ValueExtractionMixin" href="mixins.html#fin_statement_model.io.core.mixins.ValueExtractionMixin">ValueExtractionMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.io.core.mixins.ValueExtractionMixin.extract_node_value" href="mixins.html#fin_statement_model.io.core.mixins.ValueExtractionMixin.extract_node_value">extract_node_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.io.core.DataReader"><code class="flex name class">
<span>class <span class="ident">DataReader</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataReader(ABC):
    &#34;&#34;&#34;Abstract base class for all data readers.

    Defines the interface for classes that read data from various sources
    and typically populate or return a Graph object.
    &#34;&#34;&#34;

    @abstractmethod
    def read(self, source: Any, **kwargs: dict[str, Any]) -&gt; Graph:
        &#34;&#34;&#34;Read data from the specified source and return a Graph.

        Args:
            source: The data source. Type depends on the reader implementation
                (e.g., file path `str`, ticker `str`, `pd.DataFrame`, `dict`).
            **kwargs: Additional format-specific options for reading.

        Returns:
            A Graph object populated with the data from the source.

        Raises:
            ReadError: If an error occurs during the reading process.
            NotImplementedError: If the method is not implemented by a subclass.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Abstract base class for all data readers.</p>
<p>Defines the interface for classes that read data from various sources
and typically populate or return a Graph object.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.core.mixins.FileBasedReader" href="mixins.html#fin_statement_model.io.core.mixins.FileBasedReader">FileBasedReader</a></li>
<li><a title="fin_statement_model.io.formats.api.fmp.FmpReader" href="../formats/api/fmp.html#fin_statement_model.io.formats.api.fmp.FmpReader">FmpReader</a></li>
<li><a title="fin_statement_model.io.formats.dataframe.reader.DataFrameReader" href="../formats/dataframe/reader.html#fin_statement_model.io.formats.dataframe.reader.DataFrameReader">DataFrameReader</a></li>
<li><a title="fin_statement_model.io.formats.dict.reader.DictReader" href="../formats/dict/reader.html#fin_statement_model.io.formats.dict.reader.DictReader">DictReader</a></li>
<li><a title="fin_statement_model.io.specialized.graph.GraphDefinitionReader" href="../specialized/graph.html#fin_statement_model.io.specialized.graph.GraphDefinitionReader">GraphDefinitionReader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.DataReader.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, source: Any, **kwargs: dict[str, typing.Any]) ‑> <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(self, source: Any, **kwargs: dict[str, Any]) -&gt; Graph:
    &#34;&#34;&#34;Read data from the specified source and return a Graph.

    Args:
        source: The data source. Type depends on the reader implementation
            (e.g., file path `str`, ticker `str`, `pd.DataFrame`, `dict`).
        **kwargs: Additional format-specific options for reading.

    Returns:
        A Graph object populated with the data from the source.

    Raises:
        ReadError: If an error occurs during the reading process.
        NotImplementedError: If the method is not implemented by a subclass.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Read data from the specified source and return a Graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>The data source. Type depends on the reader implementation
(e.g., file path <code>str</code>, ticker <code>str</code>, <code>pd.DataFrame</code>, <code>dict</code>).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional format-specific options for reading.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Graph object populated with the data from the source.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ReadError</code></dt>
<dd>If an error occurs during the reading process.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>If the method is not implemented by a subclass.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.io.core.DataWriter"><code class="flex name class">
<span>class <span class="ident">DataWriter</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataWriter(ABC):
    &#34;&#34;&#34;Abstract base class for all data writers.

    Defines the interface for classes that write graph data to various targets.
    &#34;&#34;&#34;

    @abstractmethod
    def write(self, graph: Graph, target: Any, **kwargs: dict[str, Any]) -&gt; object:
        &#34;&#34;&#34;Write data from the Graph object to the specified target.

        Args:
            graph: The Graph object containing the data to write.
            target: The destination target. Type depends on the writer implementation
                (e.g., file path `str`, or ignored if the writer returns an object).
            **kwargs: Additional format-specific options for writing.

        Raises:
            WriteError: If an error occurs during the writing process.
            NotImplementedError: If the method is not implemented by a subclass.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Abstract base class for all data writers.</p>
<p>Defines the interface for classes that write graph data to various targets.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.formats.excel.writer.ExcelWriter" href="../formats/excel/writer.html#fin_statement_model.io.formats.excel.writer.ExcelWriter">ExcelWriter</a></li>
<li><a title="fin_statement_model.io.formats.markdown.writer.MarkdownWriter" href="../formats/markdown/writer.html#fin_statement_model.io.formats.markdown.writer.MarkdownWriter">MarkdownWriter</a></li>
<li><a title="fin_statement_model.io.specialized.graph.GraphDefinitionWriter" href="../specialized/graph.html#fin_statement_model.io.specialized.graph.GraphDefinitionWriter">GraphDefinitionWriter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.DataWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self,<br>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>target: Any,<br>**kwargs: dict[str, typing.Any]) ‑> object</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, graph: Graph, target: Any, **kwargs: dict[str, Any]) -&gt; object:
    &#34;&#34;&#34;Write data from the Graph object to the specified target.

    Args:
        graph: The Graph object containing the data to write.
        target: The destination target. Type depends on the writer implementation
            (e.g., file path `str`, or ignored if the writer returns an object).
        **kwargs: Additional format-specific options for writing.

    Raises:
        WriteError: If an error occurs during the writing process.
        NotImplementedError: If the method is not implemented by a subclass.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Write data from the Graph object to the specified target.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The Graph object containing the data to write.</dd>
<dt><strong><code>target</code></strong></dt>
<dd>The destination target. Type depends on the writer implementation
(e.g., file path <code>str</code>, or ignored if the writer returns an object).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional format-specific options for writing.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>WriteError</code></dt>
<dd>If an error occurs during the writing process.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>If the method is not implemented by a subclass.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.io.core.FileBasedReader"><code class="flex name class">
<span>class <span class="ident">FileBasedReader</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileBasedReader(DataReader):
    &#34;&#34;&#34;Base class for file-based readers with common validation.

    This class provides common file validation methods and ensures
    consistent error handling for all file-based readers.

    Note: Subclasses should apply the @handle_read_errors() decorator
    to their read() method implementation for consistent error handling.
    &#34;&#34;&#34;

    def validate_file_exists(self, path: str) -&gt; None:
        &#34;&#34;&#34;Validate that file exists.

        Args:
            path: Path to the file to validate.

        Raises:
            ReadError: If the file does not exist.
        &#34;&#34;&#34;
        if not os.path.exists(path):
            raise ReadError(
                f&#34;File not found: {path}&#34;,
                source=path,
                reader_type=self.__class__.__name__,
            )

    def validate_file_extension(
        self, path: str, valid_extensions: tuple[str, ...]
    ) -&gt; None:
        &#34;&#34;&#34;Validate file has correct extension.

        Args:
            path: Path to the file to validate.
            valid_extensions: Tuple of valid file extensions (e.g., (&#39;.csv&#39;, &#39;.txt&#39;)).

        Raises:
            ReadError: If the file extension is not valid.
        &#34;&#34;&#34;
        if not path.lower().endswith(valid_extensions):
            raise ReadError(
                f&#34;Invalid file extension. Expected one of {valid_extensions}, &#34;
                f&#34;got &#39;{os.path.splitext(path)[1]}&#39;&#34;,
                source=path,
                reader_type=self.__class__.__name__,
            )

    @abstractmethod
    def read(self, source: str, **kwargs: Any) -&gt; Graph:
        &#34;&#34;&#34;Read from file source.

        Subclasses must implement this method with their specific
        file reading logic. It&#39;s recommended to apply the @handle_read_errors()
        decorator to the implementation.

        Args:
            source: Path to the file to read.
            **kwargs: Additional reader-specific options.

        Returns:
            Graph populated with data from the file.
        &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Base class for file-based readers with common validation.</p>
<p>This class provides common file validation methods and ensures
consistent error handling for all file-based readers.</p>
<p>Note: Subclasses should apply the @handle_read_errors() decorator
to their read() method implementation for consistent error handling.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.core.base.DataReader" href="base.html#fin_statement_model.io.core.base.DataReader">DataReader</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.formats.csv.reader.CsvReader" href="../formats/csv/reader.html#fin_statement_model.io.formats.csv.reader.CsvReader">CsvReader</a></li>
<li><a title="fin_statement_model.io.formats.excel.reader.ExcelReader" href="../formats/excel/reader.html#fin_statement_model.io.formats.excel.reader.ExcelReader">ExcelReader</a></li>
<li><a title="fin_statement_model.io.specialized.adjustments.AdjustmentsExcelReader" href="../specialized/adjustments.html#fin_statement_model.io.specialized.adjustments.AdjustmentsExcelReader">AdjustmentsExcelReader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.FileBasedReader.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, source: str, **kwargs: Any) ‑> <a title="fin_statement_model.core.graph.graph.Graph" href="../../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(self, source: str, **kwargs: Any) -&gt; Graph:
    &#34;&#34;&#34;Read from file source.

    Subclasses must implement this method with their specific
    file reading logic. It&#39;s recommended to apply the @handle_read_errors()
    decorator to the implementation.

    Args:
        source: Path to the file to read.
        **kwargs: Additional reader-specific options.

    Returns:
        Graph populated with data from the file.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Read from file source.</p>
<p>Subclasses must implement this method with their specific
file reading logic. It's recommended to apply the @handle_read_errors()
decorator to the implementation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>Path to the file to read.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional reader-specific options.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Graph populated with data from the file.</p></div>
</dd>
<dt id="fin_statement_model.io.core.FileBasedReader.validate_file_exists"><code class="name flex">
<span>def <span class="ident">validate_file_exists</span></span>(<span>self, path: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_file_exists(self, path: str) -&gt; None:
    &#34;&#34;&#34;Validate that file exists.

    Args:
        path: Path to the file to validate.

    Raises:
        ReadError: If the file does not exist.
    &#34;&#34;&#34;
    if not os.path.exists(path):
        raise ReadError(
            f&#34;File not found: {path}&#34;,
            source=path,
            reader_type=self.__class__.__name__,
        )</code></pre>
</details>
<div class="desc"><p>Validate that file exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the file to validate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ReadError</code></dt>
<dd>If the file does not exist.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.FileBasedReader.validate_file_extension"><code class="name flex">
<span>def <span class="ident">validate_file_extension</span></span>(<span>self, path: str, valid_extensions: tuple[str, ...]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_file_extension(
    self, path: str, valid_extensions: tuple[str, ...]
) -&gt; None:
    &#34;&#34;&#34;Validate file has correct extension.

    Args:
        path: Path to the file to validate.
        valid_extensions: Tuple of valid file extensions (e.g., (&#39;.csv&#39;, &#39;.txt&#39;)).

    Raises:
        ReadError: If the file extension is not valid.
    &#34;&#34;&#34;
    if not path.lower().endswith(valid_extensions):
        raise ReadError(
            f&#34;Invalid file extension. Expected one of {valid_extensions}, &#34;
            f&#34;got &#39;{os.path.splitext(path)[1]}&#39;&#34;,
            source=path,
            reader_type=self.__class__.__name__,
        )</code></pre>
</details>
<div class="desc"><p>Validate file has correct extension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the file to validate.</dd>
<dt><strong><code>valid_extensions</code></strong></dt>
<dd>Tuple of valid file extensions (e.g., ('.csv', '.txt')).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ReadError</code></dt>
<dd>If the file extension is not valid.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry"><code class="flex name class">
<span>class <span class="ident">HandlerRegistry</span></span>
<span>(</span><span>handler_type: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HandlerRegistry(Generic[T]):
    &#34;&#34;&#34;Generic registry for managing format handlers (readers or writers).

    This class provides a reusable registry pattern for registering and
    retrieving handler classes by format type.

    Attributes:
        _registry: Internal dictionary mapping format types to handler classes.
        _handler_type: String describing the handler type (&#39;reader&#39; or &#39;writer&#39;).
        _schema_map: Internal dictionary mapping format types to Pydantic schema classes.
    &#34;&#34;&#34;

    def __init__(self, handler_type: str):
        &#34;&#34;&#34;Initialize the registry.

        Args:
            handler_type: Type of handlers (&#39;reader&#39; or &#39;writer&#39;) for error messages.
        &#34;&#34;&#34;
        self._registry: dict[str, type[T]] = {}
        self._handler_type = handler_type
        self._schema_map: dict[str, type[BaseModel]] = {}

    def register(
        self, format_type: str, *, schema: type[BaseModel] | None = None
    ) -&gt; Callable[[type[T]], type[T]]:
        &#34;&#34;&#34;Create a decorator to register a handler class for a format type.

        Args:
            format_type: The format identifier (e.g., &#39;excel&#39;, &#39;csv&#39;).
            schema: Optional Pydantic schema for the format.

        Returns:
            A decorator function that registers the class.

        Raises:
            ValueError: If the format is already registered to a different class.
        &#34;&#34;&#34;

        def decorator(cls: type[T]) -&gt; type[T]:
            if format_type in self._registry:
                # Allow re-registration of the same class (idempotent)
                if self._registry[format_type] is not cls:
                    raise ValueError(
                        f&#34;{self._handler_type.capitalize()} format type &#39;{format_type}&#39; &#34;
                        f&#34;already registered to {self._registry[format_type]}.&#34;
                    )
                logger.debug(
                    f&#34;Re-registering {self._handler_type} format type &#39;{format_type}&#39; &#34;
                    f&#34;to {cls.__name__}&#34;
                )
            else:
                logger.debug(
                    f&#34;Registering {self._handler_type} format type &#39;{format_type}&#39; &#34;
                    f&#34;to {cls.__name__}&#34;
                )

            self._registry[format_type] = cls
            if schema is not None:
                self._schema_map[format_type] = schema
            return cls

        return decorator

    def get(self, format_type: str) -&gt; type[T]:
        &#34;&#34;&#34;Get the registered handler class for a format type.

        Args:
            format_type: The format identifier.

        Returns:
            The registered handler class.

        Raises:
            FormatNotSupportedError: If no handler is registered for the format.
        &#34;&#34;&#34;
        if format_type not in self._registry:
            raise FormatNotSupportedError(
                format_type=format_type, operation=f&#34;{self._handler_type} operations&#34;
            )

        return self._registry[format_type]

    def list_formats(self) -&gt; dict[str, type[T]]:
        &#34;&#34;&#34;Return a copy of all registered format handlers.

        Returns:
            Dictionary mapping format types to handler classes.
        &#34;&#34;&#34;
        return self._registry.copy()

    def is_registered(self, format_type: str) -&gt; bool:
        &#34;&#34;&#34;Check if a format type is registered.

        Args:
            format_type: The format identifier to check.

        Returns:
            True if the format is registered, False otherwise.
        &#34;&#34;&#34;
        return format_type in self._registry

    def unregister(self, format_type: str) -&gt; Optional[type[T]]:
        &#34;&#34;&#34;Remove a format handler from the registry.

        This method is primarily useful for testing.

        Args:
            format_type: The format identifier to remove.

        Returns:
            The removed handler class, or None if not found.
        &#34;&#34;&#34;
        return self._registry.pop(format_type, None)

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear all registered handlers.

        This method is primarily useful for testing.
        &#34;&#34;&#34;
        self._registry.clear()

    def __contains__(self, format_type: str) -&gt; bool:
        &#34;&#34;&#34;Check if a format type is registered using &#39;in&#39; operator.

        Args:
            format_type: The format identifier to check.

        Returns:
            True if the format is registered, False otherwise.
        &#34;&#34;&#34;
        return format_type in self._registry

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of registered formats.

        Returns:
            Number of registered format handlers.
        &#34;&#34;&#34;
        return len(self._registry)

    def get_schema(self, format_type: str) -&gt; Optional[type[BaseModel]]:
        &#34;&#34;&#34;Return the Pydantic schema for a registered format type, if any.&#34;&#34;&#34;
        return self._schema_map.get(format_type)</code></pre>
</details>
<div class="desc"><p>Generic registry for managing format handlers (readers or writers).</p>
<p>This class provides a reusable registry pattern for registering and
retrieving handler classes by format type.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_registry</code></strong></dt>
<dd>Internal dictionary mapping format types to handler classes.</dd>
<dt><strong><code>_handler_type</code></strong></dt>
<dd>String describing the handler type ('reader' or 'writer').</dd>
<dt><strong><code>_schema_map</code></strong></dt>
<dd>Internal dictionary mapping format types to Pydantic schema classes.</dd>
</dl>
<p>Initialize the registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handler_type</code></strong></dt>
<dd>Type of handlers ('reader' or 'writer') for error messages.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.HandlerRegistry.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear all registered handlers.

    This method is primarily useful for testing.
    &#34;&#34;&#34;
    self._registry.clear()</code></pre>
</details>
<div class="desc"><p>Clear all registered handlers.</p>
<p>This method is primarily useful for testing.</p></div>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, format_type: str) ‑> type[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, format_type: str) -&gt; type[T]:
    &#34;&#34;&#34;Get the registered handler class for a format type.

    Args:
        format_type: The format identifier.

    Returns:
        The registered handler class.

    Raises:
        FormatNotSupportedError: If no handler is registered for the format.
    &#34;&#34;&#34;
    if format_type not in self._registry:
        raise FormatNotSupportedError(
            format_type=format_type, operation=f&#34;{self._handler_type} operations&#34;
        )

    return self._registry[format_type]</code></pre>
</details>
<div class="desc"><p>Get the registered handler class for a format type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The format identifier.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The registered handler class.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FormatNotSupportedError</code></dt>
<dd>If no handler is registered for the format.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry.get_schema"><code class="name flex">
<span>def <span class="ident">get_schema</span></span>(<span>self, format_type: str) ‑> type[pydantic.main.BaseModel] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schema(self, format_type: str) -&gt; Optional[type[BaseModel]]:
    &#34;&#34;&#34;Return the Pydantic schema for a registered format type, if any.&#34;&#34;&#34;
    return self._schema_map.get(format_type)</code></pre>
</details>
<div class="desc"><p>Return the Pydantic schema for a registered format type, if any.</p></div>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry.is_registered"><code class="name flex">
<span>def <span class="ident">is_registered</span></span>(<span>self, format_type: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_registered(self, format_type: str) -&gt; bool:
    &#34;&#34;&#34;Check if a format type is registered.

    Args:
        format_type: The format identifier to check.

    Returns:
        True if the format is registered, False otherwise.
    &#34;&#34;&#34;
    return format_type in self._registry</code></pre>
</details>
<div class="desc"><p>Check if a format type is registered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The format identifier to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the format is registered, False otherwise.</p></div>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry.list_formats"><code class="name flex">
<span>def <span class="ident">list_formats</span></span>(<span>self) ‑> dict[str, type[~T]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_formats(self) -&gt; dict[str, type[T]]:
    &#34;&#34;&#34;Return a copy of all registered format handlers.

    Returns:
        Dictionary mapping format types to handler classes.
    &#34;&#34;&#34;
    return self._registry.copy()</code></pre>
</details>
<div class="desc"><p>Return a copy of all registered format handlers.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping format types to handler classes.</p></div>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, format_type: str, *, schema: type[pydantic.main.BaseModel] | None = None) ‑> Callable[[type[~T]], type[~T]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(
    self, format_type: str, *, schema: type[BaseModel] | None = None
) -&gt; Callable[[type[T]], type[T]]:
    &#34;&#34;&#34;Create a decorator to register a handler class for a format type.

    Args:
        format_type: The format identifier (e.g., &#39;excel&#39;, &#39;csv&#39;).
        schema: Optional Pydantic schema for the format.

    Returns:
        A decorator function that registers the class.

    Raises:
        ValueError: If the format is already registered to a different class.
    &#34;&#34;&#34;

    def decorator(cls: type[T]) -&gt; type[T]:
        if format_type in self._registry:
            # Allow re-registration of the same class (idempotent)
            if self._registry[format_type] is not cls:
                raise ValueError(
                    f&#34;{self._handler_type.capitalize()} format type &#39;{format_type}&#39; &#34;
                    f&#34;already registered to {self._registry[format_type]}.&#34;
                )
            logger.debug(
                f&#34;Re-registering {self._handler_type} format type &#39;{format_type}&#39; &#34;
                f&#34;to {cls.__name__}&#34;
            )
        else:
            logger.debug(
                f&#34;Registering {self._handler_type} format type &#39;{format_type}&#39; &#34;
                f&#34;to {cls.__name__}&#34;
            )

        self._registry[format_type] = cls
        if schema is not None:
            self._schema_map[format_type] = schema
        return cls

    return decorator</code></pre>
</details>
<div class="desc"><p>Create a decorator to register a handler class for a format type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The format identifier (e.g., 'excel', 'csv').</dd>
<dt><strong><code>schema</code></strong></dt>
<dd>Optional Pydantic schema for the format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A decorator function that registers the class.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the format is already registered to a different class.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.HandlerRegistry.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, format_type: str) ‑> type[~T] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, format_type: str) -&gt; Optional[type[T]]:
    &#34;&#34;&#34;Remove a format handler from the registry.

    This method is primarily useful for testing.

    Args:
        format_type: The format identifier to remove.

    Returns:
        The removed handler class, or None if not found.
    &#34;&#34;&#34;
    return self._registry.pop(format_type, None)</code></pre>
</details>
<div class="desc"><p>Remove a format handler from the registry.</p>
<p>This method is primarily useful for testing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format_type</code></strong></dt>
<dd>The format identifier to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The removed handler class, or None if not found.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector"><code class="flex name class">
<span>class <span class="ident">ValidationResultCollector</span></span>
<span>(</span><span>context: dict[str, typing.Any] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidationResultCollector:
    &#34;&#34;&#34;Enhanced utility class for collecting and summarizing validation results.

    Useful for batch operations where you want to collect all validation
    results and report them together. Supports categorization, context tracking,
    and detailed metrics.
    &#34;&#34;&#34;

    def __init__(self, context: Optional[dict[str, Any]] = None):
        &#34;&#34;&#34;Initialize the validation result collector.

        Args:
            context: Optional context information for validation.
        &#34;&#34;&#34;
        self.results: list[
            tuple[str, bool, str, str]
        ] = []  # item, valid, message, category
        self.errors: list[str] = []
        self.warnings: list[str] = []
        self.context = context or {}
        self._categories: dict[str, int] = {}

    def add_result(
        self,
        item_name: str,
        is_valid: bool,
        message: str,
        category: str = &#34;general&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;Add a validation result with optional categorization.

        Args:
            item_name: Name/identifier of the item being validated.
            is_valid: Whether the validation passed.
            message: Validation message or error description.
            category: Category of validation (e.g., &#39;data_type&#39;, &#39;range&#39;, &#39;format&#39;).
        &#34;&#34;&#34;
        self.results.append((item_name, is_valid, message, category))

        # Track categories
        if category not in self._categories:
            self._categories[category] = 0
        if not is_valid:
            self._categories[category] += 1

        if not is_valid:
            self.errors.append(f&#34;{item_name}: {message}&#34;)
        elif &#34;warning&#34; in message.lower():
            self.warnings.append(f&#34;{item_name}: {message}&#34;)

    def add_warning(
        self, item_name: str, message: str, category: str = &#34;warning&#34;
    ) -&gt; None:
        &#34;&#34;&#34;Add a warning (non-blocking validation issue).

        Args:
            item_name: Name/identifier of the item.
            message: Warning message.
            category: Category of the warning.
        &#34;&#34;&#34;
        self.warnings.append(f&#34;{item_name}: {message}&#34;)
        self.results.append((item_name, True, f&#34;WARNING: {message}&#34;, category))

    def has_errors(self) -&gt; bool:
        &#34;&#34;&#34;Check if any errors were collected.&#34;&#34;&#34;
        return len(self.errors) &gt; 0

    def has_warnings(self) -&gt; bool:
        &#34;&#34;&#34;Check if any warnings were collected.&#34;&#34;&#34;
        return len(self.warnings) &gt; 0

    def get_error_count_by_category(self) -&gt; dict[str, int]:
        &#34;&#34;&#34;Get error counts grouped by category.

        Returns:
            Dictionary mapping category names to error counts.
        &#34;&#34;&#34;
        return self._categories.copy()

    def get_items_with_errors(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of item names that had validation errors.

        Returns:
            List of item names with errors.
        &#34;&#34;&#34;
        return [item for item, valid, _, _ in self.results if not valid]

    def get_summary(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get a comprehensive summary of all validation results.

        Returns:
            Dictionary containing validation metrics and summaries.
        &#34;&#34;&#34;
        total = len(self.results)
        valid = sum(1 for _, is_valid, _, _ in self.results if is_valid)

        # Calculate category-specific metrics
        category_summary = {}
        for category, error_count in self._categories.items():
            category_total = sum(1 for _, _, _, cat in self.results if cat == category)
            category_summary[category] = {
                &#34;total&#34;: category_total,
                &#34;errors&#34;: error_count,
                &#34;success_rate&#34;: (
                    (category_total - error_count) / category_total
                    if category_total &gt; 0
                    else 1.0
                ),
            }

        return {
            &#34;total&#34;: total,
            &#34;valid&#34;: valid,
            &#34;invalid&#34;: total - valid,
            &#34;errors&#34;: self.errors.copy(),
            &#34;warnings&#34;: self.warnings.copy(),
            &#34;error_rate&#34;: (total - valid) / total if total &gt; 0 else 0.0,
            &#34;warning_count&#34;: len(self.warnings),
            &#34;categories&#34;: category_summary,
            &#34;context&#34;: self.context.copy(),
            &#34;items_with_errors&#34;: self.get_items_with_errors(),
        }

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear all collected results.&#34;&#34;&#34;
        self.results.clear()
        self.errors.clear()
        self.warnings.clear()
        self._categories.clear()

    def merge(self, other: &#34;ValidationResultCollector&#34;) -&gt; None:
        &#34;&#34;&#34;Merge results from another collector.

        Args:
            other: Another ValidationResultCollector to merge from.
        &#34;&#34;&#34;
        for item, valid, message, category in other.results:
            self.add_result(item, valid, message, category)

    def get_detailed_report(self) -&gt; str:
        &#34;&#34;&#34;Generate a detailed text report of validation results.

        Returns:
            Formatted string report.
        &#34;&#34;&#34;
        summary = self.get_summary()

        report_lines = [
            &#34;=== Validation Report ===&#34;,
            f&#34;Total items processed: {summary[&#39;total&#39;]}&#34;,
            f&#34;Valid items: {summary[&#39;valid&#39;]}&#34;,
            f&#34;Invalid items: {summary[&#39;invalid&#39;]}&#34;,
            f&#34;Warnings: {summary[&#39;warning_count&#39;]}&#34;,
            f&#34;Overall success rate: {(1 - summary[&#39;error_rate&#39;]) * 100:.1f}%&#34;,
        ]

        if summary[&#34;categories&#34;]:
            report_lines.append(&#34;\n--- Category Breakdown ---&#34;)
            for category, stats in summary[&#34;categories&#34;].items():
                report_lines.append(
                    f&#34;{category}: {stats[&#39;total&#39;]} items, {stats[&#39;errors&#39;]} errors &#34;
                    f&#34;({stats[&#39;success_rate&#39;] * 100:.1f}% success)&#34;
                )

        if self.has_errors():
            report_lines.append(&#34;\n--- First 10 Errors ---&#34;)
            report_lines.extend(f&#34;  • {error}&#34; for error in self.errors[:10])
            if len(self.errors) &gt; 10:
                report_lines.append(f&#34;  ... and {len(self.errors) - 10} more errors&#34;)

        if self.has_warnings():
            report_lines.append(&#34;\n--- First 5 Warnings ---&#34;)
            report_lines.extend(f&#34;  • {warning}&#34; for warning in self.warnings[:5])
            if len(self.warnings) &gt; 5:
                report_lines.append(f&#34;  ... and {len(self.warnings) - 5} more warnings&#34;)

        return &#34;\n&#34;.join(report_lines)</code></pre>
</details>
<div class="desc"><p>Enhanced utility class for collecting and summarizing validation results.</p>
<p>Useful for batch operations where you want to collect all validation
results and report them together. Supports categorization, context tracking,
and detailed metrics.</p>
<p>Initialize the validation result collector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>Optional context information for validation.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.ValidationResultCollector.add_result"><code class="name flex">
<span>def <span class="ident">add_result</span></span>(<span>self, item_name: str, is_valid: bool, message: str, category: str = 'general') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_result(
    self,
    item_name: str,
    is_valid: bool,
    message: str,
    category: str = &#34;general&#34;,
) -&gt; None:
    &#34;&#34;&#34;Add a validation result with optional categorization.

    Args:
        item_name: Name/identifier of the item being validated.
        is_valid: Whether the validation passed.
        message: Validation message or error description.
        category: Category of validation (e.g., &#39;data_type&#39;, &#39;range&#39;, &#39;format&#39;).
    &#34;&#34;&#34;
    self.results.append((item_name, is_valid, message, category))

    # Track categories
    if category not in self._categories:
        self._categories[category] = 0
    if not is_valid:
        self._categories[category] += 1

    if not is_valid:
        self.errors.append(f&#34;{item_name}: {message}&#34;)
    elif &#34;warning&#34; in message.lower():
        self.warnings.append(f&#34;{item_name}: {message}&#34;)</code></pre>
</details>
<div class="desc"><p>Add a validation result with optional categorization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_name</code></strong></dt>
<dd>Name/identifier of the item being validated.</dd>
<dt><strong><code>is_valid</code></strong></dt>
<dd>Whether the validation passed.</dd>
<dt><strong><code>message</code></strong></dt>
<dd>Validation message or error description.</dd>
<dt><strong><code>category</code></strong></dt>
<dd>Category of validation (e.g., 'data_type', 'range', 'format').</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.add_warning"><code class="name flex">
<span>def <span class="ident">add_warning</span></span>(<span>self, item_name: str, message: str, category: str = 'warning') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_warning(
    self, item_name: str, message: str, category: str = &#34;warning&#34;
) -&gt; None:
    &#34;&#34;&#34;Add a warning (non-blocking validation issue).

    Args:
        item_name: Name/identifier of the item.
        message: Warning message.
        category: Category of the warning.
    &#34;&#34;&#34;
    self.warnings.append(f&#34;{item_name}: {message}&#34;)
    self.results.append((item_name, True, f&#34;WARNING: {message}&#34;, category))</code></pre>
</details>
<div class="desc"><p>Add a warning (non-blocking validation issue).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_name</code></strong></dt>
<dd>Name/identifier of the item.</dd>
<dt><strong><code>message</code></strong></dt>
<dd>Warning message.</dd>
<dt><strong><code>category</code></strong></dt>
<dd>Category of the warning.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear all collected results.&#34;&#34;&#34;
    self.results.clear()
    self.errors.clear()
    self.warnings.clear()
    self._categories.clear()</code></pre>
</details>
<div class="desc"><p>Clear all collected results.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.get_detailed_report"><code class="name flex">
<span>def <span class="ident">get_detailed_report</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_detailed_report(self) -&gt; str:
    &#34;&#34;&#34;Generate a detailed text report of validation results.

    Returns:
        Formatted string report.
    &#34;&#34;&#34;
    summary = self.get_summary()

    report_lines = [
        &#34;=== Validation Report ===&#34;,
        f&#34;Total items processed: {summary[&#39;total&#39;]}&#34;,
        f&#34;Valid items: {summary[&#39;valid&#39;]}&#34;,
        f&#34;Invalid items: {summary[&#39;invalid&#39;]}&#34;,
        f&#34;Warnings: {summary[&#39;warning_count&#39;]}&#34;,
        f&#34;Overall success rate: {(1 - summary[&#39;error_rate&#39;]) * 100:.1f}%&#34;,
    ]

    if summary[&#34;categories&#34;]:
        report_lines.append(&#34;\n--- Category Breakdown ---&#34;)
        for category, stats in summary[&#34;categories&#34;].items():
            report_lines.append(
                f&#34;{category}: {stats[&#39;total&#39;]} items, {stats[&#39;errors&#39;]} errors &#34;
                f&#34;({stats[&#39;success_rate&#39;] * 100:.1f}% success)&#34;
            )

    if self.has_errors():
        report_lines.append(&#34;\n--- First 10 Errors ---&#34;)
        report_lines.extend(f&#34;  • {error}&#34; for error in self.errors[:10])
        if len(self.errors) &gt; 10:
            report_lines.append(f&#34;  ... and {len(self.errors) - 10} more errors&#34;)

    if self.has_warnings():
        report_lines.append(&#34;\n--- First 5 Warnings ---&#34;)
        report_lines.extend(f&#34;  • {warning}&#34; for warning in self.warnings[:5])
        if len(self.warnings) &gt; 5:
            report_lines.append(f&#34;  ... and {len(self.warnings) - 5} more warnings&#34;)

    return &#34;\n&#34;.join(report_lines)</code></pre>
</details>
<div class="desc"><p>Generate a detailed text report of validation results.</p>
<h2 id="returns">Returns</h2>
<p>Formatted string report.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.get_error_count_by_category"><code class="name flex">
<span>def <span class="ident">get_error_count_by_category</span></span>(<span>self) ‑> dict[str, int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error_count_by_category(self) -&gt; dict[str, int]:
    &#34;&#34;&#34;Get error counts grouped by category.

    Returns:
        Dictionary mapping category names to error counts.
    &#34;&#34;&#34;
    return self._categories.copy()</code></pre>
</details>
<div class="desc"><p>Get error counts grouped by category.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping category names to error counts.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.get_items_with_errors"><code class="name flex">
<span>def <span class="ident">get_items_with_errors</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_items_with_errors(self) -&gt; list[str]:
    &#34;&#34;&#34;Get list of item names that had validation errors.

    Returns:
        List of item names with errors.
    &#34;&#34;&#34;
    return [item for item, valid, _, _ in self.results if not valid]</code></pre>
</details>
<div class="desc"><p>Get list of item names that had validation errors.</p>
<h2 id="returns">Returns</h2>
<p>List of item names with errors.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.get_summary"><code class="name flex">
<span>def <span class="ident">get_summary</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_summary(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get a comprehensive summary of all validation results.

    Returns:
        Dictionary containing validation metrics and summaries.
    &#34;&#34;&#34;
    total = len(self.results)
    valid = sum(1 for _, is_valid, _, _ in self.results if is_valid)

    # Calculate category-specific metrics
    category_summary = {}
    for category, error_count in self._categories.items():
        category_total = sum(1 for _, _, _, cat in self.results if cat == category)
        category_summary[category] = {
            &#34;total&#34;: category_total,
            &#34;errors&#34;: error_count,
            &#34;success_rate&#34;: (
                (category_total - error_count) / category_total
                if category_total &gt; 0
                else 1.0
            ),
        }

    return {
        &#34;total&#34;: total,
        &#34;valid&#34;: valid,
        &#34;invalid&#34;: total - valid,
        &#34;errors&#34;: self.errors.copy(),
        &#34;warnings&#34;: self.warnings.copy(),
        &#34;error_rate&#34;: (total - valid) / total if total &gt; 0 else 0.0,
        &#34;warning_count&#34;: len(self.warnings),
        &#34;categories&#34;: category_summary,
        &#34;context&#34;: self.context.copy(),
        &#34;items_with_errors&#34;: self.get_items_with_errors(),
    }</code></pre>
</details>
<div class="desc"><p>Get a comprehensive summary of all validation results.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing validation metrics and summaries.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.has_errors"><code class="name flex">
<span>def <span class="ident">has_errors</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_errors(self) -&gt; bool:
    &#34;&#34;&#34;Check if any errors were collected.&#34;&#34;&#34;
    return len(self.errors) &gt; 0</code></pre>
</details>
<div class="desc"><p>Check if any errors were collected.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.has_warnings"><code class="name flex">
<span>def <span class="ident">has_warnings</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_warnings(self) -&gt; bool:
    &#34;&#34;&#34;Check if any warnings were collected.&#34;&#34;&#34;
    return len(self.warnings) &gt; 0</code></pre>
</details>
<div class="desc"><p>Check if any warnings were collected.</p></div>
</dd>
<dt id="fin_statement_model.io.core.ValidationResultCollector.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self,<br>other: <a title="fin_statement_model.io.core.ValidationResultCollector" href="#fin_statement_model.io.core.ValidationResultCollector">ValidationResultCollector</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other: &#34;ValidationResultCollector&#34;) -&gt; None:
    &#34;&#34;&#34;Merge results from another collector.

    Args:
        other: Another ValidationResultCollector to merge from.
    &#34;&#34;&#34;
    for item, valid, message, category in other.results:
        self.add_result(item, valid, message, category)</code></pre>
</details>
<div class="desc"><p>Merge results from another collector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>Another ValidationResultCollector to merge from.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.io.core.ValueExtractionMixin"><code class="flex name class">
<span>class <span class="ident">ValueExtractionMixin</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueExtractionMixin:
    &#34;&#34;&#34;Mixin for consistent value extraction from nodes.

    This mixin provides a standardized way to extract values from nodes,
    handling both calculated values and stored values with proper error
    handling.
    &#34;&#34;&#34;

    def extract_node_value(
        self,
        node: Any,  # Avoid circular import with Node type
        period: str,
        calculate: bool = True,
    ) -&gt; Optional[float]:
        &#34;&#34;&#34;Extract value from node with consistent error handling.

        Args:
            node: The node to extract value from.
            period: The period to get the value for.
            calculate: If True, attempt to calculate the value using node.calculate().
                      If False, only look for stored values.

        Returns:
            The extracted value as a float, or None if no value could be extracted.
        &#34;&#34;&#34;
        try:
            # First try calculation if enabled and method exists
            if calculate and hasattr(node, &#34;calculate&#34;) and callable(node.calculate):
                value = node.calculate(period)
                if isinstance(value, int | float):
                    return float(value)

            # Fall back to stored values
            if hasattr(node, &#34;values&#34;) and isinstance(node.values, dict):
                value = node.values.get(period)
                if isinstance(value, int | float):
                    return float(value)

            return None

        except Exception as e:
            logger.debug(
                f&#34;Failed to extract value from node &#39;{getattr(node, &#39;name&#39;, &#39;unknown&#39;)}&#39; &#34;
                f&#34;for period &#39;{period}&#39;: {e}&#34;
            )
            return None</code></pre>
</details>
<div class="desc"><p>Mixin for consistent value extraction from nodes.</p>
<p>This mixin provides a standardized way to extract values from nodes,
handling both calculated values and stored values with proper error
handling.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.io.core.mixins.DataFrameBasedWriter" href="mixins.html#fin_statement_model.io.core.mixins.DataFrameBasedWriter">DataFrameBasedWriter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.io.core.ValueExtractionMixin.extract_node_value"><code class="name flex">
<span>def <span class="ident">extract_node_value</span></span>(<span>self, node: Any, period: str, calculate: bool = True) ‑> float | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_node_value(
    self,
    node: Any,  # Avoid circular import with Node type
    period: str,
    calculate: bool = True,
) -&gt; Optional[float]:
    &#34;&#34;&#34;Extract value from node with consistent error handling.

    Args:
        node: The node to extract value from.
        period: The period to get the value for.
        calculate: If True, attempt to calculate the value using node.calculate().
                  If False, only look for stored values.

    Returns:
        The extracted value as a float, or None if no value could be extracted.
    &#34;&#34;&#34;
    try:
        # First try calculation if enabled and method exists
        if calculate and hasattr(node, &#34;calculate&#34;) and callable(node.calculate):
            value = node.calculate(period)
            if isinstance(value, int | float):
                return float(value)

        # Fall back to stored values
        if hasattr(node, &#34;values&#34;) and isinstance(node.values, dict):
            value = node.values.get(period)
            if isinstance(value, int | float):
                return float(value)

        return None

    except Exception as e:
        logger.debug(
            f&#34;Failed to extract value from node &#39;{getattr(node, &#39;name&#39;, &#39;unknown&#39;)}&#39; &#34;
            f&#34;for period &#39;{period}&#39;: {e}&#34;
        )
        return None</code></pre>
</details>
<div class="desc"><p>Extract value from node with consistent error handling.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract value from.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The period to get the value for.</dd>
<dt><strong><code>calculate</code></strong></dt>
<dd>If True, attempt to calculate the value using node.calculate().
If False, only look for stored values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The extracted value as a float, or None if no value could be extracted.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.io" href="../index.html">fin_statement_model.io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.io.core.base" href="base.html">fin_statement_model.io.core.base</a></code></li>
<li><code><a title="fin_statement_model.io.core.facade" href="facade.html">fin_statement_model.io.core.facade</a></code></li>
<li><code><a title="fin_statement_model.io.core.mixins" href="mixins.html">fin_statement_model.io.core.mixins</a></code></li>
<li><code><a title="fin_statement_model.io.core.registry" href="registry.html">fin_statement_model.io.core.registry</a></code></li>
<li><code><a title="fin_statement_model.io.core.utils" href="utils.html">fin_statement_model.io.core.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="fin_statement_model.io.core.get_reader" href="#fin_statement_model.io.core.get_reader">get_reader</a></code></li>
<li><code><a title="fin_statement_model.io.core.get_writer" href="#fin_statement_model.io.core.get_writer">get_writer</a></code></li>
<li><code><a title="fin_statement_model.io.core.handle_read_errors" href="#fin_statement_model.io.core.handle_read_errors">handle_read_errors</a></code></li>
<li><code><a title="fin_statement_model.io.core.handle_write_errors" href="#fin_statement_model.io.core.handle_write_errors">handle_write_errors</a></code></li>
<li><code><a title="fin_statement_model.io.core.list_readers" href="#fin_statement_model.io.core.list_readers">list_readers</a></code></li>
<li><code><a title="fin_statement_model.io.core.list_writers" href="#fin_statement_model.io.core.list_writers">list_writers</a></code></li>
<li><code><a title="fin_statement_model.io.core.read_data" href="#fin_statement_model.io.core.read_data">read_data</a></code></li>
<li><code><a title="fin_statement_model.io.core.register_reader" href="#fin_statement_model.io.core.register_reader">register_reader</a></code></li>
<li><code><a title="fin_statement_model.io.core.register_writer" href="#fin_statement_model.io.core.register_writer">register_writer</a></code></li>
<li><code><a title="fin_statement_model.io.core.write_data" href="#fin_statement_model.io.core.write_data">write_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.io.core.ConfigurationMixin" href="#fin_statement_model.io.core.ConfigurationMixin">ConfigurationMixin</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.clear_config_overrides" href="#fin_statement_model.io.core.ConfigurationMixin.clear_config_overrides">clear_config_overrides</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.get_config_context" href="#fin_statement_model.io.core.ConfigurationMixin.get_config_context">get_config_context</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.get_config_value" href="#fin_statement_model.io.core.ConfigurationMixin.get_config_value">get_config_value</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.get_config_with_env_fallback" href="#fin_statement_model.io.core.ConfigurationMixin.get_config_with_env_fallback">get_config_with_env_fallback</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.get_effective_configuration" href="#fin_statement_model.io.core.ConfigurationMixin.get_effective_configuration">get_effective_configuration</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.merge_configurations" href="#fin_statement_model.io.core.ConfigurationMixin.merge_configurations">merge_configurations</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.require_config_value" href="#fin_statement_model.io.core.ConfigurationMixin.require_config_value">require_config_value</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.set_config_context" href="#fin_statement_model.io.core.ConfigurationMixin.set_config_context">set_config_context</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.set_config_override" href="#fin_statement_model.io.core.ConfigurationMixin.set_config_override">set_config_override</a></code></li>
<li><code><a title="fin_statement_model.io.core.ConfigurationMixin.validate_configuration" href="#fin_statement_model.io.core.ConfigurationMixin.validate_configuration">validate_configuration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.DataFrameBasedWriter" href="#fin_statement_model.io.core.DataFrameBasedWriter">DataFrameBasedWriter</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.DataFrameBasedWriter.extract_graph_data" href="#fin_statement_model.io.core.DataFrameBasedWriter.extract_graph_data">extract_graph_data</a></code></li>
<li><code><a title="fin_statement_model.io.core.DataFrameBasedWriter.write" href="#fin_statement_model.io.core.DataFrameBasedWriter.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.DataReader" href="#fin_statement_model.io.core.DataReader">DataReader</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.DataReader.read" href="#fin_statement_model.io.core.DataReader.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.DataWriter" href="#fin_statement_model.io.core.DataWriter">DataWriter</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.DataWriter.write" href="#fin_statement_model.io.core.DataWriter.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.FileBasedReader" href="#fin_statement_model.io.core.FileBasedReader">FileBasedReader</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.FileBasedReader.read" href="#fin_statement_model.io.core.FileBasedReader.read">read</a></code></li>
<li><code><a title="fin_statement_model.io.core.FileBasedReader.validate_file_exists" href="#fin_statement_model.io.core.FileBasedReader.validate_file_exists">validate_file_exists</a></code></li>
<li><code><a title="fin_statement_model.io.core.FileBasedReader.validate_file_extension" href="#fin_statement_model.io.core.FileBasedReader.validate_file_extension">validate_file_extension</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.HandlerRegistry" href="#fin_statement_model.io.core.HandlerRegistry">HandlerRegistry</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.clear" href="#fin_statement_model.io.core.HandlerRegistry.clear">clear</a></code></li>
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.get" href="#fin_statement_model.io.core.HandlerRegistry.get">get</a></code></li>
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.get_schema" href="#fin_statement_model.io.core.HandlerRegistry.get_schema">get_schema</a></code></li>
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.is_registered" href="#fin_statement_model.io.core.HandlerRegistry.is_registered">is_registered</a></code></li>
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.list_formats" href="#fin_statement_model.io.core.HandlerRegistry.list_formats">list_formats</a></code></li>
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.register" href="#fin_statement_model.io.core.HandlerRegistry.register">register</a></code></li>
<li><code><a title="fin_statement_model.io.core.HandlerRegistry.unregister" href="#fin_statement_model.io.core.HandlerRegistry.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.ValidationResultCollector" href="#fin_statement_model.io.core.ValidationResultCollector">ValidationResultCollector</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.add_result" href="#fin_statement_model.io.core.ValidationResultCollector.add_result">add_result</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.add_warning" href="#fin_statement_model.io.core.ValidationResultCollector.add_warning">add_warning</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.clear" href="#fin_statement_model.io.core.ValidationResultCollector.clear">clear</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.get_detailed_report" href="#fin_statement_model.io.core.ValidationResultCollector.get_detailed_report">get_detailed_report</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.get_error_count_by_category" href="#fin_statement_model.io.core.ValidationResultCollector.get_error_count_by_category">get_error_count_by_category</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.get_items_with_errors" href="#fin_statement_model.io.core.ValidationResultCollector.get_items_with_errors">get_items_with_errors</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.get_summary" href="#fin_statement_model.io.core.ValidationResultCollector.get_summary">get_summary</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.has_errors" href="#fin_statement_model.io.core.ValidationResultCollector.has_errors">has_errors</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.has_warnings" href="#fin_statement_model.io.core.ValidationResultCollector.has_warnings">has_warnings</a></code></li>
<li><code><a title="fin_statement_model.io.core.ValidationResultCollector.merge" href="#fin_statement_model.io.core.ValidationResultCollector.merge">merge</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.io.core.ValueExtractionMixin" href="#fin_statement_model.io.core.ValueExtractionMixin">ValueExtractionMixin</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.io.core.ValueExtractionMixin.extract_node_value" href="#fin_statement_model.io.core.ValueExtractionMixin.extract_node_value">extract_node_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
