<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model API documentation</title>
<meta name="description" content="Financial Statement Model library …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>fin_statement_model</code></h1>
</header>
<section id="section-intro">
<p>Financial Statement Model library.</p>
<p>A comprehensive library for building and analyzing financial statement models
using a node-based graph structure.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.config" href="config/index.html">fin_statement_model.config</a></code></dt>
<dd>
<div class="desc"><p>Provide centralized configuration management for fin_statement_model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core" href="core/index.html">fin_statement_model.core</a></code></dt>
<dd>
<div class="desc"><p>Foundation of <em>fin_statement_model</em> — graph engine, nodes, calculations &amp; more …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting" href="forecasting/index.html">fin_statement_model.forecasting</a></code></dt>
<dd>
<div class="desc"><p>Provide forecasting capabilities for financial statement graphs …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.io" href="io/index.html">fin_statement_model.io</a></code></dt>
<dd>
<div class="desc"><p>Input/Output components for the Financial Statement Model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.logging_config" href="logging_config.html">fin_statement_model.logging_config</a></code></dt>
<dd>
<div class="desc"><p>Configure centralized logging for the fin_statement_model library …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.preprocessing" href="preprocessing/index.html">fin_statement_model.preprocessing</a></code></dt>
<dd>
<div class="desc"><p>Preprocessing module entrypoint …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements" href="statements/index.html">fin_statement_model.statements</a></code></dt>
<dd>
<div class="desc"><p>Financial Statements Layer (<code><a title="fin_statement_model.statements" href="statements/index.html">fin_statement_model.statements</a></code>) …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>) ‑> <a title="fin_statement_model.config.models.Config" href="config/models.html#fin_statement_model.config.models.Config">Config</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config() -&gt; Config:
    &#34;&#34;&#34;Get the global configuration singleton.

    Returns:
        The `Config` object managed by the global ConfigManager.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.config.manager import get_config
        &gt;&gt;&gt; cfg = get_config()
        &gt;&gt;&gt; cfg.logging.level
        &#39;WARNING&#39;
    &#34;&#34;&#34;
    return _config_manager.get()</code></pre>
</details>
<div class="desc"><p>Get the global configuration singleton.</p>
<h2 id="returns">Returns</h2>
<p>The <code>Config</code> object managed by the global ConfigManager.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.config.manager import get_config
&gt;&gt;&gt; cfg = get_config()
&gt;&gt;&gt; cfg.logging.level
'WARNING'
</code></pre></div>
</dd>
<dt id="fin_statement_model.update_config"><code class="name flex">
<span>def <span class="ident">update_config</span></span>(<span>updates: dict[str, typing.Any]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_config(updates: dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Apply runtime overrides to the global configuration.

    Args:
        updates: Nested dict of configuration keys and values to override.
    &#34;&#34;&#34;
    _config_manager.update(updates)</code></pre>
</details>
<div class="desc"><p>Apply runtime overrides to the global configuration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>updates</code></strong></dt>
<dd>Nested dict of configuration keys and values to override.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.CalculationNode"><code class="flex name class">
<span>class <span class="ident">CalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="core/calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>,<br>**kwargs: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculationNode(Node):
    &#34;&#34;&#34;Delegate calculation logic to a calculation object.

    Use a calculation object to encapsulate the algorithm for computing node values.

    Attributes:
        name (str): Identifier for this node.
        inputs (List[Node]): A list of input nodes required by the calculation.
        calculation (Any): An object possessing a `calculate(inputs: List[Node], period: str) -&gt; float` method.
        _values (Dict[str, float]): Internal cache for calculated results.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;

    def __init__(
        self, name: str, inputs: list[Node], calculation: Calculation, **kwargs: Any
    ):
        &#34;&#34;&#34;Initialize the CalculationNode.

        Args:
            name (str): The unique identifier for this node.
            inputs (List[Node]): List of input nodes needed by the calculation.
            calculation (Any): The calculation object implementing the calculation.
                Must have a `calculate` method.
            **kwargs: Additional attributes to store on the node (e.g., metric_name, metric_description).

        Raises:
            TypeError: If `inputs` is not a list of Nodes, or if `calculation`
                does not have a callable `calculate` method.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(inputs, list) or not all(isinstance(n, Node) for n in inputs):
            raise TypeError(&#34;CalculationNode inputs must be a list of Node instances.&#34;)
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(
            getattr(calculation, &#34;calculate&#34;)
        ):
            raise TypeError(
                &#34;Calculation object must have a callable &#39;calculate&#39; method.&#34;
            )

        self.inputs = inputs
        self.calculation = calculation
        self._values: dict[str, float] = {}  # Cache for calculated values

        # Store any additional attributes passed via kwargs
        for key, value in kwargs.items():
            setattr(self, key, value)

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Raises:
            CalculationError: If calculation fails or returns a non-numeric value.
        &#34;&#34;&#34;
        if period in self._values:
            return self._values[period]

        try:
            # Delegate to the calculation object&#39;s calculate method
            result = self.calculation.calculate(self.inputs, period)
            if not isinstance(result, int | float):
                raise TypeError(
                    f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
                )
            # Cache and return the result
            self._values[period] = float(result)
            return self._values[period]
        except Exception as e:
            # Wrap potential errors from the calculation
            raise CalculationError(
                message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=period,
                details={
                    &#34;calculation&#34;: type(self.calculation).__name__,
                    &#34;error&#34;: str(e),
                },
            ) from e

    def set_calculation(self, calculation: Calculation) -&gt; None:
        &#34;&#34;&#34;Change the calculation object for the node.

        Args:
            calculation (Any): The new calculation object. Must have a callable
                `calculate` method.

        Raises:
            TypeError: If the new calculation is invalid.
        &#34;&#34;&#34;
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(
            getattr(calculation, &#34;calculate&#34;)
        ):
            raise TypeError(
                &#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;
            )
        self.calculation = calculation
        self.clear_cache()  # Clear cache as logic has changed

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the internal cache of calculated values.

        Returns:
            None
        &#34;&#34;&#34;
        self._values.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Return the names of input nodes used by the calculation.

        Returns:
            A list of input node names.
        &#34;&#34;&#34;
        return [node.name for node in self.inputs]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s type, name, inputs, and calculation info.

        Note:
            This method requires access to NodeFactory&#39;s calculation registry
            to properly serialize the calculation type. Some calculation types
            with non-serializable parameters may include warnings.
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        node_dict: dict[str, Any] = {
            &#34;type&#34;: &#34;calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
        }

        # Add calculation type information
        calc_class_name = type(self.calculation).__name__
        node_dict[&#34;calculation_type_class&#34;] = calc_class_name

        # Find the calculation type key from NodeFactory registry
        inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
        type_key = inv_map.get(calc_class_name)
        if type_key:
            node_dict[&#34;calculation_type&#34;] = type_key

            # Extract calculation-specific arguments
            calculation_args = {}

            # Handle specific calculation types
            if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
                calculation_args[&#34;weights&#34;] = self.calculation.weights
            elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
                calculation_args[&#34;formula&#34;] = self.calculation.formula
                if hasattr(self.calculation, &#34;input_variable_names&#34;):
                    node_dict[&#34;formula_variable_names&#34;] = (
                        self.calculation.input_variable_names
                    )
            elif type_key == &#34;custom_formula&#34;:
                node_dict[&#34;serialization_warning&#34;] = (
                    &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                    &#34;Manual reconstruction required.&#34;
                )

            if calculation_args:
                node_dict[&#34;calculation_args&#34;] = calculation_args

        # Add any additional attributes (like metric info)
        if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
            node_dict[&#34;metric_name&#34;] = self.metric_name
        if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
            node_dict[&#34;metric_description&#34;] = self.metric_description

        return node_dict

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;CalculationNode&#34;:
        &#34;&#34;&#34;Create a CalculationNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CalculationNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        if data.get(&#34;type&#34;) != &#34;calculation&#34;:
            raise ValueError(f&#34;Invalid type for CalculationNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CalculationNode data&#34;)

        input_names = data.get(&#34;inputs&#34;, [])
        if not isinstance(input_names, list):
            raise TypeError(&#34;&#39;inputs&#39; field must be a list&#34;)

        # Resolve input nodes from context
        input_nodes = []
        for input_name in input_names:
            if input_name not in context:
                raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
            input_nodes.append(context[input_name])

        calculation_type = data.get(&#34;calculation_type&#34;)
        if not calculation_type:
            raise ValueError(&#34;Missing &#39;calculation_type&#39; field in CalculationNode data&#34;)

        # Get calculation arguments
        calculation_args = data.get(&#34;calculation_args&#34;, {})

        # Handle formula variable names for formula calculations
        formula_variable_names = data.get(&#34;formula_variable_names&#34;)

        # Extract metric information
        metric_name = data.get(&#34;metric_name&#34;)
        metric_description = data.get(&#34;metric_description&#34;)

        # Create the node using NodeFactory
        return NodeFactory.create_calculation_node(
            name=name,
            inputs=input_nodes,
            calculation_type=calculation_type,
            formula_variable_names=formula_variable_names,
            metric_name=metric_name,
            metric_description=metric_description,
            **calculation_args,
        )</code></pre>
</details>
<div class="desc"><p>Delegate calculation logic to a calculation object.</p>
<p>Use a calculation object to encapsulate the algorithm for computing node values.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>]</code></dt>
<dd>A list of input nodes required by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>An object possessing a <code>calculate(inputs: List[Node], period: str) -&gt; float</code> method.</dd>
<dt><strong><code>_values</code></strong> :&ensp;<code>Dict[str, float]</code></dt>
<dd>Internal cache for calculated results.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre>
<p>Initialize the CalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>]</code></dt>
<dd>List of input nodes needed by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The calculation object implementing the calculation.
Must have a <code>calculate</code> method.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional attributes to store on the node (e.g., metric_name, metric_description).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>inputs</code> is not a list of Nodes, or if <code>calculation</code>
does not have a callable <code>calculate</code> method.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode">FormulaCalculationNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.CalculationNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;CalculationNode&#34;:
    &#34;&#34;&#34;Create a CalculationNode from a dictionary with node context.

    Args:
        data: Dictionary containing the node&#39;s serialized data.
        context: Dictionary of existing nodes to resolve dependencies.

    Returns:
        A new CalculationNode instance.

    Raises:
        ValueError: If the data is invalid or missing required fields.
    &#34;&#34;&#34;
    # Import here to avoid circular imports
    from fin_statement_model.core.node_factory import NodeFactory

    if data.get(&#34;type&#34;) != &#34;calculation&#34;:
        raise ValueError(f&#34;Invalid type for CalculationNode: {data.get(&#39;type&#39;)}&#34;)

    name = data.get(&#34;name&#34;)
    if not name:
        raise ValueError(&#34;Missing &#39;name&#39; field in CalculationNode data&#34;)

    input_names = data.get(&#34;inputs&#34;, [])
    if not isinstance(input_names, list):
        raise TypeError(&#34;&#39;inputs&#39; field must be a list&#34;)

    # Resolve input nodes from context
    input_nodes = []
    for input_name in input_names:
        if input_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
        input_nodes.append(context[input_name])

    calculation_type = data.get(&#34;calculation_type&#34;)
    if not calculation_type:
        raise ValueError(&#34;Missing &#39;calculation_type&#39; field in CalculationNode data&#34;)

    # Get calculation arguments
    calculation_args = data.get(&#34;calculation_args&#34;, {})

    # Handle formula variable names for formula calculations
    formula_variable_names = data.get(&#34;formula_variable_names&#34;)

    # Extract metric information
    metric_name = data.get(&#34;metric_name&#34;)
    metric_description = data.get(&#34;metric_description&#34;)

    # Create the node using NodeFactory
    return NodeFactory.create_calculation_node(
        name=name,
        inputs=input_nodes,
        calculation_type=calculation_type,
        formula_variable_names=formula_variable_names,
        metric_name=metric_name,
        metric_description=metric_description,
        **calculation_args,
    )</code></pre>
</details>
<div class="desc"><p>Create a CalculationNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CalculationNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.CalculationNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Raises:
        CalculationError: If calculation fails or returns a non-numeric value.
    &#34;&#34;&#34;
    if period in self._values:
        return self._values[period]

    try:
        # Delegate to the calculation object&#39;s calculate method
        result = self.calculation.calculate(self.inputs, period)
        if not isinstance(result, int | float):
            raise TypeError(
                f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
            )
        # Cache and return the result
        self._values[period] = float(result)
        return self._values[period]
    except Exception as e:
        # Wrap potential errors from the calculation
        raise CalculationError(
            message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=period,
            details={
                &#34;calculation&#34;: type(self.calculation).__name__,
                &#34;error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Check the cache; on a miss, delegate to <code>calculation.calculate</code> and cache the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If calculation fails or returns a non-numeric value.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.CalculationNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the internal cache of calculated values.

    Returns:
        None
    &#34;&#34;&#34;
    self._values.clear()</code></pre>
</details>
<div class="desc"><p>Clear the internal cache of calculated values.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="fin_statement_model.CalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Return the names of input nodes used by the calculation.

    Returns:
        A list of input node names.
    &#34;&#34;&#34;
    return [node.name for node in self.inputs]</code></pre>
</details>
<div class="desc"><p>Return the names of input nodes used by the calculation.</p>
<h2 id="returns">Returns</h2>
<p>A list of input node names.</p></div>
</dd>
<dt id="fin_statement_model.CalculationNode.set_calculation"><code class="name flex">
<span>def <span class="ident">set_calculation</span></span>(<span>self,<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="core/calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calculation(self, calculation: Calculation) -&gt; None:
    &#34;&#34;&#34;Change the calculation object for the node.

    Args:
        calculation (Any): The new calculation object. Must have a callable
            `calculate` method.

    Raises:
        TypeError: If the new calculation is invalid.
    &#34;&#34;&#34;
    if not hasattr(calculation, &#34;calculate&#34;) or not callable(
        getattr(calculation, &#34;calculate&#34;)
    ):
        raise TypeError(
            &#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;
        )
    self.calculation = calculation
    self.clear_cache()  # Clear cache as logic has changed</code></pre>
</details>
<div class="desc"><p>Change the calculation object for the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The new calculation object. Must have a callable
<code>calculate</code> method.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the new calculation is invalid.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.CalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s type, name, inputs, and calculation info.

    Note:
        This method requires access to NodeFactory&#39;s calculation registry
        to properly serialize the calculation type. Some calculation types
        with non-serializable parameters may include warnings.
    &#34;&#34;&#34;
    # Import here to avoid circular imports
    from fin_statement_model.core.node_factory import NodeFactory

    node_dict: dict[str, Any] = {
        &#34;type&#34;: &#34;calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
    }

    # Add calculation type information
    calc_class_name = type(self.calculation).__name__
    node_dict[&#34;calculation_type_class&#34;] = calc_class_name

    # Find the calculation type key from NodeFactory registry
    inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
    type_key = inv_map.get(calc_class_name)
    if type_key:
        node_dict[&#34;calculation_type&#34;] = type_key

        # Extract calculation-specific arguments
        calculation_args = {}

        # Handle specific calculation types
        if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
            calculation_args[&#34;weights&#34;] = self.calculation.weights
        elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
            calculation_args[&#34;formula&#34;] = self.calculation.formula
            if hasattr(self.calculation, &#34;input_variable_names&#34;):
                node_dict[&#34;formula_variable_names&#34;] = (
                    self.calculation.input_variable_names
                )
        elif type_key == &#34;custom_formula&#34;:
            node_dict[&#34;serialization_warning&#34;] = (
                &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            )

        if calculation_args:
            node_dict[&#34;calculation_args&#34;] = calculation_args

    # Add any additional attributes (like metric info)
    if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
        node_dict[&#34;metric_name&#34;] = self.metric_name
    if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
        node_dict[&#34;metric_description&#34;] = self.metric_description

    return node_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's type, name, inputs, and calculation info.</p>
<h2 id="note">Note</h2>
<p>This method requires access to NodeFactory's calculation registry
to properly serialize the calculation type. Some calculation types
with non-serializable parameters may include warnings.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.CurveGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">CurveGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_rates: list[float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurveGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node with period-specific growth rates.

    Apply a unique growth rate to each forecast period, allowing tapered or step-wise growth assumptions.

    Attributes:
        growth_rates (list[float]): Growth rate for each corresponding forecast period.

    Examples:
        &gt;&gt;&gt; rates = [0.10, 0.08, 0.05]  # 10 %, 8 %, 5 %
        &gt;&gt;&gt; forecast = CurveGrowthForecastNode(revenue, &#34;FY2022&#34;, [&#34;FY2023&#34;, &#34;FY2024&#34;, &#34;FY2025&#34;], rates)
        &gt;&gt;&gt; round(forecast.calculate(&#34;FY2025&#34;), 2)
        123.48
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_rates: list[float],
    ):
        &#34;&#34;&#34;Create a CurveGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_rates (list[float]): Growth rate for each forecast period; length must equal *forecast_periods*.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        if len(growth_rates) != len(forecast_periods):
            raise ValueError(&#34;Number of growth rates must match forecast periods.&#34;)
        self.growth_rates = [
            float(rate) for rate in growth_rates
        ]  # Ensure all are floats
        logger.debug(
            f&#34;Created CurveGrowthForecastNode with growth rates: {self.growth_rates}&#34;
        )
        logger.debug(f&#34;  Base period: {base_period}&#34;)
        logger.debug(f&#34;  Forecast periods: {forecast_periods}&#34;)
        logger.debug(f&#34;  Base value: {input_node.calculate(base_period)}&#34;)

    def _get_growth_factor_for_period(
        self, period: str, prev_period: str, prev_value: float
    ) -&gt; float:
        &#34;&#34;&#34;Get the growth factor for a specific period.&#34;&#34;&#34;
        idx = self.forecast_periods.index(period)
        growth_rate = self.growth_rates[idx]
        logger.debug(
            f&#34;CurveGrowthForecastNode: Using growth rate {growth_rate} for period {period}&#34;
        )
        logger.debug(f&#34;  Previous period: {prev_period}&#34;)
        logger.debug(f&#34;  Previous value: {prev_value}&#34;)
        return growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update(
            {
                &#34;forecast_type&#34;: &#34;curve&#34;,
                &#34;growth_params&#34;: self.growth_rates.copy(),
            }
        )
        return base_dict

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;CurveGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a CurveGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CurveGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CurveGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(
                &#34;Missing &#39;base_node_name&#39; field in CurveGrowthForecastNode data&#34;
            )

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])
        growth_params = data.get(&#34;growth_params&#34;, [])

        if not base_period:
            raise ValueError(
                &#34;Missing &#39;base_period&#39; field in CurveGrowthForecastNode data&#34;
            )

        if not isinstance(growth_params, list):
            raise TypeError(
                &#34;&#39;growth_params&#39; must be a list for CurveGrowthForecastNode&#34;
            )

        node = CurveGrowthForecastNode(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            growth_rates=growth_params,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node with period-specific growth rates.</p>
<p>Apply a unique growth rate to each forecast period, allowing tapered or step-wise growth assumptions.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_rates</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Growth rate for each corresponding forecast period.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; rates = [0.10, 0.08, 0.05]  # 10 %, 8 %, 5 %
&gt;&gt;&gt; forecast = CurveGrowthForecastNode(revenue, &quot;FY2022&quot;, [&quot;FY2023&quot;, &quot;FY2024&quot;, &quot;FY2025&quot;], rates)
&gt;&gt;&gt; round(forecast.calculate(&quot;FY2025&quot;), 2)
123.48
</code></pre>
<p>Create a CurveGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_rates</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Growth rate for each forecast period; length must equal <em>forecast_periods</em>.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.CurveGrowthForecastNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;CurveGrowthForecastNode&#34;:
    &#34;&#34;&#34;Create a CurveGrowthForecastNode from a dictionary with node context.

    Args:
        data: Dictionary containing the node&#39;s serialized data.
        context: Dictionary of existing nodes to resolve dependencies.

    Returns:
        A new CurveGrowthForecastNode instance.

    Raises:
        ValueError: If the data is invalid or missing required fields.
    &#34;&#34;&#34;
    name = data.get(&#34;name&#34;)
    if not name:
        raise ValueError(&#34;Missing &#39;name&#39; field in CurveGrowthForecastNode data&#34;)

    base_node_name = data.get(&#34;base_node_name&#34;)
    if not base_node_name:
        raise ValueError(
            &#34;Missing &#39;base_node_name&#39; field in CurveGrowthForecastNode data&#34;
        )

    if base_node_name not in context:
        raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

    base_node = context[base_node_name]
    base_period = data.get(&#34;base_period&#34;)
    forecast_periods = data.get(&#34;forecast_periods&#34;, [])
    growth_params = data.get(&#34;growth_params&#34;, [])

    if not base_period:
        raise ValueError(
            &#34;Missing &#39;base_period&#39; field in CurveGrowthForecastNode data&#34;
        )

    if not isinstance(growth_params, list):
        raise TypeError(
            &#34;&#39;growth_params&#39; must be a list for CurveGrowthForecastNode&#34;
        )

    node = CurveGrowthForecastNode(
        input_node=base_node,
        base_period=base_period,
        forecast_periods=forecast_periods,
        growth_rates=growth_params,
    )

    # Set the correct name from the serialized data
    node.name = name
    return node</code></pre>
</details>
<div class="desc"><p>Create a CurveGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CurveGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.CurveGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update(
        {
            &#34;forecast_type&#34;: &#34;curve&#34;,
            &#34;growth_params&#34;: self.growth_rates.copy(),
        }
    )
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.CustomGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">CustomGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_function: Callable[[str, str, float], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that computes growth via a user-supplied function.

    The supplied ``growth_function`` receives ``period``, ``prev_period``, and ``prev_value`` and
    returns a growth factor for the period.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_function: Callable[[str, str, float], float],
    ):
        &#34;&#34;&#34;Create a CustomGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_function (Callable[[str, str, float], float]): Function returning growth factor.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.growth_function = growth_function

    def _get_growth_factor_for_period(
        self, period: str, prev_period: str, prev_value: float
    ) -&gt; float:
        return self.growth_function(period, prev_period, prev_value)

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.

        Note:
            The growth_function cannot be serialized, so a warning is included.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update(
            {
                &#34;forecast_type&#34;: &#34;custom&#34;,
                &#34;serialization_warning&#34;: (
                    &#34;CustomGrowthForecastNode uses a growth function which cannot be serialized. &#34;
                    &#34;Manual reconstruction required.&#34;
                ),
            }
        )
        return base_dict

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;CustomGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a CustomGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CustomGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
            NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized
                because the growth_function cannot be serialized.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;CustomGrowthForecastNode cannot be fully deserialized because the &#34;
            &#34;growth_function cannot be serialized. Manual reconstruction required.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Forecast node that computes growth via a user-supplied function.</p>
<p>The supplied <code>growth_function</code> receives <code>period</code>, <code>prev_period</code>, and <code>prev_value</code> and
returns a growth factor for the period.</p>
<p>Create a CustomGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_function</code></strong> :&ensp;<code>Callable[[str, str, float], float]</code></dt>
<dd>Function returning growth factor.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.CustomGrowthForecastNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;CustomGrowthForecastNode&#34;:
    &#34;&#34;&#34;Create a CustomGrowthForecastNode from a dictionary with node context.

    Args:
        data: Dictionary containing the node&#39;s serialized data.
        context: Dictionary of existing nodes to resolve dependencies.

    Returns:
        A new CustomGrowthForecastNode instance.

    Raises:
        ValueError: If the data is invalid or missing required fields.
        NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized
            because the growth_function cannot be serialized.
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;CustomGrowthForecastNode cannot be fully deserialized because the &#34;
        &#34;growth_function cannot be serialized. Manual reconstruction required.&#34;
    )</code></pre>
</details>
<div class="desc"><p>Create a CustomGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CustomGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>CustomGrowthForecastNode cannot be fully deserialized
because the growth_function cannot be serialized.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.CustomGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.

    Note:
        The growth_function cannot be serialized, so a warning is included.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update(
        {
            &#34;forecast_type&#34;: &#34;custom&#34;,
            &#34;serialization_warning&#34;: (
                &#34;CustomGrowthForecastNode uses a growth function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        }
    )
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p>
<h2 id="note">Note</h2>
<p>The growth_function cannot be serialized, so a warning is included.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.FinancialModelError"><code class="flex name class">
<span>class <span class="ident">FinancialModelError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinancialModelError(Exception):
    &#34;&#34;&#34;Base exception for all financial statement model errors.

    All custom exceptions raised within the library should inherit from this class.

    Examples:
        &gt;&gt;&gt; raise FinancialModelError(&#34;An error occurred.&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str):
        &#34;&#34;&#34;Initialize the FinancialModelError.

        Args:
            message: A human-readable description of the error.
        &#34;&#34;&#34;
        self.message = message
        super().__init__(self.message)</code></pre>
</details>
<div class="desc"><p>Base exception for all financial statement model errors.</p>
<p>All custom exceptions raised within the library should inherit from this class.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise FinancialModelError(&quot;An error occurred.&quot;)
</code></pre>
<p>Initialize the FinancialModelError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>A human-readable description of the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.config.helpers.ConfigurationAccessError" href="config/helpers.html#fin_statement_model.config.helpers.ConfigurationAccessError">ConfigurationAccessError</a></li>
<li><a title="fin_statement_model.config.manager.ConfigurationError" href="config/manager.html#fin_statement_model.config.manager.ConfigurationError">ConfigurationError</a></li>
<li><a title="fin_statement_model.core.errors.CalculationError" href="core/errors.html#fin_statement_model.core.errors.CalculationError">CalculationError</a></li>
<li><a title="fin_statement_model.core.errors.CircularDependencyError" href="core/errors.html#fin_statement_model.core.errors.CircularDependencyError">CircularDependencyError</a></li>
<li><a title="fin_statement_model.core.errors.ConfigurationError" href="core/errors.html#fin_statement_model.core.errors.ConfigurationError">ConfigurationError</a></li>
<li><a title="fin_statement_model.core.errors.DataValidationError" href="core/errors.html#fin_statement_model.core.errors.DataValidationError">DataValidationError</a></li>
<li><a title="fin_statement_model.core.errors.GraphError" href="core/errors.html#fin_statement_model.core.errors.GraphError">GraphError</a></li>
<li><a title="fin_statement_model.core.errors.MetricError" href="core/errors.html#fin_statement_model.core.errors.MetricError">MetricError</a></li>
<li><a title="fin_statement_model.core.errors.MissingInputError" href="core/errors.html#fin_statement_model.core.errors.MissingInputError">MissingInputError</a></li>
<li><a title="fin_statement_model.core.errors.NodeError" href="core/errors.html#fin_statement_model.core.errors.NodeError">NodeError</a></li>
<li><a title="fin_statement_model.core.errors.PeriodError" href="core/errors.html#fin_statement_model.core.errors.PeriodError">PeriodError</a></li>
<li><a title="fin_statement_model.core.errors.StatementError" href="core/errors.html#fin_statement_model.core.errors.StatementError">StatementError</a></li>
<li><a title="fin_statement_model.core.errors.StrategyError" href="core/errors.html#fin_statement_model.core.errors.StrategyError">StrategyError</a></li>
<li><a title="fin_statement_model.core.errors.TransformationError" href="core/errors.html#fin_statement_model.core.errors.TransformationError">TransformationError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="forecasting/errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.io.exceptions.IOError" href="io/exceptions.html#fin_statement_model.io.exceptions.IOError">IOError</a></li>
<li><a title="fin_statement_model.preprocessing.errors.PreprocessingError" href="preprocessing/errors.html#fin_statement_model.preprocessing.errors.PreprocessingError">PreprocessingError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.FinancialStatementItemNode"><code class="flex name class">
<span>class <span class="ident">FinancialStatementItemNode</span></span>
<span>(</span><span>name: str, values: dict[str, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinancialStatementItemNode(Node):
    &#34;&#34;&#34;Store raw financial statement values for specific periods.

    Represents a leaf node containing actual reported financial data
    (e.g., revenue, COGS) across time periods.

    Attributes:
        name (str): Unique identifier for the financial item.
        values (dict[str, float]): Mapping from period identifiers to their values.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 1000.0, &#34;2023&#34;: 1200.0}
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        1200.0
        &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
        &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
        1500.0
    &#34;&#34;&#34;

    values: dict[str, float]

    def __init__(self, name: str, values: dict[str, float]):
        &#34;&#34;&#34;Create a FinancialStatementItemNode.

        Args:
            name (str): Unique identifier for the financial item.
            values (dict[str, float]): Initial mapping of periods to values.

        Raises:
            ValueError: If `name` is empty, contains invalid characters, or has leading/trailing whitespace.
        &#34;&#34;&#34;
        super().__init__(name)
        self.values = values

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Get the value for a specific period.

        Args:
            period (str): Period identifier to retrieve.

        Returns:
            float: Stored value for `period`, or 0.0 if not present.
        &#34;&#34;&#34;
        return self.values.get(period, 0.0)

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set the value for a specific period.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.
        &#34;&#34;&#34;
        self.values[period] = value

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

        Examples:
            &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; data = node.to_dict()
            &gt;&gt;&gt; data[&#39;type&#39;]
            &#39;financial_statement_item&#39;
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;financial_statement_item&#34;,
            &#34;name&#34;: self.name,
            &#34;values&#34;: self.values.copy(),
        }

    @staticmethod
    def from_dict(data: dict[str, Any]) -&gt; &#34;FinancialStatementItemNode&#34;:
        &#34;&#34;&#34;Create a FinancialStatementItemNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data; must contain keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

        Returns:
            FinancialStatementItemNode: Reconstructed node.

        Raises:
            ValueError: If &#39;type&#39; is not &#39;financial_statement_item&#39; or &#39;name&#39; is missing.
            TypeError: If &#39;values&#39; is not a dict.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;financial_statement_item&#34;:
            raise ValueError(
                f&#34;Invalid type for FinancialStatementItemNode: {data.get(&#39;type&#39;)}&#34;
            )

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FinancialStatementItemNode data&#34;)

        values = data.get(&#34;values&#34;, {})
        if not isinstance(values, dict):
            raise TypeError(&#34;&#39;values&#39; field must be a dict[str, float]&#34;)

        return FinancialStatementItemNode(name, values)</code></pre>
</details>
<div class="desc"><p>Store raw financial statement values for specific periods.</p>
<p>Represents a leaf node containing actual reported financial data
(e.g., revenue, COGS) across time periods.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Mapping from period identifiers to their values.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 1000.0, &quot;2023&quot;: 1200.0}
&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1200.0
&gt;&gt;&gt; node.set_value(&quot;2024&quot;, 1500.0)
&gt;&gt;&gt; node.calculate(&quot;2024&quot;)
1500.0
</code></pre>
<p>Create a FinancialStatementItemNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Initial mapping of periods to values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, contains invalid characters, or has leading/trailing whitespace.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.FinancialStatementItemNode.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.FinancialStatementItemNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any]) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(data: dict[str, Any]) -&gt; &#34;FinancialStatementItemNode&#34;:
    &#34;&#34;&#34;Create a FinancialStatementItemNode from serialized data.

    Args:
        data (dict[str, Any]): Serialized node data; must contain keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

    Returns:
        FinancialStatementItemNode: Reconstructed node.

    Raises:
        ValueError: If &#39;type&#39; is not &#39;financial_statement_item&#39; or &#39;name&#39; is missing.
        TypeError: If &#39;values&#39; is not a dict.
    &#34;&#34;&#34;
    if data.get(&#34;type&#34;) != &#34;financial_statement_item&#34;:
        raise ValueError(
            f&#34;Invalid type for FinancialStatementItemNode: {data.get(&#39;type&#39;)}&#34;
        )

    name = data.get(&#34;name&#34;)
    if not name:
        raise ValueError(&#34;Missing &#39;name&#39; field in FinancialStatementItemNode data&#34;)

    values = data.get(&#34;values&#34;, {})
    if not isinstance(values, dict):
        raise TypeError(&#34;&#39;values&#39; field must be a dict[str, float]&#34;)

    return FinancialStatementItemNode(name, values)</code></pre>
</details>
<div class="desc"><p>Create a FinancialStatementItemNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data; must contain keys 'type', 'name', and 'values'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If 'type' is not 'financial_statement_item' or 'name' is missing.</dd>
<dt><code>TypeError</code></dt>
<dd>If 'values' is not a dict.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.FinancialStatementItemNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Get the value for a specific period.

    Args:
        period (str): Period identifier to retrieve.

    Returns:
        float: Stored value for `period`, or 0.0 if not present.
    &#34;&#34;&#34;
    return self.values.get(period, 0.0)</code></pre>
</details>
<div class="desc"><p>Get the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Stored value for <code>period</code>, or 0.0 if not present.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.FinancialStatementItemNode.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set the value for a specific period.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.
    &#34;&#34;&#34;
    self.values[period] = value</code></pre>
</details>
<div class="desc"><p>Set the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.FinancialStatementItemNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; data = node.to_dict()
        &gt;&gt;&gt; data[&#39;type&#39;]
        &#39;financial_statement_item&#39;
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;financial_statement_item&#34;,
        &#34;name&#34;: self.name,
        &#34;values&#34;: self.values.copy(),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary with keys 'type', 'name', and 'values'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; data = node.to_dict()
&gt;&gt;&gt; data['type']
'financial_statement_item'
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_dependencies" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.FixedGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">FixedGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_rate: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FixedGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that applies a single growth rate to every future period.

    Attributes:
        growth_rate (float): Constant growth factor expressed as a decimal (``0.05`` → 5 %).

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;FY2022&#34;: 100})
        &gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &#34;FY2022&#34;, [&#34;FY2023&#34;, &#34;FY2024&#34;], 0.05)
        &gt;&gt;&gt; round(forecast.calculate(&#34;FY2024&#34;), 2)
        110.25
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_rate: Optional[float] = None,
    ):
        &#34;&#34;&#34;Create a FixedGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_rate (float | None): Constant growth rate (``0.05`` → 5 %).
                If ``None``, the default configured in ``cfg(&#39;forecasting.default_growth_rate&#39;)`` is used.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)

        # Use config default if not provided (import inside to avoid circular import)
        if growth_rate is None:
            from fin_statement_model.config.helpers import cfg

            growth_rate = cfg(&#34;forecasting.default_growth_rate&#34;)

        self.growth_rate = float(growth_rate)  # Ensure it&#39;s a float
        logger.debug(
            f&#34;Created FixedGrowthForecastNode with growth rate: {self.growth_rate}&#34;
        )

    def _get_growth_factor_for_period(
        self, period: str, prev_period: str, prev_value: float
    ) -&gt; float:
        logger.debug(
            f&#34;FixedGrowthForecastNode: Using growth rate {self.growth_rate} for period {period}&#34;
        )
        return self.growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update(
            {
                &#34;forecast_type&#34;: &#34;simple&#34;,
                &#34;growth_params&#34;: self.growth_rate,
            }
        )
        return base_dict

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;FixedGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a FixedGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new FixedGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FixedGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(
                &#34;Missing &#39;base_node_name&#39; field in FixedGrowthForecastNode data&#34;
            )

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])
        growth_params = data.get(&#34;growth_params&#34;)

        if not base_period:
            raise ValueError(
                &#34;Missing &#39;base_period&#39; field in FixedGrowthForecastNode data&#34;
            )

        node = FixedGrowthForecastNode(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            growth_rate=growth_params,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node that applies a single growth rate to every future period.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Constant growth factor expressed as a decimal (<code>0.05</code> → 5 %).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;FY2022&quot;: 100})
&gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &quot;FY2022&quot;, [&quot;FY2023&quot;, &quot;FY2024&quot;], 0.05)
&gt;&gt;&gt; round(forecast.calculate(&quot;FY2024&quot;), 2)
110.25
</code></pre>
<p>Create a FixedGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_rate</code></strong> :&ensp;<code>float | None</code></dt>
<dd>Constant growth rate (<code>0.05</code> → 5 %).
If <code>None</code>, the default configured in <code>cfg('forecasting.default_growth_rate')</code> is used.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.FixedGrowthForecastNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;FixedGrowthForecastNode&#34;:
    &#34;&#34;&#34;Create a FixedGrowthForecastNode from a dictionary with node context.

    Args:
        data: Dictionary containing the node&#39;s serialized data.
        context: Dictionary of existing nodes to resolve dependencies.

    Returns:
        A new FixedGrowthForecastNode instance.

    Raises:
        ValueError: If the data is invalid or missing required fields.
    &#34;&#34;&#34;
    name = data.get(&#34;name&#34;)
    if not name:
        raise ValueError(&#34;Missing &#39;name&#39; field in FixedGrowthForecastNode data&#34;)

    base_node_name = data.get(&#34;base_node_name&#34;)
    if not base_node_name:
        raise ValueError(
            &#34;Missing &#39;base_node_name&#39; field in FixedGrowthForecastNode data&#34;
        )

    if base_node_name not in context:
        raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

    base_node = context[base_node_name]
    base_period = data.get(&#34;base_period&#34;)
    forecast_periods = data.get(&#34;forecast_periods&#34;, [])
    growth_params = data.get(&#34;growth_params&#34;)

    if not base_period:
        raise ValueError(
            &#34;Missing &#39;base_period&#39; field in FixedGrowthForecastNode data&#34;
        )

    node = FixedGrowthForecastNode(
        input_node=base_node,
        base_period=base_period,
        forecast_periods=forecast_periods,
        growth_rate=growth_params,
    )

    # Set the correct name from the serialized data
    node.name = name
    return node</code></pre>
</details>
<div class="desc"><p>Create a FixedGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new FixedGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.FixedGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update(
        {
            &#34;forecast_type&#34;: &#34;simple&#34;,
            &#34;growth_params&#34;: self.growth_rate,
        }
    )
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.ForecastNode"><code class="flex name class">
<span>class <span class="ident">ForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastNode(Node):
    &#34;&#34;&#34;ForecastNode defines base behavior for projecting future values.

    ForecastNode uses a source node&#39;s historical data to generate projected values
    for specified future periods, caching results to avoid redundant computations.

    Attributes:
        input_node (Node): Node providing historical data.
        base_period (str): Last historical period used as forecast base.
        forecast_periods (list[str]): Future periods to project.
        values (dict[str, float]): Historical and forecasted values.
    &#34;&#34;&#34;

    _cache: dict[str, float]

    def __init__(self, input_node: Node, base_period: str, forecast_periods: list[str]):
        &#34;&#34;&#34;Initialize a ForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period as forecast base.
            forecast_periods (list[str]): Future periods to generate forecasts for.
        &#34;&#34;&#34;
        # Initialize with a default name based on input node, but allow it to be overridden
        super().__init__(input_node.name)
        self.input_node = input_node
        self.base_period = base_period
        self.forecast_periods = forecast_periods
        self._cache = {}

        # Copy historical values from input node
        if hasattr(input_node, &#34;values&#34;):
            self.values = input_node.values.copy()
        else:
            self.values = {}

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Returns historical values for periods up to `base_period`; computes forecast for later periods.

        Args:
            period (str): Period identifier, historical or forecast.

        Returns:
            float: Value for the specified period.

        Raises:
            ValueError: If `period` is not a historical or forecast period.
        &#34;&#34;&#34;
        if period not in self._cache:
            self._cache[period] = self._calculate_value(period)
        return self._cache[period]

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached forecast values.

        Use to force recomputation of all periods when input data changes.
        &#34;&#34;&#34;
        self._cache.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes that this forecast depends on.

        Returns:
            list[str]: Single-element list of the input node&#39;s name.
        &#34;&#34;&#34;
        return [self.input_node.name]

    def _calculate_value(self, period: str) -&gt; float:
        &#34;&#34;&#34;Compute the value for a given period without caching.

        Args:
            period (str): Period identifier to compute.

        Returns:
            float: Historical or forecasted value.

        Raises:
            ValueError: If `period` is not valid for this node.
        &#34;&#34;&#34;
        # For historical periods, return the actual value
        if period &lt;= self.base_period:
            # Return historical value, ensuring float type
            return float(self.values.get(period, 0.0))

        # For forecast periods, calculate using growth rate
        if period not in self.forecast_periods:
            raise ValueError(
                f&#34;Period &#39;{period}&#39; not in forecast periods for {self.name}&#34;
            )

        # Get the previous period&#39;s value
        prev_period = self._get_previous_period(period)
        prev_value = self.calculate(prev_period)

        # Get the growth rate for this period
        growth_factor = self._get_growth_factor_for_period(
            period, prev_period, prev_value
        )

        # Calculate the new value
        return prev_value * (1 + growth_factor)

    def _get_previous_period(self, current_period: str) -&gt; str:
        all_periods = sorted([self.base_period, *self.forecast_periods])
        idx = all_periods.index(current_period)
        return all_periods[idx - 1]

    def _get_growth_factor_for_period(
        self, period: str, prev_period: str, prev_value: float
    ) -&gt; float:
        raise NotImplementedError(&#34;Implement in subclass.&#34;)

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation including base forecast parameters.

        Note:
            Subclasses should override to include specific forecast details.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;forecast&#34;,
            &#34;name&#34;: self.name,
            &#34;base_node_name&#34;: self.input_node.name,
            &#34;base_period&#34;: self.base_period,
            &#34;forecast_periods&#34;: self.forecast_periods.copy(),
            &#34;forecast_type&#34;: &#34;base&#34;,  # Override in subclasses
        }

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;ForecastNode&#34;:
        &#34;&#34;&#34;Recreate a ForecastNode from serialized data.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new ForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
            NotImplementedError: This base method should be overridden by subclasses.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Subclasses must implement from_dict_with_context&#34;)</code></pre>
</details>
<div class="desc"><p>ForecastNode defines base behavior for projecting future values.</p>
<p>ForecastNode uses a source node's historical data to generate projected values
for specified future periods, caching results to avoid redundant computations.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node providing historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period used as forecast base.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Historical and forecasted values.</dd>
</dl>
<p>Initialize a ForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period as forecast base.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to generate forecasts for.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode">AverageHistoricalGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode">AverageValueForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.ForecastNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;ForecastNode&#34;:
    &#34;&#34;&#34;Recreate a ForecastNode from serialized data.

    Args:
        data: Dictionary containing the node&#39;s serialized data.
        context: Dictionary of existing nodes to resolve dependencies.

    Returns:
        A new ForecastNode instance.

    Raises:
        ValueError: If the data is invalid or missing required fields.
        NotImplementedError: This base method should be overridden by subclasses.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;Subclasses must implement from_dict_with_context&#34;)</code></pre>
</details>
<div class="desc"><p>Recreate a ForecastNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new ForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>This base method should be overridden by subclasses.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.ForecastNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Returns historical values for periods up to `base_period`; computes forecast for later periods.

    Args:
        period (str): Period identifier, historical or forecast.

    Returns:
        float: Value for the specified period.

    Raises:
        ValueError: If `period` is not a historical or forecast period.
    &#34;&#34;&#34;
    if period not in self._cache:
        self._cache[period] = self._calculate_value(period)
    return self._cache[period]</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Returns historical values for periods up to <code>base_period</code>; computes forecast for later periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier, historical or forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Value for the specified period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>period</code> is not a historical or forecast period.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.ForecastNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached forecast values.

    Use to force recomputation of all periods when input data changes.
    &#34;&#34;&#34;
    self._cache.clear()</code></pre>
</details>
<div class="desc"><p>Clear cached forecast values.</p>
<p>Use to force recomputation of all periods when input data changes.</p></div>
</dd>
<dt id="fin_statement_model.ForecastNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes that this forecast depends on.

    Returns:
        list[str]: Single-element list of the input node&#39;s name.
    &#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes that this forecast depends on.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Single-element list of the input node's name.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.ForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation including base forecast parameters.

    Note:
        Subclasses should override to include specific forecast details.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;forecast&#34;,
        &#34;name&#34;: self.name,
        &#34;base_node_name&#34;: self.input_node.name,
        &#34;base_period&#34;: self.base_period,
        &#34;forecast_periods&#34;: self.forecast_periods.copy(),
        &#34;forecast_type&#34;: &#34;base&#34;,  # Override in subclasses
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation including base forecast parameters.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Subclasses should override to include specific forecast details.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>periods: list[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;Core directed-graph abstraction for financial statement modeling.

    The `Graph` class orchestrates construction, mutation, traversal,
    calculation, and forecasting of nodes representing financial statement
    items and metrics. It exposes high-level convenience methods for
    building and evaluating the model, while delegating structural
    mutations and read-only inspections to its sub-APIs.

    Attributes:
        _nodes: Mapping of node names (str) to Node instances registered in the graph.
        _periods: Sorted list of unique period identifiers (str) managed by the graph.
        _cache: Nested dict caching calculated float values per node per period.
        _node_factory: `NodeFactory` instance for creating new nodes.
        manipulator: `GraphManipulator` for structural mutations (add/remove/replace nodes, set values).
        traverser: `GraphTraverser` for read-only traversal, validation, and cycle detection.
        adjustment_manager: `AdjustmentManager` handling discretionary adjustments.
    &#34;&#34;&#34;

    def __init__(self, periods: Optional[list[str]] = None):
        &#34;&#34;&#34;Initialize a new `Graph` instance.

        Sets up core components: node registry, period list, calculation cache,
        node factory, and sub-API instances (`manipulator`, `traverser`,
        `adjustment_manager`).

        Args:
            periods: Optional list of period identifiers (str) to initialize.
                     Periods are automatically deduplicated and sorted.

        Raises:
            TypeError: If `periods` is not a list of strings.

        Examples:
            &gt;&gt;&gt; from fin_statement_model.core.graph.graph import Graph
            &gt;&gt;&gt; g = Graph()
            &gt;&gt;&gt; g.periods
            []
            &gt;&gt;&gt; g = Graph(periods=[&#34;2024&#34;, &#34;2023&#34;])
            &gt;&gt;&gt; g.periods
            [&#34;2023&#34;, &#34;2024&#34;]
            &gt;&gt;&gt; Graph(periods=&#34;2023&#34;)  # raises TypeError
        &#34;&#34;&#34;
        # No super().__init__() needed as mixins don&#39;t have __init__
        # and GraphCore is removed.

        self._nodes: dict[str, Node] = {}

        # Initialize core attributes for periods, cache, and node factory
        self._periods: list[str] = []
        self._cache: dict[str, dict[str, float]] = {}
        self._node_factory: NodeFactory = NodeFactory()

        # Handle initial periods directly
        if periods:
            if not isinstance(periods, list):
                raise TypeError(&#34;Initial periods must be a list&#34;)
            self.add_periods(periods)

        self.manipulator = GraphManipulator(self)
        self.traverser = GraphTraverser(self)

        # --- Adjustment Manager Integration ---
        self.adjustment_manager = AdjustmentManager()
        # --- End Adjustment Manager Integration ---

    @property
    def nodes(self) -&gt; dict[str, Node]:
        &#34;&#34;&#34;Provide access to the dictionary of all nodes in the graph.

        Returns:
            A dictionary where keys are node names (str) and values are
            `Node` objects. This dictionary represents the shared node registry.

        Examples:
            &gt;&gt;&gt; graph = Graph()
            &gt;&gt;&gt; item_node = graph.add_financial_statement_item(&#34;Revenue&#34;, {&#34;2023&#34;: 100})
            &gt;&gt;&gt; logger.info(list(graph.nodes.keys()))
            &gt;&gt;&gt; logger.info(graph.nodes[&#34;Revenue&#34;] == item_node)
        &#34;&#34;&#34;
        return self._nodes

    @property
    def periods(self) -&gt; list[str]:
        &#34;&#34;&#34;Retrieve the list of time periods currently managed by the graph.

        Returns:
            A sorted list of unique time period strings managed by the graph.

        Examples:
            &gt;&gt;&gt; graph = Graph(periods=[&#34;2024&#34;, &#34;2023&#34;])
            &gt;&gt;&gt; logger.info(graph.periods)
            &gt;&gt;&gt; graph.add_periods([&#34;2025&#34;])
            &gt;&gt;&gt; logger.info(graph.periods)
        &#34;&#34;&#34;
        return self._periods

    def add_periods(self, periods: list[str]) -&gt; None:
        &#34;&#34;&#34;Add new time periods to the graph.

        Update the internal period list, ensuring uniqueness and sorting.

        Args:
            periods: A list of strings representing the time periods to add.

        Raises:
            TypeError: If `periods` is not a list.
        &#34;&#34;&#34;
        if not isinstance(periods, list):
            raise TypeError(&#34;Periods must be provided as a list.&#34;)
        # Ensure unique and sorted periods
        combined = set(self._periods).union(periods)
        self._periods = sorted(combined)
        logger.debug(f&#34;Added periods {periods}; current periods: {self._periods}&#34;)

    def add_calculation(
        self,
        name: str,
        input_names: list[str],
        operation_type: str,
        formula_variable_names: Optional[list[str]] = None,
        **calculation_kwargs: Any,
    ) -&gt; Node:
        &#34;&#34;&#34;Add a new calculation node to the graph using the node factory.

        Resolve input node names to Node objects, create a CalculationNode,
        register it in the graph, and return it.

        Args:
            name: Unique name for the calculation node.
            input_names: List of node names to use as inputs.
            operation_type: Calculation type key (e.g., &#39;addition&#39;).
            formula_variable_names: Optional list of variable names used in the formula
                string, required if creating a FormulaCalculationNode via this method.
            **calculation_kwargs: Additional parameters for the calculation constructor.

        Returns:
            The created calculation node.

        Raises:
            NodeError: If any input node name does not exist.
            ValueError: If the name is invalid or creation fails.
            TypeError: If inputs are invalid.
            CircularDependencyError: If adding the node would create a cycle.
        &#34;&#34;&#34;
        # Validate inputs
        if not isinstance(input_names, list):
            raise TypeError(&#34;input_names must be a list of node names.&#34;)

        # Resolve input node names to Node objects
        resolved_inputs = self._resolve_input_nodes(input_names)

        # Create the node via factory
        try:
            node = self._node_factory.create_calculation_node(
                name=name,
                inputs=resolved_inputs,
                calculation_type=operation_type,
                formula_variable_names=formula_variable_names,
                **calculation_kwargs,
            )
        except (ValueError, TypeError):
            logger.exception(
                f&#34;Failed to create calculation node &#39;{name}&#39; with type &#39;{operation_type}&#39;&#34;
            )
            raise

        # Add with validation (includes cycle detection)
        added_node = self._add_node_with_validation(node)

        logger.info(
            f&#34;Added calculation node &#39;{name}&#39; of type &#39;{operation_type}&#39; with inputs {input_names}&#34;
        )
        return added_node

    def add_metric(
        self,
        metric_name: str,
        node_name: Optional[str] = None,
        *,
        input_node_map: Optional[dict[str, str]] = None,
    ) -&gt; Node:
        &#34;&#34;&#34;Add a metric calculation node based on a metric definition.

        If `node_name` is None, uses `metric_name` as the node name.

        Uses the metric registry to load inputs and formula, creates a
        calculation node using the formula strategy, registers it, and stores metric
        metadata on the node itself.

        Args:
            metric_name: Key of the metric definition to add.
            node_name: Optional name for the metric node; defaults to metric_name.
            input_node_map: Optional dictionary mapping metric input variable names
                (from metric definition) to the actual node names present in the graph.
                If None, assumes graph node names match metric input variable names.

        Returns:
            The created calculation node.

        Raises:
            TypeError: If node_name is invalid.
            ValueError: If node_name already exists.
            ConfigurationError: If metric definition is missing or invalid.
            NodeError: If required input nodes (after mapping) are missing.
        &#34;&#34;&#34;
        # Default node_name to metric_name if not provided
        if node_name is None:
            node_name = metric_name
        if not node_name or not isinstance(node_name, str):
            raise TypeError(&#34;Metric node name must be a non-empty string.&#34;)
        # Check for name conflict
        if node_name in self._nodes:
            raise ValueError(
                f&#34;A node with name &#39;{node_name}&#39; already exists in the graph.&#34;
            )

        # Load metric definition (Pydantic model)
        try:
            metric_def = metric_registry.get(metric_name)
        except KeyError as e:
            raise ConfigurationError(
                f&#34;Unknown metric definition: &#39;{metric_name}&#39;&#34;
            ) from e

        # Extract required fields from definition
        required_inputs = metric_def.inputs
        formula = metric_def.formula
        description = metric_def.description

        # Build list of input node names and formula variable names
        input_node_names: list[str] = []
        formula_variable_names: list[str] = []
        missing = []

        for req_input_name in required_inputs:
            # Determine the actual graph node name to look for
            target_node_name = req_input_name  # Default case
            if input_node_map and req_input_name in input_node_map:
                target_node_name = input_node_map[req_input_name]
            elif input_node_map:
                # If map provided but doesn&#39;t contain the required input, it&#39;s an error in the map
                missing.append(f&#34;{req_input_name} (mapping missing in input_node_map)&#34;)
                continue  # Skip trying to find the node

            # Check if the node exists in the graph
            if target_node_name not in self._nodes:
                missing.append(target_node_name)  # Report the name we looked for
            else:
                input_node_names.append(target_node_name)
                formula_variable_names.append(
                    req_input_name
                )  # Use the metric&#39;s variable name

        if missing:
            raise NodeError(
                f&#34;Cannot create metric &#39;{metric_name}&#39;: missing required nodes {missing}&#34;,
                node_id=node_name,
            )

        # Create calculation node using add_calculation
        try:
            new_node = self.add_calculation(
                name=node_name,
                input_names=input_node_names,
                operation_type=&#34;formula&#34;,
                formula_variable_names=formula_variable_names,
                formula=formula,
                metric_name=metric_name,  # Pass metric metadata
                metric_description=description,  # Pass metric description
            )
        except Exception as e:
            logger.exception(
                f&#34;Failed to create calculation node for metric &#39;{metric_name}&#39; as node &#39;{node_name}&#39;&#34;
            )
            # Re-raise as ConfigurationError or keep original, depending on desired error reporting
            raise ConfigurationError(
                f&#34;Error creating node for metric &#39;{metric_name}&#39;: {e}&#34;
            ) from e

        logger.info(
            f&#34;Added metric &#39;{metric_name}&#39; as calculation node &#39;{node_name}&#39; with inputs {input_node_names}&#34;
        )
        return new_node

    def add_custom_calculation(
        self,
        name: str,
        calculation_func: Callable[..., float],
        inputs: Optional[list[str]] = None,
        description: str = &#34;&#34;,
    ) -&gt; Node:
        &#34;&#34;&#34;Add a custom calculation node using a Python callable.

        Args:
            name: Unique name for the custom calculation node.
            calculation_func: A callable that accepts (period, **inputs) and returns float.
            inputs: Optional list of node names to use as inputs.
            description: Optional description of the calculation.

        Returns:
            The created custom calculation node.

        Raises:
            NodeError: If any specified input nodes are missing.
            TypeError: If calculation_func is not callable.
            CircularDependencyError: If adding the node would create a cycle.
        &#34;&#34;&#34;
        # Validate callable
        if not callable(calculation_func):
            raise TypeError(&#34;calculation_func must be callable.&#34;)

        # Resolve inputs if provided
        resolved_inputs: list[Node] = []
        if inputs is not None:
            if not isinstance(inputs, list):
                raise TypeError(&#34;inputs must be a list of node names.&#34;)
            resolved_inputs = self._resolve_input_nodes(inputs)

        # Create custom node via factory
        try:
            custom_node = self._node_factory._create_custom_node_from_callable(
                name=name,
                inputs=resolved_inputs,
                formula=calculation_func,
                description=description,
            )
        except (ValueError, TypeError):
            logger.exception(f&#34;Failed to create custom calculation node &#39;{name}&#39;&#34;)
            raise

        # Add with validation (includes cycle detection)
        added_node = self._add_node_with_validation(custom_node)

        logger.info(f&#34;Added custom calculation node &#39;{name}&#39; with inputs {inputs}&#34;)
        return added_node

    def ensure_signed_nodes(
        self, base_node_ids: list[str], *, suffix: str = &#34;_signed&#34;
    ) -&gt; list[str]:
        &#34;&#34;&#34;Ensure signed calculation nodes (-1 * input) exist for each base node.

        Args:
            base_node_ids: List of existing node names to sign.
            suffix: Suffix to append for signed node names.

        Returns:
            List of names of newly created signed nodes.
        &#34;&#34;&#34;
        created: list[str] = []
        for base_id in base_node_ids:
            signed_id = f&#34;{base_id}{suffix}&#34;
            # Skip if already present
            if signed_id in self._nodes:
                continue
            # Ensure base node exists
            if base_id not in self._nodes:
                from fin_statement_model.core.errors import NodeError

                raise NodeError(
                    f&#34;Cannot create signed node for missing base node &#39;{base_id}&#39;&#34;,
                    node_id=base_id,
                )
            # Create formula node that multiplies by -1
            self.add_calculation(
                name=signed_id,
                input_names=[base_id],
                operation_type=&#34;formula&#34;,
                formula=&#34;-input_0&#34;,
                formula_variable_names=[&#34;input_0&#34;],
            )
            created.append(signed_id)
        return created

    def change_calculation_method(
        self,
        node_name: str,
        new_method_key: str,
        **kwargs: dict[str, Any],
    ) -&gt; None:
        &#34;&#34;&#34;Change the calculation method for an existing calculation-based node.

        Args:
            node_name: Name of the existing calculation node.
            new_method_key: Key of the new calculation method to apply.
            **kwargs: Additional parameters required by the new calculation.

        Returns:
            None

        Raises:
            NodeError: If the target node does not exist or is not a CalculationNode.
            ValueError: If `new_method_key` is not a recognized calculation key.
            TypeError: If the new calculation cannot be instantiated with the provided arguments.

        Examples:
            &gt;&gt;&gt; graph.change_calculation_method(&#34;GrossProfit&#34;, &#34;addition&#34;)
        &#34;&#34;&#34;
        node = self.manipulator.get_node(node_name)
        if node is None:
            raise NodeError(&#34;Node not found for calculation change&#34;, node_id=node_name)
        if not isinstance(node, CalculationNode):
            raise NodeError(
                f&#34;Node &#39;{node_name}&#39; is not a CalculationNode&#34;, node_id=node_name
            )
        # Map method key to registry name
        if new_method_key not in self._node_factory._calculation_methods:
            raise ValueError(f&#34;Calculation &#39;{new_method_key}&#39; is not recognized.&#34;)
        calculation_class_name = self._node_factory._calculation_methods[new_method_key]
        try:
            calculation_cls = Registry.get(calculation_class_name)
        except KeyError as e:
            raise ValueError(
                f&#34;Calculation class &#39;{calculation_class_name}&#39; not found in registry.&#34;
            ) from e
        try:
            calculation_instance = calculation_cls(**kwargs)
        except TypeError as e:
            raise TypeError(
                f&#34;Failed to instantiate calculation &#39;{new_method_key}&#39;: {e}&#34;
            )
        # Apply new calculation
        node.set_calculation(calculation_instance)
        # Clear cached calculations for this node
        if node_name in self._cache:
            del self._cache[node_name]
        logger.info(f&#34;Changed calculation for node &#39;{node_name}&#39; to &#39;{new_method_key}&#39;&#34;)

    def get_metric(self, metric_id: str) -&gt; Optional[Node]:
        &#34;&#34;&#34;Return the metric node for a given metric ID, if present.

        Searches for a node with the given ID that was created as a metric
        (identified by having a `metric_name` attribute).

        Args:
            metric_id: Identifier of the metric node to retrieve.

        Returns:
            The Node corresponding to `metric_id` if it&#39;s a metric node, or None.

        Examples:
            &gt;&gt;&gt; m = graph.get_metric(&#34;current_ratio&#34;)
            &gt;&gt;&gt; if m:
            ...     logger.info(m.name)
        &#34;&#34;&#34;
        node = self._nodes.get(metric_id)
        # Check if the node exists and has the metric_name attribute populated
        if node and getattr(node, &#34;metric_name&#34;, None) == metric_id:
            return node
        return None

    def get_available_metrics(self) -&gt; list[str]:
        &#34;&#34;&#34;Return a sorted list of all metric node IDs currently in the graph.

        Identifies metric nodes by checking for the presence and non-None value
        of the `metric_name` attribute.

        Returns:
            A sorted list of metric node names.

        Examples:
            &gt;&gt;&gt; graph.get_available_metrics()
            [&#39;current_ratio&#39;, &#39;debt_equity_ratio&#39;]
        &#34;&#34;&#34;
        # Iterate through all nodes and collect names of those that are metrics
        metric_node_names = [
            node.name
            for node in self._nodes.values()
            if getattr(node, &#34;metric_name&#34;, None) is not None
        ]
        return sorted(metric_node_names)

    def get_metric_info(self, metric_id: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Return detailed information for a specific metric node.

        Args:
            metric_id: Identifier of the metric node to inspect.

        Returns:
            A dict containing &#39;id&#39;, &#39;name&#39;, &#39;description&#39;, and &#39;inputs&#39; for the metric.

        Raises:
            ValueError: If `metric_id` does not correspond to a metric node.

        Examples:
            &gt;&gt;&gt; info = graph.get_metric_info(&#34;current_ratio&#34;)
            &gt;&gt;&gt; logger.info(info[&#39;inputs&#39;])
        &#34;&#34;&#34;
        metric_node = self.get_metric(metric_id)
        if metric_node is None:
            if metric_id in self._nodes:
                raise ValueError(
                    f&#34;Node &#39;{metric_id}&#39; exists but is not a metric (missing metric_name attribute).&#34;
                )
            raise ValueError(f&#34;Metric node &#39;{metric_id}&#39; not found in graph.&#34;)

        # Extract info directly from the FormulaCalculationNode
        try:
            # Use getattr for safety, retrieving stored metric metadata
            description = getattr(metric_node, &#34;metric_description&#34;, &#34;N/A&#34;)
            # metric_name stored on the node is the key from the registry
            registry_key = getattr(metric_node, &#34;metric_name&#34;, metric_id)

            # We might want the display name from the original definition.
            # Fetch the definition again if needed for the display name.
            try:
                metric_def = metric_registry.get(registry_key)
                display_name = metric_def.name
            except Exception:
                logger.warning(
                    f&#34;Could not reload metric definition for &#39;{registry_key}&#39; to get display name. Using node name &#39;{metric_id}&#39; instead.&#34;
                )
                display_name = metric_id  # Fallback to node name

            inputs = metric_node.get_dependencies()
        except Exception as e:
            # Catch potential attribute errors or other issues
            logger.error(
                f&#34;Error retrieving info for metric node &#39;{metric_id}&#39;: {e}&#34;,
                exc_info=True,
            )
            raise ValueError(
                f&#34;Failed to retrieve metric info for &#39;{metric_id}&#39;: {e}&#34;
            ) from e

        return {
            &#34;id&#34;: metric_id,
            &#34;name&#34;: display_name,
            &#34;description&#34;: description,
            &#34;inputs&#34;: inputs,
        }

    @overload
    def get_adjusted_value(
        self,
        node_name: str,
        period: str,
        filter_input: &#34;AdjustmentFilterInput&#34; = None,
        *,
        return_flag: Literal[True],
    ) -&gt; tuple[float, bool]: ...

    @overload
    def get_adjusted_value(
        self,
        node_name: str,
        period: str,
        filter_input: &#34;AdjustmentFilterInput&#34; = None,
        *,
        return_flag: Literal[False] = False,
    ) -&gt; float: ...

    def get_adjusted_value(
        self,
        node_name: str,
        period: str,
        filter_input: &#34;AdjustmentFilterInput&#34; = None,
        *,
        return_flag: bool = False,
    ) -&gt; float | tuple[float, bool]:
        &#34;&#34;&#34;Calculates the value of a node for a period, applying selected adjustments.

        Fetches the base calculated value, retrieves adjustments matching the filter,
        applies them in order, and returns the result.

        Args:
            node_name: The name of the node to calculate.
            period: The time period identifier.
            filter_input: Criteria for selecting which adjustments to apply. Can be:
                - None: applies default filter (default scenario, all adjustments).
                - AdjustmentFilter: filter by scenarios, tags, types, and period window.
                - set of tags: shorthand for include_tags filter.
                - Callable[[Adjustment], bool] or Callable[[Adjustment, str], bool]:
                    predicate to select adjustments. Two-arg predicates receive
                    the current period as the second argument.
            return_flag: If True, return a tuple (adjusted_value, was_adjusted_flag);
                         if False (default), return only the adjusted_value.

        Returns:
            The adjusted float value, or a tuple (value, flag) if return_flag is True.

        Raises:
            NodeError: If the specified node does not exist.
            CalculationError: If an error occurs during the base calculation or adjustment application.
            TypeError: If filter_input is an invalid type.
        &#34;&#34;&#34;
        # 1. Get the base value (result of underlying node calculation)
        try:
            base_value = self.calculate(node_name, period)
        except (NodeError, CalculationError, TypeError):
            # Propagate errors from base calculation
            logger.exception(
                f&#34;Error getting base value for &#39;{node_name}&#39; in period &#39;{period}&#39;&#34;
            )
            raise

        # 2. Get filtered adjustments from the manager
        try:
            adjustments_to_apply = self.adjustment_manager.get_filtered_adjustments(
                node_name=node_name, period=period, filter_input=filter_input
            )
        except TypeError:
            logger.exception(&#34;Invalid filter type provided for get_adjusted_value&#34;)
            raise

        # 3. Apply the adjustments
        adjusted_value, was_adjusted = self.adjustment_manager.apply_adjustments(
            base_value, adjustments_to_apply
        )

        # 4. Return result based on flag
        if return_flag:
            return adjusted_value, was_adjusted
        else:
            return adjusted_value

    def calculate(self, node_name: str, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate and return the value of a specific node for a given period.

        This method uses internal caching to speed repeated calls, and wraps
        underlying errors in CalculationError for clarity.

        Args:
            node_name: Name of the node to calculate.
            period: Time period identifier for the calculation.

        Returns:
            The calculated float value for the node and period.

        Raises:
            NodeError: If the specified node does not exist.
            TypeError: If the node has no callable `calculate` method.
            CalculationError: If an error occurs during the node&#39;s calculation.

        Examples:
            &gt;&gt;&gt; value = graph.calculate(&#34;Revenue&#34;, &#34;2023&#34;)
        &#34;&#34;&#34;
        # Return cached value if present
        if node_name in self._cache and period in self._cache[node_name]:
            logger.debug(f&#34;Cache hit for node &#39;{node_name}&#39;, period &#39;{period}&#39;&#34;)
            return self._cache[node_name][period]
        # Resolve node
        node = self.manipulator.get_node(node_name)
        if node is None:
            raise NodeError(f&#34;Node &#39;{node_name}&#39; not found&#34;, node_id=node_name)
        # Validate calculate method
        if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
            raise TypeError(f&#34;Node &#39;{node_name}&#39; has no callable calculate method.&#34;)
        # Perform calculation with error handling
        try:
            value = node.calculate(period)
        except (
            NodeError,
            ConfigurationError,
            CalculationError,
            ValueError,
            KeyError,
            ZeroDivisionError,
        ) as e:
            logger.error(
                f&#34;Error calculating node &#39;{node_name}&#39; for period &#39;{period}&#39;: {e}&#34;,
                exc_info=True,
            )
            raise CalculationError(
                message=f&#34;Failed to calculate node &#39;{node_name}&#39;&#34;,
                node_id=node_name,
                period=period,
                details={&#34;original_error&#34;: str(e)},
            ) from e
        # Cache and return
        self._cache.setdefault(node_name, {})[period] = value
        logger.debug(f&#34;Cached value for node &#39;{node_name}&#39;, period &#39;{period}&#39;: {value}&#34;)
        return value

    def recalculate_all(self, periods: Optional[list[str]] = None) -&gt; None:
        &#34;&#34;&#34;Recalculate all nodes for given periods, clearing all caches first.

        Args:
            periods: List of period strings, a single string, or None to use all periods.

        Returns:
            None

        Raises:
            TypeError: If `periods` is not a list, string, or None.

        Examples:
            &gt;&gt;&gt; graph.recalculate_all([&#34;2023&#34;, &#34;2024&#34;])
        &#34;&#34;&#34;
        # Normalize periods input
        if periods is None:
            periods_to_use = self.periods
        elif isinstance(periods, str):
            periods_to_use = [periods]
        elif isinstance(periods, list):
            periods_to_use = periods
        else:
            raise TypeError(
                &#34;Periods must be a list of strings, a single string, or None.&#34;
            )
        # Clear all caches (node-level and central) to force full recalculation
        self.clear_all_caches()
        if not periods_to_use:
            return
        # Recalculate each node for each period
        for node_name in list(self._nodes.keys()):
            for period in periods_to_use:
                try:
                    self.calculate(node_name, period)
                except Exception as e:
                    logger.warning(
                        f&#34;Error recalculating node &#39;{node_name}&#39; for period &#39;{period}&#39;: {e}&#34;
                    )

    def clear_all_caches(self) -&gt; None:
        &#34;&#34;&#34;Clear all node-level and central calculation caches.

        Returns:
            None

        Examples:
            &gt;&gt;&gt; graph.clear_all_caches()
        &#34;&#34;&#34;
        logger.debug(f&#34;Clearing node-level caches for {len(self.nodes)} nodes.&#34;)
        for node in self.nodes.values():
            if hasattr(node, &#34;clear_cache&#34;):
                try:
                    node.clear_cache()
                except Exception as e:
                    logger.warning(f&#34;Failed to clear cache for node &#39;{node.name}&#39;: {e}&#34;)
        # Clear central calculation cache
        self.clear_calculation_cache()
        logger.debug(&#34;Cleared central calculation cache.&#34;)

    def clear_calculation_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the graph&#39;s internal calculation cache.

        Returns:
            None

        Examples:
            &gt;&gt;&gt; graph.clear_calculation_cache()
        &#34;&#34;&#34;
        self._cache.clear()
        logger.debug(&#34;Cleared graph calculation cache.&#34;)

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Reset the graph by clearing nodes, periods, adjustments, and caches.&#34;&#34;&#34;
        self._nodes = {}
        self._periods = []
        self._cache = {}

        # --- Adjustment Manager Integration ---
        self.adjustment_manager.clear_all()
        # --- End Adjustment Manager Integration ---

        logger.info(&#34;Graph cleared: nodes, periods, adjustments, and caches reset.&#34;)

    def add_financial_statement_item(
        self, name: str, values: dict[str, float]
    ) -&gt; FinancialStatementItemNode:
        &#34;&#34;&#34;Add a basic financial statement item (data node) to the graph.

        Args:
            name: Unique name for the financial statement item node.
            values: Mapping of period strings to float values for this item.

        Returns:
            The newly created `FinancialStatementItemNode`.

        Raises:
            ValueError: If node name is invalid.
            TypeError: If `values` is not a dict or contains invalid types.

        Examples:
            &gt;&gt;&gt; item_node = graph.add_financial_statement_item(&#34;SG&amp;A&#34;, {&#34;2023&#34;: 50.0})
            &gt;&gt;&gt; item_node.calculate(&#34;2023&#34;)
            50.0
        &#34;&#34;&#34;
        # Validate inputs
        if not isinstance(values, dict):
            raise TypeError(&#34;Values must be provided as a dict[str, float]&#34;)

        # Create a new financial statement item node
        new_node = self._node_factory.create_financial_statement_item(
            name=name, values=values.copy()
        )

        # Add with validation (no cycle detection needed for data nodes)
        # Cast to FinancialStatementItemNode for correct return type
        from typing import cast

        added_node = cast(
            FinancialStatementItemNode,
            self._add_node_with_validation(
                new_node,
                check_cycles=False,  # Data nodes don&#39;t have inputs, so no cycles possible
                validate_inputs=False,  # Data nodes don&#39;t have inputs to validate
            ),
        )

        logger.info(
            f&#34;Added FinancialStatementItemNode &#39;{name}&#39; with periods {list(values.keys())}&#34;
        )
        return added_node

    def update_financial_statement_item(
        self, name: str, values: dict[str, float], replace_existing: bool = False
    ) -&gt; FinancialStatementItemNode:
        &#34;&#34;&#34;Update values for an existing financial statement item node.

        Args:
            name: Name of the existing financial statement item node.
            values: Mapping of new period strings to float values.
            replace_existing: If True, replace existing values entirely; otherwise merge.

        Returns:
            The updated `FinancialStatementItemNode`.

        Raises:
            NodeError: If the node does not exist.
            TypeError: If the node is not a `FinancialStatementItemNode` or `values` is not a dict.

        Examples:
            &gt;&gt;&gt; graph.update_financial_statement_item(&#34;SG&amp;A&#34;, {&#34;2024&#34;: 60.0})
        &#34;&#34;&#34;
        node = self.manipulator.get_node(name)
        if node is None:
            raise NodeError(&#34;Node not found&#34;, node_id=name)
        if not isinstance(node, FinancialStatementItemNode):
            raise TypeError(f&#34;Node &#39;{name}&#39; is not a FinancialStatementItemNode&#34;)
        if not isinstance(values, dict):
            raise TypeError(&#34;Values must be provided as a dict[str, float]&#34;)
        if replace_existing:
            node.values = values.copy()
        else:
            node.values.update(values)
        self.add_periods(list(values.keys()))
        logger.info(
            f&#34;Updated FinancialStatementItemNode &#39;{name}&#39; with periods {list(values.keys())}; replace_existing={replace_existing}&#34;
        )
        return node

    def get_financial_statement_items(self) -&gt; list[Node]:
        &#34;&#34;&#34;Retrieve all financial statement item nodes from the graph.

        Returns:
            A list of `FinancialStatementItemNode` objects currently in the graph.

        Examples:
            &gt;&gt;&gt; items = graph.get_financial_statement_items()
        &#34;&#34;&#34;
        from fin_statement_model.core.nodes import (
            FinancialStatementItemNode,
        )  # Keep import local as it&#39;s specific

        return [
            node
            for node in self.nodes.values()
            if isinstance(node, FinancialStatementItemNode)
        ]

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Provide a concise, developer-friendly string representation of the graph.

        Summarize total nodes, FS items, calculations, dependencies, and periods.

        Returns:
            A string summarizing the graph&#39;s structure and contents.

        Examples:
            &gt;&gt;&gt; logger.info(repr(graph))
        &#34;&#34;&#34;
        from fin_statement_model.core.nodes import (
            FinancialStatementItemNode,
        )  # Keep import local

        num_nodes = len(self.nodes)
        periods_str = &#34;, &#34;.join(map(repr, self.periods)) if self.periods else &#34;None&#34;

        fs_item_count = 0
        calc_node_count = 0
        other_node_count = 0
        dependencies_count = 0

        for node in self.nodes.values():
            if isinstance(node, FinancialStatementItemNode):
                fs_item_count += 1
            elif is_calculation_node(node):
                calc_node_count += 1
                # Prioritize get_dependencies if available, otherwise check inputs
                if hasattr(node, &#34;get_dependencies&#34;):
                    try:
                        dependencies_count += len(node.get_dependencies())
                    except Exception as e:
                        logger.warning(
                            f&#34;Error calling get_dependencies for node &#39;{node.name}&#39;: {e}&#34;
                        )
                elif hasattr(node, &#34;inputs&#34;):
                    try:
                        if isinstance(node.inputs, list):
                            # Ensure inputs are nodes with names
                            dep_names = [
                                inp.name for inp in node.inputs if hasattr(inp, &#34;name&#34;)
                            ]
                            dependencies_count += len(dep_names)
                        elif isinstance(node.inputs, dict):
                            # Assume keys are dependency names for dict inputs
                            dependencies_count += len(node.inputs)
                    except Exception as e:
                        logger.warning(
                            f&#34;Error processing inputs for node &#39;{node.name}&#39;: {e}&#34;
                        )
            else:
                other_node_count += 1

        repr_parts = [
            f&#34;Total Nodes: {num_nodes}&#34;,
            f&#34;FS Items: {fs_item_count}&#34;,
            f&#34;Calculations: {calc_node_count}&#34;,
        ]
        if other_node_count &gt; 0:
            repr_parts.append(f&#34;Other: {other_node_count}&#34;)
        repr_parts.append(f&#34;Dependencies: {dependencies_count}&#34;)
        repr_parts.append(f&#34;Periods: [{periods_str}]&#34;)

        return f&#34;&lt;{type(self).__name__}({&#39;, &#39;.join(repr_parts)})&gt;&#34;

    def has_cycle(self, source_node: Node, target_node: Node) -&gt; bool:
        &#34;&#34;&#34;Check if a cycle exists from a source node to a target node.

        This method delegates to GraphTraverser to determine if `target_node` is
        reachable from `source_node` via successors, indicating that adding an edge
        from `target_node` to `source_node` would create a cycle.

        Args:
            source_node: The starting node for cycle detection.
            target_node: The node to detect return path to.

        Returns:
            True if a cycle exists, False otherwise.
        &#34;&#34;&#34;
        if source_node.name not in self._nodes or target_node.name not in self._nodes:
            return False

        # Use GraphTraverser&#39;s reachability check
        return self.traverser._is_reachable(source_node.name, target_node.name)

    def get_node(self, name: str) -&gt; Optional[Node]:
        &#34;&#34;&#34;Retrieve a node from the graph by its name.

        Args:
            name: The unique name of the node to retrieve.

        Returns:
            The `Node` instance if found, else None.

        Examples:
            &gt;&gt;&gt; node = graph.get_node(&#34;Revenue&#34;)
        &#34;&#34;&#34;
        return self.manipulator.get_node(name)

    def _add_node_with_validation(
        self, node: Node, check_cycles: bool = True, validate_inputs: bool = True
    ) -&gt; Node:
        &#34;&#34;&#34;Internal method for adding nodes with common validation logic.

        Args:
            node: The Node instance to add
            check_cycles: Whether to perform cycle detection
            validate_inputs: Whether to validate input node references

        Returns:
            The added node

        Raises:
            ValueError: If node name is invalid
            NodeError: If input validation fails
            CircularDependencyError: If adding the node would create a cycle
        &#34;&#34;&#34;
        # 1. Name validation
        if not node.name or not isinstance(node.name, str):
            raise ValueError(&#34;Node name must be a non-empty string&#34;)

        # 2. Check for existing node
        if node.name in self._nodes:
            logger.warning(f&#34;Overwriting existing node &#39;{node.name}&#39;&#34;)

        # 3. Input validation (if applicable)
        if validate_inputs and hasattr(node, &#34;inputs&#34;) and node.inputs:
            self._validate_node_inputs(node)

        # 4. Cycle detection (if applicable)
        if (
            check_cycles
            and hasattr(node, &#34;inputs&#34;)
            and node.inputs
            and self.traverser.would_create_cycle(node)
        ):
            # Try to find the actual cycle path for better error message
            cycle_path = None
            for input_node in node.inputs:
                if hasattr(input_node, &#34;name&#34;):
                    path = self.traverser.find_cycle_path(input_node.name, node.name)
                    if path:
                        cycle_path = path
                        break

            raise CircularDependencyError(
                f&#34;Adding node &#39;{node.name}&#39; would create a cycle&#34;,
                cycle=cycle_path or [node.name, &#34;...&#34;, node.name],
            )

        # 5. Register node
        self._nodes[node.name] = node

        # 6. Update periods if applicable
        if hasattr(node, &#34;values&#34;) and isinstance(node.values, dict):
            self.add_periods(list(node.values.keys()))

        logger.debug(f&#34;Added node &#39;{node.name}&#39; to graph&#34;)
        return node

    def _validate_node_inputs(self, node: Node) -&gt; None:
        &#34;&#34;&#34;Validate that all input nodes exist in the graph.

        Args:
            node: The node whose inputs to validate

        Raises:
            NodeError: If any input node is missing
        &#34;&#34;&#34;
        missing_inputs = []

        if hasattr(node, &#34;inputs&#34;) and node.inputs:
            for input_node in node.inputs:
                if hasattr(input_node, &#34;name&#34;):
                    if input_node.name not in self._nodes:
                        missing_inputs.append(input_node.name)
                # Handle case where inputs might be strings instead of Node objects
                elif isinstance(input_node, str) and input_node not in self._nodes:
                    missing_inputs.append(input_node)

        if missing_inputs:
            raise NodeError(
                f&#34;Cannot add node &#39;{node.name}&#39;: missing required input nodes {missing_inputs}&#34;,
                node_id=node.name,
            )

    def _resolve_input_nodes(self, input_names: list[str]) -&gt; list[Node]:
        &#34;&#34;&#34;Resolve input node names to Node objects.

        Args:
            input_names: List of node names to resolve

        Returns:
            List of resolved Node objects

        Raises:
            NodeError: If any input node name does not exist
        &#34;&#34;&#34;
        resolved_inputs: list[Node] = []
        missing = []

        for name in input_names:
            node = self._nodes.get(name)
            if node is None:
                missing.append(name)
            else:
                resolved_inputs.append(node)

        if missing:
            raise NodeError(f&#34;Cannot resolve input nodes: missing nodes {missing}&#34;)

        return resolved_inputs

    def add_node(self, node: Node) -&gt; None:
        &#34;&#34;&#34;Add a node to the graph.

        Args:
            node: A ``Node`` instance to add to the graph.

        Raises:
            TypeError: If the provided object is not a Node instance.

        Examples:
            &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000})
            &gt;&gt;&gt; graph.add_node(node)
        &#34;&#34;&#34;
        from fin_statement_model.core.nodes.base import Node as _NodeBase

        if not isinstance(node, _NodeBase):
            raise TypeError(f&#34;Expected Node instance, got {type(node).__name__}&#34;)

        return self.manipulator.add_node(node)

    def remove_node(self, node_name: str) -&gt; None:
        &#34;&#34;&#34;Remove a node from the graph by name, updating dependencies.

        Args:
            node_name: The name of the node to remove.

        Returns:
            None

        Examples:
            &gt;&gt;&gt; graph.remove_node(&#34;OldItem&#34;)
        &#34;&#34;&#34;
        return self.manipulator.remove_node(node_name)

    def replace_node(self, node_name: str, new_node: Node) -&gt; None:
        &#34;&#34;&#34;Replace an existing node with a new node instance.

        Args:
            node_name: Name of the node to replace.
            new_node: The new `Node` instance to substitute.

        Returns:
            None

        Examples:
            &gt;&gt;&gt; graph.replace_node(&#34;Item&#34;, updated_node)
        &#34;&#34;&#34;
        return self.manipulator.replace_node(node_name, new_node)

    def has_node(self, node_id: str) -&gt; bool:
        &#34;&#34;&#34;Check if a node with the given ID exists in the graph.

        Args:
            node_id: The name of the node to check.

        Returns:
            True if the node exists, False otherwise.

        Examples:
            &gt;&gt;&gt; graph.has_node(&#34;Revenue&#34;)
        &#34;&#34;&#34;
        return self.manipulator.has_node(node_id)

    def set_value(self, node_id: str, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set or update the value for a node in a specific period.

        Args:
            node_id: The name of the node.
            period: The period identifier to set the value for.
            value: The float value to assign.

        Returns:
            None

        Raises:
            ValueError: If the period is not recognized by the graph.
            NodeError: If the node does not exist.
            TypeError: If the node does not support setting a value.

        Examples:
            &gt;&gt;&gt; graph.set_value(&#34;SG&amp;A&#34;, &#34;2024&#34;, 55.0)
        &#34;&#34;&#34;
        return self.manipulator.set_value(node_id, period, value)

    def topological_sort(self) -&gt; list[str]:
        &#34;&#34;&#34;Perform a topological sort of all graph nodes.

        Returns:
            A list of node IDs in topological order.

        Raises:
            ValueError: If a cycle is detected in the graph.

        Examples:
            &gt;&gt;&gt; order = graph.topological_sort()
        &#34;&#34;&#34;
        return self.traverser.topological_sort()

    def get_calculation_nodes(self) -&gt; list[str]:
        &#34;&#34;&#34;Get all calculation node IDs in the graph.

        Returns:
            A list of node names that have associated calculations.

        Examples:
            &gt;&gt;&gt; graph.get_calculation_nodes()
        &#34;&#34;&#34;
        return self.traverser.get_calculation_nodes()

    def get_dependencies(self, node_id: str) -&gt; list[str]:
        &#34;&#34;&#34;Get the direct predecessor node IDs (dependencies) for a given node.

        Args:
            node_id: The name of the node to inspect.

        Returns:
            A list of node IDs that the given node depends on.

        Examples:
            &gt;&gt;&gt; graph.get_dependencies(&#34;GrossProfit&#34;)
        &#34;&#34;&#34;
        return self.traverser.get_dependencies(node_id)

    def get_dependency_graph(self) -&gt; dict[str, list[str]]:
        &#34;&#34;&#34;Get the full dependency graph mapping of node IDs to their inputs.

        Returns:
            A dict mapping each node ID to a list of its dependency node IDs.

        Examples:
            &gt;&gt;&gt; graph.get_dependency_graph()
        &#34;&#34;&#34;
        return self.traverser.get_dependency_graph()

    def detect_cycles(self) -&gt; list[list[str]]:
        &#34;&#34;&#34;Detect all cycles in the graph&#39;s dependency structure.

        Returns:
            A list of cycles, each represented as a list of node IDs.

        Examples:
            &gt;&gt;&gt; graph.detect_cycles()
        &#34;&#34;&#34;
        return self.traverser.detect_cycles()

    def validate(self) -&gt; list[str]:
        &#34;&#34;&#34;Validate the graph structure for errors such as cycles or missing nodes.

        Returns:
            A list of validation error messages, empty if valid.

        Examples:
            &gt;&gt;&gt; graph.validate()
        &#34;&#34;&#34;
        return self.traverser.validate()

    def breadth_first_search(
        self, start_node: str, direction: str = &#34;successors&#34;
    ) -&gt; list[list[str]]:
        &#34;&#34;&#34;Perform a breadth-first search (BFS) traversal of the graph.

        Args:
            start_node: The starting node ID for BFS.
            direction: Either &#39;successors&#39; or &#39;predecessors&#39; to traverse.

        Returns:
            A nested list of node IDs per BFS level.

        Raises:
            ValueError: If `direction` is not &#39;successors&#39; or &#39;predecessors&#39;.

        Examples:
            &gt;&gt;&gt; graph.breadth_first_search(&#34;Revenue&#34;, &#34;successors&#34;)
        &#34;&#34;&#34;
        return self.traverser.breadth_first_search(start_node, direction)

    def get_direct_successors(self, node_id: str) -&gt; list[str]:
        &#34;&#34;&#34;Get immediate successor node IDs for a given node.

        Args:
            node_id: The name of the node to inspect.

        Returns:
            A list of node IDs that directly follow the given node.

        Examples:
            &gt;&gt;&gt; graph.get_direct_successors(&#34;Revenue&#34;)
        &#34;&#34;&#34;
        return self.traverser.get_direct_successors(node_id)

    def get_direct_predecessors(self, node_id: str) -&gt; list[str]:
        &#34;&#34;&#34;Get immediate predecessor node IDs (inputs) for a given node.

        Args:
            node_id: The name of the node to inspect.

        Returns:
            A list of node IDs that the given node directly depends on.

        Examples:
            &gt;&gt;&gt; graph.get_direct_predecessors(&#34;GrossProfit&#34;)
        &#34;&#34;&#34;
        return self.traverser.get_direct_predecessors(node_id)

    def merge_from(self, other_graph: &#34;Graph&#34;) -&gt; None:
        &#34;&#34;&#34;Merge nodes and periods from another Graph into this one.

        Adds periods from the other graph if they don&#39;t exist in this graph.
        Adds nodes from the other graph if they don&#39;t exist.
        If a node exists in both graphs, attempts to merge the &#39;values&#39; dictionary
        from the other graph&#39;s node into this graph&#39;s node.

        Args:
            other_graph: The Graph instance to merge data from.

        Raises:
            TypeError: If other_graph is not a Graph instance.
        &#34;&#34;&#34;
        if not isinstance(other_graph, Graph):
            raise TypeError(&#34;Can only merge from another Graph instance.&#34;)

        logger.info(f&#34;Starting merge from graph {other_graph!r} into {self!r}&#34;)

        # 1. Update periods
        new_periods = [p for p in other_graph.periods if p not in self.periods]
        if new_periods:
            self.add_periods(new_periods)
            logger.debug(f&#34;Merged periods: {new_periods}&#34;)

        # 2. Merge nodes
        nodes_added = 0
        nodes_updated = 0
        for node_name, other_node in other_graph.nodes.items():
            existing_node = self.get_node(node_name)
            if existing_node is not None:
                # Node exists, merge values if applicable
                if (
                    hasattr(existing_node, &#34;values&#34;)
                    and hasattr(other_node, &#34;values&#34;)
                    and isinstance(getattr(existing_node, &#34;values&#34;, None), dict)
                    and isinstance(getattr(other_node, &#34;values&#34;, None), dict)
                ):
                    try:
                        # Perform the update
                        existing_node.values.update(other_node.values)
                        nodes_updated += 1
                        logger.debug(f&#34;Merged values into existing node &#39;{node_name}&#39;&#34;)
                        # No need to call self.add_node(existing_node) as it&#39;s already there
                    except AttributeError:
                        # Should not happen due to hasattr checks, but defensive
                        logger.warning(
                            f&#34;Could not merge values for node &#39;{node_name}&#39; due to missing &#39;values&#39; attribute despite hasattr check.&#34;
                        )
                    except Exception as e:
                        logger.warning(
                            f&#34;Could not merge values for node &#39;{node_name}&#39;: {e}&#34;
                        )
                else:
                    # Nodes exist but cannot merge values (e.g., calculation nodes without stored values)
                    logger.debug(
                        f&#34;Node &#39;{node_name}&#39; exists in both graphs, but values not merged (missing/incompatible &#39;values&#39; attribute). Keeping target graph&#39;s node.&#34;
                    )
            else:
                # Node doesn&#39;t exist in target graph, add it
                try:
                    # Ensure we add a copy if nodes might be shared or mutable in complex ways,
                    # but for now, assume adding the instance is okay.
                    self.add_node(other_node)
                    nodes_added += 1
                except Exception:
                    logger.exception(
                        f&#34;Failed to add new node &#39;{node_name}&#39; during merge:&#34;
                    )

        logger.info(
            f&#34;Merge complete. Nodes added: {nodes_added}, Nodes updated (values merged): {nodes_updated}&#34;
        )

    # --- Adjustment Management API ---

    def add_adjustment(
        self,
        node_name: str,
        period: str,
        value: float,
        reason: str,
        adj_type: AdjustmentType = AdjustmentType.ADDITIVE,
        scale: float = 1.0,
        priority: int = 0,
        tags: Optional[set[AdjustmentTag]] = None,
        scenario: Optional[str] = None,
        user: Optional[str] = None,
        start_period: Optional[str] = None,  # Phase 2
        end_period: Optional[str] = None,  # Phase 2
        adj_id: Optional[UUID] = None,  # Allow specifying ID, e.g., for re-creation
    ) -&gt; UUID:
        &#34;&#34;&#34;Adds a discretionary adjustment to a specific node and period.

        Creates an Adjustment object and delegates storage to the AdjustmentManager.

        Args:
            node_name: The name of the target node.
            period: The primary period the adjustment applies to.
            value: The numeric value of the adjustment.
            reason: Text description of why the adjustment was made.
            adj_type: How the adjustment combines with the base value.
            scale: Attenuation factor for the adjustment (0.0 to 1.0, Phase 2).
            priority: Tie-breaker for applying multiple adjustments (lower number applied first).
            tags: Set of descriptive tags for filtering and analysis.
            scenario: The named scenario this adjustment belongs to. Defaults to DEFAULT_SCENARIO if None.
            user: Identifier for the user who created the adjustment.
            start_period: The first period the adjustment is effective (inclusive, Phase 2).
            end_period: The last period the adjustment is effective (inclusive, Phase 2).
            adj_id: Optional specific UUID to use for the adjustment.

        Returns:
            The UUID of the created or updated adjustment.

        Raises:
            NodeError: If the target node_name does not exist in the graph.
            ValidationError: If adjustment parameters are invalid (e.g., scale out of bounds).
        &#34;&#34;&#34;
        if not self.has_node(node_name):
            raise NodeError(
                f&#34;Cannot add adjustment: Node &#39;{node_name}&#39; not found.&#34;,
                node_id=node_name,
            )

        # Need Pydantic&#39;s ValidationError and uuid4
        from pydantic import ValidationError
        from uuid import uuid4

        # Need Adjustment model details
        from fin_statement_model.core.adjustments.models import Adjustment

        # Assign default scenario if None was passed
        actual_scenario = scenario if scenario is not None else DEFAULT_SCENARIO

        # Create the adjustment object - Pydantic handles validation (e.g., scale)
        try:
            adj = Adjustment(
                id=adj_id or uuid4(),  # Generate new ID if not provided
                node_name=node_name,
                period=period,
                start_period=start_period,
                end_period=end_period,
                value=value,
                type=adj_type,
                scale=scale,
                priority=priority,
                tags=tags or set(),
                scenario=actual_scenario,  # Use the actual scenario
                reason=reason,
                user=user,
                # timestamp is added automatically by the model
            )
        except ValidationError:
            logger.exception(f&#34;Failed to create adjustment for node &#39;{node_name}&#39;&#34;)
            raise  # Re-raise Pydantic&#39;s validation error

        self.adjustment_manager.add_adjustment(adj)
        logger.info(
            f&#34;Added adjustment {adj.id} for node &#39;{node_name}&#39;, period &#39;{period}&#39;, scenario &#39;{scenario}&#39;.&#34;
        )
        return adj.id

    def remove_adjustment(self, adj_id: UUID) -&gt; bool:
        &#34;&#34;&#34;Removes an adjustment by its unique ID.

        Args:
            adj_id: The UUID of the adjustment to remove.

        Returns:
            True if an adjustment was found and removed, False otherwise.
        &#34;&#34;&#34;
        removed = self.adjustment_manager.remove_adjustment(adj_id)
        if removed:
            logger.info(f&#34;Removed adjustment {adj_id}.&#34;)
        else:
            logger.warning(f&#34;Attempted to remove non-existent adjustment {adj_id}.&#34;)
        return removed

    def get_adjustments(
        self, node_name: str, period: str, *, scenario: Optional[str] = None
    ) -&gt; list[Adjustment]:
        &#34;&#34;&#34;Retrieves all adjustments for a specific node, period, and scenario.

        Args:
            node_name: The name of the target node.
            period: The target period.
            scenario: The scenario to retrieve adjustments for. Defaults to DEFAULT_SCENARIO if None.

        Returns:
            A list of Adjustment objects matching the criteria, sorted by application order.
        &#34;&#34;&#34;
        if not self.has_node(node_name):
            # Or return empty list? Returning empty seems safer.
            logger.warning(f&#34;Node &#39;{node_name}&#39; not found when getting adjustments.&#34;)
            return []
        # Assign default scenario if None was passed
        actual_scenario = scenario if scenario is not None else DEFAULT_SCENARIO
        return self.adjustment_manager.get_adjustments(
            node_name, period, scenario=actual_scenario
        )

    def list_all_adjustments(self) -&gt; list[Adjustment]:
        &#34;&#34;&#34;Returns a list of all adjustments currently managed by the graph.

        Returns:
            A list containing all Adjustment objects across all nodes, periods, and scenarios.
        &#34;&#34;&#34;
        return self.adjustment_manager.get_all_adjustments()

    def was_adjusted(
        self, node_name: str, period: str, filter_input: &#34;AdjustmentFilterInput&#34; = None
    ) -&gt; bool:
        &#34;&#34;&#34;Checks if a node&#39;s value for a given period was affected by any selected adjustments.

        Args:
            node_name: The name of the node to check.
            period: The time period identifier.
            filter_input: Criteria for selecting which adjustments to consider (same as get_adjusted_value).

        Returns:
            True if any adjustment matching the filter was applied to the base value, False otherwise.

        Raises:
            NodeError: If the specified node does not exist.
            CalculationError: If an error occurs during the underlying calculation.
            TypeError: If filter_input is an invalid type.
        &#34;&#34;&#34;
        try:
            _, was_adjusted_flag = self.get_adjusted_value(
                node_name, period, filter_input, return_flag=True
            )
            return was_adjusted_flag
        except (NodeError, CalculationError, TypeError):
            # Propagate errors consistently
            logger.exception(f&#34;Error checking if node &#39;{node_name}&#39; was adjusted&#34;)
            raise

    # --- End Adjustment Management API ---</code></pre>
</details>
<div class="desc"><p>Core directed-graph abstraction for financial statement modeling.</p>
<p>The <code><a title="fin_statement_model.Graph" href="#fin_statement_model.Graph">Graph</a></code> class orchestrates construction, mutation, traversal,
calculation, and forecasting of nodes representing financial statement
items and metrics. It exposes high-level convenience methods for
building and evaluating the model, while delegating structural
mutations and read-only inspections to its sub-APIs.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_nodes</code></strong></dt>
<dd>Mapping of node names (str) to Node instances registered in the graph.</dd>
<dt><strong><code>_periods</code></strong></dt>
<dd>Sorted list of unique period identifiers (str) managed by the graph.</dd>
<dt><strong><code>_cache</code></strong></dt>
<dd>Nested dict caching calculated float values per node per period.</dd>
<dt><strong><code>_node_factory</code></strong></dt>
<dd><code><a title="fin_statement_model.NodeFactory" href="#fin_statement_model.NodeFactory">NodeFactory</a></code> instance for creating new nodes.</dd>
<dt><strong><code>manipulator</code></strong></dt>
<dd><code>GraphManipulator</code> for structural mutations (add/remove/replace nodes, set values).</dd>
<dt><strong><code>traverser</code></strong></dt>
<dd><code>GraphTraverser</code> for read-only traversal, validation, and cycle detection.</dd>
<dt><strong><code>adjustment_manager</code></strong></dt>
<dd><code>AdjustmentManager</code> handling discretionary adjustments.</dd>
</dl>
<p>Initialize a new <code><a title="fin_statement_model.Graph" href="#fin_statement_model.Graph">Graph</a></code> instance.</p>
<p>Sets up core components: node registry, period list, calculation cache,
node factory, and sub-API instances (<code>manipulator</code>, <code>traverser</code>,
<code>adjustment_manager</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>periods</code></strong></dt>
<dd>Optional list of period identifiers (str) to initialize.
Periods are automatically deduplicated and sorted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>periods</code> is not a list of strings.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.graph.graph import Graph
&gt;&gt;&gt; g = Graph()
&gt;&gt;&gt; g.periods
[]
&gt;&gt;&gt; g = Graph(periods=[&quot;2024&quot;, &quot;2023&quot;])
&gt;&gt;&gt; g.periods
[&quot;2023&quot;, &quot;2024&quot;]
&gt;&gt;&gt; Graph(periods=&quot;2023&quot;)  # raises TypeError
</code></pre></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.Graph.nodes"><code class="name">prop <span class="ident">nodes</span> : dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodes(self) -&gt; dict[str, Node]:
    &#34;&#34;&#34;Provide access to the dictionary of all nodes in the graph.

    Returns:
        A dictionary where keys are node names (str) and values are
        `Node` objects. This dictionary represents the shared node registry.

    Examples:
        &gt;&gt;&gt; graph = Graph()
        &gt;&gt;&gt; item_node = graph.add_financial_statement_item(&#34;Revenue&#34;, {&#34;2023&#34;: 100})
        &gt;&gt;&gt; logger.info(list(graph.nodes.keys()))
        &gt;&gt;&gt; logger.info(graph.nodes[&#34;Revenue&#34;] == item_node)
    &#34;&#34;&#34;
    return self._nodes</code></pre>
</details>
<div class="desc"><p>Provide access to the dictionary of all nodes in the graph.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary where keys are node names (str) and values are
<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code> objects. This dictionary represents the shared node registry.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph = Graph()
&gt;&gt;&gt; item_node = graph.add_financial_statement_item(&quot;Revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; logger.info(list(graph.nodes.keys()))
&gt;&gt;&gt; logger.info(graph.nodes[&quot;Revenue&quot;] == item_node)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.periods"><code class="name">prop <span class="ident">periods</span> : list[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def periods(self) -&gt; list[str]:
    &#34;&#34;&#34;Retrieve the list of time periods currently managed by the graph.

    Returns:
        A sorted list of unique time period strings managed by the graph.

    Examples:
        &gt;&gt;&gt; graph = Graph(periods=[&#34;2024&#34;, &#34;2023&#34;])
        &gt;&gt;&gt; logger.info(graph.periods)
        &gt;&gt;&gt; graph.add_periods([&#34;2025&#34;])
        &gt;&gt;&gt; logger.info(graph.periods)
    &#34;&#34;&#34;
    return self._periods</code></pre>
</details>
<div class="desc"><p>Retrieve the list of time periods currently managed by the graph.</p>
<h2 id="returns">Returns</h2>
<p>A sorted list of unique time period strings managed by the graph.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph = Graph(periods=[&quot;2024&quot;, &quot;2023&quot;])
&gt;&gt;&gt; logger.info(graph.periods)
&gt;&gt;&gt; graph.add_periods([&quot;2025&quot;])
&gt;&gt;&gt; logger.info(graph.periods)
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.Graph.add_adjustment"><code class="name flex">
<span>def <span class="ident">add_adjustment</span></span>(<span>self,<br>node_name: str,<br>period: str,<br>value: float,<br>reason: str,<br>adj_type: <a title="fin_statement_model.core.adjustments.models.AdjustmentType" href="core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentType">AdjustmentType</a> = AdjustmentType.ADDITIVE,<br>scale: float = 1.0,<br>priority: int = 0,<br>tags: set[str] | None = None,<br>scenario: str | None = None,<br>user: str | None = None,<br>start_period: str | None = None,<br>end_period: str | None = None,<br>adj_id: uuid.UUID | None = None) ‑> uuid.UUID</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_adjustment(
    self,
    node_name: str,
    period: str,
    value: float,
    reason: str,
    adj_type: AdjustmentType = AdjustmentType.ADDITIVE,
    scale: float = 1.0,
    priority: int = 0,
    tags: Optional[set[AdjustmentTag]] = None,
    scenario: Optional[str] = None,
    user: Optional[str] = None,
    start_period: Optional[str] = None,  # Phase 2
    end_period: Optional[str] = None,  # Phase 2
    adj_id: Optional[UUID] = None,  # Allow specifying ID, e.g., for re-creation
) -&gt; UUID:
    &#34;&#34;&#34;Adds a discretionary adjustment to a specific node and period.

    Creates an Adjustment object and delegates storage to the AdjustmentManager.

    Args:
        node_name: The name of the target node.
        period: The primary period the adjustment applies to.
        value: The numeric value of the adjustment.
        reason: Text description of why the adjustment was made.
        adj_type: How the adjustment combines with the base value.
        scale: Attenuation factor for the adjustment (0.0 to 1.0, Phase 2).
        priority: Tie-breaker for applying multiple adjustments (lower number applied first).
        tags: Set of descriptive tags for filtering and analysis.
        scenario: The named scenario this adjustment belongs to. Defaults to DEFAULT_SCENARIO if None.
        user: Identifier for the user who created the adjustment.
        start_period: The first period the adjustment is effective (inclusive, Phase 2).
        end_period: The last period the adjustment is effective (inclusive, Phase 2).
        adj_id: Optional specific UUID to use for the adjustment.

    Returns:
        The UUID of the created or updated adjustment.

    Raises:
        NodeError: If the target node_name does not exist in the graph.
        ValidationError: If adjustment parameters are invalid (e.g., scale out of bounds).
    &#34;&#34;&#34;
    if not self.has_node(node_name):
        raise NodeError(
            f&#34;Cannot add adjustment: Node &#39;{node_name}&#39; not found.&#34;,
            node_id=node_name,
        )

    # Need Pydantic&#39;s ValidationError and uuid4
    from pydantic import ValidationError
    from uuid import uuid4

    # Need Adjustment model details
    from fin_statement_model.core.adjustments.models import Adjustment

    # Assign default scenario if None was passed
    actual_scenario = scenario if scenario is not None else DEFAULT_SCENARIO

    # Create the adjustment object - Pydantic handles validation (e.g., scale)
    try:
        adj = Adjustment(
            id=adj_id or uuid4(),  # Generate new ID if not provided
            node_name=node_name,
            period=period,
            start_period=start_period,
            end_period=end_period,
            value=value,
            type=adj_type,
            scale=scale,
            priority=priority,
            tags=tags or set(),
            scenario=actual_scenario,  # Use the actual scenario
            reason=reason,
            user=user,
            # timestamp is added automatically by the model
        )
    except ValidationError:
        logger.exception(f&#34;Failed to create adjustment for node &#39;{node_name}&#39;&#34;)
        raise  # Re-raise Pydantic&#39;s validation error

    self.adjustment_manager.add_adjustment(adj)
    logger.info(
        f&#34;Added adjustment {adj.id} for node &#39;{node_name}&#39;, period &#39;{period}&#39;, scenario &#39;{scenario}&#39;.&#34;
    )
    return adj.id</code></pre>
</details>
<div class="desc"><p>Adds a discretionary adjustment to a specific node and period.</p>
<p>Creates an Adjustment object and delegates storage to the AdjustmentManager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>The name of the target node.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The primary period the adjustment applies to.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The numeric value of the adjustment.</dd>
<dt><strong><code>reason</code></strong></dt>
<dd>Text description of why the adjustment was made.</dd>
<dt><strong><code>adj_type</code></strong></dt>
<dd>How the adjustment combines with the base value.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Attenuation factor for the adjustment (0.0 to 1.0, Phase 2).</dd>
<dt><strong><code>priority</code></strong></dt>
<dd>Tie-breaker for applying multiple adjustments (lower number applied first).</dd>
<dt><strong><code>tags</code></strong></dt>
<dd>Set of descriptive tags for filtering and analysis.</dd>
<dt><strong><code>scenario</code></strong></dt>
<dd>The named scenario this adjustment belongs to. Defaults to DEFAULT_SCENARIO if None.</dd>
<dt><strong><code>user</code></strong></dt>
<dd>Identifier for the user who created the adjustment.</dd>
<dt><strong><code>start_period</code></strong></dt>
<dd>The first period the adjustment is effective (inclusive, Phase 2).</dd>
<dt><strong><code>end_period</code></strong></dt>
<dd>The last period the adjustment is effective (inclusive, Phase 2).</dd>
<dt><strong><code>adj_id</code></strong></dt>
<dd>Optional specific UUID to use for the adjustment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The UUID of the created or updated adjustment.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If the target node_name does not exist in the graph.</dd>
<dt><code>ValidationError</code></dt>
<dd>If adjustment parameters are invalid (e.g., scale out of bounds).</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.add_calculation"><code class="name flex">
<span>def <span class="ident">add_calculation</span></span>(<span>self,<br>name: str,<br>input_names: list[str],<br>operation_type: str,<br>formula_variable_names: list[str] | None = None,<br>**calculation_kwargs: Any) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_calculation(
    self,
    name: str,
    input_names: list[str],
    operation_type: str,
    formula_variable_names: Optional[list[str]] = None,
    **calculation_kwargs: Any,
) -&gt; Node:
    &#34;&#34;&#34;Add a new calculation node to the graph using the node factory.

    Resolve input node names to Node objects, create a CalculationNode,
    register it in the graph, and return it.

    Args:
        name: Unique name for the calculation node.
        input_names: List of node names to use as inputs.
        operation_type: Calculation type key (e.g., &#39;addition&#39;).
        formula_variable_names: Optional list of variable names used in the formula
            string, required if creating a FormulaCalculationNode via this method.
        **calculation_kwargs: Additional parameters for the calculation constructor.

    Returns:
        The created calculation node.

    Raises:
        NodeError: If any input node name does not exist.
        ValueError: If the name is invalid or creation fails.
        TypeError: If inputs are invalid.
        CircularDependencyError: If adding the node would create a cycle.
    &#34;&#34;&#34;
    # Validate inputs
    if not isinstance(input_names, list):
        raise TypeError(&#34;input_names must be a list of node names.&#34;)

    # Resolve input node names to Node objects
    resolved_inputs = self._resolve_input_nodes(input_names)

    # Create the node via factory
    try:
        node = self._node_factory.create_calculation_node(
            name=name,
            inputs=resolved_inputs,
            calculation_type=operation_type,
            formula_variable_names=formula_variable_names,
            **calculation_kwargs,
        )
    except (ValueError, TypeError):
        logger.exception(
            f&#34;Failed to create calculation node &#39;{name}&#39; with type &#39;{operation_type}&#39;&#34;
        )
        raise

    # Add with validation (includes cycle detection)
    added_node = self._add_node_with_validation(node)

    logger.info(
        f&#34;Added calculation node &#39;{name}&#39; of type &#39;{operation_type}&#39; with inputs {input_names}&#34;
    )
    return added_node</code></pre>
</details>
<div class="desc"><p>Add a new calculation node to the graph using the node factory.</p>
<p>Resolve input node names to Node objects, create a CalculationNode,
register it in the graph, and return it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Unique name for the calculation node.</dd>
<dt><strong><code>input_names</code></strong></dt>
<dd>List of node names to use as inputs.</dd>
<dt><strong><code>operation_type</code></strong></dt>
<dd>Calculation type key (e.g., 'addition').</dd>
<dt><strong><code>formula_variable_names</code></strong></dt>
<dd>Optional list of variable names used in the formula
string, required if creating a FormulaCalculationNode via this method.</dd>
<dt><strong><code>**calculation_kwargs</code></strong></dt>
<dd>Additional parameters for the calculation constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The created calculation node.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If any input node name does not exist.</dd>
<dt><code>ValueError</code></dt>
<dd>If the name is invalid or creation fails.</dd>
<dt><code>TypeError</code></dt>
<dd>If inputs are invalid.</dd>
<dt><code>CircularDependencyError</code></dt>
<dd>If adding the node would create a cycle.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.add_custom_calculation"><code class="name flex">
<span>def <span class="ident">add_custom_calculation</span></span>(<span>self,<br>name: str,<br>calculation_func: Callable[..., float],<br>inputs: list[str] | None = None,<br>description: str = '') ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_custom_calculation(
    self,
    name: str,
    calculation_func: Callable[..., float],
    inputs: Optional[list[str]] = None,
    description: str = &#34;&#34;,
) -&gt; Node:
    &#34;&#34;&#34;Add a custom calculation node using a Python callable.

    Args:
        name: Unique name for the custom calculation node.
        calculation_func: A callable that accepts (period, **inputs) and returns float.
        inputs: Optional list of node names to use as inputs.
        description: Optional description of the calculation.

    Returns:
        The created custom calculation node.

    Raises:
        NodeError: If any specified input nodes are missing.
        TypeError: If calculation_func is not callable.
        CircularDependencyError: If adding the node would create a cycle.
    &#34;&#34;&#34;
    # Validate callable
    if not callable(calculation_func):
        raise TypeError(&#34;calculation_func must be callable.&#34;)

    # Resolve inputs if provided
    resolved_inputs: list[Node] = []
    if inputs is not None:
        if not isinstance(inputs, list):
            raise TypeError(&#34;inputs must be a list of node names.&#34;)
        resolved_inputs = self._resolve_input_nodes(inputs)

    # Create custom node via factory
    try:
        custom_node = self._node_factory._create_custom_node_from_callable(
            name=name,
            inputs=resolved_inputs,
            formula=calculation_func,
            description=description,
        )
    except (ValueError, TypeError):
        logger.exception(f&#34;Failed to create custom calculation node &#39;{name}&#39;&#34;)
        raise

    # Add with validation (includes cycle detection)
    added_node = self._add_node_with_validation(custom_node)

    logger.info(f&#34;Added custom calculation node &#39;{name}&#39; with inputs {inputs}&#34;)
    return added_node</code></pre>
</details>
<div class="desc"><p>Add a custom calculation node using a Python callable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Unique name for the custom calculation node.</dd>
<dt><strong><code>calculation_func</code></strong></dt>
<dd>A callable that accepts (period, **inputs) and returns float.</dd>
<dt><strong><code>inputs</code></strong></dt>
<dd>Optional list of node names to use as inputs.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description of the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The created custom calculation node.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If any specified input nodes are missing.</dd>
<dt><code>TypeError</code></dt>
<dd>If calculation_func is not callable.</dd>
<dt><code>CircularDependencyError</code></dt>
<dd>If adding the node would create a cycle.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.add_financial_statement_item"><code class="name flex">
<span>def <span class="ident">add_financial_statement_item</span></span>(<span>self, name: str, values: dict[str, float]) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_financial_statement_item(
    self, name: str, values: dict[str, float]
) -&gt; FinancialStatementItemNode:
    &#34;&#34;&#34;Add a basic financial statement item (data node) to the graph.

    Args:
        name: Unique name for the financial statement item node.
        values: Mapping of period strings to float values for this item.

    Returns:
        The newly created `FinancialStatementItemNode`.

    Raises:
        ValueError: If node name is invalid.
        TypeError: If `values` is not a dict or contains invalid types.

    Examples:
        &gt;&gt;&gt; item_node = graph.add_financial_statement_item(&#34;SG&amp;A&#34;, {&#34;2023&#34;: 50.0})
        &gt;&gt;&gt; item_node.calculate(&#34;2023&#34;)
        50.0
    &#34;&#34;&#34;
    # Validate inputs
    if not isinstance(values, dict):
        raise TypeError(&#34;Values must be provided as a dict[str, float]&#34;)

    # Create a new financial statement item node
    new_node = self._node_factory.create_financial_statement_item(
        name=name, values=values.copy()
    )

    # Add with validation (no cycle detection needed for data nodes)
    # Cast to FinancialStatementItemNode for correct return type
    from typing import cast

    added_node = cast(
        FinancialStatementItemNode,
        self._add_node_with_validation(
            new_node,
            check_cycles=False,  # Data nodes don&#39;t have inputs, so no cycles possible
            validate_inputs=False,  # Data nodes don&#39;t have inputs to validate
        ),
    )

    logger.info(
        f&#34;Added FinancialStatementItemNode &#39;{name}&#39; with periods {list(values.keys())}&#34;
    )
    return added_node</code></pre>
</details>
<div class="desc"><p>Add a basic financial statement item (data node) to the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Unique name for the financial statement item node.</dd>
<dt><strong><code>values</code></strong></dt>
<dd>Mapping of period strings to float values for this item.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The newly created <code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If node name is invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>values</code> is not a dict or contains invalid types.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; item_node = graph.add_financial_statement_item(&quot;SG&amp;A&quot;, {&quot;2023&quot;: 50.0})
&gt;&gt;&gt; item_node.calculate(&quot;2023&quot;)
50.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.add_metric"><code class="name flex">
<span>def <span class="ident">add_metric</span></span>(<span>self,<br>metric_name: str,<br>node_name: str | None = None,<br>*,<br>input_node_map: dict[str, str] | None = None) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metric(
    self,
    metric_name: str,
    node_name: Optional[str] = None,
    *,
    input_node_map: Optional[dict[str, str]] = None,
) -&gt; Node:
    &#34;&#34;&#34;Add a metric calculation node based on a metric definition.

    If `node_name` is None, uses `metric_name` as the node name.

    Uses the metric registry to load inputs and formula, creates a
    calculation node using the formula strategy, registers it, and stores metric
    metadata on the node itself.

    Args:
        metric_name: Key of the metric definition to add.
        node_name: Optional name for the metric node; defaults to metric_name.
        input_node_map: Optional dictionary mapping metric input variable names
            (from metric definition) to the actual node names present in the graph.
            If None, assumes graph node names match metric input variable names.

    Returns:
        The created calculation node.

    Raises:
        TypeError: If node_name is invalid.
        ValueError: If node_name already exists.
        ConfigurationError: If metric definition is missing or invalid.
        NodeError: If required input nodes (after mapping) are missing.
    &#34;&#34;&#34;
    # Default node_name to metric_name if not provided
    if node_name is None:
        node_name = metric_name
    if not node_name or not isinstance(node_name, str):
        raise TypeError(&#34;Metric node name must be a non-empty string.&#34;)
    # Check for name conflict
    if node_name in self._nodes:
        raise ValueError(
            f&#34;A node with name &#39;{node_name}&#39; already exists in the graph.&#34;
        )

    # Load metric definition (Pydantic model)
    try:
        metric_def = metric_registry.get(metric_name)
    except KeyError as e:
        raise ConfigurationError(
            f&#34;Unknown metric definition: &#39;{metric_name}&#39;&#34;
        ) from e

    # Extract required fields from definition
    required_inputs = metric_def.inputs
    formula = metric_def.formula
    description = metric_def.description

    # Build list of input node names and formula variable names
    input_node_names: list[str] = []
    formula_variable_names: list[str] = []
    missing = []

    for req_input_name in required_inputs:
        # Determine the actual graph node name to look for
        target_node_name = req_input_name  # Default case
        if input_node_map and req_input_name in input_node_map:
            target_node_name = input_node_map[req_input_name]
        elif input_node_map:
            # If map provided but doesn&#39;t contain the required input, it&#39;s an error in the map
            missing.append(f&#34;{req_input_name} (mapping missing in input_node_map)&#34;)
            continue  # Skip trying to find the node

        # Check if the node exists in the graph
        if target_node_name not in self._nodes:
            missing.append(target_node_name)  # Report the name we looked for
        else:
            input_node_names.append(target_node_name)
            formula_variable_names.append(
                req_input_name
            )  # Use the metric&#39;s variable name

    if missing:
        raise NodeError(
            f&#34;Cannot create metric &#39;{metric_name}&#39;: missing required nodes {missing}&#34;,
            node_id=node_name,
        )

    # Create calculation node using add_calculation
    try:
        new_node = self.add_calculation(
            name=node_name,
            input_names=input_node_names,
            operation_type=&#34;formula&#34;,
            formula_variable_names=formula_variable_names,
            formula=formula,
            metric_name=metric_name,  # Pass metric metadata
            metric_description=description,  # Pass metric description
        )
    except Exception as e:
        logger.exception(
            f&#34;Failed to create calculation node for metric &#39;{metric_name}&#39; as node &#39;{node_name}&#39;&#34;
        )
        # Re-raise as ConfigurationError or keep original, depending on desired error reporting
        raise ConfigurationError(
            f&#34;Error creating node for metric &#39;{metric_name}&#39;: {e}&#34;
        ) from e

    logger.info(
        f&#34;Added metric &#39;{metric_name}&#39; as calculation node &#39;{node_name}&#39; with inputs {input_node_names}&#34;
    )
    return new_node</code></pre>
</details>
<div class="desc"><p>Add a metric calculation node based on a metric definition.</p>
<p>If <code>node_name</code> is None, uses <code>metric_name</code> as the node name.</p>
<p>Uses the metric registry to load inputs and formula, creates a
calculation node using the formula strategy, registers it, and stores metric
metadata on the node itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_name</code></strong></dt>
<dd>Key of the metric definition to add.</dd>
<dt><strong><code>node_name</code></strong></dt>
<dd>Optional name for the metric node; defaults to metric_name.</dd>
<dt><strong><code>input_node_map</code></strong></dt>
<dd>Optional dictionary mapping metric input variable names
(from metric definition) to the actual node names present in the graph.
If None, assumes graph node names match metric input variable names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The created calculation node.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If node_name is invalid.</dd>
<dt><code>ValueError</code></dt>
<dd>If node_name already exists.</dd>
<dt><code>ConfigurationError</code></dt>
<dd>If metric definition is missing or invalid.</dd>
<dt><code>NodeError</code></dt>
<dd>If required input nodes (after mapping) are missing.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, node: Node) -&gt; None:
    &#34;&#34;&#34;Add a node to the graph.

    Args:
        node: A ``Node`` instance to add to the graph.

    Raises:
        TypeError: If the provided object is not a Node instance.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000})
        &gt;&gt;&gt; graph.add_node(node)
    &#34;&#34;&#34;
    from fin_statement_model.core.nodes.base import Node as _NodeBase

    if not isinstance(node, _NodeBase):
        raise TypeError(f&#34;Expected Node instance, got {type(node).__name__}&#34;)

    return self.manipulator.add_node(node)</code></pre>
</details>
<div class="desc"><p>Add a node to the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>A <code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code> instance to add to the graph.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the provided object is not a Node instance.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode
&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000})
&gt;&gt;&gt; graph.add_node(node)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.add_periods"><code class="name flex">
<span>def <span class="ident">add_periods</span></span>(<span>self, periods: list[str]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_periods(self, periods: list[str]) -&gt; None:
    &#34;&#34;&#34;Add new time periods to the graph.

    Update the internal period list, ensuring uniqueness and sorting.

    Args:
        periods: A list of strings representing the time periods to add.

    Raises:
        TypeError: If `periods` is not a list.
    &#34;&#34;&#34;
    if not isinstance(periods, list):
        raise TypeError(&#34;Periods must be provided as a list.&#34;)
    # Ensure unique and sorted periods
    combined = set(self._periods).union(periods)
    self._periods = sorted(combined)
    logger.debug(f&#34;Added periods {periods}; current periods: {self._periods}&#34;)</code></pre>
</details>
<div class="desc"><p>Add new time periods to the graph.</p>
<p>Update the internal period list, ensuring uniqueness and sorting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>periods</code></strong></dt>
<dd>A list of strings representing the time periods to add.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>periods</code> is not a list.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.breadth_first_search"><code class="name flex">
<span>def <span class="ident">breadth_first_search</span></span>(<span>self, start_node: str, direction: str = 'successors') ‑> list[list[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def breadth_first_search(
    self, start_node: str, direction: str = &#34;successors&#34;
) -&gt; list[list[str]]:
    &#34;&#34;&#34;Perform a breadth-first search (BFS) traversal of the graph.

    Args:
        start_node: The starting node ID for BFS.
        direction: Either &#39;successors&#39; or &#39;predecessors&#39; to traverse.

    Returns:
        A nested list of node IDs per BFS level.

    Raises:
        ValueError: If `direction` is not &#39;successors&#39; or &#39;predecessors&#39;.

    Examples:
        &gt;&gt;&gt; graph.breadth_first_search(&#34;Revenue&#34;, &#34;successors&#34;)
    &#34;&#34;&#34;
    return self.traverser.breadth_first_search(start_node, direction)</code></pre>
</details>
<div class="desc"><p>Perform a breadth-first search (BFS) traversal of the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_node</code></strong></dt>
<dd>The starting node ID for BFS.</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>Either 'successors' or 'predecessors' to traverse.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A nested list of node IDs per BFS level.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>direction</code> is not 'successors' or 'predecessors'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.breadth_first_search(&quot;Revenue&quot;, &quot;successors&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, node_name: str, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, node_name: str, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate and return the value of a specific node for a given period.

    This method uses internal caching to speed repeated calls, and wraps
    underlying errors in CalculationError for clarity.

    Args:
        node_name: Name of the node to calculate.
        period: Time period identifier for the calculation.

    Returns:
        The calculated float value for the node and period.

    Raises:
        NodeError: If the specified node does not exist.
        TypeError: If the node has no callable `calculate` method.
        CalculationError: If an error occurs during the node&#39;s calculation.

    Examples:
        &gt;&gt;&gt; value = graph.calculate(&#34;Revenue&#34;, &#34;2023&#34;)
    &#34;&#34;&#34;
    # Return cached value if present
    if node_name in self._cache and period in self._cache[node_name]:
        logger.debug(f&#34;Cache hit for node &#39;{node_name}&#39;, period &#39;{period}&#39;&#34;)
        return self._cache[node_name][period]
    # Resolve node
    node = self.manipulator.get_node(node_name)
    if node is None:
        raise NodeError(f&#34;Node &#39;{node_name}&#39; not found&#34;, node_id=node_name)
    # Validate calculate method
    if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
        raise TypeError(f&#34;Node &#39;{node_name}&#39; has no callable calculate method.&#34;)
    # Perform calculation with error handling
    try:
        value = node.calculate(period)
    except (
        NodeError,
        ConfigurationError,
        CalculationError,
        ValueError,
        KeyError,
        ZeroDivisionError,
    ) as e:
        logger.error(
            f&#34;Error calculating node &#39;{node_name}&#39; for period &#39;{period}&#39;: {e}&#34;,
            exc_info=True,
        )
        raise CalculationError(
            message=f&#34;Failed to calculate node &#39;{node_name}&#39;&#34;,
            node_id=node_name,
            period=period,
            details={&#34;original_error&#34;: str(e)},
        ) from e
    # Cache and return
    self._cache.setdefault(node_name, {})[period] = value
    logger.debug(f&#34;Cached value for node &#39;{node_name}&#39;, period &#39;{period}&#39;: {value}&#34;)
    return value</code></pre>
</details>
<div class="desc"><p>Calculate and return the value of a specific node for a given period.</p>
<p>This method uses internal caching to speed repeated calls, and wraps
underlying errors in CalculationError for clarity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node to calculate.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Time period identifier for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The calculated float value for the node and period.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If the specified node does not exist.</dd>
<dt><code>TypeError</code></dt>
<dd>If the node has no callable <code>calculate</code> method.</dd>
<dt><code>CalculationError</code></dt>
<dd>If an error occurs during the node's calculation.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; value = graph.calculate(&quot;Revenue&quot;, &quot;2023&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.change_calculation_method"><code class="name flex">
<span>def <span class="ident">change_calculation_method</span></span>(<span>self, node_name: str, new_method_key: str, **kwargs: dict[str, typing.Any]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_calculation_method(
    self,
    node_name: str,
    new_method_key: str,
    **kwargs: dict[str, Any],
) -&gt; None:
    &#34;&#34;&#34;Change the calculation method for an existing calculation-based node.

    Args:
        node_name: Name of the existing calculation node.
        new_method_key: Key of the new calculation method to apply.
        **kwargs: Additional parameters required by the new calculation.

    Returns:
        None

    Raises:
        NodeError: If the target node does not exist or is not a CalculationNode.
        ValueError: If `new_method_key` is not a recognized calculation key.
        TypeError: If the new calculation cannot be instantiated with the provided arguments.

    Examples:
        &gt;&gt;&gt; graph.change_calculation_method(&#34;GrossProfit&#34;, &#34;addition&#34;)
    &#34;&#34;&#34;
    node = self.manipulator.get_node(node_name)
    if node is None:
        raise NodeError(&#34;Node not found for calculation change&#34;, node_id=node_name)
    if not isinstance(node, CalculationNode):
        raise NodeError(
            f&#34;Node &#39;{node_name}&#39; is not a CalculationNode&#34;, node_id=node_name
        )
    # Map method key to registry name
    if new_method_key not in self._node_factory._calculation_methods:
        raise ValueError(f&#34;Calculation &#39;{new_method_key}&#39; is not recognized.&#34;)
    calculation_class_name = self._node_factory._calculation_methods[new_method_key]
    try:
        calculation_cls = Registry.get(calculation_class_name)
    except KeyError as e:
        raise ValueError(
            f&#34;Calculation class &#39;{calculation_class_name}&#39; not found in registry.&#34;
        ) from e
    try:
        calculation_instance = calculation_cls(**kwargs)
    except TypeError as e:
        raise TypeError(
            f&#34;Failed to instantiate calculation &#39;{new_method_key}&#39;: {e}&#34;
        )
    # Apply new calculation
    node.set_calculation(calculation_instance)
    # Clear cached calculations for this node
    if node_name in self._cache:
        del self._cache[node_name]
    logger.info(f&#34;Changed calculation for node &#39;{node_name}&#39; to &#39;{new_method_key}&#39;&#34;)</code></pre>
</details>
<div class="desc"><p>Change the calculation method for an existing calculation-based node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the existing calculation node.</dd>
<dt><strong><code>new_method_key</code></strong></dt>
<dd>Key of the new calculation method to apply.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional parameters required by the new calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If the target node does not exist or is not a CalculationNode.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>new_method_key</code> is not a recognized calculation key.</dd>
<dt><code>TypeError</code></dt>
<dd>If the new calculation cannot be instantiated with the provided arguments.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.change_calculation_method(&quot;GrossProfit&quot;, &quot;addition&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Reset the graph by clearing nodes, periods, adjustments, and caches.&#34;&#34;&#34;
    self._nodes = {}
    self._periods = []
    self._cache = {}

    # --- Adjustment Manager Integration ---
    self.adjustment_manager.clear_all()
    # --- End Adjustment Manager Integration ---

    logger.info(&#34;Graph cleared: nodes, periods, adjustments, and caches reset.&#34;)</code></pre>
</details>
<div class="desc"><p>Reset the graph by clearing nodes, periods, adjustments, and caches.</p></div>
</dd>
<dt id="fin_statement_model.Graph.clear_all_caches"><code class="name flex">
<span>def <span class="ident">clear_all_caches</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_all_caches(self) -&gt; None:
    &#34;&#34;&#34;Clear all node-level and central calculation caches.

    Returns:
        None

    Examples:
        &gt;&gt;&gt; graph.clear_all_caches()
    &#34;&#34;&#34;
    logger.debug(f&#34;Clearing node-level caches for {len(self.nodes)} nodes.&#34;)
    for node in self.nodes.values():
        if hasattr(node, &#34;clear_cache&#34;):
            try:
                node.clear_cache()
            except Exception as e:
                logger.warning(f&#34;Failed to clear cache for node &#39;{node.name}&#39;: {e}&#34;)
    # Clear central calculation cache
    self.clear_calculation_cache()
    logger.debug(&#34;Cleared central calculation cache.&#34;)</code></pre>
</details>
<div class="desc"><p>Clear all node-level and central calculation caches.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.clear_all_caches()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.clear_calculation_cache"><code class="name flex">
<span>def <span class="ident">clear_calculation_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_calculation_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the graph&#39;s internal calculation cache.

    Returns:
        None

    Examples:
        &gt;&gt;&gt; graph.clear_calculation_cache()
    &#34;&#34;&#34;
    self._cache.clear()
    logger.debug(&#34;Cleared graph calculation cache.&#34;)</code></pre>
</details>
<div class="desc"><p>Clear the graph's internal calculation cache.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.clear_calculation_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.detect_cycles"><code class="name flex">
<span>def <span class="ident">detect_cycles</span></span>(<span>self) ‑> list[list[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_cycles(self) -&gt; list[list[str]]:
    &#34;&#34;&#34;Detect all cycles in the graph&#39;s dependency structure.

    Returns:
        A list of cycles, each represented as a list of node IDs.

    Examples:
        &gt;&gt;&gt; graph.detect_cycles()
    &#34;&#34;&#34;
    return self.traverser.detect_cycles()</code></pre>
</details>
<div class="desc"><p>Detect all cycles in the graph's dependency structure.</p>
<h2 id="returns">Returns</h2>
<p>A list of cycles, each represented as a list of node IDs.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.detect_cycles()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.ensure_signed_nodes"><code class="name flex">
<span>def <span class="ident">ensure_signed_nodes</span></span>(<span>self, base_node_ids: list[str], *, suffix: str = '_signed') ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_signed_nodes(
    self, base_node_ids: list[str], *, suffix: str = &#34;_signed&#34;
) -&gt; list[str]:
    &#34;&#34;&#34;Ensure signed calculation nodes (-1 * input) exist for each base node.

    Args:
        base_node_ids: List of existing node names to sign.
        suffix: Suffix to append for signed node names.

    Returns:
        List of names of newly created signed nodes.
    &#34;&#34;&#34;
    created: list[str] = []
    for base_id in base_node_ids:
        signed_id = f&#34;{base_id}{suffix}&#34;
        # Skip if already present
        if signed_id in self._nodes:
            continue
        # Ensure base node exists
        if base_id not in self._nodes:
            from fin_statement_model.core.errors import NodeError

            raise NodeError(
                f&#34;Cannot create signed node for missing base node &#39;{base_id}&#39;&#34;,
                node_id=base_id,
            )
        # Create formula node that multiplies by -1
        self.add_calculation(
            name=signed_id,
            input_names=[base_id],
            operation_type=&#34;formula&#34;,
            formula=&#34;-input_0&#34;,
            formula_variable_names=[&#34;input_0&#34;],
        )
        created.append(signed_id)
    return created</code></pre>
</details>
<div class="desc"><p>Ensure signed calculation nodes (-1 * input) exist for each base node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_node_ids</code></strong></dt>
<dd>List of existing node names to sign.</dd>
<dt><strong><code>suffix</code></strong></dt>
<dd>Suffix to append for signed node names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of names of newly created signed nodes.</p></div>
</dd>
<dt id="fin_statement_model.Graph.export_adjustments_to_excel"><code class="name flex">
<span>def <span class="ident">export_adjustments_to_excel</span></span>(<span>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>path: str | pathlib.Path) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_adjustments_to_excel(graph: Graph, path: str | Path) -&gt; None:
    &#34;&#34;&#34;Exports all adjustments from the graph to an Excel file.

    Args:
        graph: The Graph instance containing adjustments.
        path: Path for the output Excel file.
    &#34;&#34;&#34;
    logger.info(f&#34;Exporting all adjustments from graph to Excel ({path}).&#34;)
    all_adjustments = graph.list_all_adjustments()
    write_excel(all_adjustments, path)</code></pre>
</details>
<div class="desc"><p>Exports all adjustments from the graph to an Excel file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The Graph instance containing adjustments.</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path for the output Excel file.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.get_adjusted_value"><code class="name flex">
<span>def <span class="ident">get_adjusted_value</span></span>(<span>self,<br>node_name: str,<br>period: str,<br>filter_input: AdjustmentFilterInput = None,<br>*,<br>return_flag: bool = False) ‑> float | tuple[float, bool]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_adjusted_value(
    self,
    node_name: str,
    period: str,
    filter_input: &#34;AdjustmentFilterInput&#34; = None,
    *,
    return_flag: bool = False,
) -&gt; float | tuple[float, bool]:
    &#34;&#34;&#34;Calculates the value of a node for a period, applying selected adjustments.

    Fetches the base calculated value, retrieves adjustments matching the filter,
    applies them in order, and returns the result.

    Args:
        node_name: The name of the node to calculate.
        period: The time period identifier.
        filter_input: Criteria for selecting which adjustments to apply. Can be:
            - None: applies default filter (default scenario, all adjustments).
            - AdjustmentFilter: filter by scenarios, tags, types, and period window.
            - set of tags: shorthand for include_tags filter.
            - Callable[[Adjustment], bool] or Callable[[Adjustment, str], bool]:
                predicate to select adjustments. Two-arg predicates receive
                the current period as the second argument.
        return_flag: If True, return a tuple (adjusted_value, was_adjusted_flag);
                     if False (default), return only the adjusted_value.

    Returns:
        The adjusted float value, or a tuple (value, flag) if return_flag is True.

    Raises:
        NodeError: If the specified node does not exist.
        CalculationError: If an error occurs during the base calculation or adjustment application.
        TypeError: If filter_input is an invalid type.
    &#34;&#34;&#34;
    # 1. Get the base value (result of underlying node calculation)
    try:
        base_value = self.calculate(node_name, period)
    except (NodeError, CalculationError, TypeError):
        # Propagate errors from base calculation
        logger.exception(
            f&#34;Error getting base value for &#39;{node_name}&#39; in period &#39;{period}&#39;&#34;
        )
        raise

    # 2. Get filtered adjustments from the manager
    try:
        adjustments_to_apply = self.adjustment_manager.get_filtered_adjustments(
            node_name=node_name, period=period, filter_input=filter_input
        )
    except TypeError:
        logger.exception(&#34;Invalid filter type provided for get_adjusted_value&#34;)
        raise

    # 3. Apply the adjustments
    adjusted_value, was_adjusted = self.adjustment_manager.apply_adjustments(
        base_value, adjustments_to_apply
    )

    # 4. Return result based on flag
    if return_flag:
        return adjusted_value, was_adjusted
    else:
        return adjusted_value</code></pre>
</details>
<div class="desc"><p>Calculates the value of a node for a period, applying selected adjustments.</p>
<p>Fetches the base calculated value, retrieves adjustments matching the filter,
applies them in order, and returns the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>The name of the node to calculate.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period identifier.</dd>
<dt><strong><code>filter_input</code></strong></dt>
<dd>Criteria for selecting which adjustments to apply. Can be:
- None: applies default filter (default scenario, all adjustments).
- AdjustmentFilter: filter by scenarios, tags, types, and period window.
- set of tags: shorthand for include_tags filter.
- Callable[[Adjustment], bool] or Callable[[Adjustment, str], bool]:
predicate to select adjustments. Two-arg predicates receive
the current period as the second argument.</dd>
<dt><strong><code>return_flag</code></strong></dt>
<dd>If True, return a tuple (adjusted_value, was_adjusted_flag);
if False (default), return only the adjusted_value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The adjusted float value, or a tuple (value, flag) if return_flag is True.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If the specified node does not exist.</dd>
<dt><code>CalculationError</code></dt>
<dd>If an error occurs during the base calculation or adjustment application.</dd>
<dt><code>TypeError</code></dt>
<dd>If filter_input is an invalid type.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.get_adjustments"><code class="name flex">
<span>def <span class="ident">get_adjustments</span></span>(<span>self, node_name: str, period: str, *, scenario: str | None = None) ‑> list[<a title="fin_statement_model.core.adjustments.models.Adjustment" href="core/adjustments/models.html#fin_statement_model.core.adjustments.models.Adjustment">Adjustment</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_adjustments(
    self, node_name: str, period: str, *, scenario: Optional[str] = None
) -&gt; list[Adjustment]:
    &#34;&#34;&#34;Retrieves all adjustments for a specific node, period, and scenario.

    Args:
        node_name: The name of the target node.
        period: The target period.
        scenario: The scenario to retrieve adjustments for. Defaults to DEFAULT_SCENARIO if None.

    Returns:
        A list of Adjustment objects matching the criteria, sorted by application order.
    &#34;&#34;&#34;
    if not self.has_node(node_name):
        # Or return empty list? Returning empty seems safer.
        logger.warning(f&#34;Node &#39;{node_name}&#39; not found when getting adjustments.&#34;)
        return []
    # Assign default scenario if None was passed
    actual_scenario = scenario if scenario is not None else DEFAULT_SCENARIO
    return self.adjustment_manager.get_adjustments(
        node_name, period, scenario=actual_scenario
    )</code></pre>
</details>
<div class="desc"><p>Retrieves all adjustments for a specific node, period, and scenario.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>The name of the target node.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The target period.</dd>
<dt><strong><code>scenario</code></strong></dt>
<dd>The scenario to retrieve adjustments for. Defaults to DEFAULT_SCENARIO if None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of Adjustment objects matching the criteria, sorted by application order.</p></div>
</dd>
<dt id="fin_statement_model.Graph.get_available_metrics"><code class="name flex">
<span>def <span class="ident">get_available_metrics</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_available_metrics(self) -&gt; list[str]:
    &#34;&#34;&#34;Return a sorted list of all metric node IDs currently in the graph.

    Identifies metric nodes by checking for the presence and non-None value
    of the `metric_name` attribute.

    Returns:
        A sorted list of metric node names.

    Examples:
        &gt;&gt;&gt; graph.get_available_metrics()
        [&#39;current_ratio&#39;, &#39;debt_equity_ratio&#39;]
    &#34;&#34;&#34;
    # Iterate through all nodes and collect names of those that are metrics
    metric_node_names = [
        node.name
        for node in self._nodes.values()
        if getattr(node, &#34;metric_name&#34;, None) is not None
    ]
    return sorted(metric_node_names)</code></pre>
</details>
<div class="desc"><p>Return a sorted list of all metric node IDs currently in the graph.</p>
<p>Identifies metric nodes by checking for the presence and non-None value
of the <code>metric_name</code> attribute.</p>
<h2 id="returns">Returns</h2>
<p>A sorted list of metric node names.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.get_available_metrics()
['current_ratio', 'debt_equity_ratio']
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_calculation_nodes"><code class="name flex">
<span>def <span class="ident">get_calculation_nodes</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calculation_nodes(self) -&gt; list[str]:
    &#34;&#34;&#34;Get all calculation node IDs in the graph.

    Returns:
        A list of node names that have associated calculations.

    Examples:
        &gt;&gt;&gt; graph.get_calculation_nodes()
    &#34;&#34;&#34;
    return self.traverser.get_calculation_nodes()</code></pre>
</details>
<div class="desc"><p>Get all calculation node IDs in the graph.</p>
<h2 id="returns">Returns</h2>
<p>A list of node names that have associated calculations.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.get_calculation_nodes()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self, node_id: str) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self, node_id: str) -&gt; list[str]:
    &#34;&#34;&#34;Get the direct predecessor node IDs (dependencies) for a given node.

    Args:
        node_id: The name of the node to inspect.

    Returns:
        A list of node IDs that the given node depends on.

    Examples:
        &gt;&gt;&gt; graph.get_dependencies(&#34;GrossProfit&#34;)
    &#34;&#34;&#34;
    return self.traverser.get_dependencies(node_id)</code></pre>
</details>
<div class="desc"><p>Get the direct predecessor node IDs (dependencies) for a given node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The name of the node to inspect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of node IDs that the given node depends on.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.get_dependencies(&quot;GrossProfit&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_dependency_graph"><code class="name flex">
<span>def <span class="ident">get_dependency_graph</span></span>(<span>self) ‑> dict[str, list[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependency_graph(self) -&gt; dict[str, list[str]]:
    &#34;&#34;&#34;Get the full dependency graph mapping of node IDs to their inputs.

    Returns:
        A dict mapping each node ID to a list of its dependency node IDs.

    Examples:
        &gt;&gt;&gt; graph.get_dependency_graph()
    &#34;&#34;&#34;
    return self.traverser.get_dependency_graph()</code></pre>
</details>
<div class="desc"><p>Get the full dependency graph mapping of node IDs to their inputs.</p>
<h2 id="returns">Returns</h2>
<p>A dict mapping each node ID to a list of its dependency node IDs.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.get_dependency_graph()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_direct_predecessors"><code class="name flex">
<span>def <span class="ident">get_direct_predecessors</span></span>(<span>self, node_id: str) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_direct_predecessors(self, node_id: str) -&gt; list[str]:
    &#34;&#34;&#34;Get immediate predecessor node IDs (inputs) for a given node.

    Args:
        node_id: The name of the node to inspect.

    Returns:
        A list of node IDs that the given node directly depends on.

    Examples:
        &gt;&gt;&gt; graph.get_direct_predecessors(&#34;GrossProfit&#34;)
    &#34;&#34;&#34;
    return self.traverser.get_direct_predecessors(node_id)</code></pre>
</details>
<div class="desc"><p>Get immediate predecessor node IDs (inputs) for a given node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The name of the node to inspect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of node IDs that the given node directly depends on.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.get_direct_predecessors(&quot;GrossProfit&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_direct_successors"><code class="name flex">
<span>def <span class="ident">get_direct_successors</span></span>(<span>self, node_id: str) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_direct_successors(self, node_id: str) -&gt; list[str]:
    &#34;&#34;&#34;Get immediate successor node IDs for a given node.

    Args:
        node_id: The name of the node to inspect.

    Returns:
        A list of node IDs that directly follow the given node.

    Examples:
        &gt;&gt;&gt; graph.get_direct_successors(&#34;Revenue&#34;)
    &#34;&#34;&#34;
    return self.traverser.get_direct_successors(node_id)</code></pre>
</details>
<div class="desc"><p>Get immediate successor node IDs for a given node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The name of the node to inspect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of node IDs that directly follow the given node.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.get_direct_successors(&quot;Revenue&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_financial_statement_items"><code class="name flex">
<span>def <span class="ident">get_financial_statement_items</span></span>(<span>self) ‑> list[<a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_financial_statement_items(self) -&gt; list[Node]:
    &#34;&#34;&#34;Retrieve all financial statement item nodes from the graph.

    Returns:
        A list of `FinancialStatementItemNode` objects currently in the graph.

    Examples:
        &gt;&gt;&gt; items = graph.get_financial_statement_items()
    &#34;&#34;&#34;
    from fin_statement_model.core.nodes import (
        FinancialStatementItemNode,
    )  # Keep import local as it&#39;s specific

    return [
        node
        for node in self.nodes.values()
        if isinstance(node, FinancialStatementItemNode)
    ]</code></pre>
</details>
<div class="desc"><p>Retrieve all financial statement item nodes from the graph.</p>
<h2 id="returns">Returns</h2>
<p>A list of <code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code> objects currently in the graph.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; items = graph.get_financial_statement_items()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_metric"><code class="name flex">
<span>def <span class="ident">get_metric</span></span>(<span>self, metric_id: str) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metric(self, metric_id: str) -&gt; Optional[Node]:
    &#34;&#34;&#34;Return the metric node for a given metric ID, if present.

    Searches for a node with the given ID that was created as a metric
    (identified by having a `metric_name` attribute).

    Args:
        metric_id: Identifier of the metric node to retrieve.

    Returns:
        The Node corresponding to `metric_id` if it&#39;s a metric node, or None.

    Examples:
        &gt;&gt;&gt; m = graph.get_metric(&#34;current_ratio&#34;)
        &gt;&gt;&gt; if m:
        ...     logger.info(m.name)
    &#34;&#34;&#34;
    node = self._nodes.get(metric_id)
    # Check if the node exists and has the metric_name attribute populated
    if node and getattr(node, &#34;metric_name&#34;, None) == metric_id:
        return node
    return None</code></pre>
</details>
<div class="desc"><p>Return the metric node for a given metric ID, if present.</p>
<p>Searches for a node with the given ID that was created as a metric
(identified by having a <code>metric_name</code> attribute).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_id</code></strong></dt>
<dd>Identifier of the metric node to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Node corresponding to <code>metric_id</code> if it's a metric node, or None.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = graph.get_metric(&quot;current_ratio&quot;)
&gt;&gt;&gt; if m:
...     logger.info(m.name)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_metric_info"><code class="name flex">
<span>def <span class="ident">get_metric_info</span></span>(<span>self, metric_id: str) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metric_info(self, metric_id: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Return detailed information for a specific metric node.

    Args:
        metric_id: Identifier of the metric node to inspect.

    Returns:
        A dict containing &#39;id&#39;, &#39;name&#39;, &#39;description&#39;, and &#39;inputs&#39; for the metric.

    Raises:
        ValueError: If `metric_id` does not correspond to a metric node.

    Examples:
        &gt;&gt;&gt; info = graph.get_metric_info(&#34;current_ratio&#34;)
        &gt;&gt;&gt; logger.info(info[&#39;inputs&#39;])
    &#34;&#34;&#34;
    metric_node = self.get_metric(metric_id)
    if metric_node is None:
        if metric_id in self._nodes:
            raise ValueError(
                f&#34;Node &#39;{metric_id}&#39; exists but is not a metric (missing metric_name attribute).&#34;
            )
        raise ValueError(f&#34;Metric node &#39;{metric_id}&#39; not found in graph.&#34;)

    # Extract info directly from the FormulaCalculationNode
    try:
        # Use getattr for safety, retrieving stored metric metadata
        description = getattr(metric_node, &#34;metric_description&#34;, &#34;N/A&#34;)
        # metric_name stored on the node is the key from the registry
        registry_key = getattr(metric_node, &#34;metric_name&#34;, metric_id)

        # We might want the display name from the original definition.
        # Fetch the definition again if needed for the display name.
        try:
            metric_def = metric_registry.get(registry_key)
            display_name = metric_def.name
        except Exception:
            logger.warning(
                f&#34;Could not reload metric definition for &#39;{registry_key}&#39; to get display name. Using node name &#39;{metric_id}&#39; instead.&#34;
            )
            display_name = metric_id  # Fallback to node name

        inputs = metric_node.get_dependencies()
    except Exception as e:
        # Catch potential attribute errors or other issues
        logger.error(
            f&#34;Error retrieving info for metric node &#39;{metric_id}&#39;: {e}&#34;,
            exc_info=True,
        )
        raise ValueError(
            f&#34;Failed to retrieve metric info for &#39;{metric_id}&#39;: {e}&#34;
        ) from e

    return {
        &#34;id&#34;: metric_id,
        &#34;name&#34;: display_name,
        &#34;description&#34;: description,
        &#34;inputs&#34;: inputs,
    }</code></pre>
</details>
<div class="desc"><p>Return detailed information for a specific metric node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_id</code></strong></dt>
<dd>Identifier of the metric node to inspect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing 'id', 'name', 'description', and 'inputs' for the metric.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>metric_id</code> does not correspond to a metric node.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; info = graph.get_metric_info(&quot;current_ratio&quot;)
&gt;&gt;&gt; logger.info(info['inputs'])
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>self, name: str) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node(self, name: str) -&gt; Optional[Node]:
    &#34;&#34;&#34;Retrieve a node from the graph by its name.

    Args:
        name: The unique name of the node to retrieve.

    Returns:
        The `Node` instance if found, else None.

    Examples:
        &gt;&gt;&gt; node = graph.get_node(&#34;Revenue&#34;)
    &#34;&#34;&#34;
    return self.manipulator.get_node(name)</code></pre>
</details>
<div class="desc"><p>Retrieve a node from the graph by its name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The unique name of the node to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The <code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code> instance if found, else None.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = graph.get_node(&quot;Revenue&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.has_cycle"><code class="name flex">
<span>def <span class="ident">has_cycle</span></span>(<span>self,<br>source_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>target_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_cycle(self, source_node: Node, target_node: Node) -&gt; bool:
    &#34;&#34;&#34;Check if a cycle exists from a source node to a target node.

    This method delegates to GraphTraverser to determine if `target_node` is
    reachable from `source_node` via successors, indicating that adding an edge
    from `target_node` to `source_node` would create a cycle.

    Args:
        source_node: The starting node for cycle detection.
        target_node: The node to detect return path to.

    Returns:
        True if a cycle exists, False otherwise.
    &#34;&#34;&#34;
    if source_node.name not in self._nodes or target_node.name not in self._nodes:
        return False

    # Use GraphTraverser&#39;s reachability check
    return self.traverser._is_reachable(source_node.name, target_node.name)</code></pre>
</details>
<div class="desc"><p>Check if a cycle exists from a source node to a target node.</p>
<p>This method delegates to GraphTraverser to determine if <code>target_node</code> is
reachable from <code>source_node</code> via successors, indicating that adding an edge
from <code>target_node</code> to <code>source_node</code> would create a cycle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_node</code></strong></dt>
<dd>The starting node for cycle detection.</dd>
<dt><strong><code>target_node</code></strong></dt>
<dd>The node to detect return path to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if a cycle exists, False otherwise.</p></div>
</dd>
<dt id="fin_statement_model.Graph.has_node"><code class="name flex">
<span>def <span class="ident">has_node</span></span>(<span>self, node_id: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_node(self, node_id: str) -&gt; bool:
    &#34;&#34;&#34;Check if a node with the given ID exists in the graph.

    Args:
        node_id: The name of the node to check.

    Returns:
        True if the node exists, False otherwise.

    Examples:
        &gt;&gt;&gt; graph.has_node(&#34;Revenue&#34;)
    &#34;&#34;&#34;
    return self.manipulator.has_node(node_id)</code></pre>
</details>
<div class="desc"><p>Check if a node with the given ID exists in the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The name of the node to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the node exists, False otherwise.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.has_node(&quot;Revenue&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.list_all_adjustments"><code class="name flex">
<span>def <span class="ident">list_all_adjustments</span></span>(<span>self) ‑> list[<a title="fin_statement_model.core.adjustments.models.Adjustment" href="core/adjustments/models.html#fin_statement_model.core.adjustments.models.Adjustment">Adjustment</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_all_adjustments(self) -&gt; list[Adjustment]:
    &#34;&#34;&#34;Returns a list of all adjustments currently managed by the graph.

    Returns:
        A list containing all Adjustment objects across all nodes, periods, and scenarios.
    &#34;&#34;&#34;
    return self.adjustment_manager.get_all_adjustments()</code></pre>
</details>
<div class="desc"><p>Returns a list of all adjustments currently managed by the graph.</p>
<h2 id="returns">Returns</h2>
<p>A list containing all Adjustment objects across all nodes, periods, and scenarios.</p></div>
</dd>
<dt id="fin_statement_model.Graph.load_adjustments_from_excel"><code class="name flex">
<span>def <span class="ident">load_adjustments_from_excel</span></span>(<span>graph: <a title="fin_statement_model.core.graph.graph.Graph" href="core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>path: str | pathlib.Path,<br>replace: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_adjustments_from_excel(
    graph: Graph, path: str | Path, replace: bool = False
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Reads adjustments from Excel and adds them to the graph.

    Args:
        graph: The Graph instance to add adjustments to.
        path: Path to the Excel file.
        replace: If True, clear existing adjustments in the manager before adding new ones.

    Returns:
        pd.DataFrame: The error report DataFrame from `read_excel`.
                   Empty if no errors occurred.
    &#34;&#34;&#34;
    logger.info(
        f&#34;Loading adjustments from Excel ({path}) into graph. Replace={replace}&#34;
    )
    valid_adjustments, error_report_df = read_excel(path)

    if replace:
        logger.debug(&#34;Clearing existing adjustments before loading.&#34;)
        graph.adjustment_manager.clear_all()

    added_count = 0
    for adj in valid_adjustments:
        try:
            graph.adjustment_manager.add_adjustment(adj)
            added_count += 1
        except Exception as e:
            logger.error(
                f&#34;Failed to add valid adjustment {adj.id} to graph: {e}&#34;, exc_info=True
            )
            # Optionally add this failure to the error report?
            error_row = adj.model_dump(mode=&#34;json&#34;)
            error_row[&#34;error&#34;] = f&#34;Failed to add to graph: {e}&#34;
            # Need to handle DataFrame append carefully if modifying during iteration
            # Simplest is to report read errors, log add errors.

    logger.info(f&#34;Added {added_count} adjustments to the graph from {path}.&#34;)
    if not error_report_df.empty:
        logger.warning(
            f&#34;Encountered {len(error_report_df)} errors during Excel read process.&#34;
        )

    return error_report_df</code></pre>
</details>
<div class="desc"><p>Reads adjustments from Excel and adds them to the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The Graph instance to add adjustments to.</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the Excel file.</dd>
<dt><strong><code>replace</code></strong></dt>
<dd>If True, clear existing adjustments in the manager before adding new ones.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The error report DataFrame from <code>read_excel</code>.
Empty if no errors occurred.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.merge_from"><code class="name flex">
<span>def <span class="ident">merge_from</span></span>(<span>self,<br>other_graph: <a title="fin_statement_model.Graph" href="#fin_statement_model.Graph">Graph</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_from(self, other_graph: &#34;Graph&#34;) -&gt; None:
    &#34;&#34;&#34;Merge nodes and periods from another Graph into this one.

    Adds periods from the other graph if they don&#39;t exist in this graph.
    Adds nodes from the other graph if they don&#39;t exist.
    If a node exists in both graphs, attempts to merge the &#39;values&#39; dictionary
    from the other graph&#39;s node into this graph&#39;s node.

    Args:
        other_graph: The Graph instance to merge data from.

    Raises:
        TypeError: If other_graph is not a Graph instance.
    &#34;&#34;&#34;
    if not isinstance(other_graph, Graph):
        raise TypeError(&#34;Can only merge from another Graph instance.&#34;)

    logger.info(f&#34;Starting merge from graph {other_graph!r} into {self!r}&#34;)

    # 1. Update periods
    new_periods = [p for p in other_graph.periods if p not in self.periods]
    if new_periods:
        self.add_periods(new_periods)
        logger.debug(f&#34;Merged periods: {new_periods}&#34;)

    # 2. Merge nodes
    nodes_added = 0
    nodes_updated = 0
    for node_name, other_node in other_graph.nodes.items():
        existing_node = self.get_node(node_name)
        if existing_node is not None:
            # Node exists, merge values if applicable
            if (
                hasattr(existing_node, &#34;values&#34;)
                and hasattr(other_node, &#34;values&#34;)
                and isinstance(getattr(existing_node, &#34;values&#34;, None), dict)
                and isinstance(getattr(other_node, &#34;values&#34;, None), dict)
            ):
                try:
                    # Perform the update
                    existing_node.values.update(other_node.values)
                    nodes_updated += 1
                    logger.debug(f&#34;Merged values into existing node &#39;{node_name}&#39;&#34;)
                    # No need to call self.add_node(existing_node) as it&#39;s already there
                except AttributeError:
                    # Should not happen due to hasattr checks, but defensive
                    logger.warning(
                        f&#34;Could not merge values for node &#39;{node_name}&#39; due to missing &#39;values&#39; attribute despite hasattr check.&#34;
                    )
                except Exception as e:
                    logger.warning(
                        f&#34;Could not merge values for node &#39;{node_name}&#39;: {e}&#34;
                    )
            else:
                # Nodes exist but cannot merge values (e.g., calculation nodes without stored values)
                logger.debug(
                    f&#34;Node &#39;{node_name}&#39; exists in both graphs, but values not merged (missing/incompatible &#39;values&#39; attribute). Keeping target graph&#39;s node.&#34;
                )
        else:
            # Node doesn&#39;t exist in target graph, add it
            try:
                # Ensure we add a copy if nodes might be shared or mutable in complex ways,
                # but for now, assume adding the instance is okay.
                self.add_node(other_node)
                nodes_added += 1
            except Exception:
                logger.exception(
                    f&#34;Failed to add new node &#39;{node_name}&#39; during merge:&#34;
                )

    logger.info(
        f&#34;Merge complete. Nodes added: {nodes_added}, Nodes updated (values merged): {nodes_updated}&#34;
    )</code></pre>
</details>
<div class="desc"><p>Merge nodes and periods from another Graph into this one.</p>
<p>Adds periods from the other graph if they don't exist in this graph.
Adds nodes from the other graph if they don't exist.
If a node exists in both graphs, attempts to merge the 'values' dictionary
from the other graph's node into this graph's node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other_graph</code></strong></dt>
<dd>The Graph instance to merge data from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If other_graph is not a Graph instance.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Graph.recalculate_all"><code class="name flex">
<span>def <span class="ident">recalculate_all</span></span>(<span>self, periods: list[str] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recalculate_all(self, periods: Optional[list[str]] = None) -&gt; None:
    &#34;&#34;&#34;Recalculate all nodes for given periods, clearing all caches first.

    Args:
        periods: List of period strings, a single string, or None to use all periods.

    Returns:
        None

    Raises:
        TypeError: If `periods` is not a list, string, or None.

    Examples:
        &gt;&gt;&gt; graph.recalculate_all([&#34;2023&#34;, &#34;2024&#34;])
    &#34;&#34;&#34;
    # Normalize periods input
    if periods is None:
        periods_to_use = self.periods
    elif isinstance(periods, str):
        periods_to_use = [periods]
    elif isinstance(periods, list):
        periods_to_use = periods
    else:
        raise TypeError(
            &#34;Periods must be a list of strings, a single string, or None.&#34;
        )
    # Clear all caches (node-level and central) to force full recalculation
    self.clear_all_caches()
    if not periods_to_use:
        return
    # Recalculate each node for each period
    for node_name in list(self._nodes.keys()):
        for period in periods_to_use:
            try:
                self.calculate(node_name, period)
            except Exception as e:
                logger.warning(
                    f&#34;Error recalculating node &#39;{node_name}&#39; for period &#39;{period}&#39;: {e}&#34;
                )</code></pre>
</details>
<div class="desc"><p>Recalculate all nodes for given periods, clearing all caches first.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>periods</code></strong></dt>
<dd>List of period strings, a single string, or None to use all periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>periods</code> is not a list, string, or None.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.recalculate_all([&quot;2023&quot;, &quot;2024&quot;])
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.remove_adjustment"><code class="name flex">
<span>def <span class="ident">remove_adjustment</span></span>(<span>self, adj_id: uuid.UUID) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_adjustment(self, adj_id: UUID) -&gt; bool:
    &#34;&#34;&#34;Removes an adjustment by its unique ID.

    Args:
        adj_id: The UUID of the adjustment to remove.

    Returns:
        True if an adjustment was found and removed, False otherwise.
    &#34;&#34;&#34;
    removed = self.adjustment_manager.remove_adjustment(adj_id)
    if removed:
        logger.info(f&#34;Removed adjustment {adj_id}.&#34;)
    else:
        logger.warning(f&#34;Attempted to remove non-existent adjustment {adj_id}.&#34;)
    return removed</code></pre>
</details>
<div class="desc"><p>Removes an adjustment by its unique ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>adj_id</code></strong></dt>
<dd>The UUID of the adjustment to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if an adjustment was found and removed, False otherwise.</p></div>
</dd>
<dt id="fin_statement_model.Graph.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node_name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node(self, node_name: str) -&gt; None:
    &#34;&#34;&#34;Remove a node from the graph by name, updating dependencies.

    Args:
        node_name: The name of the node to remove.

    Returns:
        None

    Examples:
        &gt;&gt;&gt; graph.remove_node(&#34;OldItem&#34;)
    &#34;&#34;&#34;
    return self.manipulator.remove_node(node_name)</code></pre>
</details>
<div class="desc"><p>Remove a node from the graph by name, updating dependencies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>The name of the node to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.remove_node(&quot;OldItem&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.replace_node"><code class="name flex">
<span>def <span class="ident">replace_node</span></span>(<span>self,<br>node_name: str,<br>new_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_node(self, node_name: str, new_node: Node) -&gt; None:
    &#34;&#34;&#34;Replace an existing node with a new node instance.

    Args:
        node_name: Name of the node to replace.
        new_node: The new `Node` instance to substitute.

    Returns:
        None

    Examples:
        &gt;&gt;&gt; graph.replace_node(&#34;Item&#34;, updated_node)
    &#34;&#34;&#34;
    return self.manipulator.replace_node(node_name, new_node)</code></pre>
</details>
<div class="desc"><p>Replace an existing node with a new node instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node to replace.</dd>
<dt><strong><code>new_node</code></strong></dt>
<dd>The new <code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code> instance to substitute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.replace_node(&quot;Item&quot;, updated_node)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, node_id: str, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, node_id: str, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set or update the value for a node in a specific period.

    Args:
        node_id: The name of the node.
        period: The period identifier to set the value for.
        value: The float value to assign.

    Returns:
        None

    Raises:
        ValueError: If the period is not recognized by the graph.
        NodeError: If the node does not exist.
        TypeError: If the node does not support setting a value.

    Examples:
        &gt;&gt;&gt; graph.set_value(&#34;SG&amp;A&#34;, &#34;2024&#34;, 55.0)
    &#34;&#34;&#34;
    return self.manipulator.set_value(node_id, period, value)</code></pre>
</details>
<div class="desc"><p>Set or update the value for a node in a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The name of the node.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The period identifier to set the value for.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The float value to assign.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the period is not recognized by the graph.</dd>
<dt><code>NodeError</code></dt>
<dd>If the node does not exist.</dd>
<dt><code>TypeError</code></dt>
<dd>If the node does not support setting a value.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.set_value(&quot;SG&amp;A&quot;, &quot;2024&quot;, 55.0)
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.topological_sort"><code class="name flex">
<span>def <span class="ident">topological_sort</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topological_sort(self) -&gt; list[str]:
    &#34;&#34;&#34;Perform a topological sort of all graph nodes.

    Returns:
        A list of node IDs in topological order.

    Raises:
        ValueError: If a cycle is detected in the graph.

    Examples:
        &gt;&gt;&gt; order = graph.topological_sort()
    &#34;&#34;&#34;
    return self.traverser.topological_sort()</code></pre>
</details>
<div class="desc"><p>Perform a topological sort of all graph nodes.</p>
<h2 id="returns">Returns</h2>
<p>A list of node IDs in topological order.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a cycle is detected in the graph.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; order = graph.topological_sort()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.update_financial_statement_item"><code class="name flex">
<span>def <span class="ident">update_financial_statement_item</span></span>(<span>self, name: str, values: dict[str, float], replace_existing: bool = False) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_financial_statement_item(
    self, name: str, values: dict[str, float], replace_existing: bool = False
) -&gt; FinancialStatementItemNode:
    &#34;&#34;&#34;Update values for an existing financial statement item node.

    Args:
        name: Name of the existing financial statement item node.
        values: Mapping of new period strings to float values.
        replace_existing: If True, replace existing values entirely; otherwise merge.

    Returns:
        The updated `FinancialStatementItemNode`.

    Raises:
        NodeError: If the node does not exist.
        TypeError: If the node is not a `FinancialStatementItemNode` or `values` is not a dict.

    Examples:
        &gt;&gt;&gt; graph.update_financial_statement_item(&#34;SG&amp;A&#34;, {&#34;2024&#34;: 60.0})
    &#34;&#34;&#34;
    node = self.manipulator.get_node(name)
    if node is None:
        raise NodeError(&#34;Node not found&#34;, node_id=name)
    if not isinstance(node, FinancialStatementItemNode):
        raise TypeError(f&#34;Node &#39;{name}&#39; is not a FinancialStatementItemNode&#34;)
    if not isinstance(values, dict):
        raise TypeError(&#34;Values must be provided as a dict[str, float]&#34;)
    if replace_existing:
        node.values = values.copy()
    else:
        node.values.update(values)
    self.add_periods(list(values.keys()))
    logger.info(
        f&#34;Updated FinancialStatementItemNode &#39;{name}&#39; with periods {list(values.keys())}; replace_existing={replace_existing}&#34;
    )
    return node</code></pre>
</details>
<div class="desc"><p>Update values for an existing financial statement item node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the existing financial statement item node.</dd>
<dt><strong><code>values</code></strong></dt>
<dd>Mapping of new period strings to float values.</dd>
<dt><strong><code>replace_existing</code></strong></dt>
<dd>If True, replace existing values entirely; otherwise merge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated <code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If the node does not exist.</dd>
<dt><code>TypeError</code></dt>
<dd>If the node is not a <code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code> or <code>values</code> is not a dict.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.update_financial_statement_item(&quot;SG&amp;A&quot;, {&quot;2024&quot;: 60.0})
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self) -&gt; list[str]:
    &#34;&#34;&#34;Validate the graph structure for errors such as cycles or missing nodes.

    Returns:
        A list of validation error messages, empty if valid.

    Examples:
        &gt;&gt;&gt; graph.validate()
    &#34;&#34;&#34;
    return self.traverser.validate()</code></pre>
</details>
<div class="desc"><p>Validate the graph structure for errors such as cycles or missing nodes.</p>
<h2 id="returns">Returns</h2>
<p>A list of validation error messages, empty if valid.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.validate()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Graph.was_adjusted"><code class="name flex">
<span>def <span class="ident">was_adjusted</span></span>(<span>self, node_name: str, period: str, filter_input: AdjustmentFilterInput = None) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def was_adjusted(
    self, node_name: str, period: str, filter_input: &#34;AdjustmentFilterInput&#34; = None
) -&gt; bool:
    &#34;&#34;&#34;Checks if a node&#39;s value for a given period was affected by any selected adjustments.

    Args:
        node_name: The name of the node to check.
        period: The time period identifier.
        filter_input: Criteria for selecting which adjustments to consider (same as get_adjusted_value).

    Returns:
        True if any adjustment matching the filter was applied to the base value, False otherwise.

    Raises:
        NodeError: If the specified node does not exist.
        CalculationError: If an error occurs during the underlying calculation.
        TypeError: If filter_input is an invalid type.
    &#34;&#34;&#34;
    try:
        _, was_adjusted_flag = self.get_adjusted_value(
            node_name, period, filter_input, return_flag=True
        )
        return was_adjusted_flag
    except (NodeError, CalculationError, TypeError):
        # Propagate errors consistently
        logger.exception(f&#34;Error checking if node &#39;{node_name}&#39; was adjusted&#34;)
        raise</code></pre>
</details>
<div class="desc"><p>Checks if a node's value for a given period was affected by any selected adjustments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>The name of the node to check.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period identifier.</dd>
<dt><strong><code>filter_input</code></strong></dt>
<dd>Criteria for selecting which adjustments to consider (same as get_adjusted_value).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if any adjustment matching the filter was applied to the base value, False otherwise.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NodeError</code></dt>
<dd>If the specified node does not exist.</dd>
<dt><code>CalculationError</code></dt>
<dd>If an error occurs during the underlying calculation.</dd>
<dt><code>TypeError</code></dt>
<dd>If filter_input is an invalid type.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.MultiPeriodStatNode"><code class="flex name class">
<span>class <span class="ident">MultiPeriodStatNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>periods: list[str],<br>stat_func: Callable[..., Any] = &lt;function stdev&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiPeriodStatNode(Node):
    &#34;&#34;&#34;Compute a statistical measure over multiple periods.

    Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.

    Attributes:
        input_node (Node): Node providing source values.
        periods (list[str]): Period identifiers to include.
        stat_func (StatFunc): Function to apply to collected values.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
        &gt;&gt;&gt; data = {&#34;Q1&#34;: 10, &#34;Q2&#34;: 12, &#34;Q3&#34;: 11, &#34;Q4&#34;: 13}
        &gt;&gt;&gt; sales = FinancialStatementItemNode(&#34;sales&#34;, data)
        &gt;&gt;&gt; avg = MultiPeriodStatNode(&#34;avg_sales&#34;, input_node=sales, periods=[&#34;Q1&#34;,&#34;Q2&#34;,&#34;Q3&#34;,&#34;Q4&#34;], stat_func=statistics.mean)
        &gt;&gt;&gt; avg.calculate()
        11.5
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        input_node: Node,
        periods: list[str],
        stat_func: StatFunc = statistics.stdev,  # Default to standard deviation
    ):
        &#34;&#34;&#34;Create a MultiPeriodStatNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values.
            periods (list[str]): Period identifiers to analyze.
            stat_func (StatFunc): Function applied to collected values. Defaults to statistics.stdev.

        Raises:
            ValueError: If `periods` is empty or not a list.
            TypeError: If `input_node` is not a Node or `stat_func` is not callable.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;MultiPeriodStatNode input_node must be a Node instance.&#34;)
        if not isinstance(periods, list) or not periods:
            raise ValueError(&#34;MultiPeriodStatNode periods must be a non-empty list.&#34;)
        if not all(isinstance(p, str) for p in periods):
            raise TypeError(&#34;MultiPeriodStatNode periods must contain only strings.&#34;)
        if not callable(stat_func):
            raise TypeError(
                &#34;MultiPeriodStatNode stat_func must be a callable function.&#34;
            )

        self.input_node = input_node
        self.periods = periods
        self.stat_func = stat_func

    def calculate(self, period: Optional[str] = None) -&gt; float:
        &#34;&#34;&#34;Compute the statistical measure across specified periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

        Raises:
            CalculationError: If input retrieval fails or unexpected errors occur.
        &#34;&#34;&#34;
        values: list[Numeric] = []
        retrieval_errors = []
        try:
            for p in self.periods:
                try:
                    value = self.input_node.calculate(p)
                    if isinstance(value, int | float) and math.isfinite(value):
                        values.append(float(value))
                    else:
                        # Log non-numeric/non-finite values but continue if possible
                        logger.warning(
                            f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: Input &#39;{self.input_node.name}&#39; gave non-numeric/non-finite value ({value}) for period &#39;{p}&#39;. Skipping.&#34;
                        )
                except Exception as node_err:
                    # Log error fetching data for a specific period but continue
                    logger.error(
                        f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: Error getting value for period &#39;{p}&#39; from &#39;{self.input_node.name}&#39;: {node_err}&#34;,
                        exc_info=True,
                    )
                    retrieval_errors.append(p)

            # If no valid numeric values were collected
            if not values:
                logger.warning(
                    f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: No valid numeric data points found across periods {self.periods}. Returning NaN.&#34;
                )
                return float(&#34;nan&#34;)

            # Attempt the statistical calculation
            try:
                result = self.stat_func(values)
                # Ensure result is float, handle potential NaN from stat_func
                return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
            except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
                # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
                logger.warning(
                    f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: Stat function &#39;{self.stat_func.__name__}&#39; failed ({stat_err}). Values: {values}. Returning NaN.&#34;
                )
                return float(&#34;nan&#34;)

        except Exception as e:
            # Catch any other unexpected errors during the process
            raise CalculationError(
                message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=&#34;multi-period&#34;,  # Indicate calculation context
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;periods&#34;: self.periods,
                    &#34;stat_func&#34;: self.stat_func.__name__,
                    &#34;collected_values_count&#34;: len(values),
                    &#34;retrieval_errors_periods&#34;: retrieval_errors,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized data with function name and periods.

        Note:
            `stat_func` may not be fully serializable; manual reconstruction may be required.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;multi_period_stat&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;periods&#34;: self.periods.copy(),
            &#34;stat_func_name&#34;: self.stat_func.__name__,
            &#34;serialization_warning&#34;: (
                &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
                &#34;Manual reconstruction may be required for custom functions.&#34;
            ),
        }

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;MultiPeriodStatNode&#34;:
        &#34;&#34;&#34;Recreate a MultiPeriodStatNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node]): Existing nodes for dependencies.

        Returns:
            MultiPeriodStatNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;multi_period_stat&#34;:
            raise ValueError(
                f&#34;Invalid type for MultiPeriodStatNode: {data.get(&#39;type&#39;)}&#34;
            )

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in MultiPeriodStatNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(
                &#34;Missing &#39;input_node_name&#39; field in MultiPeriodStatNode data&#34;
            )

        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        periods = data.get(&#34;periods&#34;, [])
        stat_func_name = data.get(&#34;stat_func_name&#34;, &#34;stdev&#34;)

        if not periods:
            raise ValueError(
                &#34;Missing or empty &#39;periods&#39; field in MultiPeriodStatNode data&#34;
            )

        # Map common statistical function names to their implementations
        stat_func_map: dict[str, StatFunc] = {
            &#34;mean&#34;: statistics.mean,
            &#34;stdev&#34;: statistics.stdev,
            &#34;median&#34;: statistics.median,
            &#34;variance&#34;: statistics.variance,
            &#34;pstdev&#34;: statistics.pstdev,
            &#34;pvariance&#34;: statistics.pvariance,
        }

        stat_func = stat_func_map.get(stat_func_name, statistics.stdev)
        if stat_func_name not in stat_func_map:
            logger.warning(
                f&#34;Unknown stat_func_name &#39;{stat_func_name}&#39; for MultiPeriodStatNode &#39;{name}&#39;. &#34;
                f&#34;Using default statistics.stdev.&#34;
            )

        return MultiPeriodStatNode(
            name=name,
            input_node=input_node,
            periods=periods,
            stat_func=stat_func,
        )</code></pre>
</details>
<div class="desc"><p>Compute a statistical measure over multiple periods.</p>
<p>Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to include.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function to apply to collected values.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
&gt;&gt;&gt; data = {&quot;Q1&quot;: 10, &quot;Q2&quot;: 12, &quot;Q3&quot;: 11, &quot;Q4&quot;: 13}
&gt;&gt;&gt; sales = FinancialStatementItemNode(&quot;sales&quot;, data)
&gt;&gt;&gt; avg = MultiPeriodStatNode(&quot;avg_sales&quot;, input_node=sales, periods=[&quot;Q1&quot;,&quot;Q2&quot;,&quot;Q3&quot;,&quot;Q4&quot;], stat_func=statistics.mean)
&gt;&gt;&gt; avg.calculate()
11.5
</code></pre>
<p>Create a MultiPeriodStatNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to analyze.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function applied to collected values. Defaults to statistics.stdev.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>periods</code> is empty or not a list.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or <code>stat_func</code> is not callable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.MultiPeriodStatNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;MultiPeriodStatNode&#34;:
    &#34;&#34;&#34;Recreate a MultiPeriodStatNode from serialized data.

    Args:
        data (dict[str, Any]): Serialized node data.
        context (dict[str, Node]): Existing nodes for dependencies.

    Returns:
        MultiPeriodStatNode: Reconstructed node.

    Raises:
        ValueError: If required fields are missing or invalid.
    &#34;&#34;&#34;
    if data.get(&#34;type&#34;) != &#34;multi_period_stat&#34;:
        raise ValueError(
            f&#34;Invalid type for MultiPeriodStatNode: {data.get(&#39;type&#39;)}&#34;
        )

    name = data.get(&#34;name&#34;)
    if not name:
        raise ValueError(&#34;Missing &#39;name&#39; field in MultiPeriodStatNode data&#34;)

    input_node_name = data.get(&#34;input_node_name&#34;)
    if not input_node_name:
        raise ValueError(
            &#34;Missing &#39;input_node_name&#39; field in MultiPeriodStatNode data&#34;
        )

    if input_node_name not in context:
        raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

    input_node = context[input_node_name]
    periods = data.get(&#34;periods&#34;, [])
    stat_func_name = data.get(&#34;stat_func_name&#34;, &#34;stdev&#34;)

    if not periods:
        raise ValueError(
            &#34;Missing or empty &#39;periods&#39; field in MultiPeriodStatNode data&#34;
        )

    # Map common statistical function names to their implementations
    stat_func_map: dict[str, StatFunc] = {
        &#34;mean&#34;: statistics.mean,
        &#34;stdev&#34;: statistics.stdev,
        &#34;median&#34;: statistics.median,
        &#34;variance&#34;: statistics.variance,
        &#34;pstdev&#34;: statistics.pstdev,
        &#34;pvariance&#34;: statistics.pvariance,
    }

    stat_func = stat_func_map.get(stat_func_name, statistics.stdev)
    if stat_func_name not in stat_func_map:
        logger.warning(
            f&#34;Unknown stat_func_name &#39;{stat_func_name}&#39; for MultiPeriodStatNode &#39;{name}&#39;. &#34;
            f&#34;Using default statistics.stdev.&#34;
        )

    return MultiPeriodStatNode(
        name=name,
        input_node=input_node,
        periods=periods,
        stat_func=stat_func,
    )</code></pre>
</details>
<div class="desc"><p>Recreate a MultiPeriodStatNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>]</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.MultiPeriodStatNode" href="#fin_statement_model.MultiPeriodStatNode">MultiPeriodStatNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.MultiPeriodStatNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: Optional[str] = None) -&gt; float:
    &#34;&#34;&#34;Compute the statistical measure across specified periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

    Raises:
        CalculationError: If input retrieval fails or unexpected errors occur.
    &#34;&#34;&#34;
    values: list[Numeric] = []
    retrieval_errors = []
    try:
        for p in self.periods:
            try:
                value = self.input_node.calculate(p)
                if isinstance(value, int | float) and math.isfinite(value):
                    values.append(float(value))
                else:
                    # Log non-numeric/non-finite values but continue if possible
                    logger.warning(
                        f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: Input &#39;{self.input_node.name}&#39; gave non-numeric/non-finite value ({value}) for period &#39;{p}&#39;. Skipping.&#34;
                    )
            except Exception as node_err:
                # Log error fetching data for a specific period but continue
                logger.error(
                    f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: Error getting value for period &#39;{p}&#39; from &#39;{self.input_node.name}&#39;: {node_err}&#34;,
                    exc_info=True,
                )
                retrieval_errors.append(p)

        # If no valid numeric values were collected
        if not values:
            logger.warning(
                f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: No valid numeric data points found across periods {self.periods}. Returning NaN.&#34;
            )
            return float(&#34;nan&#34;)

        # Attempt the statistical calculation
        try:
            result = self.stat_func(values)
            # Ensure result is float, handle potential NaN from stat_func
            return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
        except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
            # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
            logger.warning(
                f&#34;MultiPeriodStatNode &#39;{self.name}&#39;: Stat function &#39;{self.stat_func.__name__}&#39; failed ({stat_err}). Values: {values}. Returning NaN.&#34;
            )
            return float(&#34;nan&#34;)

    except Exception as e:
        # Catch any other unexpected errors during the process
        raise CalculationError(
            message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=&#34;multi-period&#34;,  # Indicate calculation context
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;periods&#34;: self.periods,
                &#34;stat_func&#34;: self.stat_func.__name__,
                &#34;collected_values_count&#34;: len(values),
                &#34;retrieval_errors_periods&#34;: retrieval_errors,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the statistical measure across specified periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Result of <code>stat_func</code> on collected values, or NaN if insufficient valid data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If input retrieval fails or unexpected errors occur.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.MultiPeriodStatNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this statistical node depends on.</p></div>
</dd>
<dt id="fin_statement_model.MultiPeriodStatNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized data with function name and periods.

    Note:
        `stat_func` may not be fully serializable; manual reconstruction may be required.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;multi_period_stat&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;periods&#34;: self.periods.copy(),
        &#34;stat_func_name&#34;: self.stat_func.__name__,
        &#34;serialization_warning&#34;: (
            &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
            &#34;Manual reconstruction may be required for custom functions.&#34;
        ),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized data with function name and periods.</dd>
</dl>
<h2 id="note">Note</h2>
<p><code>stat_func</code> may not be fully serializable; manual reconstruction may be required.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(ABC):
    &#34;&#34;&#34;Abstract base class for nodes in the financial statement model.

    Provides the interface for calculating values, caching, serialization,
    and dependency inspection.

    Attributes:
        name (str): Unique identifier for the node instance.
    &#34;&#34;&#34;

    name: str
    values: dict[str, Any]

    def __init__(self, name: str):
        &#34;&#34;&#34;Initialize the Node instance with a unique name.

        Args:
            name: Unique identifier for the node. Must be a non-empty string.

        Raises:
            ValueError: If `name` is empty or not a string.

        Examples:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period): return 0.0
            &gt;&gt;&gt; dn = Dummy(&#34;Revenue&#34;)
            &gt;&gt;&gt; dn.name
            &#39;Revenue&#39;
        &#34;&#34;&#34;
        # Check if name is a non-empty string
        if not isinstance(name, str) or not name:
            raise ValueError(&#34;Node name must be a non-empty string.&#34;)
        # Check for invalid characters (including newline, tab)
        if &#34;\n&#34; in name or &#34;\t&#34; in name:
            raise ValueError(
                f&#34;Invalid node name: &#39;{name}&#39;. Contains invalid characters.&#34;
            )
        # Check for leading/trailing whitespace
        if name != name.strip():
            raise ValueError(
                f&#34;Invalid node name: &#39;{name}&#39;. Cannot have leading/trailing whitespace.&#34;
            )
        self.name = name

    @abstractmethod
    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Subclasses must override this method to implement specific calculation logic.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.
        &#34;&#34;&#34;

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached calculation results for this node.

        Subclasses with caching should override this method to clear their internal cache.

        Returns:
            None

        Examples:
            &gt;&gt;&gt; node.clear_cache()
        &#34;&#34;&#34;
        # Default: no cache to clear

    def has_attribute(self, attr_name: str) -&gt; bool:
        &#34;&#34;&#34;Check if the node has a specific attribute.

        Args:
            attr_name: The name of the attribute to check.

        Returns:
            True if the attribute exists, otherwise False.

        Examples:
            &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
            True
        &#34;&#34;&#34;
        return hasattr(self, attr_name)

    def get_attribute(self, attribute_name: str) -&gt; object:
        &#34;&#34;&#34;Get a named attribute from the node.

        Args:
            attribute_name: The name of the attribute to retrieve.

        Returns:
            The value of the specified attribute.

        Raises:
            AttributeError: If the attribute does not exist.

        Examples:
            &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
            &#39;Revenue&#39;
        &#34;&#34;&#34;
        try:
            return getattr(self, attribute_name)
        except AttributeError:
            raise AttributeError(
                f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;
            )

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

        Override in subclasses to support mutating stored data.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Raises:
            NotImplementedError: Always in base class.
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)

    @abstractmethod
    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        This method should return a dictionary containing all information
        necessary to reconstruct the node, including:
        - node type
        - name
        - any configuration parameters
        - values (for data nodes)
        - input references (for calculation nodes)

        Returns:
            Dictionary representation of the node.

        Examples:
            &gt;&gt;&gt; node_dict = node.to_dict()
            &gt;&gt;&gt; node_dict[&#39;type&#39;]
            &#39;financial_statement_item&#39;
        &#34;&#34;&#34;

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the names of nodes this node depends on.

        Default implementation returns empty list. Override in nodes that have dependencies.

        Returns:
            List of node names this node depends on.
        &#34;&#34;&#34;
        return []</code></pre>
</details>
<div class="desc"><p>Abstract base class for nodes in the financial statement model.</p>
<p>Provides the interface for calculating values, caching, serialization,
and dependency inspection.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node instance.</dd>
</dl>
<p>Initialize the Node instance with a unique name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Unique identifier for the node. Must be a non-empty string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty or not a string.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period): return 0.0
&gt;&gt;&gt; dn = Dummy(&quot;Revenue&quot;)
&gt;&gt;&gt; dn.name
'Revenue'
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode">CustomCalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.Node.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.Node.values"><code class="name">var <span class="ident">values</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.Node.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Subclasses must override this method to implement specific calculation logic.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Subclasses must override this method to implement specific calculation logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Node.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached calculation results for this node.

    Subclasses with caching should override this method to clear their internal cache.

    Returns:
        None

    Examples:
        &gt;&gt;&gt; node.clear_cache()
    &#34;&#34;&#34;
    # Default: no cache to clear</code></pre>
</details>
<div class="desc"><p>Clear cached calculation results for this node.</p>
<p>Subclasses with caching should override this method to clear their internal cache.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node.clear_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.get_attribute"><code class="name flex">
<span>def <span class="ident">get_attribute</span></span>(<span>self, attribute_name: str) ‑> object</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute(self, attribute_name: str) -&gt; object:
    &#34;&#34;&#34;Get a named attribute from the node.

    Args:
        attribute_name: The name of the attribute to retrieve.

    Returns:
        The value of the specified attribute.

    Raises:
        AttributeError: If the attribute does not exist.

    Examples:
        &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
        &#39;Revenue&#39;
    &#34;&#34;&#34;
    try:
        return getattr(self, attribute_name)
    except AttributeError:
        raise AttributeError(
            f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;
        )</code></pre>
</details>
<div class="desc"><p>Get a named attribute from the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_name</code></strong></dt>
<dd>The name of the attribute to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value of the specified attribute.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If the attribute does not exist.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node.get_attribute(&quot;name&quot;)
'Revenue'
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the names of nodes this node depends on.

    Default implementation returns empty list. Override in nodes that have dependencies.

    Returns:
        List of node names this node depends on.
    &#34;&#34;&#34;
    return []</code></pre>
</details>
<div class="desc"><p>Get the names of nodes this node depends on.</p>
<p>Default implementation returns empty list. Override in nodes that have dependencies.</p>
<h2 id="returns">Returns</h2>
<p>List of node names this node depends on.</p></div>
</dd>
<dt id="fin_statement_model.Node.has_attribute"><code class="name flex">
<span>def <span class="ident">has_attribute</span></span>(<span>self, attr_name: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_attribute(self, attr_name: str) -&gt; bool:
    &#34;&#34;&#34;Check if the node has a specific attribute.

    Args:
        attr_name: The name of the attribute to check.

    Returns:
        True if the attribute exists, otherwise False.

    Examples:
        &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
        True
    &#34;&#34;&#34;
    return hasattr(self, attr_name)</code></pre>
</details>
<div class="desc"><p>Check if the node has a specific attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attr_name</code></strong></dt>
<dd>The name of the attribute to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the attribute exists, otherwise False.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node.has_attribute(&quot;name&quot;)
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

    Override in subclasses to support mutating stored data.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Raises:
        NotImplementedError: Always in base class.
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)</code></pre>
</details>
<div class="desc"><p>Set a value for a specific period on data-bearing nodes.</p>
<p>Override in subclasses to support mutating stored data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Always in base class.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.Node.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    This method should return a dictionary containing all information
    necessary to reconstruct the node, including:
    - node type
    - name
    - any configuration parameters
    - values (for data nodes)
    - input references (for calculation nodes)

    Returns:
        Dictionary representation of the node.

    Examples:
        &gt;&gt;&gt; node_dict = node.to_dict()
        &gt;&gt;&gt; node_dict[&#39;type&#39;]
        &#39;financial_statement_item&#39;
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<p>This method should return a dictionary containing all information
necessary to reconstruct the node, including:
- node type
- name
- any configuration parameters
- values (for data nodes)
- input references (for calculation nodes)</p>
<h2 id="returns">Returns</h2>
<p>Dictionary representation of the node.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_dict = node.to_dict()
&gt;&gt;&gt; node_dict['type']
'financial_statement_item'
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.NodeFactory"><code class="flex name class">
<span>class <span class="ident">NodeFactory</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeFactory:
    &#34;&#34;&#34;Factory for creating nodes in the financial statement model.

    The class exposes convenience helpers that hide the underlying registry
    and deserialization logic, so client code can create nodes declaratively
    (e.g., via YAML configs or simple Python calls) without importing every
    concrete node class.

    Attributes:
        _calculation_methods: Mapping of calculation type keys (e.g., ``&#34;addition&#34;``)
            to calculation class names registered in :class:`fin_statement_model.core.calculations.Registry`.
        _node_type_registry: Mapping of node-type strings to concrete :class:`Node`
            subclasses used when deserializing from dictionaries.
    &#34;&#34;&#34;

    # Mapping of calculation type strings to Calculation class names (keys in the Registry)
    _calculation_methods: ClassVar[dict[str, str]] = {
        &#34;addition&#34;: &#34;AdditionCalculation&#34;,
        &#34;subtraction&#34;: &#34;SubtractionCalculation&#34;,
        &#34;formula&#34;: &#34;FormulaCalculation&#34;,
        &#34;division&#34;: &#34;DivisionCalculation&#34;,
        &#34;weighted_average&#34;: &#34;WeightedAverageCalculation&#34;,
        &#34;custom_formula&#34;: &#34;CustomFormulaCalculation&#34;,
    }

    # Mapping from node type names to Node classes for deserialization
    _node_type_registry: ClassVar[dict[str, type[Node]]] = {
        &#34;financial_statement_item&#34;: FinancialStatementItemNode,
        &#34;calculation&#34;: CalculationNode,
        &#34;formula_calculation&#34;: FormulaCalculationNode,
        &#34;custom_calculation&#34;: CustomCalculationNode,
        &#34;forecast&#34;: ForecastNode,
        # Specific forecast types
        &#34;fixed_growth_forecast&#34;: FixedGrowthForecastNode,
        &#34;curve_growth_forecast&#34;: CurveGrowthForecastNode,
        &#34;statistical_growth_forecast&#34;: StatisticalGrowthForecastNode,
        &#34;average_value_forecast&#34;: AverageValueForecastNode,
        &#34;average_historical_growth_forecast&#34;: AverageHistoricalGrowthForecastNode,
        &#34;custom_growth_forecast&#34;: CustomGrowthForecastNode,
        # Stats node types
        &#34;yoy_growth&#34;: YoYGrowthNode,
        &#34;multi_period_stat&#34;: MultiPeriodStatNode,
        &#34;two_period_average&#34;: TwoPeriodAverageNode,
    }

    # Mapping from forecast type strings to specific forecast node classes
    _forecast_type_registry: ClassVar[dict[str, type[ForecastNode]]] = {
        &#34;simple&#34;: FixedGrowthForecastNode,
        &#34;curve&#34;: CurveGrowthForecastNode,
        &#34;statistical&#34;: StatisticalGrowthForecastNode,
        &#34;average&#34;: AverageValueForecastNode,
        &#34;historical_growth&#34;: AverageHistoricalGrowthForecastNode,
        &#34;custom&#34;: CustomGrowthForecastNode,
    }

    @classmethod
    def create_financial_statement_item(
        cls, name: str, values: dict[str, float]
    ) -&gt; FinancialStatementItemNode:
        &#34;&#34;&#34;Create a FinancialStatementItemNode representing a base financial item.

        This node holds historical or projected values for a specific
        line item (e.g., Revenue, COGS) over different periods.

        Args:
            name: Identifier for the node (e.g., &#34;Revenue&#34;).
            values: Mapping of period identifiers to numerical values.

        Returns:
            A FinancialStatementItemNode initialized with the provided values.

        Raises:
            ValueError: If the provided name is empty or not a string.

        Examples:
            &gt;&gt;&gt; revenue_node = NodeFactory.create_financial_statement_item(
            ...     name=&#34;Revenue&#34;,
            ...     values={&#34;2023&#34;: 1000.0, &#34;2024&#34;: 1100.0}
            ... )
            &gt;&gt;&gt; revenue_node.calculate(&#34;2023&#34;)
            1000.0
        &#34;&#34;&#34;
        if not name or not isinstance(name, str):
            raise ValueError(&#34;Node name must be a non-empty string&#34;)

        logger.debug(f&#34;Creating financial statement item node: {name}&#34;)
        return FinancialStatementItemNode(name, values)

    @classmethod
    def create_calculation_node(
        cls,
        name: str,
        inputs: list[Node],
        calculation_type: str,
        formula_variable_names: Optional[list[str]] = None,
        **calculation_kwargs: Any,
    ) -&gt; CalculationNode:
        &#34;&#34;&#34;Create a CalculationNode using a pre-defined calculation.

        This method resolves a calculation class from a calculation_type key,
        instantiates it with optional parameters, and wraps it in
        a CalculationNode.

        Args:
            name: Identifier for the calculation node instance.
            inputs: List of Node instances serving as inputs to the calculation.
            calculation_type: Key for the desired calculation in the registry.
            formula_variable_names: Optional list of variable names used in the formula
                string. Required &amp; used only if creating a FormulaCalculationNode
                via the &#39;custom_formula&#39; type with a &#39;formula&#39; kwarg.
            **calculation_kwargs: Additional parameters for the calculation constructor.

        Returns:
            A CalculationNode configured with the selected calculation.

        Raises:
            ValueError: If name is invalid, inputs list is empty, or the
                calculation_type is unrecognized.
            TypeError: If the calculation cannot be instantiated with given kwargs.

        Examples:
            &gt;&gt;&gt; gross_profit = NodeFactory.create_calculation_node(
            ...     name=&#34;GrossProfit&#34;,
            ...     inputs=[revenue, cogs],
            ...     calculation_type=&#34;subtraction&#34;
            ... )
        &#34;&#34;&#34;
        # Validate inputs
        if not name or not isinstance(name, str):
            raise ValueError(&#34;Node name must be a non-empty string&#34;)

        if not inputs:
            raise ValueError(&#34;Calculation node must have at least one input&#34;)

        # Check if the calculation type maps to a known calculation name
        if calculation_type not in cls._calculation_methods:
            valid_types = list(cls._calculation_methods.keys())
            raise ValueError(
                f&#34;Invalid calculation type: &#39;{calculation_type}&#39;. Valid types are: {valid_types}&#34;
            )

        # Get the calculation name
        calculation_name = cls._calculation_methods[calculation_type]

        # For other types, resolve the Calculation class from the registry
        try:
            calculation_cls: type[Calculation] = Registry.get(calculation_name)
        except KeyError:
            # This should ideally not happen if _calculation_methods is synced with registry
            raise ValueError(
                f&#34;Calculation class &#39;{calculation_name}&#39; (for type &#39;{calculation_type}&#39;) not found in Registry.&#34;
            ) from None  # Prevent chaining the KeyError

        # Instantiate the calculation, passing any extra kwargs
        try:
            # Extract any metadata that should be stored on the node, not passed to calculation
            node_kwargs = {}
            if &#34;metric_name&#34; in calculation_kwargs:
                node_kwargs[&#34;metric_name&#34;] = calculation_kwargs.pop(&#34;metric_name&#34;)
            if &#34;metric_description&#34; in calculation_kwargs:
                node_kwargs[&#34;metric_description&#34;] = calculation_kwargs.pop(
                    &#34;metric_description&#34;
                )

            # Special handling for FormulaCalculation which needs input_variable_names
            if calculation_type == &#34;formula&#34;:
                if formula_variable_names and len(formula_variable_names) == len(
                    inputs
                ):
                    calculation_kwargs[&#34;input_variable_names&#34;] = formula_variable_names
                elif not formula_variable_names:
                    # Generate default names like var_0, var_1, ...
                    calculation_kwargs[&#34;input_variable_names&#34;] = [
                        f&#34;var_{i}&#34; for i in range(len(inputs))
                    ]
                    logger.warning(
                        f&#34;No formula_variable_names provided for formula node &#39;{name}&#39;. Using defaults: {calculation_kwargs[&#39;input_variable_names&#39;]}&#34;
                    )
                else:
                    # Mismatch between provided names and number of inputs
                    raise ConfigurationError(
                        f&#34;Mismatch between formula_variable_names ({len(formula_variable_names)}) and number of inputs ({len(inputs)}) for node &#39;{name}&#39;&#34;
                    )

            calculation_instance = calculation_cls(**calculation_kwargs)
        except TypeError as e:
            logger.exception(
                f&#34;Failed to instantiate calculation &#39;{calculation_name}&#39; with kwargs {calculation_kwargs}&#34;
            )
            raise TypeError(
                f&#34;Could not instantiate calculation &#39;{calculation_name}&#39; for node &#39;{name}&#39;. &#34;
                f&#34;Check required arguments for {calculation_cls.__name__}. Provided kwargs: {calculation_kwargs}&#34;
            ) from e

        # Create and return a CalculationNode with the instantiated calculation
        logger.debug(
            f&#34;Creating calculation node &#39;{name}&#39; with &#39;{calculation_name}&#39; calculation.&#34;
        )

        return CalculationNode(name, inputs, calculation_instance, **node_kwargs)

    @classmethod
    def create_forecast_node(
        cls,
        name: str,
        base_node: Node,
        base_period: str,
        forecast_periods: list[str],
        forecast_type: str,
        growth_params: Union[float, list[float], Callable[[], float]],
    ) -&gt; Node:
        &#34;&#34;&#34;Create a forecast node of the specified type using core forecast classes.

        Args:
            name: Custom name for the forecast node.
            base_node: The Node instance to base projections on.
            base_period: Period identifier providing the base value.
            forecast_periods: List of periods for which to forecast.
            forecast_type: Forecast method (&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;,
                &#39;average&#39;, &#39;historical_growth&#39;).
            growth_params: Parameters controlling forecast behavior (float,
                list of floats, or callable). Ignored for &#39;average&#39; and &#39;historical_growth&#39;.

        Returns:
            A Node instance implementing the chosen forecast.

        Raises:
            ValueError: If an unsupported forecast_type is provided.

        Examples:
            &gt;&gt;&gt; forecast = NodeFactory.create_forecast_node(
            ...     name=&#34;RevForecast&#34;,
            ...     base_node=revenue,
            ...     base_period=&#34;2023&#34;,
            ...     forecast_periods=[&#34;2024&#34;, &#34;2025&#34;],
            ...     forecast_type=&#34;simple&#34;,
            ...     growth_params=0.05
            ... )
        &#34;&#34;&#34;
        # Prepare placeholder to unify forecast node type
        node: ForecastNode
        # Instantiate the appropriate forecast node with proper type checking
        if forecast_type == &#34;simple&#34;:
            if not isinstance(growth_params, (int, float)):
                raise TypeError(&#34;growth_params must be a float for &#39;simple&#39; forecast&#34;)
            node = FixedGrowthForecastNode(
                base_node, base_period, forecast_periods, float(growth_params)
            )
        elif forecast_type == &#34;curve&#34;:
            if not isinstance(growth_params, list):
                raise TypeError(
                    &#34;growth_params must be a list of floats for &#39;curve&#39; forecast&#34;
                )
            rates: list[float] = [float(r) for r in growth_params]
            node = CurveGrowthForecastNode(
                base_node, base_period, forecast_periods, rates
            )
        elif forecast_type == &#34;statistical&#34;:
            if not callable(growth_params):
                raise TypeError(
                    &#34;growth_params must be a callable returning float for &#39;statistical&#39; forecast&#34;
                )
            node = StatisticalGrowthForecastNode(
                base_node, base_period, forecast_periods, growth_params
            )
        elif forecast_type == &#34;average&#34;:
            node = AverageValueForecastNode(base_node, base_period, forecast_periods)
        elif forecast_type == &#34;historical_growth&#34;:
            node = AverageHistoricalGrowthForecastNode(
                base_node, base_period, forecast_periods
            )
        else:
            raise ValueError(f&#34;Invalid forecast type: {forecast_type}&#34;)

        # Override forecast node&#39;s name to match factory &#39;name&#39; argument
        node.name = name
        logger.debug(
            f&#34;Forecast node created with custom name: {name} (original: {base_node.name})&#34;
        )
        return node

    @classmethod
    def create_from_dict(  # noqa: PLR0911
        cls, data: dict[str, Any], context: Optional[dict[str, Node]] = None
    ) -&gt; Node:
        &#34;&#34;&#34;Create a node from its dictionary representation.

        This method provides a unified interface for deserializing nodes from
        their dictionary representations, handling dependency resolution and
        type-specific deserialization logic.

        Args:
            data: Serialized node data containing at minimum a &#39;type&#39; field.
            context: Optional dictionary of existing nodes for resolving dependencies.
                Required for nodes that have dependencies (calculation, forecast nodes).

        Returns:
            Reconstructed node instance.

        Raises:
            ValueError: If the data is invalid, missing required fields, or contains
                an unknown node type.
            ConfigurationError: If dependencies cannot be resolved or node creation fails.

        Examples:
            &gt;&gt;&gt; # Simple node without dependencies
            &gt;&gt;&gt; data = {
            ...     &#39;type&#39;: &#39;financial_statement_item&#39;,
            ...     &#39;name&#39;: &#39;Revenue&#39;,
            ...     &#39;values&#39;: {&#39;2023&#39;: 1000.0}
            ... }
            &gt;&gt;&gt; node = NodeFactory.create_from_dict(data)

            &gt;&gt;&gt; # Node with dependencies
            &gt;&gt;&gt; calc_data = {
            ...     &#39;type&#39;: &#39;calculation&#39;,
            ...     &#39;name&#39;: &#39;GrossProfit&#39;,
            ...     &#39;inputs&#39;: [&#39;Revenue&#39;, &#39;COGS&#39;],
            ...     &#39;calculation_type&#39;: &#39;subtraction&#39;
            ... }
            &gt;&gt;&gt; context = {&#39;Revenue&#39;: revenue_node, &#39;COGS&#39;: cogs_node}
            &gt;&gt;&gt; calc_node = NodeFactory.create_from_dict(calc_data, context)
        &#34;&#34;&#34;
        if not isinstance(data, dict):
            raise TypeError(&#34;Node data must be a dictionary&#34;)

        node_type = data.get(&#34;type&#34;)
        if not node_type:
            raise ValueError(&#34;Missing &#39;type&#39; field in node data&#34;)

        logger.debug(f&#34;Creating node of type &#39;{node_type}&#39; from dictionary&#34;)

        # Handle nodes without dependencies first
        if node_type == &#34;financial_statement_item&#34;:
            return FinancialStatementItemNode.from_dict(data)

        # Handle nodes that require context for dependency resolution
        if context is None:
            context = {}

        # For calculation nodes, use the appropriate from_dict_with_context method
        if node_type == &#34;calculation&#34;:
            return cast(Node, CalculationNode.from_dict_with_context(data, context))
        elif node_type == &#34;formula_calculation&#34;:
            return cast(
                Node, FormulaCalculationNode.from_dict_with_context(data, context)
            )
        elif node_type == &#34;custom_calculation&#34;:
            raise ConfigurationError(
                &#34;CustomCalculationNode cannot be deserialized because it contains &#34;
                &#34;non-serializable Python functions. Manual reconstruction required.&#34;
            )

        # Handle stats nodes
        elif node_type == &#34;yoy_growth&#34;:
            return YoYGrowthNode.from_dict_with_context(data, context)
        elif node_type == &#34;multi_period_stat&#34;:
            return MultiPeriodStatNode.from_dict_with_context(data, context)
        elif node_type == &#34;two_period_average&#34;:
            return TwoPeriodAverageNode.from_dict_with_context(data, context)

        # Handle forecast nodes
        elif node_type == &#34;forecast&#34;:
            # Determine the specific forecast type from the data
            forecast_type = data.get(&#34;forecast_type&#34;)
            if not forecast_type:
                raise ValueError(&#34;Missing &#39;forecast_type&#39; field in forecast node data&#34;)

            # Get the appropriate forecast node class
            forecast_class = cls._forecast_type_registry.get(forecast_type)
            if not forecast_class:
                valid_types = list(cls._forecast_type_registry.keys())
                raise ValueError(
                    f&#34;Unknown forecast type &#39;{forecast_type}&#39;. Valid types: {valid_types}&#34;
                )

            # Handle non-serializable forecast types
            if forecast_type in [&#34;statistical&#34;, &#34;custom&#34;]:
                raise ConfigurationError(
                    f&#34;Forecast type &#39;{forecast_type}&#39; cannot be deserialized because it contains &#34;
                    &#34;non-serializable functions. Manual reconstruction required.&#34;
                )

            # Use the specific forecast class&#39;s from_dict_with_context method
            return forecast_class.from_dict_with_context(data, context)

        # Handle specific forecast node types (for backward compatibility)
        elif node_type in cls._node_type_registry:
            node_class = cls._node_type_registry[node_type]
            if hasattr(node_class, &#34;from_dict_with_context&#34;):
                return cast(Node, node_class.from_dict_with_context(data, context))
            else:
                return cast(Node, node_class.from_dict(data))  # type: ignore[attr-defined]

        else:
            valid_types = list(cls._node_type_registry.keys())
            raise ValueError(
                f&#34;Unknown node type: &#39;{node_type}&#39;. Valid types: {valid_types}&#34;
            )

    @classmethod
    def _create_custom_node_from_callable(
        cls,
        name: str,
        inputs: list[Node],
        formula: Callable[..., Any],
        description: Optional[str] = None,
    ) -&gt; CustomCalculationNode:
        &#34;&#34;&#34;Create a :class:`CustomCalculationNode` from an arbitrary Python callable.

        This helper is useful for ad-hoc or complex calculations that are not
        (yet) formalized as reusable strategies. The supplied ``formula`` is
        invoked with the *values* of each input node during evaluation.

        Args:
            name: Identifier for the custom calculation node.
            inputs: List of nodes supplying arguments to ``formula``.
            formula: Callable performing the calculation.
            description: Human-readable description of the calculation logic.

        Returns:
            The newly created :class:`CustomCalculationNode` instance.

        Raises:
            ValueError: If *name* is empty.
            TypeError: If *formula* is not callable or *inputs* contain non-Node objects.

        Examples:
            Defining a tax-calculation node::

                def tax_logic(revenue, expenses, tax_rate):
                    profit = revenue - expenses
                    return max(profit, 0) * tax_rate

                tax_node = NodeFactory._create_custom_node_from_callable(
                    name=&#34;IncomeTax&#34;,
                    inputs=[revenue, expenses, tax_rate_node],
                    formula=tax_logic,
                )

            Using a lambda for a quick ratio::

                quick_ratio = NodeFactory._create_custom_node_from_callable(
                    name=&#34;QuickRatioCustom&#34;,
                    inputs=[cash, receivables, current_liabilities],
                    formula=lambda cash, rec, liab: (cash + rec) / liab if liab else 0,
                )
        &#34;&#34;&#34;
        # Validate inputs
        if not name or not isinstance(name, str):
            raise ValueError(&#34;Node name must be a non-empty string&#34;)

        if not inputs:
            # Allowing no inputs might be valid for some custom functions (e.g., constants)
            # Reconsider if this check is always needed here.
            logger.warning(f&#34;Creating CustomCalculationNode &#39;{name}&#39; with no inputs.&#34;)
            # raise ValueError(&#34;Custom node must have at least one input&#34;)

        if not callable(formula):
            raise TypeError(&#34;Formula must be a callable function&#34;)
        if not all(isinstance(i, Node) for i in inputs):
            raise TypeError(&#34;All items in inputs must be Node instances.&#34;)

        # Use the imported CustomCalculationNode
        logger.debug(f&#34;Creating CustomCalculationNode: {name} using provided callable.&#34;)
        return CustomCalculationNode(
            name, inputs, formula_func=formula, description=description
        )</code></pre>
</details>
<div class="desc"><p>Factory for creating nodes in the financial statement model.</p>
<p>The class exposes convenience helpers that hide the underlying registry
and deserialization logic, so client code can create nodes declaratively
(e.g., via YAML configs or simple Python calls) without importing every
concrete node class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_calculation_methods</code></strong></dt>
<dd>Mapping of calculation type keys (e.g., <code>"addition"</code>)
to calculation class names registered in :class:<code><a title="fin_statement_model.core.calculations.Registry" href="core/calculations/index.html#fin_statement_model.core.calculations.Registry">Registry</a></code>.</dd>
<dt><strong><code>_node_type_registry</code></strong></dt>
<dd>Mapping of node-type strings to concrete :class:<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code>
subclasses used when deserializing from dictionaries.</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.NodeFactory.create_calculation_node"><code class="name flex">
<span>def <span class="ident">create_calculation_node</span></span>(<span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>calculation_type: str,<br>formula_variable_names: list[str] | None = None,<br>**calculation_kwargs: Any) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a CalculationNode using a pre-defined calculation.</p>
<p>This method resolves a calculation class from a calculation_type key,
instantiates it with optional parameters, and wraps it in
a CalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Identifier for the calculation node instance.</dd>
<dt><strong><code>inputs</code></strong></dt>
<dd>List of Node instances serving as inputs to the calculation.</dd>
<dt><strong><code>calculation_type</code></strong></dt>
<dd>Key for the desired calculation in the registry.</dd>
<dt><strong><code>formula_variable_names</code></strong></dt>
<dd>Optional list of variable names used in the formula
string. Required &amp; used only if creating a FormulaCalculationNode
via the 'custom_formula' type with a 'formula' kwarg.</dd>
<dt><strong><code>**calculation_kwargs</code></strong></dt>
<dd>Additional parameters for the calculation constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A CalculationNode configured with the selected calculation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If name is invalid, inputs list is empty, or the
calculation_type is unrecognized.</dd>
<dt><code>TypeError</code></dt>
<dd>If the calculation cannot be instantiated with given kwargs.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; gross_profit = NodeFactory.create_calculation_node(
...     name=&quot;GrossProfit&quot;,
...     inputs=[revenue, cogs],
...     calculation_type=&quot;subtraction&quot;
... )
</code></pre></div>
</dd>
<dt id="fin_statement_model.NodeFactory.create_financial_statement_item"><code class="name flex">
<span>def <span class="ident">create_financial_statement_item</span></span>(<span>name: str, values: dict[str, float]) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a FinancialStatementItemNode representing a base financial item.</p>
<p>This node holds historical or projected values for a specific
line item (e.g., Revenue, COGS) over different periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Identifier for the node (e.g., "Revenue").</dd>
<dt><strong><code>values</code></strong></dt>
<dd>Mapping of period identifiers to numerical values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A FinancialStatementItemNode initialized with the provided values.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the provided name is empty or not a string.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; revenue_node = NodeFactory.create_financial_statement_item(
...     name=&quot;Revenue&quot;,
...     values={&quot;2023&quot;: 1000.0, &quot;2024&quot;: 1100.0}
... )
&gt;&gt;&gt; revenue_node.calculate(&quot;2023&quot;)
1000.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.NodeFactory.create_forecast_node"><code class="name flex">
<span>def <span class="ident">create_forecast_node</span></span>(<span>name: str,<br>base_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>forecast_type: str,<br>growth_params: float | list[float] | Callable[[], float]) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a forecast node of the specified type using core forecast classes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Custom name for the forecast node.</dd>
<dt><strong><code>base_node</code></strong></dt>
<dd>The Node instance to base projections on.</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>Period identifier providing the base value.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods for which to forecast.</dd>
<dt><strong><code>forecast_type</code></strong></dt>
<dd>Forecast method ('simple', 'curve', 'statistical',
'average', 'historical_growth').</dd>
<dt><strong><code>growth_params</code></strong></dt>
<dd>Parameters controlling forecast behavior (float,
list of floats, or callable). Ignored for 'average' and 'historical_growth'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Node instance implementing the chosen forecast.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an unsupported forecast_type is provided.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; forecast = NodeFactory.create_forecast_node(
...     name=&quot;RevForecast&quot;,
...     base_node=revenue,
...     base_period=&quot;2023&quot;,
...     forecast_periods=[&quot;2024&quot;, &quot;2025&quot;],
...     forecast_type=&quot;simple&quot;,
...     growth_params=0.05
... )
</code></pre></div>
</dd>
<dt id="fin_statement_model.NodeFactory.create_from_dict"><code class="name flex">
<span>def <span class="ident">create_from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a node from its dictionary representation.</p>
<p>This method provides a unified interface for deserializing nodes from
their dictionary representations, handling dependency resolution and
type-specific deserialization logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Serialized node data containing at minimum a 'type' field.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional dictionary of existing nodes for resolving dependencies.
Required for nodes that have dependencies (calculation, forecast nodes).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Reconstructed node instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid, missing required fields, or contains
an unknown node type.</dd>
<dt><code>ConfigurationError</code></dt>
<dd>If dependencies cannot be resolved or node creation fails.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Simple node without dependencies
&gt;&gt;&gt; data = {
...     'type': 'financial_statement_item',
...     'name': 'Revenue',
...     'values': {'2023': 1000.0}
... }
&gt;&gt;&gt; node = NodeFactory.create_from_dict(data)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Node with dependencies
&gt;&gt;&gt; calc_data = {
...     'type': 'calculation',
...     'name': 'GrossProfit',
...     'inputs': ['Revenue', 'COGS'],
...     'calculation_type': 'subtraction'
... }
&gt;&gt;&gt; context = {'Revenue': revenue_node, 'COGS': cogs_node}
&gt;&gt;&gt; calc_node = NodeFactory.create_from_dict(calc_data, context)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.StatisticalGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">StatisticalGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>distribution_callable: Callable[[], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatisticalGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node whose growth rates are drawn from a random distribution.

    Use a zero-argument callable that samples from a statistical distribution to introduce stochasticity.

    Attributes:
        distribution_callable (Callable[[], float]): Function returning a pseudo-random growth rate.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        distribution_callable: Callable[[], float],
    ):
        &#34;&#34;&#34;Create a StatisticalGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            distribution_callable (Callable[[], float]): Zero-argument function returning random growth rates.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.distribution_callable = distribution_callable

    def _get_growth_factor_for_period(
        self, period: str, prev_period: str, prev_value: float
    ) -&gt; float:
        return self.distribution_callable()

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.

        Note:
            The distribution_callable cannot be serialized, so a warning is included.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update(
            {
                &#34;forecast_type&#34;: &#34;statistical&#34;,
                &#34;serialization_warning&#34;: (
                    &#34;StatisticalGrowthForecastNode uses a distribution callable which cannot be serialized. &#34;
                    &#34;Manual reconstruction required.&#34;
                ),
            }
        )
        return base_dict

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;StatisticalGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a StatisticalGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new StatisticalGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
            NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized
                because the distribution_callable cannot be serialized.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;StatisticalGrowthForecastNode cannot be fully deserialized because the &#34;
            &#34;distribution_callable cannot be serialized. Manual reconstruction required.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Forecast node whose growth rates are drawn from a random distribution.</p>
<p>Use a zero-argument callable that samples from a statistical distribution to introduce stochasticity.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>distribution_callable</code></strong> :&ensp;<code>Callable[[], float]</code></dt>
<dd>Function returning a pseudo-random growth rate.</dd>
</dl>
<p>Create a StatisticalGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>distribution_callable</code></strong> :&ensp;<code>Callable[[], float]</code></dt>
<dd>Zero-argument function returning random growth rates.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.StatisticalGrowthForecastNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;StatisticalGrowthForecastNode&#34;:
    &#34;&#34;&#34;Create a StatisticalGrowthForecastNode from a dictionary with node context.

    Args:
        data: Dictionary containing the node&#39;s serialized data.
        context: Dictionary of existing nodes to resolve dependencies.

    Returns:
        A new StatisticalGrowthForecastNode instance.

    Raises:
        ValueError: If the data is invalid or missing required fields.
        NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized
            because the distribution_callable cannot be serialized.
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;StatisticalGrowthForecastNode cannot be fully deserialized because the &#34;
        &#34;distribution_callable cannot be serialized. Manual reconstruction required.&#34;
    )</code></pre>
</details>
<div class="desc"><p>Create a StatisticalGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new StatisticalGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>StatisticalGrowthForecastNode cannot be fully deserialized
because the distribution_callable cannot be serialized.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.StatisticalGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.

    Note:
        The distribution_callable cannot be serialized, so a warning is included.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update(
        {
            &#34;forecast_type&#34;: &#34;statistical&#34;,
            &#34;serialization_warning&#34;: (
                &#34;StatisticalGrowthForecastNode uses a distribution callable which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        }
    )
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p>
<h2 id="note">Note</h2>
<p>The distribution_callable cannot be serialized, so a warning is included.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.YoYGrowthNode"><code class="flex name class">
<span>class <span class="ident">YoYGrowthNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>prior_period: str,<br>current_period: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YoYGrowthNode(Node):
    &#34;&#34;&#34;Compute year-over-year percentage growth.

    Compare values of an input node for two periods and compute
    (current_value - prior_value) / prior_value.

    Attributes:
        input_node (Node): Node providing source values.
        prior_period (str): Identifier for the earlier period.
        current_period (str): Identifier for the later period.

    Examples:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 100.0, &#34;2023&#34;: 120.0}
        &gt;&gt;&gt; base = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; yoy = YoYGrowthNode(&#34;rev_yoy&#34;, input_node=base, prior_period=&#34;2022&#34;, current_period=&#34;2023&#34;)
        &gt;&gt;&gt; round(yoy.calculate(), 2)
        0.2
    &#34;&#34;&#34;

    def __init__(
        self, name: str, input_node: Node, prior_period: str, current_period: str
    ):
        &#34;&#34;&#34;Create a YoYGrowthNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values for comparison.
            prior_period (str): Identifier for the earlier period.
            current_period (str): Identifier for the later period.

        Raises:
            TypeError: If `input_node` is not a Node or periods are not strings.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;YoYGrowthNode input_node must be a Node instance.&#34;)
        if not isinstance(prior_period, str) or not isinstance(current_period, str):
            raise TypeError(
                &#34;YoYGrowthNode prior_period and current_period must be strings.&#34;
            )

        self.input_node = input_node
        self.prior_period = prior_period
        self.current_period = current_period

    def calculate(self, period: Optional[str] = None) -&gt; float:
        &#34;&#34;&#34;Compute the YoY growth rate.

        Ignore the `period` parameter; use configured periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: (current - prior) / prior, or NaN if prior is zero or non-finite.

        Raises:
            CalculationError: On errors retrieving or validating input values.
        &#34;&#34;&#34;
        try:
            prior_value = self.input_node.calculate(self.prior_period)
            current_value = self.input_node.calculate(self.current_period)

            # Validate input types
            if not isinstance(prior_value, int | float):
                raise TypeError(
                    f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;
                )
            if not isinstance(current_value, int | float):
                raise TypeError(
                    f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;
                )

            # Handle division by zero or non-finite prior value
            if prior_value == 0 or not math.isfinite(prior_value):
                logger.warning(
                    f&#34;YoYGrowthNode &#39;{self.name}&#39;: Prior period &#39;{self.prior_period}&#39; value is zero or non-finite ({prior_value}). Returning NaN.&#34;
                )
                return float(&#34;nan&#34;)

            # Calculate growth
            growth = (float(current_value) - float(prior_value)) / float(prior_value)
            return growth

        except Exception as e:
            # Wrap any exception during calculation
            raise CalculationError(
                message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;prior_period&#34;: self.prior_period,
                    &#34;current_period&#34;: self.current_period,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation with type, name, and periods.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;yoy_growth&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;prior_period&#34;: self.prior_period,
            &#34;current_period&#34;: self.current_period,
        }

    @staticmethod
    def from_dict_with_context(
        data: dict[str, Any], context: dict[str, Node]
    ) -&gt; &#34;YoYGrowthNode&#34;:
        &#34;&#34;&#34;Recreate a YoYGrowthNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node]): Existing nodes for dependencies.

        Returns:
            YoYGrowthNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;yoy_growth&#34;:
            raise ValueError(f&#34;Invalid type for YoYGrowthNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in YoYGrowthNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in YoYGrowthNode data&#34;)

        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        prior_period = data.get(&#34;prior_period&#34;)
        current_period = data.get(&#34;current_period&#34;)

        if not prior_period:
            raise ValueError(&#34;Missing &#39;prior_period&#39; field in YoYGrowthNode data&#34;)
        if not current_period:
            raise ValueError(&#34;Missing &#39;current_period&#39; field in YoYGrowthNode data&#34;)

        return YoYGrowthNode(
            name=name,
            input_node=input_node,
            prior_period=prior_period,
            current_period=current_period,
        )</code></pre>
</details>
<div class="desc"><p>Compute year-over-year percentage growth.</p>
<p>Compare values of an input node for two periods and compute
(current_value - prior_value) / prior_value.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 100.0, &quot;2023&quot;: 120.0}
&gt;&gt;&gt; base = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; yoy = YoYGrowthNode(&quot;rev_yoy&quot;, input_node=base, prior_period=&quot;2022&quot;, current_period=&quot;2023&quot;)
&gt;&gt;&gt; round(yoy.calculate(), 2)
0.2
</code></pre>
<p>Create a YoYGrowthNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node supplying values for comparison.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or periods are not strings.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.YoYGrowthNode.from_dict_with_context"><code class="name flex">
<span>def <span class="ident">from_dict_with_context</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict_with_context(
    data: dict[str, Any], context: dict[str, Node]
) -&gt; &#34;YoYGrowthNode&#34;:
    &#34;&#34;&#34;Recreate a YoYGrowthNode from serialized data.

    Args:
        data (dict[str, Any]): Serialized node data.
        context (dict[str, Node]): Existing nodes for dependencies.

    Returns:
        YoYGrowthNode: Reconstructed node.

    Raises:
        ValueError: If required fields are missing or invalid.
    &#34;&#34;&#34;
    if data.get(&#34;type&#34;) != &#34;yoy_growth&#34;:
        raise ValueError(f&#34;Invalid type for YoYGrowthNode: {data.get(&#39;type&#39;)}&#34;)

    name = data.get(&#34;name&#34;)
    if not name:
        raise ValueError(&#34;Missing &#39;name&#39; field in YoYGrowthNode data&#34;)

    input_node_name = data.get(&#34;input_node_name&#34;)
    if not input_node_name:
        raise ValueError(&#34;Missing &#39;input_node_name&#39; field in YoYGrowthNode data&#34;)

    if input_node_name not in context:
        raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

    input_node = context[input_node_name]
    prior_period = data.get(&#34;prior_period&#34;)
    current_period = data.get(&#34;current_period&#34;)

    if not prior_period:
        raise ValueError(&#34;Missing &#39;prior_period&#39; field in YoYGrowthNode data&#34;)
    if not current_period:
        raise ValueError(&#34;Missing &#39;current_period&#39; field in YoYGrowthNode data&#34;)

    return YoYGrowthNode(
        name=name,
        input_node=input_node,
        prior_period=prior_period,
        current_period=current_period,
    )</code></pre>
</details>
<div class="desc"><p>Recreate a YoYGrowthNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>]</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.YoYGrowthNode" href="#fin_statement_model.YoYGrowthNode">YoYGrowthNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.YoYGrowthNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: Optional[str] = None) -&gt; float:
    &#34;&#34;&#34;Compute the YoY growth rate.

    Ignore the `period` parameter; use configured periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: (current - prior) / prior, or NaN if prior is zero or non-finite.

    Raises:
        CalculationError: On errors retrieving or validating input values.
    &#34;&#34;&#34;
    try:
        prior_value = self.input_node.calculate(self.prior_period)
        current_value = self.input_node.calculate(self.current_period)

        # Validate input types
        if not isinstance(prior_value, int | float):
            raise TypeError(
                f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;
            )
        if not isinstance(current_value, int | float):
            raise TypeError(
                f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;
            )

        # Handle division by zero or non-finite prior value
        if prior_value == 0 or not math.isfinite(prior_value):
            logger.warning(
                f&#34;YoYGrowthNode &#39;{self.name}&#39;: Prior period &#39;{self.prior_period}&#39; value is zero or non-finite ({prior_value}). Returning NaN.&#34;
            )
            return float(&#34;nan&#34;)

        # Calculate growth
        growth = (float(current_value) - float(prior_value)) / float(prior_value)
        return growth

    except Exception as e:
        # Wrap any exception during calculation
        raise CalculationError(
            message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;prior_period&#34;: self.prior_period,
                &#34;current_period&#34;: self.current_period,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the YoY growth rate.</p>
<p>Ignore the <code>period</code> parameter; use configured periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>(current - prior) / prior, or NaN if prior is zero or non-finite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>On errors retrieving or validating input values.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.YoYGrowthNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this node depends on.</p></div>
</dd>
<dt id="fin_statement_model.YoYGrowthNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation with type, name, and periods.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;yoy_growth&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;prior_period&#34;: self.prior_period,
        &#34;current_period&#34;: self.current_period,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation with type, name, and periods.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.config" href="config/index.html">fin_statement_model.config</a></code></li>
<li><code><a title="fin_statement_model.core" href="core/index.html">fin_statement_model.core</a></code></li>
<li><code><a title="fin_statement_model.forecasting" href="forecasting/index.html">fin_statement_model.forecasting</a></code></li>
<li><code><a title="fin_statement_model.io" href="io/index.html">fin_statement_model.io</a></code></li>
<li><code><a title="fin_statement_model.logging_config" href="logging_config.html">fin_statement_model.logging_config</a></code></li>
<li><code><a title="fin_statement_model.preprocessing" href="preprocessing/index.html">fin_statement_model.preprocessing</a></code></li>
<li><code><a title="fin_statement_model.statements" href="statements/index.html">fin_statement_model.statements</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.get_config" href="#fin_statement_model.get_config">get_config</a></code></li>
<li><code><a title="fin_statement_model.update_config" href="#fin_statement_model.update_config">update_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.CalculationNode" href="#fin_statement_model.CalculationNode">CalculationNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.CalculationNode.calculate" href="#fin_statement_model.CalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.clear_cache" href="#fin_statement_model.CalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.from_dict_with_context" href="#fin_statement_model.CalculationNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.get_dependencies" href="#fin_statement_model.CalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.set_calculation" href="#fin_statement_model.CalculationNode.set_calculation">set_calculation</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.to_dict" href="#fin_statement_model.CalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.CurveGrowthForecastNode" href="#fin_statement_model.CurveGrowthForecastNode">CurveGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.CurveGrowthForecastNode.from_dict_with_context" href="#fin_statement_model.CurveGrowthForecastNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.CurveGrowthForecastNode.to_dict" href="#fin_statement_model.CurveGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.CustomGrowthForecastNode" href="#fin_statement_model.CustomGrowthForecastNode">CustomGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.CustomGrowthForecastNode.from_dict_with_context" href="#fin_statement_model.CustomGrowthForecastNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.CustomGrowthForecastNode.to_dict" href="#fin_statement_model.CustomGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.FinancialModelError" href="#fin_statement_model.FinancialModelError">FinancialModelError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.FinancialStatementItemNode.calculate" href="#fin_statement_model.FinancialStatementItemNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.from_dict" href="#fin_statement_model.FinancialStatementItemNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.set_value" href="#fin_statement_model.FinancialStatementItemNode.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.to_dict" href="#fin_statement_model.FinancialStatementItemNode.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.values" href="#fin_statement_model.FinancialStatementItemNode.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.FixedGrowthForecastNode" href="#fin_statement_model.FixedGrowthForecastNode">FixedGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.FixedGrowthForecastNode.from_dict_with_context" href="#fin_statement_model.FixedGrowthForecastNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.FixedGrowthForecastNode.to_dict" href="#fin_statement_model.FixedGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.ForecastNode" href="#fin_statement_model.ForecastNode">ForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.ForecastNode.calculate" href="#fin_statement_model.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.clear_cache" href="#fin_statement_model.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.from_dict_with_context" href="#fin_statement_model.ForecastNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.get_dependencies" href="#fin_statement_model.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.to_dict" href="#fin_statement_model.ForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.Graph" href="#fin_statement_model.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.Graph.add_adjustment" href="#fin_statement_model.Graph.add_adjustment">add_adjustment</a></code></li>
<li><code><a title="fin_statement_model.Graph.add_calculation" href="#fin_statement_model.Graph.add_calculation">add_calculation</a></code></li>
<li><code><a title="fin_statement_model.Graph.add_custom_calculation" href="#fin_statement_model.Graph.add_custom_calculation">add_custom_calculation</a></code></li>
<li><code><a title="fin_statement_model.Graph.add_financial_statement_item" href="#fin_statement_model.Graph.add_financial_statement_item">add_financial_statement_item</a></code></li>
<li><code><a title="fin_statement_model.Graph.add_metric" href="#fin_statement_model.Graph.add_metric">add_metric</a></code></li>
<li><code><a title="fin_statement_model.Graph.add_node" href="#fin_statement_model.Graph.add_node">add_node</a></code></li>
<li><code><a title="fin_statement_model.Graph.add_periods" href="#fin_statement_model.Graph.add_periods">add_periods</a></code></li>
<li><code><a title="fin_statement_model.Graph.breadth_first_search" href="#fin_statement_model.Graph.breadth_first_search">breadth_first_search</a></code></li>
<li><code><a title="fin_statement_model.Graph.calculate" href="#fin_statement_model.Graph.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.Graph.change_calculation_method" href="#fin_statement_model.Graph.change_calculation_method">change_calculation_method</a></code></li>
<li><code><a title="fin_statement_model.Graph.clear" href="#fin_statement_model.Graph.clear">clear</a></code></li>
<li><code><a title="fin_statement_model.Graph.clear_all_caches" href="#fin_statement_model.Graph.clear_all_caches">clear_all_caches</a></code></li>
<li><code><a title="fin_statement_model.Graph.clear_calculation_cache" href="#fin_statement_model.Graph.clear_calculation_cache">clear_calculation_cache</a></code></li>
<li><code><a title="fin_statement_model.Graph.detect_cycles" href="#fin_statement_model.Graph.detect_cycles">detect_cycles</a></code></li>
<li><code><a title="fin_statement_model.Graph.ensure_signed_nodes" href="#fin_statement_model.Graph.ensure_signed_nodes">ensure_signed_nodes</a></code></li>
<li><code><a title="fin_statement_model.Graph.export_adjustments_to_excel" href="#fin_statement_model.Graph.export_adjustments_to_excel">export_adjustments_to_excel</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_adjusted_value" href="#fin_statement_model.Graph.get_adjusted_value">get_adjusted_value</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_adjustments" href="#fin_statement_model.Graph.get_adjustments">get_adjustments</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_available_metrics" href="#fin_statement_model.Graph.get_available_metrics">get_available_metrics</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_calculation_nodes" href="#fin_statement_model.Graph.get_calculation_nodes">get_calculation_nodes</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_dependencies" href="#fin_statement_model.Graph.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_dependency_graph" href="#fin_statement_model.Graph.get_dependency_graph">get_dependency_graph</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_direct_predecessors" href="#fin_statement_model.Graph.get_direct_predecessors">get_direct_predecessors</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_direct_successors" href="#fin_statement_model.Graph.get_direct_successors">get_direct_successors</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_financial_statement_items" href="#fin_statement_model.Graph.get_financial_statement_items">get_financial_statement_items</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_metric" href="#fin_statement_model.Graph.get_metric">get_metric</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_metric_info" href="#fin_statement_model.Graph.get_metric_info">get_metric_info</a></code></li>
<li><code><a title="fin_statement_model.Graph.get_node" href="#fin_statement_model.Graph.get_node">get_node</a></code></li>
<li><code><a title="fin_statement_model.Graph.has_cycle" href="#fin_statement_model.Graph.has_cycle">has_cycle</a></code></li>
<li><code><a title="fin_statement_model.Graph.has_node" href="#fin_statement_model.Graph.has_node">has_node</a></code></li>
<li><code><a title="fin_statement_model.Graph.list_all_adjustments" href="#fin_statement_model.Graph.list_all_adjustments">list_all_adjustments</a></code></li>
<li><code><a title="fin_statement_model.Graph.load_adjustments_from_excel" href="#fin_statement_model.Graph.load_adjustments_from_excel">load_adjustments_from_excel</a></code></li>
<li><code><a title="fin_statement_model.Graph.merge_from" href="#fin_statement_model.Graph.merge_from">merge_from</a></code></li>
<li><code><a title="fin_statement_model.Graph.nodes" href="#fin_statement_model.Graph.nodes">nodes</a></code></li>
<li><code><a title="fin_statement_model.Graph.periods" href="#fin_statement_model.Graph.periods">periods</a></code></li>
<li><code><a title="fin_statement_model.Graph.recalculate_all" href="#fin_statement_model.Graph.recalculate_all">recalculate_all</a></code></li>
<li><code><a title="fin_statement_model.Graph.remove_adjustment" href="#fin_statement_model.Graph.remove_adjustment">remove_adjustment</a></code></li>
<li><code><a title="fin_statement_model.Graph.remove_node" href="#fin_statement_model.Graph.remove_node">remove_node</a></code></li>
<li><code><a title="fin_statement_model.Graph.replace_node" href="#fin_statement_model.Graph.replace_node">replace_node</a></code></li>
<li><code><a title="fin_statement_model.Graph.set_value" href="#fin_statement_model.Graph.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.Graph.topological_sort" href="#fin_statement_model.Graph.topological_sort">topological_sort</a></code></li>
<li><code><a title="fin_statement_model.Graph.update_financial_statement_item" href="#fin_statement_model.Graph.update_financial_statement_item">update_financial_statement_item</a></code></li>
<li><code><a title="fin_statement_model.Graph.validate" href="#fin_statement_model.Graph.validate">validate</a></code></li>
<li><code><a title="fin_statement_model.Graph.was_adjusted" href="#fin_statement_model.Graph.was_adjusted">was_adjusted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.MultiPeriodStatNode" href="#fin_statement_model.MultiPeriodStatNode">MultiPeriodStatNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.MultiPeriodStatNode.calculate" href="#fin_statement_model.MultiPeriodStatNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.MultiPeriodStatNode.from_dict_with_context" href="#fin_statement_model.MultiPeriodStatNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.MultiPeriodStatNode.get_dependencies" href="#fin_statement_model.MultiPeriodStatNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.MultiPeriodStatNode.to_dict" href="#fin_statement_model.MultiPeriodStatNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.Node.calculate" href="#fin_statement_model.Node.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.Node.clear_cache" href="#fin_statement_model.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.Node.get_attribute" href="#fin_statement_model.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.Node.get_dependencies" href="#fin_statement_model.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.Node.has_attribute" href="#fin_statement_model.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.Node.name" href="#fin_statement_model.Node.name">name</a></code></li>
<li><code><a title="fin_statement_model.Node.set_value" href="#fin_statement_model.Node.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.Node.to_dict" href="#fin_statement_model.Node.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.Node.values" href="#fin_statement_model.Node.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.NodeFactory" href="#fin_statement_model.NodeFactory">NodeFactory</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.NodeFactory.create_calculation_node" href="#fin_statement_model.NodeFactory.create_calculation_node">create_calculation_node</a></code></li>
<li><code><a title="fin_statement_model.NodeFactory.create_financial_statement_item" href="#fin_statement_model.NodeFactory.create_financial_statement_item">create_financial_statement_item</a></code></li>
<li><code><a title="fin_statement_model.NodeFactory.create_forecast_node" href="#fin_statement_model.NodeFactory.create_forecast_node">create_forecast_node</a></code></li>
<li><code><a title="fin_statement_model.NodeFactory.create_from_dict" href="#fin_statement_model.NodeFactory.create_from_dict">create_from_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.StatisticalGrowthForecastNode" href="#fin_statement_model.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.StatisticalGrowthForecastNode.from_dict_with_context" href="#fin_statement_model.StatisticalGrowthForecastNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.StatisticalGrowthForecastNode.to_dict" href="#fin_statement_model.StatisticalGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.YoYGrowthNode" href="#fin_statement_model.YoYGrowthNode">YoYGrowthNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.YoYGrowthNode.calculate" href="#fin_statement_model.YoYGrowthNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.YoYGrowthNode.from_dict_with_context" href="#fin_statement_model.YoYGrowthNode.from_dict_with_context">from_dict_with_context</a></code></li>
<li><code><a title="fin_statement_model.YoYGrowthNode.get_dependencies" href="#fin_statement_model.YoYGrowthNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.YoYGrowthNode.to_dict" href="#fin_statement_model.YoYGrowthNode.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
