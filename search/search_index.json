{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"CHANGELOG.html","title":"Changelog","text":""},{"location":"CHANGELOG.html#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG.html#added","title":"Added","text":"<ul> <li>Introduced immutable Pydantic v2 domain models for the Template Registry &amp; Engine (TRE): <code>TemplateMeta</code>, <code>TemplateBundle</code>, <code>DiffResult</code>.</li> </ul>"},{"location":"CHANGELOG.html#changed","title":"Changed","text":""},{"location":"CHANGELOG.html#fixed","title":"Fixed","text":""},{"location":"api_reference.html","title":"API Reference","text":""},{"location":"registry_templates.html","title":"Statement Templates \u2013 Template Registry &amp; Engine (TRE)","text":"<p>Introduced in v0.4-beta \u2013 July 2025</p> <p>Financial-statement templates let you save a fully-wired calculation graph (nodes, edges, periods, metrics, adjustments) and instantiate it later \u2013 either programmatically or from the command-line \u2013 in a single line of code.</p> <p>Built-in templates are shipped as self-contained JSON bundle files inside the library and are automatically discovered by <code>install_builtin_templates()</code> - no network calls or hard-coded builders involved.</p> <p>Why bother? Templates turn hours of repetitive model scaffolding into seconds, ensure naming conventions remain intact and enable structural diffs between versions. They are the foundation for collaborative modelling workflows.</p>"},{"location":"registry_templates.html#quick-start-3-minutes","title":"Quick-start (3 minutes)","text":"<pre><code>&gt;&gt;&gt; from fin_statement_model.templates import TemplateRegistry\n&gt;&gt;&gt; from fin_statement_model.templates.builtin import install_builtin_templates\n&gt;&gt;&gt; install_builtin_templates()  # idempotent helper\n\u2705 Installed 2 built-in templates.\n\n&gt;&gt;&gt; TemplateRegistry.list()\n['lbo.standard_v1', 'real_estate.lending_v2']\n\n&gt;&gt;&gt; g = TemplateRegistry.instantiate('lbo.standard_v1', periods=[\"2024\", \"2025\", \"2026\"])\n&gt;&gt;&gt; g.calculate(\"NetIncome\", \"2025\")\n123.4\n\n&gt;&gt;&gt; diff = TemplateRegistry.diff('lbo.standard_v1', 'lbo.standard_v2', include_values=True)\n&gt;&gt;&gt; diff.structure.changed_nodes\n{'InterestExpense': 'formula'}\n&gt;&gt;&gt; diff.values.max_delta\n0.005\n</code></pre>"},{"location":"registry_templates.html#cli-cheatsheet","title":"CLI cheatsheet","text":"Task Command List available templates <code>fsm template ls</code> Instantiate template <code>fsm template apply lbo.standard_v1 --periods 2024:2028 --output model.fsm</code> Show structural &amp; value diff <code>fsm template diff lbo.standard_v1 lbo.standard_v2</code> <p>The CLI mirrors the Python API and respects the <code>FSM_TEMPLATES_PATH</code> environment variable when reading/writing from the local registry.</p>"},{"location":"registry_templates.html#internals-in-60-seconds","title":"Internals in 60 seconds","text":"<pre><code>flowchart TD\n    subgraph Registry folder\n        direction TB\n        A[index.json] --&gt; B[bundle.json]\n    end\n    B --&gt; C[IO facade `read_data()`] --&gt; D(Graph)\n    D --&gt;|clone| E(Graph copy)\n    style A fill:#f9f,stroke:#333,stroke-width:1px\n</code></pre> <ol> <li>Each TemplateBundle (<code>bundle.json</code>) is a frozen Pydantic v2 object containing metadata, a graph-definition dictionary and a SHA-256 checksum.</li> <li>The registry index (<code>index.json</code>) maps template-id (<code>lbo.standard_v1</code>) to the bundle path.</li> <li><code>instantiate()</code> re-hydrates the graph via the IO facade, then performs a deep clone to avoid shared caches.</li> </ol>"},{"location":"registry_templates.html#authoring-your-own-template","title":"Authoring your own template","text":"<pre><code>from fin_statement_model.core.graph import Graph\nfrom fin_statement_model.templates import TemplateRegistry\n\n# 1\u00b7 build or load your Graph (see core_basic_usage.py)\ng = Graph(periods=[\"2023\", \"2024\"])\n# \u2026 add nodes, calculations, adjustments \u2026\n\n# 2\u00b7 register it\nTemplateRegistry.register_graph(\n    graph=g,\n    name=\"infra.ppp\",\n    meta={\"category\": \"infrastructure\", \"description\": \"PPP concession 25-year model\"},\n)\n</code></pre> <p>The call persists a bundle.json under <code>~/.fin_statement_model/templates/store/infra/ppp/v1/</code>. Subsequent calls with the same name but no explicit version will auto-increment (<code>v2</code>, <code>v3</code>, \u2026).</p>"},{"location":"registry_templates.html#versioning-rules","title":"Versioning rules","text":"<ul> <li>Semantic suffix <code>_&lt;vX&gt;</code> where <code>X \u2208 \u2115\u207a</code> is enforced by the registry.</li> <li>Duplicate (<code>name + version</code>) raises <code>ValueError</code>.</li> <li><code>TemplateRegistry._resolve_next_version()</code> picks the highest existing <code>v&lt;N&gt;</code> and bumps by +1.</li> </ul>"},{"location":"registry_templates.html#diff-semantics","title":"Diff semantics","text":"<p><code>TemplateRegistry.diff()</code> wraps two helpers:</p> <ul> <li>compare_structure \u2192 added / removed / changed nodes</li> <li>compare_values \u2192 per-cell \u0394 between two graphs (optional)</li> </ul> <p>The result is an immutable <code>DiffResult</code> model you can pretty-print or serialise.</p>"},{"location":"registry_templates.html#faq-troubleshooting","title":"FAQ &amp; troubleshooting","text":"Symptom Likely cause Fix <code>ValueError: Checksum does not match</code> Bundle file edited manually Re-register template or delete bundle path <code>No common periods to compare</code> <code>diff(include_values=True)</code> but graphs share no periods Specify <code>periods=</code> argument <code>Template 'xyz' not found</code> Registry index corrupt Remove <code>index.json</code> and reinstall templates <p>Last updated: {{ git_commit_hash }} </p>"},{"location":"tutorials.html","title":"Quick Start","text":"<p>```python from fin_statement_model import Statement, parse_fin_statement</p> <p>stmt = parse_fin_statement(\"...some input\u2026\") print(stmt.total_assets)</p>"},{"location":"references/modules.html","title":"API Reference for fin_statement_model","text":"<p>Financial Statement Model library.</p> <p>A comprehensive library for building and analyzing financial statement models using a node-based graph structure.</p>"},{"location":"references/modules.html#fin_statement_model.__all__","title":"<code>__all__ = ['CalculationNode', 'CurveGrowthForecastNode', 'CustomGrowthForecastNode', 'FinancialModelError', 'FinancialStatementItemNode', 'FixedGrowthForecastNode', 'ForecastNode', 'Graph', 'MultiPeriodStatNode', 'Node', 'NodeFactory', 'StatisticalGrowthForecastNode', 'TemplateRegistry', 'YoYGrowthNode', '__version__', 'get_config', 'logging_config', 'update_config']</code>  <code>module-attribute</code>","text":""},{"location":"references/modules.html#fin_statement_model.__version__","title":"<code>__version__ = '0.2.0'</code>  <code>module-attribute</code>","text":""},{"location":"references/modules.html#fin_statement_model.CalculationNode","title":"<code>CalculationNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Delegate calculation logic to a calculation object.</p> <p>Use a calculation object to encapsulate the algorithm for computing node values.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode</code>:     Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Identifier for this node.</p> <code>inputs</code> <code>List[Node]</code> <p>A list of input nodes required by the calculation.</p> <code>calculation</code> <code>Any</code> <p>An object possessing a <code>calculate(inputs: List[Node], period: str) -&gt; float</code> method.</p> <code>_values</code> <code>Dict[str, float]</code> <p>Internal cache for calculated results.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode class SumCalculation: ...     def calculate(self, inputs, period): ...         return sum(node.calculate(period) for node in inputs) node_a = FinancialStatementItemNode(\"a\", {\"2023\": 10}) node_b = FinancialStatementItemNode(\"b\", {\"2023\": 20}) sum_node = CalculationNode(\"sum_ab\", inputs=[node_a, node_b], calculation=SumCalculation()) d = sum_node.to_dict() sum_node2 = CalculationNode.from_dict(d, {\"a\": node_a, \"b\": node_b}) sum_node2.calculate(\"2023\") 30.0</p>"},{"location":"references/modules.html#fin_statement_model.CalculationNode.__init__","title":"<code>__init__(name, inputs, calculation, **kwargs)</code>","text":"<p>Initialize the CalculationNode.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique identifier for this node.</p> required <code>inputs</code> <code>List[Node]</code> <p>List of input nodes needed by the calculation.</p> required <code>calculation</code> <code>Any</code> <p>The calculation object implementing the calculation. Must have a <code>calculate</code> method.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional attributes to store on the node (e.g., metric_name, metric_description).</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>inputs</code> is not a list of Nodes, or if <code>calculation</code> does not have a callable <code>calculate</code> method.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode class SumCalculation: ...     def calculate(self, inputs, period): ...         return sum(node.calculate(period) for node in inputs) node_a = FinancialStatementItemNode(\"a\", {\"2023\": 10}) node_b = FinancialStatementItemNode(\"b\", {\"2023\": 20}) sum_node = CalculationNode(\"sum_ab\", inputs=[node_a, node_b], calculation=SumCalculation()) sum_node.calculate(\"2023\") 30.0</p>"},{"location":"references/modules.html#fin_statement_model.CalculationNode.calculate","title":"<code>calculate(period)</code>","text":"<p>Calculate the node's value for a given period.</p> <p>Check the cache; on a miss, delegate to <code>calculation.calculate</code> and cache the result.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str</code> <p>Identifier for the time period.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Calculated value for the period.</p> <p>Raises:</p> Type Description <code>CalculationError</code> <p>If calculation fails or returns a non-numeric value.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode class SumCalculation: ...     def calculate(self, inputs, period): ...         return sum(node.calculate(period) for node in inputs) node_a = FinancialStatementItemNode(\"a\", {\"2023\": 10}) node_b = FinancialStatementItemNode(\"b\", {\"2023\": 20}) sum_node = CalculationNode(\"sum_ab\", inputs=[node_a, node_b], calculation=SumCalculation()) sum_node.calculate(\"2023\") 30.0</p>"},{"location":"references/modules.html#fin_statement_model.CalculationNode.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the internal cache of calculated values.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode class SumCalculation: ...     def calculate(self, inputs, period): ...         return sum(node.calculate(period) for node in inputs) node_a = FinancialStatementItemNode(\"a\", {\"2023\": 10}) node_b = FinancialStatementItemNode(\"b\", {\"2023\": 20}) sum_node = CalculationNode(\"sum_ab\", inputs=[node_a, node_b], calculation=SumCalculation()) sum_node.clear_cache()</p>"},{"location":"references/modules.html#fin_statement_model.CalculationNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Create a CalculationNode from a dictionary with node context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing the node's serialized data.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Dictionary of existing nodes to resolve dependencies.</p> <code>None</code> <p>Returns:</p> Type Description <code>CalculationNode</code> <p>A new CalculationNode instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is invalid or missing required fields.</p> Example"},{"location":"references/modules.html#fin_statement_model.CalculationNode.from_dict--see-calculationnode-usage-in-main-module-docstring","title":"See CalculationNode usage in main module docstring","text":""},{"location":"references/modules.html#fin_statement_model.CalculationNode.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Return the names of input nodes used by the calculation.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of input node names.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode class SumCalculation: ...     def calculate(self, inputs, period): ...         return sum(node.calculate(period) for node in inputs) node_a = FinancialStatementItemNode(\"a\", {\"2023\": 10}) node_b = FinancialStatementItemNode(\"b\", {\"2023\": 20}) sum_node = CalculationNode(\"sum_ab\", inputs=[node_a, node_b], calculation=SumCalculation()) sum_node.get_dependencies() ['a', 'b']</p>"},{"location":"references/modules.html#fin_statement_model.CalculationNode.set_calculation","title":"<code>set_calculation(calculation)</code>","text":"<p>Change the calculation object for the node.</p> <p>Parameters:</p> Name Type Description Default <code>calculation</code> <code>Any</code> <p>The new calculation object. Must have a callable <code>calculate</code> method.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the new calculation is invalid.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode class SumCalculation: ...     def calculate(self, inputs, period): ...         return sum(node.calculate(period) for node in inputs) node_a = FinancialStatementItemNode(\"a\", {\"2023\": 10}) node_b = FinancialStatementItemNode(\"b\", {\"2023\": 20}) sum_node = CalculationNode(\"sum_ab\", inputs=[node_a, node_b], calculation=SumCalculation()) sum_node.set_calculation(SumCalculation())</p>"},{"location":"references/modules.html#fin_statement_model.CalculationNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the node's type, name, inputs, and calculation info.</p> Note <p>This method requires access to NodeFactory's calculation registry to properly serialize the calculation type. Some calculation types with non-serializable parameters may include warnings.</p> Example"},{"location":"references/modules.html#fin_statement_model.CalculationNode.to_dict--see-calculationnode-usage-in-main-module-docstring","title":"See CalculationNode usage in main module docstring","text":""},{"location":"references/modules.html#fin_statement_model.CurveGrowthForecastNode","title":"<code>CurveGrowthForecastNode</code>","text":"<p>               Bases: <code>ForecastNode</code></p> <p>Forecast node with period-specific growth rates.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CurveGrowthForecastNode</code>:     Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</li> </ul> <p>Attributes:</p> Name Type Description <code>growth_rates</code> <code>list[float]</code> <p>Growth rate for each corresponding forecast period.</p> Example <p>from fin_statement_model.core.nodes import FinancialStatementItemNode, CurveGrowthForecastNode revenue = FinancialStatementItemNode(\"revenue\", {\"2022\": 100}) rates = [0.10, 0.08] forecast = CurveGrowthForecastNode(revenue, \"2022\", [\"2023\", \"2024\"], rates) d = forecast.to_dict() forecast2 = CurveGrowthForecastNode.from_dict(d, {\"revenue\": revenue}) round(forecast2.calculate(\"2024\"), 2) 118.8</p>"},{"location":"references/modules.html#fin_statement_model.CurveGrowthForecastNode.__init__","title":"<code>__init__(input_node, base_period, forecast_periods, growth_rates)</code>","text":"<p>Create a CurveGrowthForecastNode.</p> <p>Parameters:</p> Name Type Description Default <code>input_node</code> <code>Node</code> <p>Source of historical data.</p> required <code>base_period</code> <code>str</code> <p>Last historical period.</p> required <code>forecast_periods</code> <code>list[str]</code> <p>Future periods to project.</p> required <code>growth_rates</code> <code>list[float]</code> <p>Growth rate for each forecast period; length must equal forecast_periods.</p> required"},{"location":"references/modules.html#fin_statement_model.CurveGrowthForecastNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Create a CurveGrowthForecastNode from a dictionary with node context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing the node's serialized data.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Dictionary of existing nodes to resolve dependencies.</p> <code>None</code> <p>Returns:</p> Type Description <code>CurveGrowthForecastNode</code> <p>A new CurveGrowthForecastNode instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is invalid or missing required fields.</p>"},{"location":"references/modules.html#fin_statement_model.CurveGrowthForecastNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the node's forecast configuration.</p>"},{"location":"references/modules.html#fin_statement_model.CustomGrowthForecastNode","title":"<code>CustomGrowthForecastNode</code>","text":"<p>               Bases: <code>ForecastNode</code></p> <p>Forecast node that computes growth via a user-supplied function.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomGrowthForecastNode</code>:     Not supported; always raises NotImplementedError because the function cannot be serialized.</li> </ul> <p>Attributes:</p> Name Type Description <code>growth_function</code> <code>Callable[[str, str, float], float]</code> <p>Function returning growth factor.</p> Example"},{"location":"references/modules.html#fin_statement_model.CustomGrowthForecastNode--not-supported","title":"Not supported:","text":"<p>from fin_statement_model.core.nodes import FinancialStatementItemNode, CustomGrowthForecastNode revenue = FinancialStatementItemNode(\"revenue\", {\"2022\": 100}) node = CustomGrowthForecastNode(revenue, \"2022\", [\"2023\"], lambda p, pp, v: 0.05) d = node.to_dict() CustomGrowthForecastNode.from_dict(d, {\"revenue\": revenue})  # doctest: +SKIP Traceback (most recent call last): ... NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized because the growth_function cannot be serialized. Manual reconstruction required.</p>"},{"location":"references/modules.html#fin_statement_model.CustomGrowthForecastNode.__init__","title":"<code>__init__(input_node, base_period, forecast_periods, growth_function)</code>","text":"<p>Create a CustomGrowthForecastNode.</p> <p>Parameters:</p> Name Type Description Default <code>input_node</code> <code>Node</code> <p>Source of historical data.</p> required <code>base_period</code> <code>str</code> <p>Last historical period.</p> required <code>forecast_periods</code> <code>list[str]</code> <p>Future periods to project.</p> required <code>growth_function</code> <code>Callable[[str, str, float], float]</code> <p>Function returning growth factor.</p> required"},{"location":"references/modules.html#fin_statement_model.CustomGrowthForecastNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Deserialization is not supported for CustomGrowthForecastNode.</p>"},{"location":"references/modules.html#fin_statement_model.CustomGrowthForecastNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the node's forecast configuration.</p> Note <p>The growth_function cannot be serialized, so a warning is included.</p>"},{"location":"references/modules.html#fin_statement_model.FinancialModelError","title":"<code>FinancialModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all financial statement model errors.</p> <p>All custom exceptions raised within the library should inherit from this class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; raise FinancialModelError(\"An error occurred.\")\n</code></pre>"},{"location":"references/modules.html#fin_statement_model.FinancialModelError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize the FinancialModelError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>A human-readable description of the error.</p> required"},{"location":"references/modules.html#fin_statement_model.FinancialStatementItemNode","title":"<code>FinancialStatementItemNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Store raw financial statement values for specific periods.</p> <p>Represents a leaf node containing actual reported financial data (e.g., revenue, COGS) across time periods.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode</code>:     Classmethod to deserialize a node from a dictionary. <code>context</code> is ignored for data nodes.</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the financial item.</p> <code>values</code> <code>dict[str, float]</code> <p>Mapping from period identifiers to their values.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode data = {\"2022\": 1000.0, \"2023\": 1200.0} node = FinancialStatementItemNode(\"revenue\", data) d = node.to_dict() node2 = FinancialStatementItemNode.from_dict(d) node2.calculate(\"2023\") 1200.0</p>"},{"location":"references/modules.html#fin_statement_model.FinancialStatementItemNode.__init__","title":"<code>__init__(name, values)</code>","text":"<p>Create a FinancialStatementItemNode.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the financial item.</p> required <code>values</code> <code>dict[str, float]</code> <p>Initial mapping of periods to values.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>name</code> is empty, contains invalid characters, or has leading/trailing whitespace.</p> Example <p>FinancialStatementItemNode(\"Revenue\", {\"2023\": 1000.0}) FinancialStatementItemNode object</p>"},{"location":"references/modules.html#fin_statement_model.FinancialStatementItemNode.calculate","title":"<code>calculate(period)</code>","text":"<p>Get the value for a specific period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str</code> <p>Period identifier to retrieve.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Stored value for <code>period</code>, or 0.0 if not present.</p> Example <p>node = FinancialStatementItemNode(\"Revenue\", {\"2023\": 1000.0}) node.calculate(\"2023\") 1000.0 node.calculate(\"2022\") 0.0</p>"},{"location":"references/modules.html#fin_statement_model.FinancialStatementItemNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Deserialize a FinancialStatementItemNode from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Serialized node data; must contain keys 'type', 'name', and 'values'.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Optional context for deserialization (ignored).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FinancialStatementItemNode</code> <code>FinancialStatementItemNode</code> <p>Reconstructed node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'type' is not 'financial_statement_item' or 'name' is missing.</p> <code>TypeError</code> <p>If 'values' is not a dict.</p> Example <p>d = {\"type\": \"financial_statement_item\", \"name\": \"Revenue\", \"values\": {\"2023\": 1000.0}} node = FinancialStatementItemNode.from_dict(d) node.name 'Revenue' node.calculate(\"2023\") 1000.0</p>"},{"location":"references/modules.html#fin_statement_model.FinancialStatementItemNode.set_value","title":"<code>set_value(period, value)</code>","text":"<p>Set the value for a specific period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str</code> <p>Period identifier.</p> required <code>value</code> <code>float</code> <p>Numerical value to store.</p> required Example <p>node = FinancialStatementItemNode(\"Revenue\", {\"2023\": 1000.0}) node.set_value(\"2024\", 1500.0) node.calculate(\"2024\") 1500.0</p>"},{"location":"references/modules.html#fin_statement_model.FinancialStatementItemNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize this node to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary with keys 'type', 'name', and 'values'.</p> Example <p>node = FinancialStatementItemNode(\"Revenue\", {\"2023\": 1000.0}) data = node.to_dict() data[\"type\"] 'financial_statement_item'</p>"},{"location":"references/modules.html#fin_statement_model.FixedGrowthForecastNode","title":"<code>FixedGrowthForecastNode</code>","text":"<p>               Bases: <code>ForecastNode</code></p> <p>Forecast node that applies a single growth rate to every future period.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FixedGrowthForecastNode</code>:     Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</li> </ul> <p>Attributes:</p> Name Type Description <code>growth_rate</code> <code>float</code> <p>Constant growth factor expressed as a decimal (<code>0.05</code> \u2192 5 %).</p> Example <p>from fin_statement_model.core.nodes import FinancialStatementItemNode, FixedGrowthForecastNode revenue = FinancialStatementItemNode(\"revenue\", {\"2022\": 100}) forecast = FixedGrowthForecastNode(revenue, \"2022\", [\"2023\", \"2024\"], 0.05) d = forecast.to_dict() forecast2 = FixedGrowthForecastNode.from_dict(d, {\"revenue\": revenue}) round(forecast2.calculate(\"2024\"), 2) 110.25</p>"},{"location":"references/modules.html#fin_statement_model.FixedGrowthForecastNode.__init__","title":"<code>__init__(input_node, base_period, forecast_periods, growth_rate=None)</code>","text":"<p>Create a FixedGrowthForecastNode.</p> <p>Parameters:</p> Name Type Description Default <code>input_node</code> <code>Node</code> <p>Source of historical data.</p> required <code>base_period</code> <code>str</code> <p>Last historical period.</p> required <code>forecast_periods</code> <code>list[str]</code> <p>Future periods to project.</p> required <code>growth_rate</code> <code>float | None</code> <p>Constant growth rate (<code>0.05</code> \u2192 5 %). If <code>None</code>, the default configured in <code>cfg('forecasting.default_growth_rate')</code> is used.</p> <code>None</code>"},{"location":"references/modules.html#fin_statement_model.FixedGrowthForecastNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Create a FixedGrowthForecastNode from a dictionary with node context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing the node's serialized data.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Dictionary of existing nodes to resolve dependencies.</p> <code>None</code> <p>Returns:</p> Type Description <code>FixedGrowthForecastNode</code> <p>A new FixedGrowthForecastNode instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is invalid or missing required fields.</p>"},{"location":"references/modules.html#fin_statement_model.FixedGrowthForecastNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the node's forecast configuration.</p>"},{"location":"references/modules.html#fin_statement_model.ForecastNode","title":"<code>ForecastNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Base class for projecting future values from historical data.</p> <p>ForecastNode uses a source node's historical data to generate projected values for specified future periods, caching results to avoid redundant computations.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; ForecastNode</code>:     Classmethod to deserialize a node from a dictionary. Subclasses must override this method.</li> </ul> <p>Attributes:</p> Name Type Description <code>input_node</code> <code>Node</code> <p>Node providing historical data.</p> <code>base_period</code> <code>str</code> <p>Last historical period used as forecast base.</p> <code>forecast_periods</code> <code>list[str]</code> <p>Future periods to project.</p> <code>values</code> <code>dict[str, float]</code> <p>Historical and forecasted values.</p> Example <p>from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode from fin_statement_model.core.nodes.forecast_nodes import FixedGrowthForecastNode revenue = FinancialStatementItemNode(\"revenue\", {\"2022\": 100, \"2023\": 110}) forecast = FixedGrowthForecastNode(revenue, \"2023\", [\"2024\", \"2025\"], 0.05) d = forecast.to_dict() forecast2 = FixedGrowthForecastNode.from_dict(d, {\"revenue\": revenue}) round(forecast2.calculate(\"2025\"), 2) 121.28</p>"},{"location":"references/modules.html#fin_statement_model.ForecastNode.__init__","title":"<code>__init__(input_node, base_period, forecast_periods)</code>","text":"<p>Initialize a ForecastNode.</p> <p>Parameters:</p> Name Type Description Default <code>input_node</code> <code>Node</code> <p>Source of historical data.</p> required <code>base_period</code> <code>str</code> <p>Last historical period as forecast base.</p> required <code>forecast_periods</code> <code>list[str]</code> <p>Future periods to generate forecasts for.</p> required"},{"location":"references/modules.html#fin_statement_model.ForecastNode.calculate","title":"<code>calculate(period)</code>","text":"<p>Calculate the node's value for a given period.</p> <p>Returns historical values for periods up to <code>base_period</code>; computes forecast for later periods.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str</code> <p>Period identifier, historical or forecast.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Value for the specified period.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>period</code> is not a historical or forecast period.</p>"},{"location":"references/modules.html#fin_statement_model.ForecastNode.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear cached forecast values.</p> <p>Use to force recomputation of all periods when input data changes.</p>"},{"location":"references/modules.html#fin_statement_model.ForecastNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Recreate a ForecastNode from serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing the node's serialized data.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Dictionary of existing nodes to resolve dependencies.</p> <code>None</code> <p>Returns:</p> Type Description <code>ForecastNode</code> <p>A new ForecastNode instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is invalid or missing required fields.</p> <code>NotImplementedError</code> <p>This base method should be overridden by subclasses.</p>"},{"location":"references/modules.html#fin_statement_model.ForecastNode.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Get names of nodes that this forecast depends on.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Single-element list of the input node's name.</p>"},{"location":"references/modules.html#fin_statement_model.ForecastNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize this node to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Serialized representation including base forecast parameters.</p> Note <p>Subclasses should override to include specific forecast details.</p>"},{"location":"references/modules.html#fin_statement_model.Graph","title":"<code>Graph</code>","text":"<p>               Bases: <code>GraphBaseMixin</code>, <code>NodeOpsMixin</code>, <code>CalcOpsMixin</code>, <code>AdjustmentMixin</code>, <code>MergeReprMixin</code>, <code>TraversalMixin</code></p> <p>Unified directed-graph abstraction for financial-statement modelling.</p> <p>The Graph class exposes a high-level API for building, mutating, and evaluating financial statement calculation graphs. All functionality is provided by the mix-ins.</p> <p>See module docstring for a comprehensive feature list and usage example.</p>"},{"location":"references/modules.html#fin_statement_model.Graph.clone","title":"<code>clone(*, deep=True)</code>","text":"<p>Return a cloned copy of the current graph.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If <code>True</code> (default) a deep copy containing new node instances and adjustment objects is returned. When <code>False</code> a shallow copy is produced which shares node objects with the original graph.  The shallow variant is primarily useful for quick read-only snapshots.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>Graph</code> <p>A new :class:<code>Graph</code> instance replicating the structure and</p> <code>Graph</code> <p>state of self.</p>"},{"location":"references/modules.html#fin_statement_model.MultiPeriodStatNode","title":"<code>MultiPeriodStatNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Compute a statistical measure over multiple periods.</p> <p>Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning if stat_func is custom).</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode</code>:     Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes. Custom stat functions may require manual reconstruction.</li> </ul> <p>Attributes:</p> Name Type Description <code>input_node</code> <code>Node</code> <p>Node providing source values.</p> <code>periods</code> <code>list[str]</code> <p>Period identifiers to include.</p> <code>stat_func</code> <code>StatFunc</code> <p>Function to apply to collected values.</p> Example <p>from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode data = {\"Q1\": 10, \"Q2\": 12, \"Q3\": 11, \"Q4\": 13} sales = FinancialStatementItemNode(\"sales\", data) import statistics avg = MultiPeriodStatNode( ...     \"avg_sales\", input_node=sales, periods=[\"Q1\", \"Q2\", \"Q3\", \"Q4\"], stat_func=statistics.mean ... ) d = avg.to_dict() avg2 = MultiPeriodStatNode.from_dict(d, {\"sales\": sales}) avg2.calculate() 11.5</p>"},{"location":"references/modules.html#fin_statement_model.MultiPeriodStatNode.__init__","title":"<code>__init__(name, input_node, periods, stat_func=statistics.stdev)</code>","text":"<p>Create a MultiPeriodStatNode.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for this node.</p> required <code>input_node</code> <code>Node</code> <p>Node supplying values.</p> required <code>periods</code> <code>list[str]</code> <p>Period identifiers to analyze.</p> required <code>stat_func</code> <code>StatFunc</code> <p>Function applied to collected values. Defaults to statistics.stdev.</p> <code>stdev</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>periods</code> is empty or not a list.</p> <code>TypeError</code> <p>If <code>input_node</code> is not a Node or <code>stat_func</code> is not callable.</p>"},{"location":"references/modules.html#fin_statement_model.MultiPeriodStatNode.calculate","title":"<code>calculate(period=None)</code>","text":"<p>Compute the statistical measure across specified periods.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str | None</code> <p>Ignored.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Result of <code>stat_func</code> on collected values, or NaN if insufficient valid data.</p> <p>Raises:</p> Type Description <code>CalculationError</code> <p>If input retrieval fails or unexpected errors occur.</p>"},{"location":"references/modules.html#fin_statement_model.MultiPeriodStatNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Recreate a MultiPeriodStatNode from serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Serialized node data.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Existing nodes for dependencies.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiPeriodStatNode</code> <code>MultiPeriodStatNode</code> <p>Reconstructed node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing or invalid.</p>"},{"location":"references/modules.html#fin_statement_model.MultiPeriodStatNode.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Get names of nodes this statistical node depends on.</p>"},{"location":"references/modules.html#fin_statement_model.MultiPeriodStatNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize this node to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Serialized data with function name and periods.</p> Note <p><code>stat_func</code> may not be fully serializable; manual reconstruction may be required.</p>"},{"location":"references/modules.html#fin_statement_model.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all nodes in the financial statement model.</p> <p>This class defines the required interface for all node types, including calculation, serialization, and dependency inspection. Subclasses must implement <code>calculate</code>, <code>to_dict</code>, and (for deserializable nodes) <code>from_dict</code> as a classmethod.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node</code>:     Classmethod to deserialize a node from a dictionary. Nodes with dependencies     (e.g., calculation, forecast, stat nodes) must use the <code>context</code> argument to resolve them.     Data nodes may ignore <code>context</code>.</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the node instance.</p> <code>values</code> <code>dict[str, Any]</code> <p>Optional mapping of period to value (for data nodes).</p> Example <p>class DummyNode(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} ... ...     @classmethod ...     def from_dict(cls, data, context=None): ...         return cls(data[\"name\"]) node = DummyNode(\"Revenue\") d = node.to_dict() DummyNode.from_dict(d).name 'Revenue'</p>"},{"location":"references/modules.html#fin_statement_model.Node.__init__","title":"<code>__init__(name)</code>","text":"<p>Initialize the Node instance with a unique name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the node. Must be a non-empty string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>name</code> is empty, not a string, or contains invalid characters.</p> Example <p>Node(\"Revenue\")  # doctest: +ELLIPSIS Traceback (most recent call last): ... TypeError: Can't instantiate abstract class Node...</p>"},{"location":"references/modules.html#fin_statement_model.Node.calculate","title":"<code>calculate(period)</code>  <code>abstractmethod</code>","text":"<p>Calculate the node's value for a given period.</p> <p>Subclasses must override this method to implement specific calculation logic.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str</code> <p>Identifier for the time period.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Calculated value for the period.</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 2.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} Dummy(\"Test\").calculate(\"2023\") 2.0</p>"},{"location":"references/modules.html#fin_statement_model.Node.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear cached calculation results for this node.</p> <p>Subclasses with caching should override this method to clear their internal cache.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} ... ...     def clear_cache(self): ...         print(\"Cache cleared!\") node = Dummy(\"Test\") node.clear_cache() Cache cleared!</p>"},{"location":"references/modules.html#fin_statement_model.Node.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Deserialize a node from its dictionary representation.</p> <p>Subclasses that support deserialization must override this method. Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the <code>context</code> argument to resolve them. Data nodes may ignore <code>context</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The serialized node dictionary (usually produced by :py:meth:<code>to_dict</code>).</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Optional mapping of node names to node objects that have already been deserialized.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>A fully instantiated node object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not overridden in a subclass.</p> Example <p>class DummyNode(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} ... ...     @classmethod ...     def from_dict(cls, data, context=None): ...         return cls(data[\"name\"]) node = DummyNode(\"Revenue\") d = node.to_dict() DummyNode.from_dict(d).name 'Revenue'</p>"},{"location":"references/modules.html#fin_statement_model.Node.get_attribute","title":"<code>get_attribute(attribute_name)</code>","text":"<p>Get a named attribute from the node.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>The name of the attribute to retrieve.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The value of the specified attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist.</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} node = Dummy(\"Test\") node.get_attribute(\"name\") 'Test'</p>"},{"location":"references/modules.html#fin_statement_model.Node.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Get the names of nodes this node depends on.</p> <p>Default implementation returns empty list. Override in nodes that have dependencies.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of node names this node depends on.</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} ... ...     def get_dependencies(self): ...         return [\"dep1\", \"dep2\"] node = Dummy(\"Test\") node.get_dependencies() ['dep1', 'dep2']</p>"},{"location":"references/modules.html#fin_statement_model.Node.has_attribute","title":"<code>has_attribute(attr_name)</code>","text":"<p>Check if the node has a specific attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The name of the attribute to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the attribute exists, otherwise False.</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} node = Dummy(\"Test\") node.has_attribute(\"name\") True</p>"},{"location":"references/modules.html#fin_statement_model.Node.set_value","title":"<code>set_value(period, value)</code>","text":"<p>Set a value for a specific period on data-bearing nodes.</p> <p>Override in subclasses to support mutating stored data.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str</code> <p>Period identifier.</p> required <code>value</code> <code>float</code> <p>Numerical value to store.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always in base class.</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} ... ...     def set_value(self, period, value): ...         print(f\"Set {period} to {value}\") node = Dummy(\"Test\") node.set_value(\"2023\", 100) Set 2023 to 100</p>"},{"location":"references/modules.html#fin_statement_model.Node.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>Serialize the node to a dictionary representation.</p> <p>This method should return a dictionary containing all information necessary to reconstruct the node, including: - node type - name - any configuration parameters - values (for data nodes) - input references (for calculation nodes)</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary representation of the node.</p> Example <p>class Dummy(Node): ...     def calculate(self, period): ...         return 1.0 ... ...     def to_dict(self): ...         return {\"type\": \"dummy\", \"name\": self.name} node = Dummy(\"Test\") node.to_dict()[\"type\"] 'dummy'</p>"},{"location":"references/modules.html#fin_statement_model.NodeFactory","title":"<code>NodeFactory</code>","text":"<p>Static aggregation of builder, deserializer, and helper functions for node creation.</p> <p>This class exposes static methods for creating financial statement items, calculation nodes, forecast nodes, and for deserializing nodes from dictionaries. It also provides access to custom node creation helpers and legacy calculation method mappings.</p> <p>All methods are static and simply delegate to the underlying functional helpers. This allows both service-object and functional usage patterns.</p> Example <p>from fin_statement_model.core.node_factory import NodeFactory node = NodeFactory.create_financial_statement_item(\"COGS\", {\"2022\": 50.0}) node"},{"location":"references/modules.html#fin_statement_model.StatisticalGrowthForecastNode","title":"<code>StatisticalGrowthForecastNode</code>","text":"<p>               Bases: <code>ForecastNode</code></p> <p>Forecast node whose growth rates are drawn from a random distribution.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; StatisticalGrowthForecastNode</code>:     Not supported; always raises NotImplementedError because the callable cannot be serialized.</li> </ul> <p>Attributes:</p> Name Type Description <code>distribution_callable</code> <code>Callable[[], float]</code> <p>Function returning a pseudo-random growth rate.</p> Example"},{"location":"references/modules.html#fin_statement_model.StatisticalGrowthForecastNode--not-supported","title":"Not supported:","text":"<p>from fin_statement_model.core.nodes import FinancialStatementItemNode, StatisticalGrowthForecastNode import random revenue = FinancialStatementItemNode(\"revenue\", {\"2022\": 100}) node = StatisticalGrowthForecastNode(revenue, \"2022\", [\"2023\"], lambda: random.gauss(0.05, 0.01)) d = node.to_dict() StatisticalGrowthForecastNode.from_dict(d, {\"revenue\": revenue})  # doctest: +SKIP Traceback (most recent call last): ... NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized because the distribution_callable cannot be serialized. Manual reconstruction required.</p>"},{"location":"references/modules.html#fin_statement_model.StatisticalGrowthForecastNode.__init__","title":"<code>__init__(input_node, base_period, forecast_periods, distribution_callable)</code>","text":"<p>Create a StatisticalGrowthForecastNode.</p> <p>Parameters:</p> Name Type Description Default <code>input_node</code> <code>Node</code> <p>Source of historical data.</p> required <code>base_period</code> <code>str</code> <p>Last historical period.</p> required <code>forecast_periods</code> <code>list[str]</code> <p>Future periods to project.</p> required <code>distribution_callable</code> <code>Callable[[], float]</code> <p>Zero-argument function returning random growth rates.</p> required"},{"location":"references/modules.html#fin_statement_model.StatisticalGrowthForecastNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Deserialization is not supported for StatisticalGrowthForecastNode.</p>"},{"location":"references/modules.html#fin_statement_model.StatisticalGrowthForecastNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the node's forecast configuration.</p> Note <p>The distribution_callable cannot be serialized, so a warning is included.</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry","title":"<code>TemplateRegistry</code>","text":"<p>Local filesystem-backed registry for financial statement templates.</p> <p>A singleton-style class providing centralized template storage, versioning, and retrieval. Templates are persisted as JSON bundles with automatic indexing for efficient discovery and integrity verification.</p> <p>The registry supports the complete template lifecycle: - Registration of new templates with automatic versioning - Retrieval and instantiation of stored templates - Comparison between different template versions - Deletion and cleanup of obsolete templates</p> <p>All operations are thread-safe and atomic where possible to support concurrent access patterns.</p> Class Attributes <p>_ENV_VAR: Environment variable name for custom registry path _INDEX_FILE: Name of the JSON index file _STORE_DIR: Directory name for template storage</p> Example Note <p>The registry creates secure storage with restrictive permissions (0700 for directories, 0600 for files) to protect potentially sensitive financial data.</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry--basic-registry-operations","title":"Basic registry operations","text":"<p>templates = TemplateRegistry.list() bundle = TemplateRegistry.get(\"lbo.standard_v1\") graph = TemplateRegistry.instantiate(\"lbo.standard_v1\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry--register-new-template","title":"Register new template","text":"<p>template_id = TemplateRegistry.register_graph(my_graph, name=\"custom.model\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.delete","title":"<code>delete(template_id)</code>  <code>classmethod</code>","text":"<p>Remove a template from the registry permanently.</p> <p>Deletes both the template bundle file and its index entry. The operation is destructive and cannot be undone. Silently ignores unknown template IDs to support idempotent cleanup scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>str</code> <p>Template identifier to delete (e.g., \"lbo.standard_v1\")</p> required Example <p>TemplateRegistry.delete(\"old_template_v1\")  # Removes completely TemplateRegistry.delete(\"nonexistent\")  # Silently ignored</p> Note <p>The function also attempts to clean up empty parent directories after deletion to maintain a tidy registry structure.</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.diff","title":"<code>diff(template_id_a, template_id_b, *, include_values=True, periods=None, atol=1e-09)</code>  <code>classmethod</code>","text":"<p>Compare two registered templates for structural and value differences.</p> <p>Loads both templates, reconstructs their graphs (including forecast application), and performs comprehensive comparison analysis. Useful for understanding evolution between template versions or comparing different modeling approaches.</p> <p>Parameters:</p> Name Type Description Default <code>template_id_a</code> <code>str</code> <p>Base template identifier (left-hand side of comparison)</p> required <code>template_id_b</code> <code>str</code> <p>Target template identifier (right-hand side of comparison)</p> required <code>include_values</code> <code>bool</code> <p>Whether to include numerical value comparison in addition to structural analysis. Set False for faster topology-only diffs</p> <code>True</code> <code>periods</code> <code>list[str] | None</code> <p>Specific periods to compare. If None, uses intersection of periods from both templates</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for value comparison. Differences below this threshold are considered equal and excluded from results</p> <code>1e-09</code> <p>Returns:</p> Type Description <code>DiffResult</code> <p>DiffResult containing: - structure: Structural differences (added/removed/changed nodes) - values: Numerical differences (only if include_values=True)</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either template_id is not found in registry</p> Example Processing Details <p>Both templates are loaded and their embedded forecast specifications are applied to create fully-realized graphs before comparison. This ensures the diff reflects the complete template behavior, not just the base graph structure.</p> Performance Notes <ul> <li>Structure comparison is always fast (O(N) in number of nodes)</li> <li>Value comparison can be expensive for large graphs/many periods</li> <li>Use include_values=False when only topology matters</li> <li>Specify focused period lists for faster value comparison</li> </ul>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.diff--compare-template-versions","title":"Compare template versions","text":"<p>diff_result = TemplateRegistry.diff(\"lbo.standard_v1\", \"lbo.standard_v2\", include_values=True)</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.diff--analyze-structural-changes","title":"Analyze structural changes","text":"<p>structure = diff_result.structure print(f\"Added nodes: {structure.added_nodes}\") print(f\"Removed nodes: {structure.removed_nodes}\") print(f\"Changed nodes: {list(structure.changed_nodes.keys())}\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.diff--analyze-value-changes-if-enabled","title":"Analyze value changes (if enabled)","text":"<p>if diff_result.values: ...     values = diff_result.values ...     print(f\"Changed cells: {len(values.changed_cells)}\") ...     print(f\"Max delta: ${values.max_delta:,.2f}\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.diff--compare-specific-periods-with-tolerance","title":"Compare specific periods with tolerance","text":"<p>focused_diff = TemplateRegistry.diff( ...     \"template_a_v1\", ...     \"template_b_v1\", ...     periods=[\"2024\", \"2025\"], ...     atol=1.0,  # Ignore sub-dollar differences ... )</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.get","title":"<code>get(template_id)</code>  <code>classmethod</code>","text":"<p>Retrieve a template bundle by identifier.</p> <p>Loads and validates the stored template bundle from disk, including checksum verification to ensure data integrity.</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>str</code> <p>Template identifier (e.g., \"lbo.standard_v1\")</p> required <p>Returns:</p> Type Description <code>TemplateBundle</code> <p>Validated TemplateBundle instance</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If template_id is not found in registry</p> <code>ValueError</code> <p>If bundle checksum validation fails</p> <code>OSError</code> <p>If bundle file cannot be read</p> Example <p>bundle = TemplateRegistry.get(\"lbo.standard_v1\") print(f\"Template: {bundle.meta.name} v{bundle.meta.version}\") print(f\"Category: {bundle.meta.category}\") print(f\"Checksum: {bundle.checksum[:8]}...\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.get--access-graph-structure","title":"Access graph structure","text":"<p>graph_dict = bundle.graph_dict periods = graph_dict.get(\"periods\", []) nodes = graph_dict.get(\"nodes\", {})</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.instantiate","title":"<code>instantiate(template_id, *, periods=None, rename_map=None)</code>  <code>classmethod</code>","text":"<p>Create a working graph instance from a stored template.</p> <p>Loads the template bundle, reconstructs the graph, applies any embedded forecast and preprocessing specifications, and optionally customizes the result with additional periods and node renaming.</p> <p>Parameters:</p> Name Type Description Default <code>template_id</code> <code>str</code> <p>Template identifier (e.g., \"lbo.standard_v1\")</p> required <code>periods</code> <code>list[str] | None</code> <p>Additional periods to append to the graph. Existing periods are preserved; duplicates are ignored</p> <code>None</code> <code>rename_map</code> <code>Mapping[str, str] | None</code> <p>Node renaming mapping (old_name \u2192 new_name). Maintains all calculation relationships and edge connections</p> <code>None</code> <p>Returns:</p> Type Description <code>Graph</code> <p>Independent Graph instance ready for analysis and modification</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If template_id is not found or old node names don't exist</p> <code>TypeError</code> <p>If periods or rename_map have incorrect types</p> <code>ValueError</code> <p>If rename target names already exist in the graph</p> Example Template Processing Order <ol> <li>Load template bundle and reconstruct base graph</li> <li>Apply embedded forecast specification (if present)</li> <li>Deep clone for independence from registry caches</li> <li>Add additional periods (if specified)</li> <li>Apply node renaming (if specified)</li> <li>Apply preprocessing pipeline (if embedded)</li> <li>Clear caches and return clean graph</li> </ol> Note <p>The returned graph is completely independent of the template registry and can be modified without affecting the stored template. All forecasting and preprocessing happens automatically based on the template's embedded specifications.</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.instantiate--basic-instantiation","title":"Basic instantiation","text":"<p>graph = TemplateRegistry.instantiate(\"lbo.standard_v1\") revenue_2024 = graph.calculate(\"Revenue\", \"2024\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.instantiate--instantiation-with-customizations","title":"Instantiation with customizations","text":"<p>custom_graph = TemplateRegistry.instantiate( ...     \"lbo.standard_v1\", ...     periods=[\"2029\", \"2030\"],  # Add forecast periods ...     rename_map={  # Rename nodes ...         \"Revenue\": \"TotalRevenue\", ...         \"COGS\": \"DirectCosts\", ...     }, ... )</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.instantiate--verify-customizations","title":"Verify customizations","text":"<p>print(custom_graph.periods)  # Includes 2029, 2030 print(\"TotalRevenue\" in custom_graph.nodes)  # True print(\"Revenue\" in custom_graph.nodes)  # False</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.list","title":"<code>list()</code>  <code>classmethod</code>","text":"<p>List all registered template identifiers.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Sorted list of template IDs in the registry</p> Example <p>templates = TemplateRegistry.list() print(templates) ['lbo.standard_v1', 'real_estate_lending_v3', 'custom.model_v1']</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.list--check-if-specific-template-exists","title":"Check if specific template exists","text":"<p>if \"lbo.standard_v1\" in TemplateRegistry.list(): ...     print(\"LBO template available\")</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.register_graph","title":"<code>register_graph(graph, *, name, version=None, meta=None, forecast=None, preprocessing=None)</code>  <code>classmethod</code>","text":"<p>Register a financial statement graph as a reusable template.</p> <p>Serializes the graph and stores it in the registry with metadata, optional forecasting configuration, and preprocessing pipeline. Automatically calculates version numbers if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Graph instance to persist as a template</p> required <code>name</code> <code>str</code> <p>Template name (e.g., \"lbo.standard\", \"real_estate.construction\")</p> required <code>version</code> <code>str | None</code> <p>Explicit version string (\"v1\", \"v2\"). If None, automatically calculates the next available version</p> <code>None</code> <code>meta</code> <code>Mapping[str, Any] | None</code> <p>Additional metadata fields. Standard fields (name, version, category) are set automatically and override any duplicates in meta</p> <code>None</code> <code>forecast</code> <code>ForecastSpec | None</code> <p>Optional declarative forecasting specification</p> <code>None</code> <code>preprocessing</code> <code>PreprocessingSpec | None</code> <p>Optional data transformation pipeline</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete template identifier (e.g., \"lbo.standard_v1\")</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If name is not a non-empty string</p> <code>ValueError</code> <p>If template_id already exists in registry</p> <code>OSError</code> <p>If filesystem operations fail</p> Example Note <p>The graph is deep-cloned during serialization to ensure the stored template is independent of the original graph instance. Template bundles include SHA-256 checksums for integrity verification.</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.register_graph--basic-registration-with-auto-versioning","title":"Basic registration with auto-versioning","text":"<p>template_id = TemplateRegistry.register_graph( ...     my_graph, name=\"custom.model\", meta={\"description\": \"Custom financial model\", \"category\": \"custom\"} ... ) print(template_id)  # \"custom.model_v1\"</p>"},{"location":"references/modules.html#fin_statement_model.TemplateRegistry.register_graph--registration-with-forecasting","title":"Registration with forecasting","text":"<p>from fin_statement_model.templates.models import ForecastSpec forecast_spec = ForecastSpec( ...     periods=[\"2027\", \"2028\"], node_configs={\"Revenue\": {\"method\": \"simple\", \"config\": 0.1}} ... ) template_id = TemplateRegistry.register_graph(my_graph, name=\"forecast.model\", forecast=forecast_spec)</p>"},{"location":"references/modules.html#fin_statement_model.YoYGrowthNode","title":"<code>YoYGrowthNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Compute year-over-year percentage growth.</p> <p>Compare values of an input node for two periods and compute (current_value - prior_value) / prior_value.</p> Serialization contract <ul> <li><code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.</li> <li><code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode</code>:     Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</li> </ul> <p>Attributes:</p> Name Type Description <code>input_node</code> <code>Node</code> <p>Node providing source values.</p> <code>prior_period</code> <code>str</code> <p>Identifier for the earlier period.</p> <code>current_period</code> <code>str</code> <p>Identifier for the later period.</p> Example <p>from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode data = {\"2022\": 100.0, \"2023\": 120.0} base = FinancialStatementItemNode(\"revenue\", data) yoy = YoYGrowthNode(\"rev_yoy\", input_node=base, prior_period=\"2022\", current_period=\"2023\") d = yoy.to_dict() yoy2 = YoYGrowthNode.from_dict(d, {\"revenue\": base}) round(yoy2.calculate(), 2) 0.2</p>"},{"location":"references/modules.html#fin_statement_model.YoYGrowthNode.__init__","title":"<code>__init__(name, input_node, prior_period, current_period)</code>","text":"<p>Create a YoYGrowthNode.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for this node.</p> required <code>input_node</code> <code>Node</code> <p>Node supplying values for comparison.</p> required <code>prior_period</code> <code>str</code> <p>Identifier for the earlier period.</p> required <code>current_period</code> <code>str</code> <p>Identifier for the later period.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>input_node</code> is not a Node or periods are not strings.</p>"},{"location":"references/modules.html#fin_statement_model.YoYGrowthNode.calculate","title":"<code>calculate(period=None)</code>","text":"<p>Compute the YoY growth rate.</p> <p>Ignore the <code>period</code> parameter; use configured periods.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>str | None</code> <p>Ignored.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>(current - prior) / prior, or NaN if prior is zero or non-finite.</p> <p>Raises:</p> Type Description <code>CalculationError</code> <p>On errors retrieving or validating input values.</p>"},{"location":"references/modules.html#fin_statement_model.YoYGrowthNode.from_dict","title":"<code>from_dict(data, context=None)</code>  <code>classmethod</code>","text":"<p>Recreate a YoYGrowthNode from serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Serialized node data.</p> required <code>context</code> <code>dict[str, Node] | None</code> <p>Existing nodes for dependencies.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>YoYGrowthNode</code> <code>YoYGrowthNode</code> <p>Reconstructed node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing or invalid.</p>"},{"location":"references/modules.html#fin_statement_model.YoYGrowthNode.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Get names of nodes this node depends on.</p>"},{"location":"references/modules.html#fin_statement_model.YoYGrowthNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize this node to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Serialized representation with type, name, and periods.</p>"},{"location":"references/modules.html#fin_statement_model.get_config","title":"<code>get_config()</code>","text":"<p>Return the effective global configuration singleton.</p> <p>This is the primary helper for accessing configuration throughout the library. It delegates to the <code>get()</code> method of the internal <code>_runtime_store</code> singleton.</p> <p>Returns:</p> Type Description <code>Config</code> <p>The active, validated <code>Config</code> instance.</p>"},{"location":"references/modules.html#fin_statement_model.update_config","title":"<code>update_config(updates)</code>","text":"<p>Apply <code>updates</code> to the global configuration singleton.</p> <p>This is the primary helper for modifying configuration at runtime. It performs a deep merge of the provided dictionary into the current runtime overrides.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, Any]</code> <p>A dictionary of configuration values to merge.</p> required"}]}