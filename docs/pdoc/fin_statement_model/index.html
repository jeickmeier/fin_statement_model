<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model API documentation</title>
<meta name="description" content="Financial Statement Model library …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>fin_statement_model</code></h1>
</header>
<section id="section-intro">
<p>Financial Statement Model library.</p>
<p>A comprehensive library for building and analyzing financial statement models
using a node-based graph structure.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.config" href="config/index.html">fin_statement_model.config</a></code></dt>
<dd>
<div class="desc"><p>Provide centralized configuration management for fin_statement_model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core" href="core/index.html">fin_statement_model.core</a></code></dt>
<dd>
<div class="desc"><p>Foundation of <em>fin_statement_model</em> — graph engine, nodes, calculations, and more …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting" href="forecasting/index.html">fin_statement_model.forecasting</a></code></dt>
<dd>
<div class="desc"><p>Provide forecasting capabilities for financial statement graphs …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.io" href="io/index.html">fin_statement_model.io</a></code></dt>
<dd>
<div class="desc"><p>Input/Output components for the Financial Statement Model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.logging_config" href="logging_config.html">fin_statement_model.logging_config</a></code></dt>
<dd>
<div class="desc"><p>Configure centralized logging for the fin_statement_model library …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.preprocessing" href="preprocessing/index.html">fin_statement_model.preprocessing</a></code></dt>
<dd>
<div class="desc"><p>Preprocessing module entrypoint …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements" href="statements/index.html">fin_statement_model.statements</a></code></dt>
<dd>
<div class="desc"><p>Financial Statements Layer (<code><a title="fin_statement_model.statements" href="statements/index.html">fin_statement_model.statements</a></code>) …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.utils" href="utils/index.html">fin_statement_model.utils</a></code></dt>
<dd>
<div class="desc"><p>Utility sub-package for generic helper functions that can be shared across layers …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>) ‑> Config</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config() -&gt; Config:
    &#34;&#34;&#34;Return the effective global configuration singleton.

    This is the primary helper for accessing configuration throughout the library.
    It delegates to the `get()` method of the internal `_runtime_store` singleton.

    Returns:
        The active, validated `Config` instance.
    &#34;&#34;&#34;
    return _runtime_store.get()</code></pre>
</details>
<div class="desc"><p>Return the effective global configuration singleton.</p>
<p>This is the primary helper for accessing configuration throughout the library.
It delegates to the <code>get()</code> method of the internal <code>_runtime_store</code> singleton.</p>
<h2 id="returns">Returns</h2>
<p>The active, validated <code>Config</code> instance.</p></div>
</dd>
<dt id="fin_statement_model.update_config"><code class="name flex">
<span>def <span class="ident">update_config</span></span>(<span>updates: dict[str, Any]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_config(updates: dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Apply `updates` to the global configuration singleton.

    This is the primary helper for modifying configuration at runtime. It performs
    a deep merge of the provided dictionary into the current runtime overrides.

    Args:
        updates: A dictionary of configuration values to merge.
    &#34;&#34;&#34;
    _runtime_store.update(updates)</code></pre>
</details>
<div class="desc"><p>Apply <code>updates</code> to the global configuration singleton.</p>
<p>This is the primary helper for modifying configuration at runtime. It performs
a deep merge of the provided dictionary into the current runtime overrides.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>updates</code></strong></dt>
<dd>A dictionary of configuration values to merge.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.CalculationNode"><code class="flex name class">
<span>class <span class="ident">CalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="core/calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>,<br>**kwargs: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;calculation&#34;)
class CalculationNode(Node):
    &#34;&#34;&#34;Delegate calculation logic to a calculation object.

    Use a calculation object to encapsulate the algorithm for computing node values.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        name (str): Identifier for this node.
        inputs (List[Node]): A list of input nodes required by the calculation.
        calculation (Any): An object possessing a `calculate(inputs: List[Node], period: str) -&gt; float` method.
        _values (Dict[str, float]): Internal cache for calculated results.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; d = sum_node.to_dict()
        &gt;&gt;&gt; sum_node2 = CalculationNode.from_dict(d, {&#34;a&#34;: node_a, &#34;b&#34;: node_b})
        &gt;&gt;&gt; sum_node2.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;

    def __init__(self, name: str, inputs: list[Node], calculation: Calculation, **kwargs: Any):
        &#34;&#34;&#34;Initialize the CalculationNode.

        Args:
            name (str): The unique identifier for this node.
            inputs (List[Node]): List of input nodes needed by the calculation.
            calculation (Any): The calculation object implementing the calculation.
                Must have a `calculate` method.
            **kwargs: Additional attributes to store on the node (e.g., metric_name, metric_description).

        Raises:
            TypeError: If `inputs` is not a list of Nodes, or if `calculation`
                does not have a callable `calculate` method.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(inputs, list) or not all(isinstance(n, Node) for n in inputs):
            raise TypeError(&#34;CalculationNode inputs must be a list of Node instances.&#34;)
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
            raise TypeError(&#34;Calculation object must have a callable &#39;calculate&#39; method.&#34;)

        self.inputs = inputs
        self.calculation = calculation
        self._values: dict[str, float] = {}  # Cache for calculated values

        # Store any additional attributes passed via kwargs
        for key, value in kwargs.items():
            setattr(self, key, value)

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Raises:
            CalculationError: If calculation fails or returns a non-numeric value.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        if period in self._values:
            return self._values[period]

        try:
            # Delegate to the calculation object&#39;s calculate method
            result = self.calculation.calculate(self.inputs, period)
            if not isinstance(result, int | float):
                raise TypeError(
                    f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
                )
            # Cache and return the result
            self._values[period] = float(result)
            return self._values[period]
        except Exception as e:
            # Wrap potential errors from the calculation
            raise CalculationError(
                message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=period,
                details={
                    &#34;calculation&#34;: type(self.calculation).__name__,
                    &#34;error&#34;: str(e),
                },
            ) from e

    def set_calculation(self, calculation: Calculation) -&gt; None:
        &#34;&#34;&#34;Change the calculation object for the node.

        Args:
            calculation (Any): The new calculation object. Must have a callable
                `calculate` method.

        Raises:
            TypeError: If the new calculation is invalid.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
        &#34;&#34;&#34;
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
            raise TypeError(&#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;)
        self.calculation = calculation
        self.clear_cache()  # Clear cache as logic has changed

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the internal cache of calculated values.

        Returns:
            None

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.clear_cache()
        &#34;&#34;&#34;
        self._values.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Return the names of input nodes used by the calculation.

        Returns:
            A list of input node names.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.get_dependencies()
            [&#39;a&#39;, &#39;b&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s type, name, inputs, and calculation info.

        Note:
            This method requires access to NodeFactory&#39;s calculation registry
            to properly serialize the calculation type. Some calculation types
            with non-serializable parameters may include warnings.

        Example:
            &gt;&gt;&gt; # See CalculationNode usage in main module docstring
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        node_dict: dict[str, Any] = {
            &#34;type&#34;: &#34;calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
        }

        # Add calculation type information
        calc_class_name = type(self.calculation).__name__
        node_dict[&#34;calculation_type_class&#34;] = calc_class_name

        # Find the calculation type key from NodeFactory registry
        inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
        type_key = inv_map.get(calc_class_name)
        if type_key:
            node_dict[&#34;calculation_type&#34;] = type_key

            # Extract calculation-specific arguments
            calculation_args = {}

            # Handle specific calculation types
            if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
                calculation_args[&#34;weights&#34;] = self.calculation.weights
            elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
                calculation_args[&#34;formula&#34;] = self.calculation.formula
                if hasattr(self.calculation, &#34;input_variable_names&#34;):
                    node_dict[&#34;formula_variable_names&#34;] = self.calculation.input_variable_names
            elif type_key == &#34;custom_formula&#34;:
                node_dict[&#34;serialization_warning&#34;] = (
                    &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                    &#34;Manual reconstruction required.&#34;
                )

            if calculation_args:
                node_dict[&#34;calculation_args&#34;] = calculation_args

        # Add any additional attributes (like metric info)
        if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
            node_dict[&#34;metric_name&#34;] = self.metric_name
        if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
            node_dict[&#34;metric_description&#34;] = self.metric_description

        return node_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CalculationNode&#34;:
        &#34;&#34;&#34;Create a CalculationNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CalculationNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.

        Example:
            &gt;&gt;&gt; # See CalculationNode usage in main module docstring
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        if data.get(&#34;type&#34;) != &#34;calculation&#34;:
            raise ValueError(f&#34;Invalid type for CalculationNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CalculationNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize CalculationNode&#34;)

        input_names = data.get(&#34;inputs&#34;, [])
        if not isinstance(input_names, list):
            raise TypeError(&#34;&#39;inputs&#39; field must be a list&#34;)

        # Resolve input nodes from context
        input_nodes = []
        for input_name in input_names:
            if input_name not in context:
                raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
            input_nodes.append(context[input_name])

        calculation_type = data.get(&#34;calculation_type&#34;)
        if not calculation_type:
            raise ValueError(&#34;Missing &#39;calculation_type&#39; field in CalculationNode data&#34;)

        # Get calculation arguments
        calculation_args = data.get(&#34;calculation_args&#34;, {})

        # Handle formula variable names for formula calculations
        formula_variable_names = data.get(&#34;formula_variable_names&#34;)

        # Extract metric information
        metric_name = data.get(&#34;metric_name&#34;)
        metric_description = data.get(&#34;metric_description&#34;)

        # Create the node using NodeFactory
        return cast(
            &#34;CalculationNode&#34;,
            NodeFactory.create_calculation_node(
                name=name,
                inputs=input_nodes,
                calculation_type=calculation_type,
                formula_variable_names=formula_variable_names,
                metric_name=metric_name,
                metric_description=metric_description,
                **calculation_args,
            ),
        )</code></pre>
</details>
<div class="desc"><p>Delegate calculation logic to a calculation object.</p>
<p>Use a calculation object to encapsulate the algorithm for computing node values.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>]</code></dt>
<dd>A list of input nodes required by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>An object possessing a <code>calculate(inputs: List[Node], period: str) -&gt; float</code> method.</dd>
<dt><strong><code>_values</code></strong> :&ensp;<code>Dict[str, float]</code></dt>
<dd>Internal cache for calculated results.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; d = sum_node.to_dict()
&gt;&gt;&gt; sum_node2 = CalculationNode.from_dict(d, {&quot;a&quot;: node_a, &quot;b&quot;: node_b})
&gt;&gt;&gt; sum_node2.calculate(&quot;2023&quot;)
30.0
</code></pre>
<p>Initialize the CalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>]</code></dt>
<dd>List of input nodes needed by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The calculation object implementing the calculation.
Must have a <code>calculate</code> method.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional attributes to store on the node (e.g., metric_name, metric_description).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>inputs</code> is not a list of Nodes, or if <code>calculation</code>
does not have a callable <code>calculate</code> method.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode">FormulaCalculationNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.CalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a CalculationNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CalculationNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.CalculationNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Raises:
        CalculationError: If calculation fails or returns a non-numeric value.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;
    if period in self._values:
        return self._values[period]

    try:
        # Delegate to the calculation object&#39;s calculate method
        result = self.calculation.calculate(self.inputs, period)
        if not isinstance(result, int | float):
            raise TypeError(
                f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
            )
        # Cache and return the result
        self._values[period] = float(result)
        return self._values[period]
    except Exception as e:
        # Wrap potential errors from the calculation
        raise CalculationError(
            message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=period,
            details={
                &#34;calculation&#34;: type(self.calculation).__name__,
                &#34;error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Check the cache; on a miss, delegate to <code>calculation.calculate</code> and cache the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If calculation fails or returns a non-numeric value.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.CalculationNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the internal cache of calculated values.

    Returns:
        None

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.clear_cache()
    &#34;&#34;&#34;
    self._values.clear()</code></pre>
</details>
<div class="desc"><p>Clear the internal cache of calculated values.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.clear_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.CalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Return the names of input nodes used by the calculation.

    Returns:
        A list of input node names.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.get_dependencies()
        [&#39;a&#39;, &#39;b&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs]</code></pre>
</details>
<div class="desc"><p>Return the names of input nodes used by the calculation.</p>
<h2 id="returns">Returns</h2>
<p>A list of input node names.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.get_dependencies()
['a', 'b']
</code></pre></div>
</dd>
<dt id="fin_statement_model.CalculationNode.set_calculation"><code class="name flex">
<span>def <span class="ident">set_calculation</span></span>(<span>self,<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="core/calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calculation(self, calculation: Calculation) -&gt; None:
    &#34;&#34;&#34;Change the calculation object for the node.

    Args:
        calculation (Any): The new calculation object. Must have a callable
            `calculate` method.

    Raises:
        TypeError: If the new calculation is invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
    &#34;&#34;&#34;
    if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
        raise TypeError(&#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;)
    self.calculation = calculation
    self.clear_cache()  # Clear cache as logic has changed</code></pre>
</details>
<div class="desc"><p>Change the calculation object for the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The new calculation object. Must have a callable
<code>calculate</code> method.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the new calculation is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
</code></pre></div>
</dd>
<dt id="fin_statement_model.CalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s type, name, inputs, and calculation info.

    Note:
        This method requires access to NodeFactory&#39;s calculation registry
        to properly serialize the calculation type. Some calculation types
        with non-serializable parameters may include warnings.

    Example:
        &gt;&gt;&gt; # See CalculationNode usage in main module docstring
    &#34;&#34;&#34;
    # Import here to avoid circular imports
    from fin_statement_model.core.node_factory import NodeFactory

    node_dict: dict[str, Any] = {
        &#34;type&#34;: &#34;calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
    }

    # Add calculation type information
    calc_class_name = type(self.calculation).__name__
    node_dict[&#34;calculation_type_class&#34;] = calc_class_name

    # Find the calculation type key from NodeFactory registry
    inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
    type_key = inv_map.get(calc_class_name)
    if type_key:
        node_dict[&#34;calculation_type&#34;] = type_key

        # Extract calculation-specific arguments
        calculation_args = {}

        # Handle specific calculation types
        if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
            calculation_args[&#34;weights&#34;] = self.calculation.weights
        elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
            calculation_args[&#34;formula&#34;] = self.calculation.formula
            if hasattr(self.calculation, &#34;input_variable_names&#34;):
                node_dict[&#34;formula_variable_names&#34;] = self.calculation.input_variable_names
        elif type_key == &#34;custom_formula&#34;:
            node_dict[&#34;serialization_warning&#34;] = (
                &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            )

        if calculation_args:
            node_dict[&#34;calculation_args&#34;] = calculation_args

    # Add any additional attributes (like metric info)
    if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
        node_dict[&#34;metric_name&#34;] = self.metric_name
    if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
        node_dict[&#34;metric_description&#34;] = self.metric_description

    return node_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's type, name, inputs, and calculation info.</p>
<h2 id="note">Note</h2>
<p>This method requires access to NodeFactory's calculation registry
to properly serialize the calculation type. Some calculation types
with non-serializable parameters may include warnings.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.CurveGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">CurveGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_rates: list[float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;curve&#34;)
class CurveGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node with period-specific growth rates.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CurveGrowthForecastNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve the base node.

    Attributes:
        growth_rates (list[float]): Growth rate for each corresponding forecast period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CurveGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; rates = [0.10, 0.08]
        &gt;&gt;&gt; forecast = CurveGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;, &#34;2024&#34;], rates)
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = CurveGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2024&#34;), 2)
        118.8
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_rates: list[float],
    ):
        &#34;&#34;&#34;Create a CurveGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_rates (list[float]): Growth rate for each forecast period; length must equal *forecast_periods*.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        if len(growth_rates) != len(forecast_periods):
            raise ValueError(&#34;Number of growth rates must match forecast periods.&#34;)
        self.growth_rates = [float(rate) for rate in growth_rates]  # Ensure all are floats
        logger.debug(&#34;Created CurveGrowthForecastNode with growth rates: %s&#34;, self.growth_rates)
        logger.debug(&#34;  Base period: %s&#34;, base_period)
        logger.debug(&#34;  Forecast periods: %s&#34;, forecast_periods)
        logger.debug(&#34;  Base value: %s&#34;, input_node.calculate(base_period))

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        &#34;&#34;&#34;Get the growth factor for a specific period.&#34;&#34;&#34;
        idx = self.forecast_periods.index(period)
        growth_rate = self.growth_rates[idx]
        logger.debug(
            &#34;CurveGrowthForecastNode: Using growth rate %s for period %s&#34;,
            growth_rate,
            period,
        )
        logger.debug(&#34;  Previous period: %s&#34;, prev_period)
        logger.debug(&#34;  Previous value: %s&#34;, prev_value)
        return growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;curve&#34;,
            &#34;growth_params&#34;: self.growth_rates.copy(),
        })
        return base_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CurveGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a CurveGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CurveGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize CurveGrowthForecastNode&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CurveGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(&#34;Missing &#39;base_node_name&#39; field in CurveGrowthForecastNode data&#34;)

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])
        growth_params = data.get(&#34;growth_params&#34;, [])

        if not base_period:
            raise ValueError(&#34;Missing &#39;base_period&#39; field in CurveGrowthForecastNode data&#34;)

        if not isinstance(growth_params, list):
            raise TypeError(&#34;&#39;growth_params&#39; must be a list for CurveGrowthForecastNode&#34;)

        node = cls(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            growth_rates=growth_params,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node with period-specific growth rates.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CurveGrowthForecastNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_rates</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Growth rate for each corresponding forecast period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CurveGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; rates = [0.10, 0.08]
&gt;&gt;&gt; forecast = CurveGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;, &quot;2024&quot;], rates)
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = CurveGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2024&quot;), 2)
118.8
</code></pre>
<p>Create a CurveGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_rates</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Growth rate for each forecast period; length must equal <em>forecast_periods</em>.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.CurveGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a CurveGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CurveGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.CurveGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;curve&#34;,
        &#34;growth_params&#34;: self.growth_rates.copy(),
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.CustomGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">CustomGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_function: Callable[[str, str, float], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;custom&#34;)
class CustomGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that computes growth via a user-supplied function.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomGrowthForecastNode`:
            Not supported; always raises NotImplementedError because the function cannot be serialized.

    Attributes:
        growth_function (Callable[[str, str, float], float]): Function returning growth factor.

    Example:
        &gt;&gt;&gt; # Not supported:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CustomGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; node = CustomGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;], lambda p, pp, v: 0.05)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; CustomGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})  # doctest: +SKIP
        Traceback (most recent call last):
        ...
        NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized because the growth_function cannot be serialized. Manual reconstruction required.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_function: Callable[[str, str, float], float],
    ):
        &#34;&#34;&#34;Create a CustomGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_function (Callable[[str, str, float], float]): Function returning growth factor.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.growth_function = growth_function

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        return self.growth_function(period, prev_period, prev_value)

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.

        Note:
            The growth_function cannot be serialized, so a warning is included.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;custom&#34;,
            &#34;serialization_warning&#34;: (
                &#34;CustomGrowthForecastNode uses a growth function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        })
        return base_dict

    # Deserialization intentionally unsupported - growth_function is not serializable.

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CustomGrowthForecastNode&#34;:  # pragma: no cover
        &#34;&#34;&#34;Deserialization is not supported for CustomGrowthForecastNode.&#34;&#34;&#34;
        raise NotImplementedError(
            &#34;CustomGrowthForecastNode cannot be deserialized; growth_function is not serializable.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Forecast node that computes growth via a user-supplied function.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomGrowthForecastNode</code>:
Not supported; always raises NotImplementedError because the function cannot be serialized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_function</code></strong> :&ensp;<code>Callable[[str, str, float], float]</code></dt>
<dd>Function returning growth factor.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Not supported:
&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CustomGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; node = CustomGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;], lambda p, pp, v: 0.05)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; CustomGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})  # doctest: +SKIP
Traceback (most recent call last):
...
NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized because the growth_function cannot be serialized. Manual reconstruction required.
</code></pre>
<p>Create a CustomGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_function</code></strong> :&ensp;<code>Callable[[str, str, float], float]</code></dt>
<dd>Function returning growth factor.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.CustomGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization is not supported for CustomGrowthForecastNode.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.CustomGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.

    Note:
        The growth_function cannot be serialized, so a warning is included.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;custom&#34;,
        &#34;serialization_warning&#34;: (
            &#34;CustomGrowthForecastNode uses a growth function which cannot be serialized. &#34;
            &#34;Manual reconstruction required.&#34;
        ),
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p>
<h2 id="note">Note</h2>
<p>The growth_function cannot be serialized, so a warning is included.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.FinancialModelError"><code class="flex name class">
<span>class <span class="ident">FinancialModelError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinancialModelError(Exception):
    &#34;&#34;&#34;Base exception for all financial statement model errors.

    All custom exceptions raised within the library should inherit from this class.

    Examples:
        &gt;&gt;&gt; raise FinancialModelError(&#34;An error occurred.&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str):
        &#34;&#34;&#34;Initialize the FinancialModelError.

        Args:
            message: A human-readable description of the error.
        &#34;&#34;&#34;
        self.message = message
        super().__init__(self.message)</code></pre>
</details>
<div class="desc"><p>Base exception for all financial statement model errors.</p>
<p>All custom exceptions raised within the library should inherit from this class.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise FinancialModelError(&quot;An error occurred.&quot;)
</code></pre>
<p>Initialize the FinancialModelError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>A human-readable description of the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.config.access.ConfigurationAccessError" href="config/access.html#fin_statement_model.config.access.ConfigurationAccessError">ConfigurationAccessError</a></li>
<li><a title="fin_statement_model.config.loader.ConfigurationError" href="config/loader.html#fin_statement_model.config.loader.ConfigurationError">ConfigurationError</a></li>
<li><a title="fin_statement_model.core.errors.CalculationError" href="core/errors.html#fin_statement_model.core.errors.CalculationError">CalculationError</a></li>
<li><a title="fin_statement_model.core.errors.CircularDependencyError" href="core/errors.html#fin_statement_model.core.errors.CircularDependencyError">CircularDependencyError</a></li>
<li><a title="fin_statement_model.core.errors.ConfigurationError" href="core/errors.html#fin_statement_model.core.errors.ConfigurationError">ConfigurationError</a></li>
<li><a title="fin_statement_model.core.errors.DataValidationError" href="core/errors.html#fin_statement_model.core.errors.DataValidationError">DataValidationError</a></li>
<li><a title="fin_statement_model.core.errors.GraphError" href="core/errors.html#fin_statement_model.core.errors.GraphError">GraphError</a></li>
<li><a title="fin_statement_model.core.errors.MetricError" href="core/errors.html#fin_statement_model.core.errors.MetricError">MetricError</a></li>
<li><a title="fin_statement_model.core.errors.MissingInputError" href="core/errors.html#fin_statement_model.core.errors.MissingInputError">MissingInputError</a></li>
<li><a title="fin_statement_model.core.errors.NodeError" href="core/errors.html#fin_statement_model.core.errors.NodeError">NodeError</a></li>
<li><a title="fin_statement_model.core.errors.PeriodError" href="core/errors.html#fin_statement_model.core.errors.PeriodError">PeriodError</a></li>
<li><a title="fin_statement_model.core.errors.StatementError" href="core/errors.html#fin_statement_model.core.errors.StatementError">StatementError</a></li>
<li><a title="fin_statement_model.core.errors.StrategyError" href="core/errors.html#fin_statement_model.core.errors.StrategyError">StrategyError</a></li>
<li><a title="fin_statement_model.core.errors.TransformationError" href="core/errors.html#fin_statement_model.core.errors.TransformationError">TransformationError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="forecasting/errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.io.exceptions.IOError" href="io/exceptions.html#fin_statement_model.io.exceptions.IOError">IOError</a></li>
<li><a title="fin_statement_model.preprocessing.errors.PreprocessingError" href="preprocessing/errors.html#fin_statement_model.preprocessing.errors.PreprocessingError">PreprocessingError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.FinancialStatementItemNode"><code class="flex name class">
<span>class <span class="ident">FinancialStatementItemNode</span></span>
<span>(</span><span>name: str, values: dict[str, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;financial_statement_item&#34;)
class FinancialStatementItemNode(Node):
    &#34;&#34;&#34;Store raw financial statement values for specific periods.

    Represents a leaf node containing actual reported financial data
    (e.g., revenue, COGS) across time periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode`:
            Classmethod to deserialize a node from a dictionary. `context` is ignored for data nodes.

    Attributes:
        name (str): Unique identifier for the financial item.
        values (dict[str, float]): Mapping from period identifiers to their values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 1000.0, &#34;2023&#34;: 1200.0}
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; node2 = FinancialStatementItemNode.from_dict(d)
        &gt;&gt;&gt; node2.calculate(&#34;2023&#34;)
        1200.0
    &#34;&#34;&#34;

    values: dict[str, float]

    def __init__(self, name: str, values: dict[str, float]):
        &#34;&#34;&#34;Create a FinancialStatementItemNode.

        Args:
            name (str): Unique identifier for the financial item.
            values (dict[str, float]): Initial mapping of periods to values.

        Raises:
            ValueError: If `name` is empty, contains invalid characters, or has leading/trailing whitespace.

        Example:
            &gt;&gt;&gt; FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            FinancialStatementItemNode object
        &#34;&#34;&#34;
        super().__init__(name)
        self.values = values

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Get the value for a specific period.

        Args:
            period (str): Period identifier to retrieve.

        Returns:
            float: Stored value for `period`, or 0.0 if not present.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            1000.0
            &gt;&gt;&gt; node.calculate(&#34;2022&#34;)
            0.0
        &#34;&#34;&#34;
        return self.values.get(period, 0.0)

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set the value for a specific period.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
            &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
            1500.0
        &#34;&#34;&#34;
        self.values[period] = value

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; data = node.to_dict()
            &gt;&gt;&gt; data[&#34;type&#34;]
            &#39;financial_statement_item&#39;
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;financial_statement_item&#34;,
            &#34;name&#34;: self.name,
            &#34;values&#34;: self.values.copy(),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, &#34;Node&#34;] | None = None,
    ) -&gt; &#34;FinancialStatementItemNode&#34;:
        &#34;&#34;&#34;Deserialize a FinancialStatementItemNode from a dictionary.

        Args:
            data (dict[str, Any]): Serialized node data; must contain keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.
            context (dict[str, Node] | None): Optional context for deserialization (ignored).

        Returns:
            FinancialStatementItemNode: Reconstructed node.

        Raises:
            ValueError: If &#39;type&#39; is not &#39;financial_statement_item&#39; or &#39;name&#39; is missing.
            TypeError: If &#39;values&#39; is not a dict.

        Example:
            &gt;&gt;&gt; d = {&#34;type&#34;: &#34;financial_statement_item&#34;, &#34;name&#34;: &#34;Revenue&#34;, &#34;values&#34;: {&#34;2023&#34;: 1000.0}}
            &gt;&gt;&gt; node = FinancialStatementItemNode.from_dict(d)
            &gt;&gt;&gt; node.name
            &#39;Revenue&#39;
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            1000.0
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;financial_statement_item&#34;:
            raise ValueError(f&#34;Invalid type for FinancialStatementItemNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FinancialStatementItemNode data&#34;)

        values = data.get(&#34;values&#34;, {})
        if not isinstance(values, dict):
            raise TypeError(&#34;&#39;values&#39; field must be a dict[str, float]&#34;)

        # Context is intentionally ignored for simple data nodes but referenced to avoid
        # unused-argument linter violations and to aid future debugging.
        if context is not None:
            logger.debug(
                &#34;FinancialStatementItemNode.from_dict received a non-null &#39;context&#39; argument, which is currently ignored. Node: %s&#34;,
                name,
            )

        return cls(name, values)</code></pre>
</details>
<div class="desc"><p>Store raw financial statement values for specific periods.</p>
<p>Represents a leaf node containing actual reported financial data
(e.g., revenue, COGS) across time periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is ignored for data nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Mapping from period identifiers to their values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 1000.0, &quot;2023&quot;: 1200.0}
&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; node2 = FinancialStatementItemNode.from_dict(d)
&gt;&gt;&gt; node2.calculate(&quot;2023&quot;)
1200.0
</code></pre>
<p>Create a FinancialStatementItemNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Initial mapping of periods to values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, contains invalid characters, or has leading/trailing whitespace.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
FinancialStatementItemNode object
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.FinancialStatementItemNode.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.FinancialStatementItemNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, '<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>'] | None = None) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize a FinancialStatementItemNode from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data; must contain keys 'type', 'name', and 'values'.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Optional context for deserialization (ignored).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If 'type' is not 'financial_statement_item' or 'name' is missing.</dd>
<dt><code>TypeError</code></dt>
<dd>If 'values' is not a dict.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {&quot;type&quot;: &quot;financial_statement_item&quot;, &quot;name&quot;: &quot;Revenue&quot;, &quot;values&quot;: {&quot;2023&quot;: 1000.0}}
&gt;&gt;&gt; node = FinancialStatementItemNode.from_dict(d)
&gt;&gt;&gt; node.name
'Revenue'
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1000.0
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.FinancialStatementItemNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Get the value for a specific period.

    Args:
        period (str): Period identifier to retrieve.

    Returns:
        float: Stored value for `period`, or 0.0 if not present.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        1000.0
        &gt;&gt;&gt; node.calculate(&#34;2022&#34;)
        0.0
    &#34;&#34;&#34;
    return self.values.get(period, 0.0)</code></pre>
</details>
<div class="desc"><p>Get the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Stored value for <code>period</code>, or 0.0 if not present.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1000.0
&gt;&gt;&gt; node.calculate(&quot;2022&quot;)
0.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.FinancialStatementItemNode.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set the value for a specific period.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
        &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
        1500.0
    &#34;&#34;&#34;
    self.values[period] = value</code></pre>
</details>
<div class="desc"><p>Set the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; node.set_value(&quot;2024&quot;, 1500.0)
&gt;&gt;&gt; node.calculate(&quot;2024&quot;)
1500.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.FinancialStatementItemNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; data = node.to_dict()
        &gt;&gt;&gt; data[&#34;type&#34;]
        &#39;financial_statement_item&#39;
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;financial_statement_item&#34;,
        &#34;name&#34;: self.name,
        &#34;values&#34;: self.values.copy(),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary with keys 'type', 'name', and 'values'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; data = node.to_dict()
&gt;&gt;&gt; data[&quot;type&quot;]
'financial_statement_item'
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_dependencies" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.FixedGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">FixedGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_rate: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;simple&#34;)
class FixedGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that applies a single growth rate to every future period.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FixedGrowthForecastNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve the base node.

    Attributes:
        growth_rate (float): Constant growth factor expressed as a decimal (``0.05`` → 5 %).

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, FixedGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;, &#34;2024&#34;], 0.05)
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2024&#34;), 2)
        110.25
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_rate: float | None = None,
    ):
        &#34;&#34;&#34;Create a FixedGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_rate (float | None): Constant growth rate (``0.05`` → 5 %).
                If ``None``, the default configured in ``cfg(&#39;forecasting.default_growth_rate&#39;)`` is used.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)

        # Use config default if not provided (import inside to avoid circular import)
        if growth_rate is None:
            from fin_statement_model.config.access import cfg

            growth_rate = cfg(&#34;forecasting.default_growth_rate&#34;)

        self.growth_rate = float(growth_rate)  # Ensure it&#39;s a float
        logger.debug(&#34;Created FixedGrowthForecastNode with growth rate: %s&#34;, self.growth_rate)

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (prev_period, prev_value)  # Mark unused parameters to satisfy linters
        logger.debug(
            &#34;FixedGrowthForecastNode: Using growth rate %s for period %s&#34;,
            self.growth_rate,
            period,
        )
        return self.growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;simple&#34;,
            &#34;growth_params&#34;: self.growth_rate,
        })
        return base_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;FixedGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a FixedGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new FixedGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize FixedGrowthForecastNode&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FixedGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(&#34;Missing &#39;base_node_name&#39; field in FixedGrowthForecastNode data&#34;)

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])
        growth_params = data.get(&#34;growth_params&#34;)

        if not base_period:
            raise ValueError(&#34;Missing &#39;base_period&#39; field in FixedGrowthForecastNode data&#34;)

        node = cls(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            growth_rate=growth_params,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node that applies a single growth rate to every future period.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FixedGrowthForecastNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Constant growth factor expressed as a decimal (<code>0.05</code> → 5 %).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, FixedGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;, &quot;2024&quot;], 0.05)
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2024&quot;), 2)
110.25
</code></pre>
<p>Create a FixedGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_rate</code></strong> :&ensp;<code>float | None</code></dt>
<dd>Constant growth rate (<code>0.05</code> → 5 %).
If <code>None</code>, the default configured in <code>cfg('forecasting.default_growth_rate')</code> is used.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.FixedGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a FixedGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new FixedGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.FixedGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;simple&#34;,
        &#34;growth_params&#34;: self.growth_rate,
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.ForecastNode"><code class="flex name class">
<span>class <span class="ident">ForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastNode(Node):
    &#34;&#34;&#34;Base class for projecting future values from historical data.

    ForecastNode uses a source node&#39;s historical data to generate projected values
    for specified future periods, caching results to avoid redundant computations.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; ForecastNode`:
            Classmethod to deserialize a node from a dictionary. Subclasses must override this method.

    Attributes:
        input_node (Node): Node providing historical data.
        base_period (str): Last historical period used as forecast base.
        forecast_periods (list[str]): Future periods to project.
        values (dict[str, float]): Historical and forecasted values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; from fin_statement_model.core.nodes.forecast_nodes import FixedGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100, &#34;2023&#34;: 110})
        &gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &#34;2023&#34;, [&#34;2024&#34;, &#34;2025&#34;], 0.05)
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2025&#34;), 2)
        121.28
    &#34;&#34;&#34;

    _cache: dict[str, float]

    def __init__(self, input_node: Node, base_period: str, forecast_periods: list[str]):
        &#34;&#34;&#34;Initialize a ForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period as forecast base.
            forecast_periods (list[str]): Future periods to generate forecasts for.
        &#34;&#34;&#34;
        # Initialize with a default name based on input node, but allow it to be overridden
        super().__init__(input_node.name)
        self.input_node = input_node
        self.base_period = base_period
        self.forecast_periods = forecast_periods
        self._cache = {}

        # Copy historical values from input node
        if hasattr(input_node, &#34;values&#34;):
            self.values = input_node.values.copy()
        else:
            self.values = {}

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Returns historical values for periods up to `base_period`; computes forecast for later periods.

        Args:
            period (str): Period identifier, historical or forecast.

        Returns:
            float: Value for the specified period.

        Raises:
            ValueError: If `period` is not a historical or forecast period.
        &#34;&#34;&#34;
        if period not in self._cache:
            self._cache[period] = self._calculate_value(period)
        return self._cache[period]

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached forecast values.

        Use to force recomputation of all periods when input data changes.
        &#34;&#34;&#34;
        self._cache.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes that this forecast depends on.

        Returns:
            list[str]: Single-element list of the input node&#39;s name.
        &#34;&#34;&#34;
        return [self.input_node.name]

    def _calculate_value(self, period: str) -&gt; float:
        &#34;&#34;&#34;Compute the value for a given period without caching.

        Args:
            period (str): Period identifier to compute.

        Returns:
            float: Historical or forecasted value.

        Raises:
            ValueError: If `period` is not valid for this node.
        &#34;&#34;&#34;
        # For historical periods, return the actual value
        if period &lt;= self.base_period:
            # Return historical value, ensuring float type
            return float(self.values.get(period, 0.0))

        # For forecast periods, calculate using growth rate
        if period not in self.forecast_periods:
            raise ValueError(f&#34;Period &#39;{period}&#39; not in forecast periods for {self.name}&#34;)

        # Get the previous period&#39;s value
        prev_period = self._get_previous_period(period)
        prev_value = self.calculate(prev_period)

        # Get the growth rate for this period
        growth_factor = self._get_growth_factor_for_period(period, prev_period, prev_value)

        # Calculate the new value
        return prev_value * (1 + growth_factor)

    def _get_previous_period(self, current_period: str) -&gt; str:
        all_periods = sorted([self.base_period, *self.forecast_periods])
        idx = all_periods.index(current_period)
        return all_periods[idx - 1]

    @abstractmethod
    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        &#34;&#34;&#34;Return the growth factor for *period*.

        Subclasses must implement this to provide their specific growth logic.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Subclasses must implement _get_growth_factor_for_period.&#34;)

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation including base forecast parameters.

        Note:
            Subclasses should override to include specific forecast details.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;forecast&#34;,
            &#34;name&#34;: self.name,
            &#34;base_node_name&#34;: self.input_node.name,
            &#34;base_period&#34;: self.base_period,
            &#34;forecast_periods&#34;: self.forecast_periods.copy(),
            &#34;forecast_type&#34;: &#34;base&#34;,  # Override in subclasses
        }

    @classmethod
    @abstractmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;ForecastNode&#34;:
        &#34;&#34;&#34;Recreate a ForecastNode from serialized data.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new ForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
            NotImplementedError: This base method should be overridden by subclasses.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Subclasses must implement from_dict.&#34;)</code></pre>
</details>
<div class="desc"><p>Base class for projecting future values from historical data.</p>
<p>ForecastNode uses a source node's historical data to generate projected values
for specified future periods, caching results to avoid redundant computations.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; ForecastNode</code>:
Classmethod to deserialize a node from a dictionary. Subclasses must override this method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node providing historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period used as forecast base.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Historical and forecasted values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; from fin_statement_model.core.nodes.forecast_nodes import FixedGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100, &quot;2023&quot;: 110})
&gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &quot;2023&quot;, [&quot;2024&quot;, &quot;2025&quot;], 0.05)
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2025&quot;), 2)
121.28
</code></pre>
<p>Initialize a ForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period as forecast base.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to generate forecasts for.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode">AverageHistoricalGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode">AverageValueForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.ForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a ForecastNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new ForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>This base method should be overridden by subclasses.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.ForecastNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Returns historical values for periods up to `base_period`; computes forecast for later periods.

    Args:
        period (str): Period identifier, historical or forecast.

    Returns:
        float: Value for the specified period.

    Raises:
        ValueError: If `period` is not a historical or forecast period.
    &#34;&#34;&#34;
    if period not in self._cache:
        self._cache[period] = self._calculate_value(period)
    return self._cache[period]</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Returns historical values for periods up to <code>base_period</code>; computes forecast for later periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier, historical or forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Value for the specified period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>period</code> is not a historical or forecast period.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.ForecastNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached forecast values.

    Use to force recomputation of all periods when input data changes.
    &#34;&#34;&#34;
    self._cache.clear()</code></pre>
</details>
<div class="desc"><p>Clear cached forecast values.</p>
<p>Use to force recomputation of all periods when input data changes.</p></div>
</dd>
<dt id="fin_statement_model.ForecastNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes that this forecast depends on.

    Returns:
        list[str]: Single-element list of the input node&#39;s name.
    &#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes that this forecast depends on.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Single-element list of the input node's name.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.ForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation including base forecast parameters.

    Note:
        Subclasses should override to include specific forecast details.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;forecast&#34;,
        &#34;name&#34;: self.name,
        &#34;base_node_name&#34;: self.input_node.name,
        &#34;base_period&#34;: self.base_period,
        &#34;forecast_periods&#34;: self.forecast_periods.copy(),
        &#34;forecast_type&#34;: &#34;base&#34;,  # Override in subclasses
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation including base forecast parameters.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Subclasses should override to include specific forecast details.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>periods: list[str] | None = None,<br>*,<br>calc_engine_cls: type[CalculationEngine] = fin_statement_model.core.graph.services.calculation_engine.CalculationEngine,<br>period_service_cls: type[PeriodService] = fin_statement_model.core.graph.services.period_service.PeriodService,<br>adjustment_service_cls: type[AdjustmentService] = fin_statement_model.core.graph.services.adjustment_service.AdjustmentService)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(
    GraphBaseMixin,
    NodeOpsMixin,
    CalcOpsMixin,
    AdjustmentMixin,
    MergeReprMixin,
    TraversalMixin,
):
    &#34;&#34;&#34;Unified directed-graph abstraction for financial-statement modelling.

    The Graph class exposes a high-level API for building, mutating, and evaluating
    financial statement calculation graphs. All functionality is provided by the mix-ins.

    See module docstring for a comprehensive feature list and usage example.
    &#34;&#34;&#34;

    # All functionality is provided by the mix-ins.</code></pre>
</details>
<div class="desc"><p>Unified directed-graph abstraction for financial-statement modelling.</p>
<p>The Graph class exposes a high-level API for building, mutating, and evaluating
financial statement calculation graphs. All functionality is provided by the mix-ins.</p>
<p>See module docstring for a comprehensive feature list and usage example.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fin_statement_model.core.graph.components._base.GraphBaseMixin</li>
<li>fin_statement_model.core.graph.components._node_ops.NodeOpsMixin</li>
<li>fin_statement_model.core.graph.components._calc_ops.CalcOpsMixin</li>
<li>fin_statement_model.core.graph.components._adjustment_ops.AdjustmentMixin</li>
<li>fin_statement_model.core.graph.components._merge_repr.MergeReprMixin</li>
<li>fin_statement_model.core.graph.components._traversal_ops.TraversalMixin</li>
</ul>
</dd>
<dt id="fin_statement_model.MultiPeriodStatNode"><code class="flex name class">
<span>class <span class="ident">MultiPeriodStatNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>periods: list[str],<br>stat_func: Callable[..., typing.Any] = &lt;function stdev&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;multi_period_stat&#34;)
class MultiPeriodStatNode(Node):
    &#34;&#34;&#34;Compute a statistical measure over multiple periods.

    Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning if stat_func is custom).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes. Custom stat functions may require manual reconstruction.

    Attributes:
        input_node (Node): Node providing source values.
        periods (list[str]): Period identifiers to include.
        stat_func (StatFunc): Function to apply to collected values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
        &gt;&gt;&gt; data = {&#34;Q1&#34;: 10, &#34;Q2&#34;: 12, &#34;Q3&#34;: 11, &#34;Q4&#34;: 13}
        &gt;&gt;&gt; sales = FinancialStatementItemNode(&#34;sales&#34;, data)
        &gt;&gt;&gt; import statistics
        &gt;&gt;&gt; avg = MultiPeriodStatNode(
        ...     &#34;avg_sales&#34;, input_node=sales, periods=[&#34;Q1&#34;, &#34;Q2&#34;, &#34;Q3&#34;, &#34;Q4&#34;], stat_func=statistics.mean
        ... )
        &gt;&gt;&gt; d = avg.to_dict()
        &gt;&gt;&gt; avg2 = MultiPeriodStatNode.from_dict(d, {&#34;sales&#34;: sales})
        &gt;&gt;&gt; avg2.calculate()
        11.5
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        input_node: Node,
        periods: list[str],
        stat_func: StatFunc = statistics.stdev,  # Default to standard deviation
    ):
        &#34;&#34;&#34;Create a MultiPeriodStatNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values.
            periods (list[str]): Period identifiers to analyze.
            stat_func (StatFunc): Function applied to collected values. Defaults to statistics.stdev.

        Raises:
            ValueError: If `periods` is empty or not a list.
            TypeError: If `input_node` is not a Node or `stat_func` is not callable.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;MultiPeriodStatNode input_node must be a Node instance.&#34;)
        if not isinstance(periods, list) or not periods:
            raise ValueError(&#34;MultiPeriodStatNode periods must be a non-empty list.&#34;)
        if not all(isinstance(p, str) for p in periods):
            raise TypeError(&#34;MultiPeriodStatNode periods must contain only strings.&#34;)
        if not callable(stat_func):
            raise TypeError(&#34;MultiPeriodStatNode stat_func must be a callable function.&#34;)

        self.input_node = input_node
        self.periods = periods
        self.stat_func = stat_func

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the statistical measure across specified periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

        Raises:
            CalculationError: If input retrieval fails or unexpected errors occur.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        values: list[Numeric] = []
        retrieval_errors = []
        try:
            for p in self.periods:
                try:
                    value = self.input_node.calculate(p)
                    if isinstance(value, int | float) and math.isfinite(value):
                        values.append(float(value))
                    else:
                        # Log non-numeric/non-finite values but continue if possible
                        logger.warning(
                            &#34;MultiPeriodStatNode &#39;%s&#39;: Input &#39;%s&#39; gave non-numeric/non-finite value (%s) for period &#39;%s&#39;. Skipping.&#34;,
                            self.name,
                            self.input_node.name,
                            value,
                            p,
                        )
                except Exception:
                    # Log error fetching data for a specific period but continue
                    logger.exception(
                        &#34;MultiPeriodStatNode &#39;%s&#39;: Error getting value for period &#39;%s&#39; from &#39;%s&#39;&#34;,
                        self.name,
                        p,
                        self.input_node.name,
                    )
                    retrieval_errors.append(p)

            # If no valid numeric values were collected
            if not values:
                logger.warning(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: No valid numeric data points found across periods %s. Returning NaN.&#34;,
                    self.name,
                    self.periods,
                )
                return float(&#34;nan&#34;)

            # Attempt the statistical calculation
            try:
                result = self.stat_func(values)
                # Ensure result is float, handle potential NaN from stat_func
                return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
            except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
                # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
                logger.warning(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: Stat function &#39;%s&#39; failed (%s). Values: %s. Returning NaN.&#34;,
                    self.name,
                    self.stat_func.__name__,
                    stat_err,
                    values,
                )
                return float(&#34;nan&#34;)

        except Exception as e:
            # Catch any other unexpected errors during the process
            raise CalculationError(
                message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=&#34;multi-period&#34;,  # Indicate calculation context
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;periods&#34;: self.periods,
                    &#34;stat_func&#34;: self.stat_func.__name__,
                    &#34;collected_values_count&#34;: len(values),
                    &#34;retrieval_errors_periods&#34;: retrieval_errors,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized data with function name and periods.

        Note:
            `stat_func` may not be fully serializable; manual reconstruction may be required.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;multi_period_stat&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;periods&#34;: self.periods.copy(),
            &#34;stat_func_name&#34;: self.stat_func.__name__,
            &#34;serialization_warning&#34;: (
                &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
                &#34;Manual reconstruction may be required for custom functions.&#34;
            ),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;MultiPeriodStatNode&#34;:
        &#34;&#34;&#34;Recreate a MultiPeriodStatNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            MultiPeriodStatNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;multi_period_stat&#34;:
            raise ValueError(f&#34;Invalid type for MultiPeriodStatNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in MultiPeriodStatNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in MultiPeriodStatNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize MultiPeriodStatNode&#34;)
        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        periods = data.get(&#34;periods&#34;, [])
        stat_func_name = data.get(&#34;stat_func_name&#34;, &#34;stdev&#34;)

        if not periods:
            raise ValueError(&#34;Missing or empty &#39;periods&#39; field in MultiPeriodStatNode data&#34;)

        # Map common statistical function names to their implementations
        stat_func_map: dict[str, StatFunc] = {
            &#34;mean&#34;: statistics.mean,
            &#34;stdev&#34;: statistics.stdev,
            &#34;median&#34;: statistics.median,
            &#34;variance&#34;: statistics.variance,
            &#34;pstdev&#34;: statistics.pstdev,
            &#34;pvariance&#34;: statistics.pvariance,
        }

        stat_func = stat_func_map.get(stat_func_name, statistics.stdev)
        if stat_func_name not in stat_func_map:
            logger.warning(
                &#34;Unknown stat_func_name &#39;%s&#39; for MultiPeriodStatNode &#39;%s&#39;. Using default statistics.stdev.&#34;,
                stat_func_name,
                name,
            )

        return cls(
            name=name,
            input_node=input_node,
            periods=periods,
            stat_func=stat_func,
        )</code></pre>
</details>
<div class="desc"><p>Compute a statistical measure over multiple periods.</p>
<p>Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning if stat_func is custom).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes. Custom stat functions may require manual reconstruction.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to include.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function to apply to collected values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
&gt;&gt;&gt; data = {&quot;Q1&quot;: 10, &quot;Q2&quot;: 12, &quot;Q3&quot;: 11, &quot;Q4&quot;: 13}
&gt;&gt;&gt; sales = FinancialStatementItemNode(&quot;sales&quot;, data)
&gt;&gt;&gt; import statistics
&gt;&gt;&gt; avg = MultiPeriodStatNode(
...     &quot;avg_sales&quot;, input_node=sales, periods=[&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot;], stat_func=statistics.mean
... )
&gt;&gt;&gt; d = avg.to_dict()
&gt;&gt;&gt; avg2 = MultiPeriodStatNode.from_dict(d, {&quot;sales&quot;: sales})
&gt;&gt;&gt; avg2.calculate()
11.5
</code></pre>
<p>Create a MultiPeriodStatNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to analyze.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function applied to collected values. Defaults to statistics.stdev.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>periods</code> is empty or not a list.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or <code>stat_func</code> is not callable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.MultiPeriodStatNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a MultiPeriodStatNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.MultiPeriodStatNode" href="#fin_statement_model.MultiPeriodStatNode">MultiPeriodStatNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.MultiPeriodStatNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the statistical measure across specified periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

    Raises:
        CalculationError: If input retrieval fails or unexpected errors occur.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    values: list[Numeric] = []
    retrieval_errors = []
    try:
        for p in self.periods:
            try:
                value = self.input_node.calculate(p)
                if isinstance(value, int | float) and math.isfinite(value):
                    values.append(float(value))
                else:
                    # Log non-numeric/non-finite values but continue if possible
                    logger.warning(
                        &#34;MultiPeriodStatNode &#39;%s&#39;: Input &#39;%s&#39; gave non-numeric/non-finite value (%s) for period &#39;%s&#39;. Skipping.&#34;,
                        self.name,
                        self.input_node.name,
                        value,
                        p,
                    )
            except Exception:
                # Log error fetching data for a specific period but continue
                logger.exception(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: Error getting value for period &#39;%s&#39; from &#39;%s&#39;&#34;,
                    self.name,
                    p,
                    self.input_node.name,
                )
                retrieval_errors.append(p)

        # If no valid numeric values were collected
        if not values:
            logger.warning(
                &#34;MultiPeriodStatNode &#39;%s&#39;: No valid numeric data points found across periods %s. Returning NaN.&#34;,
                self.name,
                self.periods,
            )
            return float(&#34;nan&#34;)

        # Attempt the statistical calculation
        try:
            result = self.stat_func(values)
            # Ensure result is float, handle potential NaN from stat_func
            return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
        except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
            # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
            logger.warning(
                &#34;MultiPeriodStatNode &#39;%s&#39;: Stat function &#39;%s&#39; failed (%s). Values: %s. Returning NaN.&#34;,
                self.name,
                self.stat_func.__name__,
                stat_err,
                values,
            )
            return float(&#34;nan&#34;)

    except Exception as e:
        # Catch any other unexpected errors during the process
        raise CalculationError(
            message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=&#34;multi-period&#34;,  # Indicate calculation context
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;periods&#34;: self.periods,
                &#34;stat_func&#34;: self.stat_func.__name__,
                &#34;collected_values_count&#34;: len(values),
                &#34;retrieval_errors_periods&#34;: retrieval_errors,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the statistical measure across specified periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Result of <code>stat_func</code> on collected values, or NaN if insufficient valid data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If input retrieval fails or unexpected errors occur.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.MultiPeriodStatNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this statistical node depends on.</p></div>
</dd>
<dt id="fin_statement_model.MultiPeriodStatNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized data with function name and periods.

    Note:
        `stat_func` may not be fully serializable; manual reconstruction may be required.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;multi_period_stat&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;periods&#34;: self.periods.copy(),
        &#34;stat_func_name&#34;: self.stat_func.__name__,
        &#34;serialization_warning&#34;: (
            &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
            &#34;Manual reconstruction may be required for custom functions.&#34;
        ),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized data with function name and periods.</dd>
</dl>
<h2 id="note">Note</h2>
<p><code>stat_func</code> may not be fully serializable; manual reconstruction may be required.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(ABC):
    &#34;&#34;&#34;Abstract base class for all nodes in the financial statement model.

    This class defines the required interface for all node types, including calculation,
    serialization, and dependency inspection. Subclasses must implement `calculate`, `to_dict`,
    and (for deserializable nodes) `from_dict` as a classmethod.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node`:
            Classmethod to deserialize a node from a dictionary. Nodes with dependencies
            (e.g., calculation, forecast, stat nodes) must use the `context` argument to resolve them.
            Data nodes may ignore `context`.

    Attributes:
        name (str): Unique identifier for the node instance.
        values (dict[str, Any]): Optional mapping of period to value (for data nodes).

    Example:
        &gt;&gt;&gt; class DummyNode(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     @classmethod
        ...     def from_dict(cls, data, context=None):
        ...         return cls(data[&#34;name&#34;])
        &gt;&gt;&gt; node = DummyNode(&#34;Revenue&#34;)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; DummyNode.from_dict(d).name
        &#39;Revenue&#39;
    &#34;&#34;&#34;

    name: str
    values: dict[str, Any]

    def __init__(self, name: str):
        &#34;&#34;&#34;Initialize the Node instance with a unique name.

        Args:
            name (str): Unique identifier for the node. Must be a non-empty string.

        Raises:
            ValueError: If `name` is empty, not a string, or contains invalid characters.

        Example:
            &gt;&gt;&gt; Node(&#34;Revenue&#34;)  # doctest: +ELLIPSIS
            Traceback (most recent call last):
            ...
            TypeError: Can&#39;t instantiate abstract class Node...
        &#34;&#34;&#34;
        # Check if name is a non-empty string
        if not isinstance(name, str) or not name:
            raise ValueError(&#34;Node name must be a non-empty string.&#34;)
        # Check for invalid characters (including newline, tab)
        if &#34;\n&#34; in name or &#34;\t&#34; in name:
            raise ValueError(f&#34;Invalid node name: &#39;{name}&#39;. Contains invalid characters.&#34;)
        # Check for leading/trailing whitespace
        if name != name.strip():
            raise ValueError(f&#34;Invalid node name: &#39;{name}&#39;. Cannot have leading/trailing whitespace.&#34;)
        self.name = name

    @abstractmethod
    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Subclasses must override this method to implement specific calculation logic.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 2.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; Dummy(&#34;Test&#34;).calculate(&#34;2023&#34;)
            2.0
        &#34;&#34;&#34;

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached calculation results for this node.

        Subclasses with caching should override this method to clear their internal cache.

        Returns:
            None

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def clear_cache(self):
            ...         print(&#34;Cache cleared!&#34;)
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.clear_cache()
            Cache cleared!
        &#34;&#34;&#34;
        # Default: no cache to clear
        return None

    def has_attribute(self, attr_name: str) -&gt; bool:
        &#34;&#34;&#34;Check if the node has a specific attribute.

        Args:
            attr_name (str): The name of the attribute to check.

        Returns:
            bool: True if the attribute exists, otherwise False.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
            True
        &#34;&#34;&#34;
        return hasattr(self, attr_name)

    def get_attribute(self, attribute_name: str) -&gt; object:
        &#34;&#34;&#34;Get a named attribute from the node.

        Args:
            attribute_name (str): The name of the attribute to retrieve.

        Returns:
            object: The value of the specified attribute.

        Raises:
            AttributeError: If the attribute does not exist.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
            &#39;Test&#39;
        &#34;&#34;&#34;
        try:
            return getattr(self, attribute_name)
        except AttributeError as err:
            raise AttributeError(f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;) from err

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

        Override in subclasses to support mutating stored data.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Raises:
            NotImplementedError: Always in base class.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def set_value(self, period, value):
            ...         print(f&#34;Set {period} to {value}&#34;)
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.set_value(&#34;2023&#34;, 100)
            Set 2023 to 100
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)

    @abstractmethod
    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        This method should return a dictionary containing all information
        necessary to reconstruct the node, including:
        - node type
        - name
        - any configuration parameters
        - values (for data nodes)
        - input references (for calculation nodes)

        Returns:
            dict[str, Any]: Dictionary representation of the node.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.to_dict()[&#34;type&#34;]
            &#39;dummy&#39;
        &#34;&#34;&#34;

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the names of nodes this node depends on.

        Default implementation returns empty list. Override in nodes that have dependencies.

        Returns:
            list[str]: List of node names this node depends on.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def get_dependencies(self):
            ...         return [&#34;dep1&#34;, &#34;dep2&#34;]
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.get_dependencies()
            [&#39;dep1&#39;, &#39;dep2&#39;]
        &#34;&#34;&#34;
        return []

    @classmethod
    @abstractmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, &#34;Node&#34;] | None = None,
    ) -&gt; &#34;Node&#34;:
        &#34;&#34;&#34;Deserialize a node from its dictionary representation.

        Subclasses that support deserialization must override this method.
        Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the
        `context` argument to resolve them. Data nodes may ignore `context`.

        Args:
            data: The serialized node dictionary (usually produced by :py:meth:`to_dict`).
            context: Optional mapping of node names to node objects that have already been deserialized.

        Returns:
            Node: A fully instantiated node object.

        Raises:
            NotImplementedError: If not overridden in a subclass.

        Example:
            &gt;&gt;&gt; class DummyNode(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     @classmethod
            ...     def from_dict(cls, data, context=None):
            ...         return cls(data[&#34;name&#34;])
            &gt;&gt;&gt; node = DummyNode(&#34;Revenue&#34;)
            &gt;&gt;&gt; d = node.to_dict()
            &gt;&gt;&gt; DummyNode.from_dict(d).name
            &#39;Revenue&#39;
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{cls.__name__}.from_dict() is not implemented. Subclasses requiring deserialization must override this method.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Abstract base class for all nodes in the financial statement model.</p>
<p>This class defines the required interface for all node types, including calculation,
serialization, and dependency inspection. Subclasses must implement <code>calculate</code>, <code>to_dict</code>,
and (for deserializable nodes) <code>from_dict</code> as a classmethod.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node</code>:
Classmethod to deserialize a node from a dictionary. Nodes with dependencies
(e.g., calculation, forecast, stat nodes) must use the <code>context</code> argument to resolve them.
Data nodes may ignore <code>context</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node instance.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Optional mapping of period to value (for data nodes).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     @classmethod
...     def from_dict(cls, data, context=None):
...         return cls(data[&quot;name&quot;])
&gt;&gt;&gt; node = DummyNode(&quot;Revenue&quot;)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; DummyNode.from_dict(d).name
'Revenue'
</code></pre>
<p>Initialize the Node instance with a unique name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node. Must be a non-empty string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, not a string, or contains invalid characters.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Node(&quot;Revenue&quot;)  # doctest: +ELLIPSIS
Traceback (most recent call last):
...
TypeError: Can't instantiate abstract class Node...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode" href="core/nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode">CustomCalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="core/nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></li>
<li>fin_statement_model.io.graph.definition_io.GraphDefinitionReader._TempNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.Node.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.Node.values"><code class="name">var <span class="ident">values</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.Node.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, '<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>'] | None = None) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize a node from its dictionary representation.</p>
<p>Subclasses that support deserialization must override this method.
Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the
<code>context</code> argument to resolve them. Data nodes may ignore <code>context</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The serialized node dictionary (usually produced by :py:meth:<code>to_dict</code>).</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional mapping of node names to node objects that have already been deserialized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>A fully instantiated node object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If not overridden in a subclass.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     @classmethod
...     def from_dict(cls, data, context=None):
...         return cls(data[&quot;name&quot;])
&gt;&gt;&gt; node = DummyNode(&quot;Revenue&quot;)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; DummyNode.from_dict(d).name
'Revenue'
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.Node.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Subclasses must override this method to implement specific calculation logic.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 2.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; Dummy(&#34;Test&#34;).calculate(&#34;2023&#34;)
        2.0
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Subclasses must override this method to implement specific calculation logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 2.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; Dummy(&quot;Test&quot;).calculate(&quot;2023&quot;)
2.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached calculation results for this node.

    Subclasses with caching should override this method to clear their internal cache.

    Returns:
        None

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def clear_cache(self):
        ...         print(&#34;Cache cleared!&#34;)
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.clear_cache()
        Cache cleared!
    &#34;&#34;&#34;
    # Default: no cache to clear
    return None</code></pre>
</details>
<div class="desc"><p>Clear cached calculation results for this node.</p>
<p>Subclasses with caching should override this method to clear their internal cache.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def clear_cache(self):
...         print(&quot;Cache cleared!&quot;)
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.clear_cache()
Cache cleared!
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.get_attribute"><code class="name flex">
<span>def <span class="ident">get_attribute</span></span>(<span>self, attribute_name: str) ‑> object</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute(self, attribute_name: str) -&gt; object:
    &#34;&#34;&#34;Get a named attribute from the node.

    Args:
        attribute_name (str): The name of the attribute to retrieve.

    Returns:
        object: The value of the specified attribute.

    Raises:
        AttributeError: If the attribute does not exist.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
        &#39;Test&#39;
    &#34;&#34;&#34;
    try:
        return getattr(self, attribute_name)
    except AttributeError as err:
        raise AttributeError(f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;) from err</code></pre>
</details>
<div class="desc"><p>Get a named attribute from the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the attribute to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The value of the specified attribute.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If the attribute does not exist.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.get_attribute(&quot;name&quot;)
'Test'
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the names of nodes this node depends on.

    Default implementation returns empty list. Override in nodes that have dependencies.

    Returns:
        list[str]: List of node names this node depends on.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def get_dependencies(self):
        ...         return [&#34;dep1&#34;, &#34;dep2&#34;]
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.get_dependencies()
        [&#39;dep1&#39;, &#39;dep2&#39;]
    &#34;&#34;&#34;
    return []</code></pre>
</details>
<div class="desc"><p>Get the names of nodes this node depends on.</p>
<p>Default implementation returns empty list. Override in nodes that have dependencies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of node names this node depends on.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def get_dependencies(self):
...         return [&quot;dep1&quot;, &quot;dep2&quot;]
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.get_dependencies()
['dep1', 'dep2']
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.has_attribute"><code class="name flex">
<span>def <span class="ident">has_attribute</span></span>(<span>self, attr_name: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_attribute(self, attr_name: str) -&gt; bool:
    &#34;&#34;&#34;Check if the node has a specific attribute.

    Args:
        attr_name (str): The name of the attribute to check.

    Returns:
        bool: True if the attribute exists, otherwise False.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
        True
    &#34;&#34;&#34;
    return hasattr(self, attr_name)</code></pre>
</details>
<div class="desc"><p>Check if the node has a specific attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attr_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the attribute to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the attribute exists, otherwise False.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.has_attribute(&quot;name&quot;)
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

    Override in subclasses to support mutating stored data.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Raises:
        NotImplementedError: Always in base class.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def set_value(self, period, value):
        ...         print(f&#34;Set {period} to {value}&#34;)
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.set_value(&#34;2023&#34;, 100)
        Set 2023 to 100
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)</code></pre>
</details>
<div class="desc"><p>Set a value for a specific period on data-bearing nodes.</p>
<p>Override in subclasses to support mutating stored data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Always in base class.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def set_value(self, period, value):
...         print(f&quot;Set {period} to {value}&quot;)
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.set_value(&quot;2023&quot;, 100)
Set 2023 to 100
</code></pre></div>
</dd>
<dt id="fin_statement_model.Node.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    This method should return a dictionary containing all information
    necessary to reconstruct the node, including:
    - node type
    - name
    - any configuration parameters
    - values (for data nodes)
    - input references (for calculation nodes)

    Returns:
        dict[str, Any]: Dictionary representation of the node.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.to_dict()[&#34;type&#34;]
        &#39;dummy&#39;
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<p>This method should return a dictionary containing all information
necessary to reconstruct the node, including:
- node type
- name
- any configuration parameters
- values (for data nodes)
- input references (for calculation nodes)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary representation of the node.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.to_dict()[&quot;type&quot;]
'dummy'
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.NodeFactory"><code class="flex name class">
<span>class <span class="ident">NodeFactory</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeFactory:  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Static aggregation of builder, deserializer, and helper functions for node creation.

    This class exposes static methods for creating financial statement items, calculation nodes, forecast nodes,
    and for deserializing nodes from dictionaries. It also provides access to custom node creation helpers and
    legacy calculation method mappings.

    All methods are static and simply delegate to the underlying functional helpers. This allows both service-object
    and functional usage patterns.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory import NodeFactory
        &gt;&gt;&gt; node = NodeFactory.create_financial_statement_item(&#34;COGS&#34;, {&#34;2022&#34;: 50.0})
        &gt;&gt;&gt; node
        &lt;FinancialStatementItemNode name=&#39;COGS&#39;&gt;
    &#34;&#34;&#34;

    # ------------------------------------------------------------------
    # Builders
    # ------------------------------------------------------------------
    create_financial_statement_item = staticmethod(_builders.create_financial_statement_item)
    create_calculation_node = staticmethod(_builders.create_calculation_node)
    create_forecast_node = staticmethod(_builders.create_forecast_node)

    # ------------------------------------------------------------------
    # Deserialisation
    # ------------------------------------------------------------------
    create_from_dict = staticmethod(_deser.create_from_dict)

    # ------------------------------------------------------------------
    # Custom helper
    # ------------------------------------------------------------------
    _create_custom_node_from_callable = staticmethod(
        _custom._create_custom_node_from_callable  # pylint: disable=protected-access
    )

    # ------------------------------------------------------------------
    # Legacy attribute mapping used by existing code
    # ------------------------------------------------------------------
    _calculation_methods: ClassVar[dict[str, str]] = {
        alias: cls.__name__ for alias, cls in CalculationAliasRegistry.items()
    }</code></pre>
</details>
<div class="desc"><p>Static aggregation of builder, deserializer, and helper functions for node creation.</p>
<p>This class exposes static methods for creating financial statement items, calculation nodes, forecast nodes,
and for deserializing nodes from dictionaries. It also provides access to custom node creation helpers and
legacy calculation method mappings.</p>
<p>All methods are static and simply delegate to the underlying functional helpers. This allows both service-object
and functional usage patterns.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory import NodeFactory
&gt;&gt;&gt; node = NodeFactory.create_financial_statement_item(&quot;COGS&quot;, {&quot;2022&quot;: 50.0})
&gt;&gt;&gt; node
&lt;FinancialStatementItemNode name='COGS'&gt;
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.NodeFactory.create_calculation_node"><code class="name flex">
<span>def <span class="ident">create_calculation_node</span></span>(<span>*,<br>name: str,<br>inputs: list[<a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>],<br>calculation_type: str,<br>formula_variable_names: list[str] | None = None,<br>**calculation_kwargs: Any) ‑> <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_calculation_node(
    *,
    name: str,
    inputs: list[Node],
    calculation_type: str,
    formula_variable_names: list[str] | None = None,
    **calculation_kwargs: Any,
) -&gt; Node:
    &#34;&#34;&#34;Create a generic calculation node using alias lookup.

    Args:
        name: The name of the calculation node.
        inputs: List of input Node instances.
        calculation_type: Alias for the calculation type (e.g., &#39;addition&#39;, &#39;formula&#39;).
        formula_variable_names: Optional list of variable names for formula calculations.
        **calculation_kwargs: Additional keyword arguments for calculation or node attributes.

    Returns:
        Node: An instance of CalculationNode with the specified calculation logic.

    Raises:
        ConfigurationError: If the calculation_type is unknown or inputs are invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_calculation_node
        &gt;&gt;&gt; # Assume n1, n2 are Node instances
        &gt;&gt;&gt; node = create_calculation_node(name=&#34;GrossProfit&#34;, inputs=[n1, n2], calculation_type=&#34;addition&#34;)
        &gt;&gt;&gt; node.name
        &#39;GrossProfit&#39;
    &#34;&#34;&#34;
    # Lazy import to avoid heavy dependency when this builder is unused
    calculation_node_cls = _import_calculation_node()

    # Validate inputs are Node instances
    for n in inputs:
        _ensure_node_instance(n)

    try:
        calc_cls = CalculationAliasRegistry.get(calculation_type)
    except KeyError as exc:
        raise ConfigurationError(
            f&#34;Unknown calculation_type alias &#39;{calculation_type}&#39;. Registered: {CalculationAliasRegistry.list()}&#34;
        ) from exc

    # Special case: formula calculation needs variable names - tack them on via
    # kwargs so constructor signature remains flexible.
    if formula_variable_names is not None:
        calculation_kwargs.setdefault(&#34;input_variable_names&#34;, formula_variable_names)

    # Split kwargs between calculation-init and node extra attributes
    node_extra_kwargs = {}
    for key in (&#34;metric_name&#34;, &#34;metric_description&#34;):
        if key in calculation_kwargs:
            node_extra_kwargs[key] = calculation_kwargs.pop(key)

    calculation_instance = calc_cls(**calculation_kwargs)

    return cast(
        &#34;Node&#34;,
        calculation_node_cls(name, inputs, calculation_instance, **node_extra_kwargs),
    )</code></pre>
</details>
<div class="desc"><p>Create a generic calculation node using alias lookup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the calculation node.</dd>
<dt><strong><code>inputs</code></strong></dt>
<dd>List of input Node instances.</dd>
<dt><strong><code>calculation_type</code></strong></dt>
<dd>Alias for the calculation type (e.g., 'addition', 'formula').</dd>
<dt><strong><code>formula_variable_names</code></strong></dt>
<dd>Optional list of variable names for formula calculations.</dd>
<dt><strong><code>**calculation_kwargs</code></strong></dt>
<dd>Additional keyword arguments for calculation or node attributes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>An instance of CalculationNode with the specified calculation logic.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConfigurationError</code></dt>
<dd>If the calculation_type is unknown or inputs are invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_calculation_node
&gt;&gt;&gt; # Assume n1, n2 are Node instances
&gt;&gt;&gt; node = create_calculation_node(name=&quot;GrossProfit&quot;, inputs=[n1, n2], calculation_type=&quot;addition&quot;)
&gt;&gt;&gt; node.name
'GrossProfit'
</code></pre></div>
</dd>
<dt id="fin_statement_model.NodeFactory.create_financial_statement_item"><code class="name flex">
<span>def <span class="ident">create_financial_statement_item</span></span>(<span>name: str, values: dict[str, float]) ‑> <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_financial_statement_item(name: str, values: dict[str, float]) -&gt; Node:
    &#34;&#34;&#34;Instantiate a FinancialStatementItemNode via the registry.

    Args:
        name: The name of the financial statement item (e.g., &#39;Revenue&#39;).
        values: A dictionary mapping period strings to float values.

    Returns:
        Node: An instance of FinancialStatementItemNode.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_financial_statement_item
        &gt;&gt;&gt; node = create_financial_statement_item(&#34;Revenue&#34;, {&#34;2022&#34;: 100.0})
        &gt;&gt;&gt; node.name
        &#39;Revenue&#39;
    &#34;&#34;&#34;
    try:
        node_cls = NodeTypeRegistry.get(&#34;financial_statement_item&#34;)
    except KeyError:
        # Fallback to direct import if not registered yet (pre-decorator phase)
        from fin_statement_model.core.nodes.item_node import (
            FinancialStatementItemNode,
        )  # pylint: disable=import-outside-toplevel

        node_cls = FinancialStatementItemNode

    return cast(&#34;Node&#34;, node_cls(name, values))</code></pre>
</details>
<div class="desc"><p>Instantiate a FinancialStatementItemNode via the registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the financial statement item (e.g., 'Revenue').</dd>
<dt><strong><code>values</code></strong></dt>
<dd>A dictionary mapping period strings to float values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>An instance of FinancialStatementItemNode.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_financial_statement_item
&gt;&gt;&gt; node = create_financial_statement_item(&quot;Revenue&quot;, {&quot;2022&quot;: 100.0})
&gt;&gt;&gt; node.name
'Revenue'
</code></pre></div>
</dd>
<dt id="fin_statement_model.NodeFactory.create_forecast_node"><code class="name flex">
<span>def <span class="ident">create_forecast_node</span></span>(<span>*,<br>forecast_type: str | None = None,<br>input_node: <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a> | None = None,<br>base_period: str | None = None,<br>forecast_periods: list[str] | None = None,<br>growth_params: Any = None,<br>name: str | None = None,<br>base_node: <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a> | None = None,<br>forecast_config: Any | None = None,<br>**_extra: Any) ‑> <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_forecast_node(
    *,
    forecast_type: str | None = None,
    input_node: Node | None = None,
    base_period: str | None = None,
    forecast_periods: list[str] | None = None,
    growth_params: Any = None,
    name: str | None = None,
    base_node: Node | None = None,
    forecast_config: Any | None = None,
    **_extra: Any,
) -&gt; Node:
    &#34;&#34;&#34;Instantiate a forecast node using forecast_type registry lookup.

    Args:
        forecast_type: The type of forecast node to create (e.g., &#39;simple&#39;, &#39;curve&#39;).
        input_node: The input Node to forecast (or use base_node for legacy).
        base_period: The base period string (e.g., &#39;2022&#39;).
        forecast_periods: List of periods to forecast.
        growth_params: Parameters for the forecast method.
        name: (Legacy) Name of the node (ignored).
        base_node: (Legacy) Alias for input_node.
        forecast_config: (Not supported yet).
        **_extra: Additional keyword arguments (ignored).

    Returns:
        Node: An instance of the appropriate ForecastNode subclass.

    Raises:
        ConfigurationError: If required parameters are missing or instantiation fails.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_forecast_node
        &gt;&gt;&gt; # Assume n1 is a Node instance
        &gt;&gt;&gt; node = create_forecast_node(
        ...     forecast_type=&#34;simple&#34;, input_node=n1, base_period=&#34;2022&#34;, forecast_periods=[&#34;2023&#34;, &#34;2024&#34;]
        ... )
        &gt;&gt;&gt; node.name
        n1.name  # Typically inherits from input_node
    &#34;&#34;&#34;
    # Map legacy parameters -------------------------------------------------
    if input_node is None and base_node is not None:
        input_node = base_node

    if name is not None:
        logger.debug(&#34;create_forecast_node: received legacy &#39;name&#39; parameter (ignored): %s&#34;, name)

    if forecast_config is not None:
        # TODO: parse ForecastConfig in a later iteration
        raise ConfigurationError(&#34;create_forecast_node currently does not support &#39;forecast_config&#39; parameter.&#34;)

    if forecast_type is None:
        raise ConfigurationError(&#34;&#39;forecast_type&#39; must be provided.&#34;)
    if input_node is None:
        raise ConfigurationError(&#34;&#39;input_node&#39; (or &#39;base_node&#39;) must be provided.&#34;)
    if base_period is None or forecast_periods is None:
        raise ConfigurationError(&#34;&#39;base_period&#39; and &#39;forecast_periods&#39; are required.&#34;)

    _ensure_node_instance(input_node)

    try:
        forecast_cls = ForecastTypeRegistry.get(forecast_type)
    except KeyError as exc:
        raise ConfigurationError(
            f&#34;Unknown forecast_type &#39;{forecast_type}&#39;. Registered: {ForecastTypeRegistry.list()}&#34;
        ) from exc

    # ---------------------------------------------------------------------
    # Dynamic constructor handling via reflection
    # ---------------------------------------------------------------------
    # We inspect the __init__ signature of the forecast class to determine
    # whether it expects a fourth positional/keyword parameter (commonly
    # `growth_params`). This avoids hard-coding special cases for each
    # forecast_type and automatically works for any new classes added later.

    try:
        sig = inspect.signature(forecast_cls.__init__)
        # Drop the implicit &#39;self&#39;
        ctor_params = [p for p in sig.parameters.values() if p.name != &#34;self&#34;]

        # Base signature is (input_node, base_period, forecast_periods)
        args: list[Any] = [input_node, base_period, forecast_periods]

        # If the constructor defines a 4th parameter OR has a parameter named
        # &#39;growth_params&#39;, we append growth_params as the 4th argument.
        needs_growth = False
        if len(ctor_params) &gt; PARAMS_GROWTH_THRESHOLD:
            needs_growth = True
        else:
            needs_growth = any(p.name == &#34;growth_params&#34; for p in ctor_params)

        if needs_growth:
            args.append(growth_params)

        return cast(&#34;Node&#34;, forecast_cls(*args))

    except TypeError as exc:
        # Provide helpful context with expected signature
        expected = [p.name for p in ctor_params]
        raise ConfigurationError(
            f&#34;Failed to instantiate forecast node for type &#39;{forecast_type}&#39;: {exc}\nConstructor parameters: {expected}&#34;
        ) from exc</code></pre>
</details>
<div class="desc"><p>Instantiate a forecast node using forecast_type registry lookup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forecast_type</code></strong></dt>
<dd>The type of forecast node to create (e.g., 'simple', 'curve').</dd>
<dt><strong><code>input_node</code></strong></dt>
<dd>The input Node to forecast (or use base_node for legacy).</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>The base period string (e.g., '2022').</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
<dt><strong><code>growth_params</code></strong></dt>
<dd>Parameters for the forecast method.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>(Legacy) Name of the node (ignored).</dd>
<dt><strong><code>base_node</code></strong></dt>
<dd>(Legacy) Alias for input_node.</dd>
<dt><strong><code>forecast_config</code></strong></dt>
<dd>(Not supported yet).</dd>
<dt><strong><code>**_extra</code></strong></dt>
<dd>Additional keyword arguments (ignored).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>An instance of the appropriate ForecastNode subclass.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConfigurationError</code></dt>
<dd>If required parameters are missing or instantiation fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_forecast_node
&gt;&gt;&gt; # Assume n1 is a Node instance
&gt;&gt;&gt; node = create_forecast_node(
...     forecast_type=&quot;simple&quot;, input_node=n1, base_period=&quot;2022&quot;, forecast_periods=[&quot;2023&quot;, &quot;2024&quot;]
... )
&gt;&gt;&gt; node.name
n1.name  # Typically inherits from input_node
</code></pre></div>
</dd>
<dt id="fin_statement_model.NodeFactory.create_from_dict"><code class="name flex">
<span>def <span class="ident">create_from_dict</span></span>(<span>data: dict[str, Any],<br>ctx: dict[str, <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>] | None = None,<br>*,<br>context: dict[str, <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_from_dict(
    data: dict[str, Any],
    ctx: dict[str, Node] | None = None,
    *,
    context: dict[str, Node] | None = None,
) -&gt; Node:
    &#34;&#34;&#34;Rebuild a Node from its serialised data.

    Args:
        data: Mapping produced by Node.to_dict().
        ctx: Existing nodes (name ➜ Node) used to resolve dependencies.
        context: Alternative keyword for backward-compatibility.

    Returns:
        Node: A live Node instance reconstructed from the dictionary.

    Raises:
        TypeError: If data is not a dict.
        ConfigurationError: If the payload is invalid or type look-up fails.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.deserialisers import create_from_dict
        &gt;&gt;&gt; # Assume dct is a valid node dict and ctx is a context dict
        &gt;&gt;&gt; node = create_from_dict(dct, ctx)
        &gt;&gt;&gt; node.name
        dct[&#39;name&#39;]
    &#34;&#34;&#34;
    # Support alternative keyword ``context`` for backward-compat
    if ctx is None and context is not None:
        ctx = context
    if ctx is None:
        ctx = {}

    if not isinstance(data, dict):
        raise TypeError(&#34;create_from_dict: &#39;data&#39; must be a dict&#34;)

    node_type_key = data.get(&#34;type&#34;)
    if not node_type_key or not isinstance(node_type_key, str):
        raise ConfigurationError(&#34;Serialised node missing &#39;type&#39; field.&#34;)

    # Special dispatch for forecasts - their *sub*-type is stored separately
    if node_type_key == &#34;forecast&#34;:
        node_cls = _get_forecast_node_cls(data)
    else:
        try:
            node_cls = NodeTypeRegistry.get(node_type_key)
        except KeyError as exc:
            raise ConfigurationError(
                f&#34;Unknown node &#39;type&#39; &#39;{node_type_key}&#39;. Registered: {NodeTypeRegistry.list()}&#34;
            ) from exc

    # Use unified from_dict API
    if hasattr(node_cls, &#34;from_dict&#34;):
        logger.debug(&#34;Deserialising %s via from_dict&#34;, node_cls)
        return node_cls.from_dict(data, ctx)

    # If we get here the node class does not support deserialisation via factory
    raise ConfigurationError(f&#34;Node class {node_cls.__name__} does not expose from_dict method.&#34;)</code></pre>
</details>
<div class="desc"><p>Rebuild a Node from its serialised data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Mapping produced by Node.to_dict().</dd>
<dt><strong><code>ctx</code></strong></dt>
<dd>Existing nodes (name ➜ Node) used to resolve dependencies.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Alternative keyword for backward-compatibility.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>A live Node instance reconstructed from the dictionary.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If data is not a dict.</dd>
<dt><code>ConfigurationError</code></dt>
<dd>If the payload is invalid or type look-up fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.deserialisers import create_from_dict
&gt;&gt;&gt; # Assume dct is a valid node dict and ctx is a context dict
&gt;&gt;&gt; node = create_from_dict(dct, ctx)
&gt;&gt;&gt; node.name
dct['name']
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.StatisticalGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">StatisticalGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>distribution_callable: Callable[[], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;statistical&#34;)
class StatisticalGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node whose growth rates are drawn from a random distribution.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; StatisticalGrowthForecastNode`:
            Not supported; always raises NotImplementedError because the callable cannot be serialized.

    Attributes:
        distribution_callable (Callable[[], float]): Function returning a pseudo-random growth rate.

    Example:
        &gt;&gt;&gt; # Not supported:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, StatisticalGrowthForecastNode
        &gt;&gt;&gt; import random
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; node = StatisticalGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;], lambda: random.gauss(0.05, 0.01))
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; StatisticalGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})  # doctest: +SKIP
        Traceback (most recent call last):
        ...
        NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized because the distribution_callable cannot be serialized. Manual reconstruction required.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        distribution_callable: Callable[[], float],
    ):
        &#34;&#34;&#34;Create a StatisticalGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            distribution_callable (Callable[[], float]): Zero-argument function returning random growth rates.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.distribution_callable = distribution_callable

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        return self.distribution_callable()

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.

        Note:
            The distribution_callable cannot be serialized, so a warning is included.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;statistical&#34;,
            &#34;serialization_warning&#34;: (
                &#34;StatisticalGrowthForecastNode uses a distribution callable which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        })
        return base_dict

    # Deserialization intentionally unsupported - distribution_callable is not serializable.

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;StatisticalGrowthForecastNode&#34;:  # pragma: no cover
        &#34;&#34;&#34;Deserialization is not supported for StatisticalGrowthForecastNode.&#34;&#34;&#34;
        raise NotImplementedError(
            &#34;StatisticalGrowthForecastNode cannot be deserialized; distribution_callable is not serializable.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Forecast node whose growth rates are drawn from a random distribution.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; StatisticalGrowthForecastNode</code>:
Not supported; always raises NotImplementedError because the callable cannot be serialized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>distribution_callable</code></strong> :&ensp;<code>Callable[[], float]</code></dt>
<dd>Function returning a pseudo-random growth rate.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Not supported:
&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, StatisticalGrowthForecastNode
&gt;&gt;&gt; import random
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; node = StatisticalGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;], lambda: random.gauss(0.05, 0.01))
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; StatisticalGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})  # doctest: +SKIP
Traceback (most recent call last):
...
NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized because the distribution_callable cannot be serialized. Manual reconstruction required.
</code></pre>
<p>Create a StatisticalGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>distribution_callable</code></strong> :&ensp;<code>Callable[[], float]</code></dt>
<dd>Zero-argument function returning random growth rates.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.StatisticalGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization is not supported for StatisticalGrowthForecastNode.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.StatisticalGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.

    Note:
        The distribution_callable cannot be serialized, so a warning is included.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;statistical&#34;,
        &#34;serialization_warning&#34;: (
            &#34;StatisticalGrowthForecastNode uses a distribution callable which cannot be serialized. &#34;
            &#34;Manual reconstruction required.&#34;
        ),
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p>
<h2 id="note">Note</h2>
<p>The distribution_callable cannot be serialized, so a warning is included.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="core/nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.YoYGrowthNode"><code class="flex name class">
<span>class <span class="ident">YoYGrowthNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>prior_period: str,<br>current_period: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;yoy_growth&#34;)
class YoYGrowthNode(Node):
    &#34;&#34;&#34;Compute year-over-year percentage growth.

    Compare values of an input node for two periods and compute
    (current_value - prior_value) / prior_value.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        input_node (Node): Node providing source values.
        prior_period (str): Identifier for the earlier period.
        current_period (str): Identifier for the later period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 100.0, &#34;2023&#34;: 120.0}
        &gt;&gt;&gt; base = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; yoy = YoYGrowthNode(&#34;rev_yoy&#34;, input_node=base, prior_period=&#34;2022&#34;, current_period=&#34;2023&#34;)
        &gt;&gt;&gt; d = yoy.to_dict()
        &gt;&gt;&gt; yoy2 = YoYGrowthNode.from_dict(d, {&#34;revenue&#34;: base})
        &gt;&gt;&gt; round(yoy2.calculate(), 2)
        0.2
    &#34;&#34;&#34;

    def __init__(self, name: str, input_node: Node, prior_period: str, current_period: str):
        &#34;&#34;&#34;Create a YoYGrowthNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values for comparison.
            prior_period (str): Identifier for the earlier period.
            current_period (str): Identifier for the later period.

        Raises:
            TypeError: If `input_node` is not a Node or periods are not strings.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;YoYGrowthNode input_node must be a Node instance.&#34;)
        if not isinstance(prior_period, str) or not isinstance(current_period, str):
            raise TypeError(&#34;YoYGrowthNode prior_period and current_period must be strings.&#34;)

        self.input_node = input_node
        self.prior_period = prior_period
        self.current_period = current_period

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the YoY growth rate.

        Ignore the `period` parameter; use configured periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: (current - prior) / prior, or NaN if prior is zero or non-finite.

        Raises:
            CalculationError: On errors retrieving or validating input values.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        try:
            prior_value = self.input_node.calculate(self.prior_period)
            current_value = self.input_node.calculate(self.current_period)

            # Validate input types
            if not isinstance(prior_value, int | float):
                raise TypeError(f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;)
            if not isinstance(current_value, int | float):
                raise TypeError(f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;)

            # Handle division by zero or non-finite prior value
            if prior_value == 0 or not math.isfinite(prior_value):
                logger.warning(
                    &#34;YoYGrowthNode &#39;%s&#39;: Prior period &#39;%s&#39; value is zero or non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.prior_period,
                    prior_value,
                )
                return float(&#34;nan&#34;)

            # Calculate growth
            growth = (float(current_value) - float(prior_value)) / float(prior_value)
        except Exception as e:
            # Wrap any exception during calculation
            raise CalculationError(
                message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;prior_period&#34;: self.prior_period,
                    &#34;current_period&#34;: self.current_period,
                    &#34;original_error&#34;: str(e),
                },
            ) from e
        else:
            return growth

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation with type, name, and periods.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;yoy_growth&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;prior_period&#34;: self.prior_period,
            &#34;current_period&#34;: self.current_period,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;YoYGrowthNode&#34;:
        &#34;&#34;&#34;Recreate a YoYGrowthNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            YoYGrowthNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;yoy_growth&#34;:
            raise ValueError(f&#34;Invalid type for YoYGrowthNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in YoYGrowthNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in YoYGrowthNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize YoYGrowthNode&#34;)
        input_node = context[input_node_name]

        prior_period = data.get(&#34;prior_period&#34;)
        current_period = data.get(&#34;current_period&#34;)

        if not prior_period:
            raise ValueError(&#34;Missing &#39;prior_period&#39; field in YoYGrowthNode data&#34;)
        if not current_period:
            raise ValueError(&#34;Missing &#39;current_period&#39; field in YoYGrowthNode data&#34;)

        return cls(
            name=name,
            input_node=input_node,
            prior_period=prior_period,
            current_period=current_period,
        )</code></pre>
</details>
<div class="desc"><p>Compute year-over-year percentage growth.</p>
<p>Compare values of an input node for two periods and compute
(current_value - prior_value) / prior_value.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 100.0, &quot;2023&quot;: 120.0}
&gt;&gt;&gt; base = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; yoy = YoYGrowthNode(&quot;rev_yoy&quot;, input_node=base, prior_period=&quot;2022&quot;, current_period=&quot;2023&quot;)
&gt;&gt;&gt; d = yoy.to_dict()
&gt;&gt;&gt; yoy2 = YoYGrowthNode.from_dict(d, {&quot;revenue&quot;: base})
&gt;&gt;&gt; round(yoy2.calculate(), 2)
0.2
</code></pre>
<p>Create a YoYGrowthNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></dt>
<dd>Node supplying values for comparison.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or periods are not strings.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.YoYGrowthNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="core/nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a YoYGrowthNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.YoYGrowthNode" href="#fin_statement_model.YoYGrowthNode">YoYGrowthNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.YoYGrowthNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the YoY growth rate.

    Ignore the `period` parameter; use configured periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: (current - prior) / prior, or NaN if prior is zero or non-finite.

    Raises:
        CalculationError: On errors retrieving or validating input values.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    try:
        prior_value = self.input_node.calculate(self.prior_period)
        current_value = self.input_node.calculate(self.current_period)

        # Validate input types
        if not isinstance(prior_value, int | float):
            raise TypeError(f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;)
        if not isinstance(current_value, int | float):
            raise TypeError(f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;)

        # Handle division by zero or non-finite prior value
        if prior_value == 0 or not math.isfinite(prior_value):
            logger.warning(
                &#34;YoYGrowthNode &#39;%s&#39;: Prior period &#39;%s&#39; value is zero or non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.prior_period,
                prior_value,
            )
            return float(&#34;nan&#34;)

        # Calculate growth
        growth = (float(current_value) - float(prior_value)) / float(prior_value)
    except Exception as e:
        # Wrap any exception during calculation
        raise CalculationError(
            message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;prior_period&#34;: self.prior_period,
                &#34;current_period&#34;: self.current_period,
                &#34;original_error&#34;: str(e),
            },
        ) from e
    else:
        return growth</code></pre>
</details>
<div class="desc"><p>Compute the YoY growth rate.</p>
<p>Ignore the <code>period</code> parameter; use configured periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>(current - prior) / prior, or NaN if prior is zero or non-finite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>On errors retrieving or validating input values.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.YoYGrowthNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this node depends on.</p></div>
</dd>
<dt id="fin_statement_model.YoYGrowthNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation with type, name, and periods.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;yoy_growth&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;prior_period&#34;: self.prior_period,
        &#34;current_period&#34;: self.current_period,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation with type, name, and periods.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="core/nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.config" href="config/index.html">fin_statement_model.config</a></code></li>
<li><code><a title="fin_statement_model.core" href="core/index.html">fin_statement_model.core</a></code></li>
<li><code><a title="fin_statement_model.forecasting" href="forecasting/index.html">fin_statement_model.forecasting</a></code></li>
<li><code><a title="fin_statement_model.io" href="io/index.html">fin_statement_model.io</a></code></li>
<li><code><a title="fin_statement_model.logging_config" href="logging_config.html">fin_statement_model.logging_config</a></code></li>
<li><code><a title="fin_statement_model.preprocessing" href="preprocessing/index.html">fin_statement_model.preprocessing</a></code></li>
<li><code><a title="fin_statement_model.statements" href="statements/index.html">fin_statement_model.statements</a></code></li>
<li><code><a title="fin_statement_model.utils" href="utils/index.html">fin_statement_model.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.get_config" href="#fin_statement_model.get_config">get_config</a></code></li>
<li><code><a title="fin_statement_model.update_config" href="#fin_statement_model.update_config">update_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.CalculationNode" href="#fin_statement_model.CalculationNode">CalculationNode</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.CalculationNode.calculate" href="#fin_statement_model.CalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.clear_cache" href="#fin_statement_model.CalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.from_dict" href="#fin_statement_model.CalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.get_dependencies" href="#fin_statement_model.CalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.set_calculation" href="#fin_statement_model.CalculationNode.set_calculation">set_calculation</a></code></li>
<li><code><a title="fin_statement_model.CalculationNode.to_dict" href="#fin_statement_model.CalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.CurveGrowthForecastNode" href="#fin_statement_model.CurveGrowthForecastNode">CurveGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.CurveGrowthForecastNode.from_dict" href="#fin_statement_model.CurveGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.CurveGrowthForecastNode.to_dict" href="#fin_statement_model.CurveGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.CustomGrowthForecastNode" href="#fin_statement_model.CustomGrowthForecastNode">CustomGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.CustomGrowthForecastNode.from_dict" href="#fin_statement_model.CustomGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.CustomGrowthForecastNode.to_dict" href="#fin_statement_model.CustomGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.FinancialModelError" href="#fin_statement_model.FinancialModelError">FinancialModelError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.FinancialStatementItemNode" href="#fin_statement_model.FinancialStatementItemNode">FinancialStatementItemNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.FinancialStatementItemNode.calculate" href="#fin_statement_model.FinancialStatementItemNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.from_dict" href="#fin_statement_model.FinancialStatementItemNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.set_value" href="#fin_statement_model.FinancialStatementItemNode.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.to_dict" href="#fin_statement_model.FinancialStatementItemNode.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.FinancialStatementItemNode.values" href="#fin_statement_model.FinancialStatementItemNode.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.FixedGrowthForecastNode" href="#fin_statement_model.FixedGrowthForecastNode">FixedGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.FixedGrowthForecastNode.from_dict" href="#fin_statement_model.FixedGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.FixedGrowthForecastNode.to_dict" href="#fin_statement_model.FixedGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.ForecastNode" href="#fin_statement_model.ForecastNode">ForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.ForecastNode.calculate" href="#fin_statement_model.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.clear_cache" href="#fin_statement_model.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.from_dict" href="#fin_statement_model.ForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.get_dependencies" href="#fin_statement_model.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.ForecastNode.to_dict" href="#fin_statement_model.ForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.Graph" href="#fin_statement_model.Graph">Graph</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.MultiPeriodStatNode" href="#fin_statement_model.MultiPeriodStatNode">MultiPeriodStatNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.MultiPeriodStatNode.calculate" href="#fin_statement_model.MultiPeriodStatNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.MultiPeriodStatNode.from_dict" href="#fin_statement_model.MultiPeriodStatNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.MultiPeriodStatNode.get_dependencies" href="#fin_statement_model.MultiPeriodStatNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.MultiPeriodStatNode.to_dict" href="#fin_statement_model.MultiPeriodStatNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.Node" href="#fin_statement_model.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.Node.calculate" href="#fin_statement_model.Node.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.Node.clear_cache" href="#fin_statement_model.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.Node.from_dict" href="#fin_statement_model.Node.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.Node.get_attribute" href="#fin_statement_model.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.Node.get_dependencies" href="#fin_statement_model.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.Node.has_attribute" href="#fin_statement_model.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.Node.name" href="#fin_statement_model.Node.name">name</a></code></li>
<li><code><a title="fin_statement_model.Node.set_value" href="#fin_statement_model.Node.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.Node.to_dict" href="#fin_statement_model.Node.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.Node.values" href="#fin_statement_model.Node.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.NodeFactory" href="#fin_statement_model.NodeFactory">NodeFactory</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.NodeFactory.create_calculation_node" href="#fin_statement_model.NodeFactory.create_calculation_node">create_calculation_node</a></code></li>
<li><code><a title="fin_statement_model.NodeFactory.create_financial_statement_item" href="#fin_statement_model.NodeFactory.create_financial_statement_item">create_financial_statement_item</a></code></li>
<li><code><a title="fin_statement_model.NodeFactory.create_forecast_node" href="#fin_statement_model.NodeFactory.create_forecast_node">create_forecast_node</a></code></li>
<li><code><a title="fin_statement_model.NodeFactory.create_from_dict" href="#fin_statement_model.NodeFactory.create_from_dict">create_from_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.StatisticalGrowthForecastNode" href="#fin_statement_model.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.StatisticalGrowthForecastNode.from_dict" href="#fin_statement_model.StatisticalGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.StatisticalGrowthForecastNode.to_dict" href="#fin_statement_model.StatisticalGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.YoYGrowthNode" href="#fin_statement_model.YoYGrowthNode">YoYGrowthNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.YoYGrowthNode.calculate" href="#fin_statement_model.YoYGrowthNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.YoYGrowthNode.from_dict" href="#fin_statement_model.YoYGrowthNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.YoYGrowthNode.get_dependencies" href="#fin_statement_model.YoYGrowthNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.YoYGrowthNode.to_dict" href="#fin_statement_model.YoYGrowthNode.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
