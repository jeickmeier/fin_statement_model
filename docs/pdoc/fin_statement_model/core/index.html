<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.core API documentation</title>
<meta name="description" content="Foundation of *fin_statement_model* — graph engine, nodes, calculations, and more …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.core</code></h1>
</header>
<section id="section-intro">
<p>Foundation of <em>fin_statement_model</em> — graph engine, nodes, calculations, and more.</p>
<p>The <strong>core</strong> package is the foundational layer of the fin_statement_model library. It is intentionally self-contained (nothing here imports from <code>statements/</code>, <code>io/</code>, or <code>extensions/</code>). It provides the primitives that higher-level layers build upon, including the graph engine, node hierarchy, calculation strategies, metric registry, and core utilities.</p>
<p>Main Features:
- Directed graph data structure for financial modeling (<code><a title="fin_statement_model.core.Graph" href="#fin_statement_model.core.Graph">Graph</a></code>, <code>GraphManipulator</code>, <code>GraphTraverser</code>).
- Node system for representing raw data, calculations, statistics, and forecasts.
- Calculation strategies and a global registry for arithmetic and formula logic.
- YAML-driven metric definitions and interpretation helpers.
- Models and managers for discretionary adjustments and scenario analysis.
- Factory utilities for programmatic or YAML-based node creation.
- Unified exception hierarchy rooted at <code><a title="fin_statement_model.core.FinancialModelError" href="#fin_statement_model.core.FinancialModelError">FinancialModelError</a></code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core import Graph
&gt;&gt;&gt; g = Graph(periods=[&quot;2023&quot;, &quot;2024&quot;])
&gt;&gt;&gt; _ = g.add_financial_statement_item(&quot;Revenue&quot;, {&quot;2023&quot;: 1000, &quot;2024&quot;: 1200})
&gt;&gt;&gt; _ = g.add_financial_statement_item(&quot;COGS&quot;, {&quot;2023&quot;: 600, &quot;2024&quot;: 720})
&gt;&gt;&gt; g.add_calculation(
...     name=&quot;GrossProfit&quot;,
...     input_names=[&quot;Revenue&quot;, &quot;COGS&quot;],
...     operation_type=&quot;subtraction&quot;,
... )
&gt;&gt;&gt; g.calculate(&quot;GrossProfit&quot;, &quot;2024&quot;)
480.0
</code></pre>
<p>For a deeper dive into each component, advanced features, and extensibility, see <code>core/README.md</code>.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.core.adjustments" href="adjustments/index.html">fin_statement_model.core.adjustments</a></code></dt>
<dd>
<div class="desc"><p>Initialize core adjustments subpackage …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.calculations" href="calculations/index.html">fin_statement_model.core.calculations</a></code></dt>
<dd>
<div class="desc"><p>Calculation strategies for the Financial Statement Model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.errors" href="errors.html">fin_statement_model.core.errors</a></code></dt>
<dd>
<div class="desc"><p>Custom exception classes for the financial statement model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.graph" href="graph/index.html">fin_statement_model.core.graph</a></code></dt>
<dd>
<div class="desc"><p>Expose the public graph API for <em>fin_statement_model</em> …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.metrics" href="metrics/index.html">fin_statement_model.core.metrics</a></code></dt>
<dd>
<div class="desc"><p>Comprehensive system for defining, calculating, and interpreting financial metrics …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.node_factory" href="node_factory/index.html">fin_statement_model.core.node_factory</a></code></dt>
<dd>
<div class="desc"><p>NodeFactory façade for fin_statement_model.core …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes" href="nodes/index.html">fin_statement_model.core.nodes</a></code></dt>
<dd>
<div class="desc"><p>Provide core node implementations for the financial statement model …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.core.AdditionCalculation"><code class="flex name class">
<span>class <span class="ident">AdditionCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdditionCalculation(Calculation):
    &#34;&#34;&#34;Implements an addition calculation, summing values from multiple input nodes.

    This calculation sums the values obtained from calling
    the `calculate` method on each of the provided input nodes for a given period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Sums the calculated values from all input nodes for the specified period.

        Args:
            inputs: A list of Node objects.
            period: The time period string (e.g., &#34;2023Q4&#34;) for the calculation.

        Returns:
            The total sum of the values calculated from the input nodes. Returns
            0.0 if the input list is empty.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value):
            ...         self._value = value
            ...
            ...     def calculate(self, period):
            ...         return self._value
            &gt;&gt;&gt; strategy = AdditionCalculation()
            &gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(5)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            35.0
            &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
            0.0
        &#34;&#34;&#34;
        logger.debug(&#34;Applying addition calculation for period %s&#34;, period)
        # Using a generator expression for potentially better memory efficiency
        return sum(input_node.calculate(period) for input_node in inputs)

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the addition calculation.&#34;&#34;&#34;
        return &#34;Addition (sum of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements an addition calculation, summing values from multiple input nodes.</p>
<p>This calculation sums the values obtained from calling
the <code>calculate</code> method on each of the provided input nodes for a given period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.AdditionCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the addition calculation.&#34;&#34;&#34;
    return &#34;Addition (sum of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the addition calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.AdditionCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Sums the calculated values from all input nodes for the specified period.

    Args:
        inputs: A list of Node objects.
        period: The time period string (e.g., &#34;2023Q4&#34;) for the calculation.

    Returns:
        The total sum of the values calculated from the input nodes. Returns
        0.0 if the input list is empty.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value):
        ...         self._value = value
        ...
        ...     def calculate(self, period):
        ...         return self._value
        &gt;&gt;&gt; strategy = AdditionCalculation()
        &gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(5)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        35.0
        &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
        0.0
    &#34;&#34;&#34;
    logger.debug(&#34;Applying addition calculation for period %s&#34;, period)
    # Using a generator expression for potentially better memory efficiency
    return sum(input_node.calculate(period) for input_node in inputs)</code></pre>
</details>
<div class="desc"><p>Sums the calculated values from all input nodes for the specified period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2023Q4") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The total sum of the values calculated from the input nodes. Returns
0.0 if the input list is empty.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value):
...         self._value = value
...
...     def calculate(self, period):
...         return self._value
&gt;&gt;&gt; strategy = AdditionCalculation()
&gt;&gt;&gt; nodes = [MockNode(10), MockNode(20), MockNode(5)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
35.0
&gt;&gt;&gt; strategy.calculate([], &quot;2023&quot;)
0.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.CalculationError"><code class="flex name class">
<span>class <span class="ident">CalculationError</span></span>
<span>(</span><span>message: str,<br>node_id: str | None = None,<br>period: str | None = None,<br>details: dict[str, typing.Any] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculationError(FinancialModelError):
    &#34;&#34;&#34;Error raised during calculation operations.

    Indicates a problem while computing the value of a node, often due
    to issues with the calculation logic, input data, or strategy used.

    Examples:
        &gt;&gt;&gt; raise CalculationError(&#34;Division by zero&#34;, node_id=&#34;profit_margin&#34;, period=&#34;2023-Q1&#34;)
        &gt;&gt;&gt; raise CalculationError(
        ...     &#34;Incompatible input types&#34;,
        ...     node_id=&#34;total_assets&#34;,
        ...     details={&#34;input_a_type&#34;: &#34;str&#34;, &#34;input_b_type&#34;: &#34;int&#34;},
        ... )
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        node_id: str | None = None,
        period: str | None = None,
        details: dict[str, Any] | None = None,
    ):
        &#34;&#34;&#34;Initialize the CalculationError.

        Args:
            message: The base error message.
            node_id: Optional ID of the node where the calculation failed.
            period: Optional period for which the calculation failed.
            details: Optional dictionary containing additional context about the error.
        &#34;&#34;&#34;
        self.node_id = node_id
        self.period = period
        self.details = details or {}

        context = []
        if node_id:
            context.append(f&#34;node &#39;{node_id}&#39;&#34;)
        if period:
            context.append(f&#34;period &#39;{period}&#39;&#34;)

        full_message = f&#34;{message} for {&#39; and &#39;.join(context)}&#34; if context else message

        # Append details to the message for better context
        if self.details:
            details_str = &#34;, &#34;.join(f&#39;{k}=&#34;{v}&#34;&#39; for k, v in self.details.items())
            # Prioritize showing the original underlying error if captured
            original_error_str = self.details.get(&#34;original_error&#34;)
            if original_error_str:
                full_message = f&#34;{full_message}: {original_error_str}&#34;
            else:
                full_message = f&#34;{full_message} (Details: {details_str})&#34;

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised during calculation operations.</p>
<p>Indicates a problem while computing the value of a node, often due
to issues with the calculation logic, input data, or strategy used.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise CalculationError(&quot;Division by zero&quot;, node_id=&quot;profit_margin&quot;, period=&quot;2023-Q1&quot;)
&gt;&gt;&gt; raise CalculationError(
...     &quot;Incompatible input types&quot;,
...     node_id=&quot;total_assets&quot;,
...     details={&quot;input_a_type&quot;: &quot;str&quot;, &quot;input_b_type&quot;: &quot;int&quot;},
... )
</code></pre>
<p>Initialize the CalculationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node where the calculation failed.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Optional period for which the calculation failed.</dd>
<dt><strong><code>details</code></strong></dt>
<dd>Optional dictionary containing additional context about the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.CalculationNode"><code class="flex name class">
<span>class <span class="ident">CalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>,<br>**kwargs: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;calculation&#34;)
class CalculationNode(Node):
    &#34;&#34;&#34;Delegate calculation logic to a calculation object.

    Use a calculation object to encapsulate the algorithm for computing node values.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        name (str): Identifier for this node.
        inputs (List[Node]): A list of input nodes required by the calculation.
        calculation (Any): An object possessing a `calculate(inputs: List[Node], period: str) -&gt; float` method.
        _values (Dict[str, float]): Internal cache for calculated results.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; d = sum_node.to_dict()
        &gt;&gt;&gt; sum_node2 = CalculationNode.from_dict(d, {&#34;a&#34;: node_a, &#34;b&#34;: node_b})
        &gt;&gt;&gt; sum_node2.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;

    def __init__(self, name: str, inputs: list[Node], calculation: Calculation, **kwargs: Any):
        &#34;&#34;&#34;Initialize the CalculationNode.

        Args:
            name (str): The unique identifier for this node.
            inputs (List[Node]): List of input nodes needed by the calculation.
            calculation (Any): The calculation object implementing the calculation.
                Must have a `calculate` method.
            **kwargs: Additional attributes to store on the node (e.g., metric_name, metric_description).

        Raises:
            TypeError: If `inputs` is not a list of Nodes, or if `calculation`
                does not have a callable `calculate` method.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(inputs, list) or not all(isinstance(n, Node) for n in inputs):
            raise TypeError(&#34;CalculationNode inputs must be a list of Node instances.&#34;)
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
            raise TypeError(&#34;Calculation object must have a callable &#39;calculate&#39; method.&#34;)

        self.inputs = inputs
        self.calculation = calculation
        self._values: dict[str, float] = {}  # Cache for calculated values

        # Store any additional attributes passed via kwargs
        for key, value in kwargs.items():
            setattr(self, key, value)

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Raises:
            CalculationError: If calculation fails or returns a non-numeric value.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        if period in self._values:
            return self._values[period]

        try:
            # Delegate to the calculation object&#39;s calculate method
            result = self.calculation.calculate(self.inputs, period)
            if not isinstance(result, int | float):
                raise TypeError(
                    f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
                )
            # Cache and return the result
            self._values[period] = float(result)
            return self._values[period]
        except Exception as e:
            # Wrap potential errors from the calculation
            raise CalculationError(
                message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=period,
                details={
                    &#34;calculation&#34;: type(self.calculation).__name__,
                    &#34;error&#34;: str(e),
                },
            ) from e

    def set_calculation(self, calculation: Calculation) -&gt; None:
        &#34;&#34;&#34;Change the calculation object for the node.

        Args:
            calculation (Any): The new calculation object. Must have a callable
                `calculate` method.

        Raises:
            TypeError: If the new calculation is invalid.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
        &#34;&#34;&#34;
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
            raise TypeError(&#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;)
        self.calculation = calculation
        self.clear_cache()  # Clear cache as logic has changed

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the internal cache of calculated values.

        Returns:
            None

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.clear_cache()
        &#34;&#34;&#34;
        self._values.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Return the names of input nodes used by the calculation.

        Returns:
            A list of input node names.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.get_dependencies()
            [&#39;a&#39;, &#39;b&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s type, name, inputs, and calculation info.

        Note:
            This method requires access to NodeFactory&#39;s calculation registry
            to properly serialize the calculation type. Some calculation types
            with non-serializable parameters may include warnings.

        Example:
            &gt;&gt;&gt; # See CalculationNode usage in main module docstring
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        node_dict: dict[str, Any] = {
            &#34;type&#34;: &#34;calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
        }

        # Add calculation type information
        calc_class_name = type(self.calculation).__name__
        node_dict[&#34;calculation_type_class&#34;] = calc_class_name

        # Find the calculation type key from NodeFactory registry
        inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
        type_key = inv_map.get(calc_class_name)
        if type_key:
            node_dict[&#34;calculation_type&#34;] = type_key

            # Extract calculation-specific arguments
            calculation_args = {}

            # Handle specific calculation types
            if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
                calculation_args[&#34;weights&#34;] = self.calculation.weights
            elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
                calculation_args[&#34;formula&#34;] = self.calculation.formula
                if hasattr(self.calculation, &#34;input_variable_names&#34;):
                    node_dict[&#34;formula_variable_names&#34;] = self.calculation.input_variable_names
            elif type_key == &#34;custom_formula&#34;:
                node_dict[&#34;serialization_warning&#34;] = (
                    &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                    &#34;Manual reconstruction required.&#34;
                )

            if calculation_args:
                node_dict[&#34;calculation_args&#34;] = calculation_args

        # Add any additional attributes (like metric info)
        if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
            node_dict[&#34;metric_name&#34;] = self.metric_name
        if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
            node_dict[&#34;metric_description&#34;] = self.metric_description

        return node_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CalculationNode&#34;:
        &#34;&#34;&#34;Create a CalculationNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CalculationNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.

        Example:
            &gt;&gt;&gt; # See CalculationNode usage in main module docstring
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        if data.get(&#34;type&#34;) != &#34;calculation&#34;:
            raise ValueError(f&#34;Invalid type for CalculationNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CalculationNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize CalculationNode&#34;)

        input_names = data.get(&#34;inputs&#34;, [])
        if not isinstance(input_names, list):
            raise TypeError(&#34;&#39;inputs&#39; field must be a list&#34;)

        # Resolve input nodes from context
        input_nodes = []
        for input_name in input_names:
            if input_name not in context:
                raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
            input_nodes.append(context[input_name])

        calculation_type = data.get(&#34;calculation_type&#34;)
        if not calculation_type:
            raise ValueError(&#34;Missing &#39;calculation_type&#39; field in CalculationNode data&#34;)

        # Get calculation arguments
        calculation_args = data.get(&#34;calculation_args&#34;, {})

        # Handle formula variable names for formula calculations
        formula_variable_names = data.get(&#34;formula_variable_names&#34;)

        # Extract metric information
        metric_name = data.get(&#34;metric_name&#34;)
        metric_description = data.get(&#34;metric_description&#34;)

        # Create the node using NodeFactory
        return cast(
            &#34;CalculationNode&#34;,
            NodeFactory.create_calculation_node(
                name=name,
                inputs=input_nodes,
                calculation_type=calculation_type,
                formula_variable_names=formula_variable_names,
                metric_name=metric_name,
                metric_description=metric_description,
                **calculation_args,
            ),
        )</code></pre>
</details>
<div class="desc"><p>Delegate calculation logic to a calculation object.</p>
<p>Use a calculation object to encapsulate the algorithm for computing node values.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>]</code></dt>
<dd>A list of input nodes required by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>An object possessing a <code>calculate(inputs: List[Node], period: str) -&gt; float</code> method.</dd>
<dt><strong><code>_values</code></strong> :&ensp;<code>Dict[str, float]</code></dt>
<dd>Internal cache for calculated results.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; d = sum_node.to_dict()
&gt;&gt;&gt; sum_node2 = CalculationNode.from_dict(d, {&quot;a&quot;: node_a, &quot;b&quot;: node_b})
&gt;&gt;&gt; sum_node2.calculate(&quot;2023&quot;)
30.0
</code></pre>
<p>Initialize the CalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>]</code></dt>
<dd>List of input nodes needed by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The calculation object implementing the calculation.
Must have a <code>calculate</code> method.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional attributes to store on the node (e.g., metric_name, metric_description).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>inputs</code> is not a list of Nodes, or if <code>calculation</code>
does not have a callable <code>calculate</code> method.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode">FormulaCalculationNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.CalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a CalculationNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CalculationNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.CalculationNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Raises:
        CalculationError: If calculation fails or returns a non-numeric value.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;
    if period in self._values:
        return self._values[period]

    try:
        # Delegate to the calculation object&#39;s calculate method
        result = self.calculation.calculate(self.inputs, period)
        if not isinstance(result, int | float):
            raise TypeError(
                f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
            )
        # Cache and return the result
        self._values[period] = float(result)
        return self._values[period]
    except Exception as e:
        # Wrap potential errors from the calculation
        raise CalculationError(
            message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=period,
            details={
                &#34;calculation&#34;: type(self.calculation).__name__,
                &#34;error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Check the cache; on a miss, delegate to <code>calculation.calculate</code> and cache the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>If calculation fails or returns a non-numeric value.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CalculationNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the internal cache of calculated values.

    Returns:
        None

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.clear_cache()
    &#34;&#34;&#34;
    self._values.clear()</code></pre>
</details>
<div class="desc"><p>Clear the internal cache of calculated values.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.clear_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Return the names of input nodes used by the calculation.

    Returns:
        A list of input node names.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.get_dependencies()
        [&#39;a&#39;, &#39;b&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs]</code></pre>
</details>
<div class="desc"><p>Return the names of input nodes used by the calculation.</p>
<h2 id="returns">Returns</h2>
<p>A list of input node names.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.get_dependencies()
['a', 'b']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CalculationNode.set_calculation"><code class="name flex">
<span>def <span class="ident">set_calculation</span></span>(<span>self,<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calculation(self, calculation: Calculation) -&gt; None:
    &#34;&#34;&#34;Change the calculation object for the node.

    Args:
        calculation (Any): The new calculation object. Must have a callable
            `calculate` method.

    Raises:
        TypeError: If the new calculation is invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
    &#34;&#34;&#34;
    if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
        raise TypeError(&#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;)
    self.calculation = calculation
    self.clear_cache()  # Clear cache as logic has changed</code></pre>
</details>
<div class="desc"><p>Change the calculation object for the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The new calculation object. Must have a callable
<code>calculate</code> method.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the new calculation is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s type, name, inputs, and calculation info.

    Note:
        This method requires access to NodeFactory&#39;s calculation registry
        to properly serialize the calculation type. Some calculation types
        with non-serializable parameters may include warnings.

    Example:
        &gt;&gt;&gt; # See CalculationNode usage in main module docstring
    &#34;&#34;&#34;
    # Import here to avoid circular imports
    from fin_statement_model.core.node_factory import NodeFactory

    node_dict: dict[str, Any] = {
        &#34;type&#34;: &#34;calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
    }

    # Add calculation type information
    calc_class_name = type(self.calculation).__name__
    node_dict[&#34;calculation_type_class&#34;] = calc_class_name

    # Find the calculation type key from NodeFactory registry
    inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
    type_key = inv_map.get(calc_class_name)
    if type_key:
        node_dict[&#34;calculation_type&#34;] = type_key

        # Extract calculation-specific arguments
        calculation_args = {}

        # Handle specific calculation types
        if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
            calculation_args[&#34;weights&#34;] = self.calculation.weights
        elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
            calculation_args[&#34;formula&#34;] = self.calculation.formula
            if hasattr(self.calculation, &#34;input_variable_names&#34;):
                node_dict[&#34;formula_variable_names&#34;] = self.calculation.input_variable_names
        elif type_key == &#34;custom_formula&#34;:
            node_dict[&#34;serialization_warning&#34;] = (
                &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            )

        if calculation_args:
            node_dict[&#34;calculation_args&#34;] = calculation_args

    # Add any additional attributes (like metric info)
    if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
        node_dict[&#34;metric_name&#34;] = self.metric_name
    if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
        node_dict[&#34;metric_description&#34;] = self.metric_description

    return node_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's type, name, inputs, and calculation info.</p>
<h2 id="note">Note</h2>
<p>This method requires access to NodeFactory's calculation registry
to properly serialize the calculation type. Some calculation types
with non-serializable parameters may include warnings.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.CircularDependencyError"><code class="flex name class">
<span>class <span class="ident">CircularDependencyError</span></span>
<span>(</span><span>message: str = 'Circular dependency detected', cycle: list[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircularDependencyError(FinancialModelError):
    &#34;&#34;&#34;Error raised when a circular dependency is detected in calculations.

    Occurs if the calculation graph contains cycles, meaning a node
    directly or indirectly depends on itself.

    Examples:
        &gt;&gt;&gt; raise CircularDependencyError(cycle=[&#34;node_a&#34;, &#34;node_b&#34;, &#34;node_c&#34;, &#34;node_a&#34;])
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str = &#34;Circular dependency detected&#34;,
        cycle: list[str] | None = None,
    ):
        &#34;&#34;&#34;Initialize the CircularDependencyError.

        Args:
            message: The base error message.
            cycle: Optional list of node IDs forming the detected cycle.
        &#34;&#34;&#34;
        self.cycle = cycle or []

        if cycle:
            cycle_str = &#34; -&gt; &#34;.join(cycle)
            full_message = f&#34;{message}: {cycle_str}&#34;
        else:
            full_message = message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised when a circular dependency is detected in calculations.</p>
<p>Occurs if the calculation graph contains cycles, meaning a node
directly or indirectly depends on itself.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise CircularDependencyError(cycle=[&quot;node_a&quot;, &quot;node_b&quot;, &quot;node_c&quot;, &quot;node_a&quot;])
</code></pre>
<p>Initialize the CircularDependencyError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>cycle</code></strong></dt>
<dd>Optional list of node IDs forming the detected cycle.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.ConfigurationError"><code class="flex name class">
<span>class <span class="ident">ConfigurationError</span></span>
<span>(</span><span>message: str,<br>config_path: str | None = None,<br>errors: list[typing.Any] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationError(FinancialModelError):
    &#34;&#34;&#34;Error raised for invalid configuration files or objects.

    This typically occurs when parsing or validating configuration data,
    such as YAML files defining metrics or statement structures.

    Examples:
        &gt;&gt;&gt; raise ConfigurationError(&#34;Invalid syntax&#34;, config_path=&#34;config.yaml&#34;)
        &gt;&gt;&gt; raise ConfigurationError(
        ...     &#34;Missing required fields&#34;, config_path=&#34;metrics.yaml&#34;, errors=[&#34;Missing &#39;formula&#39; for &#39;revenue&#39;&#34;]
        ... )
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        config_path: str | None = None,
        errors: list[Any] | None = None,
    ):
        &#34;&#34;&#34;Initialize the ConfigurationError.

        Args:
            message: The base error message.
            config_path: Optional path to the configuration file where the error occurred.
            errors: Optional list of specific validation errors found.
        &#34;&#34;&#34;
        self.config_path = config_path
        self.errors = errors or []

        if config_path and self.errors:
            full_message = f&#34;{message} in {config_path}: {&#39; ; &#39;.join(str(e) for e in self.errors)}&#34;
        elif config_path:
            full_message = f&#34;{message} in {config_path}&#34;
        elif self.errors:
            full_message = f&#34;{message}: {&#39; ; &#39;.join(str(e) for e in self.errors)}&#34;
        else:
            full_message = message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for invalid configuration files or objects.</p>
<p>This typically occurs when parsing or validating configuration data,
such as YAML files defining metrics or statement structures.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise ConfigurationError(&quot;Invalid syntax&quot;, config_path=&quot;config.yaml&quot;)
&gt;&gt;&gt; raise ConfigurationError(
...     &quot;Missing required fields&quot;, config_path=&quot;metrics.yaml&quot;, errors=[&quot;Missing 'formula' for 'revenue'&quot;]
... )
</code></pre>
<p>Initialize the ConfigurationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>config_path</code></strong></dt>
<dd>Optional path to the configuration file where the error occurred.</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>Optional list of specific validation errors found.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.CustomCalculationNode"><code class="flex name class">
<span>class <span class="ident">CustomCalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>formula_func: Callable[..., float],<br>description: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;custom_calculation&#34;)
class CustomCalculationNode(Node):
    &#34;&#34;&#34;Calculate values using a custom Python function.

    Use a provided callable to compute node values from input nodes.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomCalculationNode`:
            Not supported; always raises NotImplementedError because the function cannot be serialized.

    Attributes:
        inputs (list[Node]): Nodes supplying inputs to the function.
        formula_func (Callable[..., float]): Function to compute values.
        description (Optional[str]): Description of the calculation.
        _values (dict[str, float]): Cache of computed results.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        15.0
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        inputs: list[Node],
        formula_func: Callable[..., float],
        description: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Create a CustomCalculationNode.

        Args:
            name (str): Unique identifier for the node.
            inputs (list[Node]): Nodes providing input values.
            formula_func (Callable[..., float]): Function to compute values.
            description (str, optional): Description of the calculation.

        Raises:
            TypeError: If `inputs` is not a list of Node or `formula_func` is not callable.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            15.0
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(inputs, list) or not all(isinstance(n, Node) for n in inputs):
            raise TypeError(&#34;CustomCalculationNode inputs must be a list of Node instances&#34;)
        if not callable(formula_func):
            raise TypeError(&#34;CustomCalculationNode formula_func must be a callable function&#34;)

        self.inputs = inputs
        self.formula_func = formula_func
        self.description = description
        self._values: dict[str, float] = {}  # Cache for calculated results

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Compute the node&#39;s value for a given period.

        Evaluate `formula_func` with inputs from `inputs` and cache the result.

        Args:
            period (str): The time period for which to perform the calculation.

        Returns:
            float: Computed value for the period.

        Raises:
            CalculationError: On errors retrieving inputs or computing the function.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            15.0
        &#34;&#34;&#34;
        if period in self._values:
            return self._values[period]

        try:
            # Get input values
            input_values = []
            for node in self.inputs:
                value = node.calculate(period)
                if not isinstance(value, int | float):
                    raise TypeError(
                        f&#34;Input node &#39;{node.name}&#39; did not return a numeric value for period &#39;{period}&#39;. Got {type(value).__name__}.&#34;
                    )
                input_values.append(value)

            # Calculate the value using the provided function
            result = self.formula_func(*input_values)
            if not isinstance(result, int | float):
                raise TypeError(f&#34;Formula did not return a numeric value. Got {type(result).__name__}.&#34;)

            # Cache and return the result
            self._values[period] = float(result)
            return self._values[period]
        except Exception as e:
            # Wrap potential errors from the function
            raise CalculationError(
                message=f&#34;Error during custom calculation for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=period,
                details={&#34;function&#34;: self.formula_func.__name__, &#34;error&#34;: str(e)},
            ) from e

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached calculation results for this node.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.clear_cache()
        &#34;&#34;&#34;
        self._values.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes used by the function.

        Returns:
            list[str]: Names of input nodes.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.get_dependencies()
            [&#39;A&#39;, &#39;B&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized node data with non-serializable function warning.

        Example:
            &gt;&gt;&gt; # See CustomCalculationNode usage in main module docstring
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;custom_calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
            &#34;description&#34;: self.description,
            &#34;serialization_warning&#34;: (
                &#34;CustomCalculationNode uses a Python function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        }

    # ------------------------------------------------------------------
    # Serialization helpers (unsupported)
    # ------------------------------------------------------------------

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CustomCalculationNode&#34;:  # pragma: no cover
        &#34;&#34;&#34;Deserialization is not supported for CustomCalculationNode.

        The underlying Python callable cannot be serialized/restored automatically.
        Callers must supply their own factory logic instead.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;CustomCalculationNode deserialization is not supported. &#34;
            &#34;The underlying Python callable cannot be reconstructed automatically.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Calculate values using a custom Python function.</p>
<p>Use a provided callable to compute node values from input nodes.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomCalculationNode</code>:
Not supported; always raises NotImplementedError because the function cannot be serialized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>inputs</code></strong> :&ensp;<code>list[<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>]</code></dt>
<dd>Nodes supplying inputs to the function.</dd>
<dt><strong><code>formula_func</code></strong> :&ensp;<code>Callable[&hellip;, float]</code></dt>
<dd>Function to compute values.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Description of the calculation.</dd>
<dt><strong><code>_values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Cache of computed results.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
15.0
</code></pre>
<p>Create a CustomCalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>list[<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>]</code></dt>
<dd>Nodes providing input values.</dd>
<dt><strong><code>formula_func</code></strong> :&ensp;<code>Callable[&hellip;, float]</code></dt>
<dd>Function to compute values.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Description of the calculation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>inputs</code> is not a list of Node or <code>formula_func</code> is not callable.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
15.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.CustomCalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode">CustomCalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization is not supported for CustomCalculationNode.</p>
<p>The underlying Python callable cannot be serialized/restored automatically.
Callers must supply their own factory logic instead.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.CustomCalculationNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Compute the node&#39;s value for a given period.

    Evaluate `formula_func` with inputs from `inputs` and cache the result.

    Args:
        period (str): The time period for which to perform the calculation.

    Returns:
        float: Computed value for the period.

    Raises:
        CalculationError: On errors retrieving inputs or computing the function.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        15.0
    &#34;&#34;&#34;
    if period in self._values:
        return self._values[period]

    try:
        # Get input values
        input_values = []
        for node in self.inputs:
            value = node.calculate(period)
            if not isinstance(value, int | float):
                raise TypeError(
                    f&#34;Input node &#39;{node.name}&#39; did not return a numeric value for period &#39;{period}&#39;. Got {type(value).__name__}.&#34;
                )
            input_values.append(value)

        # Calculate the value using the provided function
        result = self.formula_func(*input_values)
        if not isinstance(result, int | float):
            raise TypeError(f&#34;Formula did not return a numeric value. Got {type(result).__name__}.&#34;)

        # Cache and return the result
        self._values[period] = float(result)
        return self._values[period]
    except Exception as e:
        # Wrap potential errors from the function
        raise CalculationError(
            message=f&#34;Error during custom calculation for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=period,
            details={&#34;function&#34;: self.formula_func.__name__, &#34;error&#34;: str(e)},
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the node's value for a given period.</p>
<p>Evaluate <code>formula_func</code> with inputs from <code>inputs</code> and cache the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>The time period for which to perform the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Computed value for the period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>On errors retrieving inputs or computing the function.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
15.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CustomCalculationNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached calculation results for this node.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.clear_cache()
    &#34;&#34;&#34;
    self._values.clear()</code></pre>
</details>
<div class="desc"><p>Clear cached calculation results for this node.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.clear_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CustomCalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes used by the function.

    Returns:
        list[str]: Names of input nodes.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.get_dependencies()
        [&#39;A&#39;, &#39;B&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs]</code></pre>
</details>
<div class="desc"><p>Get names of nodes used by the function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Names of input nodes.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.get_dependencies()
['A', 'B']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.CustomCalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized node data with non-serializable function warning.

    Example:
        &gt;&gt;&gt; # See CustomCalculationNode usage in main module docstring
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;custom_calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
        &#34;description&#34;: self.description,
        &#34;serialization_warning&#34;: (
            &#34;CustomCalculationNode uses a Python function which cannot be serialized. &#34;
            &#34;Manual reconstruction required.&#34;
        ),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized node data with non-serializable function warning.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CustomCalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.DataValidationError"><code class="flex name class">
<span>class <span class="ident">DataValidationError</span></span>
<span>(</span><span>message: str, validation_errors: list[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataValidationError(FinancialModelError):
    &#34;&#34;&#34;Error raised for data validation failures.

    Typically occurs during data import or preprocessing when data
    does not conform to expected formats, types, or constraints.

    Examples:
        &gt;&gt;&gt; raise DataValidationError(
        ...     &#34;Input data failed validation&#34;,
        ...     validation_errors=[&#34;Column &#39;Date&#39; has invalid format&#34;, &#34;Value &#39;-100&#39; is not allowed for &#39;Revenue&#39;&#34;],
        ... )
    &#34;&#34;&#34;

    def __init__(self, message: str, validation_errors: list[str] | None = None):
        &#34;&#34;&#34;Initialize the DataValidationError.

        Args:
            message: The base error message.
            validation_errors: Optional list of specific validation failures.
        &#34;&#34;&#34;
        self.validation_errors = validation_errors or []

        full_message = f&#34;{message}: {&#39;; &#39;.join(validation_errors)}&#34; if validation_errors else message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for data validation failures.</p>
<p>Typically occurs during data import or preprocessing when data
does not conform to expected formats, types, or constraints.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise DataValidationError(
...     &quot;Input data failed validation&quot;,
...     validation_errors=[&quot;Column 'Date' has invalid format&quot;, &quot;Value '-100' is not allowed for 'Revenue'&quot;],
... )
</code></pre>
<p>Initialize the DataValidationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>validation_errors</code></strong></dt>
<dd>Optional list of specific validation failures.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.DivisionCalculation"><code class="flex name class">
<span>class <span class="ident">DivisionCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DivisionCalculation(Calculation):
    &#34;&#34;&#34;Implements a division calculation: first input divided by the product of the rest.

    This calculation takes the calculated value of the first node (numerator) and
    divides it by the product of the calculated values of all subsequent nodes
    (denominator) for a specific period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculates the division: first input / (product of subsequent inputs).

        Args:
            inputs: A list of Node objects. Must contain at least two nodes.
            period: The time period string (e.g., &#34;2024Q2&#34;) for the calculation.

        Returns:
            The result of the division.

        Raises:
            CalculationError: If the `inputs` list contains fewer than two nodes or if the denominator product is zero.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value):
            ...         self._value = value
            ...
            ...     def calculate(self, period):
            ...         return self._value
            &gt;&gt;&gt; strategy = DivisionCalculation()
            &gt;&gt;&gt; nodes = [MockNode(100), MockNode(5), MockNode(2)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            10.0
            &gt;&gt;&gt; nodes_zero_denom = [MockNode(100), MockNode(5), MockNode(0)]
            &gt;&gt;&gt; try:
            ...     strategy.calculate(nodes_zero_denom, &#34;2023&#34;)
            ... except CalculationError as e:
            ...     # Example: logging the error instead of printing
            ...     logger.error(e)
            Division by zero: Denominator product is zero
        &#34;&#34;&#34;
        if len(inputs) &lt; MIN_REQUIRED_INPUTS:
            raise CalculationError(
                &#34;Division calculation requires at least two input nodes&#34;,
                details={&#34;strategy&#34;: &#34;DivisionCalculation&#34;, &#34;input_count&#34;: len(inputs)},
            )

        logger.debug(&#34;Applying division calculation for period %s&#34;, period)

        values = [node.calculate(period) for node in inputs]
        numerator = values[0]

        denominator = 1.0
        for val in values[1:]:
            denominator *= val

        if denominator == 0.0:
            raise CalculationError(
                &#34;Division by zero: Denominator product is zero&#34;,
                period=period,
                details={&#34;numerator&#34;: numerator, &#34;denominator&#34;: denominator},
            )

        return numerator / denominator

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the division calculation.&#34;&#34;&#34;
        return &#34;Division (first input / product of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements a division calculation: first input divided by the product of the rest.</p>
<p>This calculation takes the calculated value of the first node (numerator) and
divides it by the product of the calculated values of all subsequent nodes
(denominator) for a specific period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.DivisionCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the division calculation.&#34;&#34;&#34;
    return &#34;Division (first input / product of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the division calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.DivisionCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculates the division: first input / (product of subsequent inputs).

    Args:
        inputs: A list of Node objects. Must contain at least two nodes.
        period: The time period string (e.g., &#34;2024Q2&#34;) for the calculation.

    Returns:
        The result of the division.

    Raises:
        CalculationError: If the `inputs` list contains fewer than two nodes or if the denominator product is zero.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value):
        ...         self._value = value
        ...
        ...     def calculate(self, period):
        ...         return self._value
        &gt;&gt;&gt; strategy = DivisionCalculation()
        &gt;&gt;&gt; nodes = [MockNode(100), MockNode(5), MockNode(2)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        10.0
        &gt;&gt;&gt; nodes_zero_denom = [MockNode(100), MockNode(5), MockNode(0)]
        &gt;&gt;&gt; try:
        ...     strategy.calculate(nodes_zero_denom, &#34;2023&#34;)
        ... except CalculationError as e:
        ...     # Example: logging the error instead of printing
        ...     logger.error(e)
        Division by zero: Denominator product is zero
    &#34;&#34;&#34;
    if len(inputs) &lt; MIN_REQUIRED_INPUTS:
        raise CalculationError(
            &#34;Division calculation requires at least two input nodes&#34;,
            details={&#34;strategy&#34;: &#34;DivisionCalculation&#34;, &#34;input_count&#34;: len(inputs)},
        )

    logger.debug(&#34;Applying division calculation for period %s&#34;, period)

    values = [node.calculate(period) for node in inputs]
    numerator = values[0]

    denominator = 1.0
    for val in values[1:]:
        denominator *= val

    if denominator == 0.0:
        raise CalculationError(
            &#34;Division by zero: Denominator product is zero&#34;,
            period=period,
            details={&#34;numerator&#34;: numerator, &#34;denominator&#34;: denominator},
        )

    return numerator / denominator</code></pre>
</details>
<div class="desc"><p>Calculates the division: first input / (product of subsequent inputs).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects. Must contain at least two nodes.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2024Q2") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result of the division.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>If the <code>inputs</code> list contains fewer than two nodes or if the denominator product is zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value):
...         self._value = value
...
...     def calculate(self, period):
...         return self._value
&gt;&gt;&gt; strategy = DivisionCalculation()
&gt;&gt;&gt; nodes = [MockNode(100), MockNode(5), MockNode(2)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
10.0
&gt;&gt;&gt; nodes_zero_denom = [MockNode(100), MockNode(5), MockNode(0)]
&gt;&gt;&gt; try:
...     strategy.calculate(nodes_zero_denom, &quot;2023&quot;)
... except CalculationError as e:
...     # Example: logging the error instead of printing
...     logger.error(e)
Division by zero: Denominator product is zero
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.FinancialModelError"><code class="flex name class">
<span>class <span class="ident">FinancialModelError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinancialModelError(Exception):
    &#34;&#34;&#34;Base exception for all financial statement model errors.

    All custom exceptions raised within the library should inherit from this class.

    Examples:
        &gt;&gt;&gt; raise FinancialModelError(&#34;An error occurred.&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str):
        &#34;&#34;&#34;Initialize the FinancialModelError.

        Args:
            message: A human-readable description of the error.
        &#34;&#34;&#34;
        self.message = message
        super().__init__(self.message)</code></pre>
</details>
<div class="desc"><p>Base exception for all financial statement model errors.</p>
<p>All custom exceptions raised within the library should inherit from this class.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise FinancialModelError(&quot;An error occurred.&quot;)
</code></pre>
<p>Initialize the FinancialModelError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>A human-readable description of the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.config.access.ConfigurationAccessError" href="../config/access.html#fin_statement_model.config.access.ConfigurationAccessError">ConfigurationAccessError</a></li>
<li><a title="fin_statement_model.config.loader.ConfigurationError" href="../config/loader.html#fin_statement_model.config.loader.ConfigurationError">ConfigurationError</a></li>
<li><a title="fin_statement_model.core.errors.CalculationError" href="errors.html#fin_statement_model.core.errors.CalculationError">CalculationError</a></li>
<li><a title="fin_statement_model.core.errors.CircularDependencyError" href="errors.html#fin_statement_model.core.errors.CircularDependencyError">CircularDependencyError</a></li>
<li><a title="fin_statement_model.core.errors.ConfigurationError" href="errors.html#fin_statement_model.core.errors.ConfigurationError">ConfigurationError</a></li>
<li><a title="fin_statement_model.core.errors.DataValidationError" href="errors.html#fin_statement_model.core.errors.DataValidationError">DataValidationError</a></li>
<li><a title="fin_statement_model.core.errors.GraphError" href="errors.html#fin_statement_model.core.errors.GraphError">GraphError</a></li>
<li><a title="fin_statement_model.core.errors.MetricError" href="errors.html#fin_statement_model.core.errors.MetricError">MetricError</a></li>
<li><a title="fin_statement_model.core.errors.MissingInputError" href="errors.html#fin_statement_model.core.errors.MissingInputError">MissingInputError</a></li>
<li><a title="fin_statement_model.core.errors.NodeError" href="errors.html#fin_statement_model.core.errors.NodeError">NodeError</a></li>
<li><a title="fin_statement_model.core.errors.PeriodError" href="errors.html#fin_statement_model.core.errors.PeriodError">PeriodError</a></li>
<li><a title="fin_statement_model.core.errors.StatementError" href="errors.html#fin_statement_model.core.errors.StatementError">StatementError</a></li>
<li><a title="fin_statement_model.core.errors.StrategyError" href="errors.html#fin_statement_model.core.errors.StrategyError">StrategyError</a></li>
<li><a title="fin_statement_model.core.errors.TransformationError" href="errors.html#fin_statement_model.core.errors.TransformationError">TransformationError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="../forecasting/errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.io.exceptions.IOError" href="../io/exceptions.html#fin_statement_model.io.exceptions.IOError">IOError</a></li>
<li><a title="fin_statement_model.preprocessing.errors.PreprocessingError" href="../preprocessing/errors.html#fin_statement_model.preprocessing.errors.PreprocessingError">PreprocessingError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.core.FinancialStatementItemNode"><code class="flex name class">
<span>class <span class="ident">FinancialStatementItemNode</span></span>
<span>(</span><span>name: str, values: dict[str, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;financial_statement_item&#34;)
class FinancialStatementItemNode(Node):
    &#34;&#34;&#34;Store raw financial statement values for specific periods.

    Represents a leaf node containing actual reported financial data
    (e.g., revenue, COGS) across time periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode`:
            Classmethod to deserialize a node from a dictionary. `context` is ignored for data nodes.

    Attributes:
        name (str): Unique identifier for the financial item.
        values (dict[str, float]): Mapping from period identifiers to their values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 1000.0, &#34;2023&#34;: 1200.0}
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; node2 = FinancialStatementItemNode.from_dict(d)
        &gt;&gt;&gt; node2.calculate(&#34;2023&#34;)
        1200.0
    &#34;&#34;&#34;

    values: dict[str, float]

    def __init__(self, name: str, values: dict[str, float]):
        &#34;&#34;&#34;Create a FinancialStatementItemNode.

        Args:
            name (str): Unique identifier for the financial item.
            values (dict[str, float]): Initial mapping of periods to values.

        Raises:
            ValueError: If `name` is empty, contains invalid characters, or has leading/trailing whitespace.

        Example:
            &gt;&gt;&gt; FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            FinancialStatementItemNode object
        &#34;&#34;&#34;
        super().__init__(name)
        self.values = values

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Get the value for a specific period.

        Args:
            period (str): Period identifier to retrieve.

        Returns:
            float: Stored value for `period`, or 0.0 if not present.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            1000.0
            &gt;&gt;&gt; node.calculate(&#34;2022&#34;)
            0.0
        &#34;&#34;&#34;
        return self.values.get(period, 0.0)

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set the value for a specific period.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
            &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
            1500.0
        &#34;&#34;&#34;
        self.values[period] = value

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; data = node.to_dict()
            &gt;&gt;&gt; data[&#34;type&#34;]
            &#39;financial_statement_item&#39;
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;financial_statement_item&#34;,
            &#34;name&#34;: self.name,
            &#34;values&#34;: self.values.copy(),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, &#34;Node&#34;] | None = None,
    ) -&gt; &#34;FinancialStatementItemNode&#34;:
        &#34;&#34;&#34;Deserialize a FinancialStatementItemNode from a dictionary.

        Args:
            data (dict[str, Any]): Serialized node data; must contain keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.
            context (dict[str, Node] | None): Optional context for deserialization (ignored).

        Returns:
            FinancialStatementItemNode: Reconstructed node.

        Raises:
            ValueError: If &#39;type&#39; is not &#39;financial_statement_item&#39; or &#39;name&#39; is missing.
            TypeError: If &#39;values&#39; is not a dict.

        Example:
            &gt;&gt;&gt; d = {&#34;type&#34;: &#34;financial_statement_item&#34;, &#34;name&#34;: &#34;Revenue&#34;, &#34;values&#34;: {&#34;2023&#34;: 1000.0}}
            &gt;&gt;&gt; node = FinancialStatementItemNode.from_dict(d)
            &gt;&gt;&gt; node.name
            &#39;Revenue&#39;
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            1000.0
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;financial_statement_item&#34;:
            raise ValueError(f&#34;Invalid type for FinancialStatementItemNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FinancialStatementItemNode data&#34;)

        values = data.get(&#34;values&#34;, {})
        if not isinstance(values, dict):
            raise TypeError(&#34;&#39;values&#39; field must be a dict[str, float]&#34;)

        # Context is intentionally ignored for simple data nodes but referenced to avoid
        # unused-argument linter violations and to aid future debugging.
        if context is not None:
            logger.debug(
                &#34;FinancialStatementItemNode.from_dict received a non-null &#39;context&#39; argument, which is currently ignored. Node: %s&#34;,
                name,
            )

        return cls(name, values)</code></pre>
</details>
<div class="desc"><p>Store raw financial statement values for specific periods.</p>
<p>Represents a leaf node containing actual reported financial data
(e.g., revenue, COGS) across time periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is ignored for data nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Mapping from period identifiers to their values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 1000.0, &quot;2023&quot;: 1200.0}
&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; node2 = FinancialStatementItemNode.from_dict(d)
&gt;&gt;&gt; node2.calculate(&quot;2023&quot;)
1200.0
</code></pre>
<p>Create a FinancialStatementItemNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Initial mapping of periods to values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, contains invalid characters, or has leading/trailing whitespace.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
FinancialStatementItemNode object
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.core.FinancialStatementItemNode.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.FinancialStatementItemNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, '<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>'] | None = None) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize a FinancialStatementItemNode from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data; must contain keys 'type', 'name', and 'values'.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Optional context for deserialization (ignored).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.FinancialStatementItemNode" href="#fin_statement_model.core.FinancialStatementItemNode">FinancialStatementItemNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If 'type' is not 'financial_statement_item' or 'name' is missing.</dd>
<dt><code>TypeError</code></dt>
<dd>If 'values' is not a dict.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {&quot;type&quot;: &quot;financial_statement_item&quot;, &quot;name&quot;: &quot;Revenue&quot;, &quot;values&quot;: {&quot;2023&quot;: 1000.0}}
&gt;&gt;&gt; node = FinancialStatementItemNode.from_dict(d)
&gt;&gt;&gt; node.name
'Revenue'
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1000.0
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.FinancialStatementItemNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Get the value for a specific period.

    Args:
        period (str): Period identifier to retrieve.

    Returns:
        float: Stored value for `period`, or 0.0 if not present.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        1000.0
        &gt;&gt;&gt; node.calculate(&#34;2022&#34;)
        0.0
    &#34;&#34;&#34;
    return self.values.get(period, 0.0)</code></pre>
</details>
<div class="desc"><p>Get the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Stored value for <code>period</code>, or 0.0 if not present.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1000.0
&gt;&gt;&gt; node.calculate(&quot;2022&quot;)
0.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.FinancialStatementItemNode.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set the value for a specific period.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
        &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
        1500.0
    &#34;&#34;&#34;
    self.values[period] = value</code></pre>
</details>
<div class="desc"><p>Set the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; node.set_value(&quot;2024&quot;, 1500.0)
&gt;&gt;&gt; node.calculate(&quot;2024&quot;)
1500.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.FinancialStatementItemNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; data = node.to_dict()
        &gt;&gt;&gt; data[&#34;type&#34;]
        &#39;financial_statement_item&#39;
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;financial_statement_item&#34;,
        &#34;name&#34;: self.name,
        &#34;values&#34;: self.values.copy(),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary with keys 'type', 'name', and 'values'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; data = node.to_dict()
&gt;&gt;&gt; data[&quot;type&quot;]
'financial_statement_item'
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_dependencies" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.FormulaCalculationNode"><code class="flex name class">
<span>class <span class="ident">FormulaCalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>formula: str,<br>metric_name: str | None = None,<br>metric_description: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;formula_calculation&#34;)
class FormulaCalculationNode(CalculationNode):
    &#34;&#34;&#34;Calculate values based on a formula string.

    Use a formula expression and mapped input nodes to evaluate a calculation.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FormulaCalculationNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        inputs_dict (dict[str, Node]): Mapping of variable names to input nodes.
        formula (str): Mathematical expression to evaluate.
        metric_name (Optional[str]): Metric identifier from the registry, if any.
        metric_description (Optional[str]): Description from the metric definition, if any.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
        &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
        &gt;&gt;&gt; formula_node = FormulaCalculationNode(
        ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
        ... )
        &gt;&gt;&gt; d = formula_node.to_dict()
        &gt;&gt;&gt; formula_node2 = FormulaCalculationNode.from_dict(d, {&#34;revenue&#34;: revenue, &#34;cogs&#34;: cogs})
        &gt;&gt;&gt; formula_node2.calculate(&#34;2023&#34;)
        40.0
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        inputs: dict[str, Node],
        formula: str,
        metric_name: str | None = None,
        metric_description: str | None = None,
    ):
        &#34;&#34;&#34;Create a FormulaCalculationNode.

        Args:
            name (str): Unique identifier for the node.
            inputs (dict[str, Node]): Mapping of variable names to input nodes.
            formula (str): Mathematical formula string to evaluate.
            metric_name (Optional[str]): Original metric key from registry.
            metric_description (Optional[str]): Description from the metric definition.

        Raises:
            ValueError: If `formula` syntax is invalid.
            TypeError: If any entry in `inputs` is not a Node.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
            &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
            &gt;&gt;&gt; formula_node = FormulaCalculationNode(
            ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
            ... )
            &gt;&gt;&gt; formula_node.calculate(&#34;2023&#34;)
            40.0
        &#34;&#34;&#34;
        if not isinstance(inputs, dict) or not all(isinstance(n, Node) for n in inputs.values()):
            raise TypeError(&#34;FormulaCalculationNode inputs must be a dict of Node instances.&#34;)

        # Store the formula and metric attributes
        self.formula = formula
        self.metric_name = metric_name
        self.metric_description = metric_description

        # Extract variable names and input nodes in consistent order
        input_variable_names = list(inputs.keys())
        input_nodes = list(inputs.values())

        # Create FormulaCalculation strategy
        formula_calculation = FormulaCalculation(formula, input_variable_names)

        # Initialize parent CalculationNode with the strategy
        super().__init__(name, input_nodes, formula_calculation)

        # Store the inputs dict for compatibility (separate from parent&#39;s inputs list)
        self.inputs_dict = inputs

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes used in the formula.

        Returns:
            list[str]: Names of input nodes.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
            &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
            &gt;&gt;&gt; formula_node = FormulaCalculationNode(
            ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
            ... )
            &gt;&gt;&gt; formula_node.get_dependencies()
            [&#39;revenue&#39;, &#39;cogs&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs_dict.values()]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized node data.

        Example:
            &gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;formula_calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
            &#34;formula_variable_names&#34;: list(self.inputs_dict.keys()),
            &#34;formula&#34;: self.formula,
            &#34;calculation_type&#34;: &#34;formula&#34;,
            &#34;metric_name&#34;: self.metric_name,
            &#34;metric_description&#34;: self.metric_description,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;FormulaCalculationNode&#34;:
        &#34;&#34;&#34;Create a FormulaCalculationNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new FormulaCalculationNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.

        Example:
            &gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;formula_calculation&#34;:
            raise ValueError(f&#34;Invalid type for FormulaCalculationNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FormulaCalculationNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize FormulaCalculationNode&#34;)

        formula = data.get(&#34;formula&#34;)
        if not formula:
            raise ValueError(&#34;Missing &#39;formula&#39; field in FormulaCalculationNode data&#34;)

        input_names = data.get(&#34;inputs&#34;, [])
        formula_variable_names = data.get(&#34;formula_variable_names&#34;, [])

        if len(input_names) != len(formula_variable_names):
            raise ValueError(&#34;Mismatch between inputs and formula_variable_names in FormulaCalculationNode data&#34;)

        # Resolve input nodes from context and create inputs dict
        inputs_dict = {}
        for var_name, input_name in zip(formula_variable_names, input_names, strict=False):
            if input_name not in context:
                raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
            inputs_dict[var_name] = context[input_name]

        # Extract metric information
        metric_name = data.get(&#34;metric_name&#34;)
        metric_description = data.get(&#34;metric_description&#34;)

        return cls(
            name=name,
            inputs=inputs_dict,
            formula=formula,
            metric_name=metric_name,
            metric_description=metric_description,
        )</code></pre>
</details>
<div class="desc"><p>Calculate values based on a formula string.</p>
<p>Use a formula expression and mapped input nodes to evaluate a calculation.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FormulaCalculationNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>inputs_dict</code></strong> :&ensp;<code>dict[str, <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>]</code></dt>
<dd>Mapping of variable names to input nodes.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Mathematical expression to evaluate.</dd>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Metric identifier from the registry, if any.</dd>
<dt><strong><code>metric_description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Description from the metric definition, if any.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2023&quot;: 60})
&gt;&gt;&gt; formula_node = FormulaCalculationNode(
...     &quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;
... )
&gt;&gt;&gt; d = formula_node.to_dict()
&gt;&gt;&gt; formula_node2 = FormulaCalculationNode.from_dict(d, {&quot;revenue&quot;: revenue, &quot;cogs&quot;: cogs})
&gt;&gt;&gt; formula_node2.calculate(&quot;2023&quot;)
40.0
</code></pre>
<p>Create a FormulaCalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>dict[str, <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>]</code></dt>
<dd>Mapping of variable names to input nodes.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Mathematical formula string to evaluate.</dd>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Original metric key from registry.</dd>
<dt><strong><code>metric_description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Description from the metric definition.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>formula</code> syntax is invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If any entry in <code>inputs</code> is not a Node.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2023&quot;: 60})
&gt;&gt;&gt; formula_node = FormulaCalculationNode(
...     &quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;
... )
&gt;&gt;&gt; formula_node.calculate(&quot;2023&quot;)
40.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.FormulaCalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode">FormulaCalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a FormulaCalculationNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new FormulaCalculationNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.FormulaCalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes used in the formula.

    Returns:
        list[str]: Names of input nodes.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
        &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
        &gt;&gt;&gt; formula_node = FormulaCalculationNode(
        ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
        ... )
        &gt;&gt;&gt; formula_node.get_dependencies()
        [&#39;revenue&#39;, &#39;cogs&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs_dict.values()]</code></pre>
</details>
<div class="desc"><p>Get names of nodes used in the formula.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Names of input nodes.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2023&quot;: 60})
&gt;&gt;&gt; formula_node = FormulaCalculationNode(
...     &quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;
... )
&gt;&gt;&gt; formula_node.get_dependencies()
['revenue', 'cogs']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.FormulaCalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized node data.

    Example:
        &gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;formula_calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
        &#34;formula_variable_names&#34;: list(self.inputs_dict.keys()),
        &#34;formula&#34;: self.formula,
        &#34;calculation_type&#34;: &#34;formula&#34;,
        &#34;metric_name&#34;: self.metric_name,
        &#34;metric_description&#34;: self.metric_description,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.calculate" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.clear_cache" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.set_calculation" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode.set_calculation">set_calculation</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.set_value" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>periods: list[str] | None = None,<br>*,<br>calc_engine_cls: type[CalculationEngine] = fin_statement_model.core.graph.services.calculation_engine.CalculationEngine,<br>period_service_cls: type[PeriodService] = fin_statement_model.core.graph.services.period_service.PeriodService,<br>adjustment_service_cls: type[AdjustmentService] = fin_statement_model.core.graph.services.adjustment_service.AdjustmentService)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(
    GraphBaseMixin,
    NodeOpsMixin,
    CalcOpsMixin,
    AdjustmentMixin,
    MergeReprMixin,
    TraversalMixin,
):
    &#34;&#34;&#34;Unified directed-graph abstraction for financial-statement modelling.

    The Graph class exposes a high-level API for building, mutating, and evaluating
    financial statement calculation graphs. All functionality is provided by the mix-ins.

    See module docstring for a comprehensive feature list and usage example.
    &#34;&#34;&#34;

    # All functionality is provided by the mix-ins.</code></pre>
</details>
<div class="desc"><p>Unified directed-graph abstraction for financial-statement modelling.</p>
<p>The Graph class exposes a high-level API for building, mutating, and evaluating
financial statement calculation graphs. All functionality is provided by the mix-ins.</p>
<p>See module docstring for a comprehensive feature list and usage example.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fin_statement_model.core.graph.components._base.GraphBaseMixin</li>
<li>fin_statement_model.core.graph.components._node_ops.NodeOpsMixin</li>
<li>fin_statement_model.core.graph.components._calc_ops.CalcOpsMixin</li>
<li>fin_statement_model.core.graph.components._adjustment_ops.AdjustmentMixin</li>
<li>fin_statement_model.core.graph.components._merge_repr.MergeReprMixin</li>
<li>fin_statement_model.core.graph.components._traversal_ops.TraversalMixin</li>
</ul>
</dd>
<dt id="fin_statement_model.core.GraphError"><code class="flex name class">
<span>class <span class="ident">GraphError</span></span>
<span>(</span><span>message: str, nodes: list[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphError(FinancialModelError):
    &#34;&#34;&#34;Error raised for invalid graph structure or operations.

    Covers issues like inconsistencies in the graph (e.g., orphaned nodes),
    problems during graph traversal, or invalid modifications to the graph.

    Examples:
        &gt;&gt;&gt; raise GraphError(&#34;Orphaned node detected&#34;, nodes=[&#34;unconnected_node&#34;])
        &gt;&gt;&gt; raise GraphError(&#34;Failed to add edge due to type mismatch&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str, nodes: list[str] | None = None):
        &#34;&#34;&#34;Initialize the GraphError.

        Args:
            message: The base error message.
            nodes: Optional list of node IDs involved in the graph error.
        &#34;&#34;&#34;
        self.nodes = nodes or []

        full_message = f&#34;{message} involving nodes: {&#39;, &#39;.join(nodes)}&#34; if nodes else message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for invalid graph structure or operations.</p>
<p>Covers issues like inconsistencies in the graph (e.g., orphaned nodes),
problems during graph traversal, or invalid modifications to the graph.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise GraphError(&quot;Orphaned node detected&quot;, nodes=[&quot;unconnected_node&quot;])
&gt;&gt;&gt; raise GraphError(&quot;Failed to add edge due to type mismatch&quot;)
</code></pre>
<p>Initialize the GraphError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>nodes</code></strong></dt>
<dd>Optional list of node IDs involved in the graph error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.MultiPeriodStatNode"><code class="flex name class">
<span>class <span class="ident">MultiPeriodStatNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>periods: list[str],<br>stat_func: Callable[..., typing.Any] = &lt;function stdev&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;multi_period_stat&#34;)
class MultiPeriodStatNode(Node):
    &#34;&#34;&#34;Compute a statistical measure over multiple periods.

    Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning if stat_func is custom).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes. Custom stat functions may require manual reconstruction.

    Attributes:
        input_node (Node): Node providing source values.
        periods (list[str]): Period identifiers to include.
        stat_func (StatFunc): Function to apply to collected values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
        &gt;&gt;&gt; data = {&#34;Q1&#34;: 10, &#34;Q2&#34;: 12, &#34;Q3&#34;: 11, &#34;Q4&#34;: 13}
        &gt;&gt;&gt; sales = FinancialStatementItemNode(&#34;sales&#34;, data)
        &gt;&gt;&gt; import statistics
        &gt;&gt;&gt; avg = MultiPeriodStatNode(
        ...     &#34;avg_sales&#34;, input_node=sales, periods=[&#34;Q1&#34;, &#34;Q2&#34;, &#34;Q3&#34;, &#34;Q4&#34;], stat_func=statistics.mean
        ... )
        &gt;&gt;&gt; d = avg.to_dict()
        &gt;&gt;&gt; avg2 = MultiPeriodStatNode.from_dict(d, {&#34;sales&#34;: sales})
        &gt;&gt;&gt; avg2.calculate()
        11.5
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        input_node: Node,
        periods: list[str],
        stat_func: StatFunc = statistics.stdev,  # Default to standard deviation
    ):
        &#34;&#34;&#34;Create a MultiPeriodStatNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values.
            periods (list[str]): Period identifiers to analyze.
            stat_func (StatFunc): Function applied to collected values. Defaults to statistics.stdev.

        Raises:
            ValueError: If `periods` is empty or not a list.
            TypeError: If `input_node` is not a Node or `stat_func` is not callable.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;MultiPeriodStatNode input_node must be a Node instance.&#34;)
        if not isinstance(periods, list) or not periods:
            raise ValueError(&#34;MultiPeriodStatNode periods must be a non-empty list.&#34;)
        if not all(isinstance(p, str) for p in periods):
            raise TypeError(&#34;MultiPeriodStatNode periods must contain only strings.&#34;)
        if not callable(stat_func):
            raise TypeError(&#34;MultiPeriodStatNode stat_func must be a callable function.&#34;)

        self.input_node = input_node
        self.periods = periods
        self.stat_func = stat_func

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the statistical measure across specified periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

        Raises:
            CalculationError: If input retrieval fails or unexpected errors occur.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        values: list[Numeric] = []
        retrieval_errors = []
        try:
            for p in self.periods:
                try:
                    value = self.input_node.calculate(p)
                    if isinstance(value, int | float) and math.isfinite(value):
                        values.append(float(value))
                    else:
                        # Log non-numeric/non-finite values but continue if possible
                        logger.warning(
                            &#34;MultiPeriodStatNode &#39;%s&#39;: Input &#39;%s&#39; gave non-numeric/non-finite value (%s) for period &#39;%s&#39;. Skipping.&#34;,
                            self.name,
                            self.input_node.name,
                            value,
                            p,
                        )
                except Exception:
                    # Log error fetching data for a specific period but continue
                    logger.exception(
                        &#34;MultiPeriodStatNode &#39;%s&#39;: Error getting value for period &#39;%s&#39; from &#39;%s&#39;&#34;,
                        self.name,
                        p,
                        self.input_node.name,
                    )
                    retrieval_errors.append(p)

            # If no valid numeric values were collected
            if not values:
                logger.warning(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: No valid numeric data points found across periods %s. Returning NaN.&#34;,
                    self.name,
                    self.periods,
                )
                return float(&#34;nan&#34;)

            # Attempt the statistical calculation
            try:
                result = self.stat_func(values)
                # Ensure result is float, handle potential NaN from stat_func
                return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
            except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
                # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
                logger.warning(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: Stat function &#39;%s&#39; failed (%s). Values: %s. Returning NaN.&#34;,
                    self.name,
                    self.stat_func.__name__,
                    stat_err,
                    values,
                )
                return float(&#34;nan&#34;)

        except Exception as e:
            # Catch any other unexpected errors during the process
            raise CalculationError(
                message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=&#34;multi-period&#34;,  # Indicate calculation context
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;periods&#34;: self.periods,
                    &#34;stat_func&#34;: self.stat_func.__name__,
                    &#34;collected_values_count&#34;: len(values),
                    &#34;retrieval_errors_periods&#34;: retrieval_errors,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized data with function name and periods.

        Note:
            `stat_func` may not be fully serializable; manual reconstruction may be required.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;multi_period_stat&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;periods&#34;: self.periods.copy(),
            &#34;stat_func_name&#34;: self.stat_func.__name__,
            &#34;serialization_warning&#34;: (
                &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
                &#34;Manual reconstruction may be required for custom functions.&#34;
            ),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;MultiPeriodStatNode&#34;:
        &#34;&#34;&#34;Recreate a MultiPeriodStatNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            MultiPeriodStatNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;multi_period_stat&#34;:
            raise ValueError(f&#34;Invalid type for MultiPeriodStatNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in MultiPeriodStatNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in MultiPeriodStatNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize MultiPeriodStatNode&#34;)
        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        periods = data.get(&#34;periods&#34;, [])
        stat_func_name = data.get(&#34;stat_func_name&#34;, &#34;stdev&#34;)

        if not periods:
            raise ValueError(&#34;Missing or empty &#39;periods&#39; field in MultiPeriodStatNode data&#34;)

        # Map common statistical function names to their implementations
        stat_func_map: dict[str, StatFunc] = {
            &#34;mean&#34;: statistics.mean,
            &#34;stdev&#34;: statistics.stdev,
            &#34;median&#34;: statistics.median,
            &#34;variance&#34;: statistics.variance,
            &#34;pstdev&#34;: statistics.pstdev,
            &#34;pvariance&#34;: statistics.pvariance,
        }

        stat_func = stat_func_map.get(stat_func_name, statistics.stdev)
        if stat_func_name not in stat_func_map:
            logger.warning(
                &#34;Unknown stat_func_name &#39;%s&#39; for MultiPeriodStatNode &#39;%s&#39;. Using default statistics.stdev.&#34;,
                stat_func_name,
                name,
            )

        return cls(
            name=name,
            input_node=input_node,
            periods=periods,
            stat_func=stat_func,
        )</code></pre>
</details>
<div class="desc"><p>Compute a statistical measure over multiple periods.</p>
<p>Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning if stat_func is custom).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes. Custom stat functions may require manual reconstruction.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to include.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function to apply to collected values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
&gt;&gt;&gt; data = {&quot;Q1&quot;: 10, &quot;Q2&quot;: 12, &quot;Q3&quot;: 11, &quot;Q4&quot;: 13}
&gt;&gt;&gt; sales = FinancialStatementItemNode(&quot;sales&quot;, data)
&gt;&gt;&gt; import statistics
&gt;&gt;&gt; avg = MultiPeriodStatNode(
...     &quot;avg_sales&quot;, input_node=sales, periods=[&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot;], stat_func=statistics.mean
... )
&gt;&gt;&gt; d = avg.to_dict()
&gt;&gt;&gt; avg2 = MultiPeriodStatNode.from_dict(d, {&quot;sales&quot;: sales})
&gt;&gt;&gt; avg2.calculate()
11.5
</code></pre>
<p>Create a MultiPeriodStatNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to analyze.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function applied to collected values. Defaults to statistics.stdev.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>periods</code> is empty or not a list.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or <code>stat_func</code> is not callable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.MultiPeriodStatNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a MultiPeriodStatNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.MultiPeriodStatNode" href="#fin_statement_model.core.MultiPeriodStatNode">MultiPeriodStatNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.MultiPeriodStatNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the statistical measure across specified periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

    Raises:
        CalculationError: If input retrieval fails or unexpected errors occur.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    values: list[Numeric] = []
    retrieval_errors = []
    try:
        for p in self.periods:
            try:
                value = self.input_node.calculate(p)
                if isinstance(value, int | float) and math.isfinite(value):
                    values.append(float(value))
                else:
                    # Log non-numeric/non-finite values but continue if possible
                    logger.warning(
                        &#34;MultiPeriodStatNode &#39;%s&#39;: Input &#39;%s&#39; gave non-numeric/non-finite value (%s) for period &#39;%s&#39;. Skipping.&#34;,
                        self.name,
                        self.input_node.name,
                        value,
                        p,
                    )
            except Exception:
                # Log error fetching data for a specific period but continue
                logger.exception(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: Error getting value for period &#39;%s&#39; from &#39;%s&#39;&#34;,
                    self.name,
                    p,
                    self.input_node.name,
                )
                retrieval_errors.append(p)

        # If no valid numeric values were collected
        if not values:
            logger.warning(
                &#34;MultiPeriodStatNode &#39;%s&#39;: No valid numeric data points found across periods %s. Returning NaN.&#34;,
                self.name,
                self.periods,
            )
            return float(&#34;nan&#34;)

        # Attempt the statistical calculation
        try:
            result = self.stat_func(values)
            # Ensure result is float, handle potential NaN from stat_func
            return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
        except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
            # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
            logger.warning(
                &#34;MultiPeriodStatNode &#39;%s&#39;: Stat function &#39;%s&#39; failed (%s). Values: %s. Returning NaN.&#34;,
                self.name,
                self.stat_func.__name__,
                stat_err,
                values,
            )
            return float(&#34;nan&#34;)

    except Exception as e:
        # Catch any other unexpected errors during the process
        raise CalculationError(
            message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=&#34;multi-period&#34;,  # Indicate calculation context
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;periods&#34;: self.periods,
                &#34;stat_func&#34;: self.stat_func.__name__,
                &#34;collected_values_count&#34;: len(values),
                &#34;retrieval_errors_periods&#34;: retrieval_errors,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the statistical measure across specified periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Result of <code>stat_func</code> on collected values, or NaN if insufficient valid data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>If input retrieval fails or unexpected errors occur.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.MultiPeriodStatNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this statistical node depends on.</p></div>
</dd>
<dt id="fin_statement_model.core.MultiPeriodStatNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized data with function name and periods.

    Note:
        `stat_func` may not be fully serializable; manual reconstruction may be required.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;multi_period_stat&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;periods&#34;: self.periods.copy(),
        &#34;stat_func_name&#34;: self.stat_func.__name__,
        &#34;serialization_warning&#34;: (
            &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
            &#34;Manual reconstruction may be required for custom functions.&#34;
        ),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized data with function name and periods.</dd>
</dl>
<h2 id="note">Note</h2>
<p><code>stat_func</code> may not be fully serializable; manual reconstruction may be required.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.MultiplicationCalculation"><code class="flex name class">
<span>class <span class="ident">MultiplicationCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiplicationCalculation(Calculation):
    &#34;&#34;&#34;Implements a multiplication calculation, calculating the product of input values.

    This calculation multiplies the calculated values of all provided input nodes
    for a given period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculates the product of the values from all input nodes.

        Args:
            inputs: A list of Node objects.
            period: The time period string (e.g., &#34;2023FY&#34;) for the calculation.

        Returns:
            The product of all input values. Returns 1.0 (multiplicative identity)
            if the input list is empty.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value):
            ...         self._value = value
            ...
            ...     def calculate(self, period):
            ...         return self._value
            &gt;&gt;&gt; strategy = MultiplicationCalculation()
            &gt;&gt;&gt; nodes = [MockNode(2), MockNode(3), MockNode(4)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            24.0
            &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
            1.0
        &#34;&#34;&#34;
        # Multiplication calculation should ideally return 1.0 for empty inputs.
        # Raising error if empty seems less conventional for multiplication.
        if not inputs:
            logger.warning(&#34;Multiplication calculation called with empty inputs, returning 1.0&#34;)
            return 1.0

        logger.debug(&#34;Applying multiplication calculation for period %s&#34;, period)
        result = 1.0
        for input_node in inputs:
            result *= input_node.calculate(period)
        return result

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the multiplication calculation.&#34;&#34;&#34;
        return &#34;Multiplication (product of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements a multiplication calculation, calculating the product of input values.</p>
<p>This calculation multiplies the calculated values of all provided input nodes
for a given period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.MultiplicationCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the multiplication calculation.&#34;&#34;&#34;
    return &#34;Multiplication (product of all inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the multiplication calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.MultiplicationCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculates the product of the values from all input nodes.

    Args:
        inputs: A list of Node objects.
        period: The time period string (e.g., &#34;2023FY&#34;) for the calculation.

    Returns:
        The product of all input values. Returns 1.0 (multiplicative identity)
        if the input list is empty.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value):
        ...         self._value = value
        ...
        ...     def calculate(self, period):
        ...         return self._value
        &gt;&gt;&gt; strategy = MultiplicationCalculation()
        &gt;&gt;&gt; nodes = [MockNode(2), MockNode(3), MockNode(4)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        24.0
        &gt;&gt;&gt; strategy.calculate([], &#34;2023&#34;)
        1.0
    &#34;&#34;&#34;
    # Multiplication calculation should ideally return 1.0 for empty inputs.
    # Raising error if empty seems less conventional for multiplication.
    if not inputs:
        logger.warning(&#34;Multiplication calculation called with empty inputs, returning 1.0&#34;)
        return 1.0

    logger.debug(&#34;Applying multiplication calculation for period %s&#34;, period)
    result = 1.0
    for input_node in inputs:
        result *= input_node.calculate(period)
    return result</code></pre>
</details>
<div class="desc"><p>Calculates the product of the values from all input nodes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2023FY") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The product of all input values. Returns 1.0 (multiplicative identity)
if the input list is empty.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value):
...         self._value = value
...
...     def calculate(self, period):
...         return self._value
&gt;&gt;&gt; strategy = MultiplicationCalculation()
&gt;&gt;&gt; nodes = [MockNode(2), MockNode(3), MockNode(4)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
24.0
&gt;&gt;&gt; strategy.calculate([], &quot;2023&quot;)
1.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(ABC):
    &#34;&#34;&#34;Abstract base class for all nodes in the financial statement model.

    This class defines the required interface for all node types, including calculation,
    serialization, and dependency inspection. Subclasses must implement `calculate`, `to_dict`,
    and (for deserializable nodes) `from_dict` as a classmethod.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node`:
            Classmethod to deserialize a node from a dictionary. Nodes with dependencies
            (e.g., calculation, forecast, stat nodes) must use the `context` argument to resolve them.
            Data nodes may ignore `context`.

    Attributes:
        name (str): Unique identifier for the node instance.
        values (dict[str, Any]): Optional mapping of period to value (for data nodes).

    Example:
        &gt;&gt;&gt; class DummyNode(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     @classmethod
        ...     def from_dict(cls, data, context=None):
        ...         return cls(data[&#34;name&#34;])
        &gt;&gt;&gt; node = DummyNode(&#34;Revenue&#34;)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; DummyNode.from_dict(d).name
        &#39;Revenue&#39;
    &#34;&#34;&#34;

    name: str
    values: dict[str, Any]

    def __init__(self, name: str):
        &#34;&#34;&#34;Initialize the Node instance with a unique name.

        Args:
            name (str): Unique identifier for the node. Must be a non-empty string.

        Raises:
            ValueError: If `name` is empty, not a string, or contains invalid characters.

        Example:
            &gt;&gt;&gt; Node(&#34;Revenue&#34;)  # doctest: +ELLIPSIS
            Traceback (most recent call last):
            ...
            TypeError: Can&#39;t instantiate abstract class Node...
        &#34;&#34;&#34;
        # Check if name is a non-empty string
        if not isinstance(name, str) or not name:
            raise ValueError(&#34;Node name must be a non-empty string.&#34;)
        # Check for invalid characters (including newline, tab)
        if &#34;\n&#34; in name or &#34;\t&#34; in name:
            raise ValueError(f&#34;Invalid node name: &#39;{name}&#39;. Contains invalid characters.&#34;)
        # Check for leading/trailing whitespace
        if name != name.strip():
            raise ValueError(f&#34;Invalid node name: &#39;{name}&#39;. Cannot have leading/trailing whitespace.&#34;)
        self.name = name

    @abstractmethod
    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Subclasses must override this method to implement specific calculation logic.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 2.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; Dummy(&#34;Test&#34;).calculate(&#34;2023&#34;)
            2.0
        &#34;&#34;&#34;

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached calculation results for this node.

        Subclasses with caching should override this method to clear their internal cache.

        Returns:
            None

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def clear_cache(self):
            ...         print(&#34;Cache cleared!&#34;)
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.clear_cache()
            Cache cleared!
        &#34;&#34;&#34;
        # Default: no cache to clear
        return None

    def has_attribute(self, attr_name: str) -&gt; bool:
        &#34;&#34;&#34;Check if the node has a specific attribute.

        Args:
            attr_name (str): The name of the attribute to check.

        Returns:
            bool: True if the attribute exists, otherwise False.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
            True
        &#34;&#34;&#34;
        return hasattr(self, attr_name)

    def get_attribute(self, attribute_name: str) -&gt; object:
        &#34;&#34;&#34;Get a named attribute from the node.

        Args:
            attribute_name (str): The name of the attribute to retrieve.

        Returns:
            object: The value of the specified attribute.

        Raises:
            AttributeError: If the attribute does not exist.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
            &#39;Test&#39;
        &#34;&#34;&#34;
        try:
            return getattr(self, attribute_name)
        except AttributeError as err:
            raise AttributeError(f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;) from err

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

        Override in subclasses to support mutating stored data.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Raises:
            NotImplementedError: Always in base class.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def set_value(self, period, value):
            ...         print(f&#34;Set {period} to {value}&#34;)
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.set_value(&#34;2023&#34;, 100)
            Set 2023 to 100
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)

    @abstractmethod
    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        This method should return a dictionary containing all information
        necessary to reconstruct the node, including:
        - node type
        - name
        - any configuration parameters
        - values (for data nodes)
        - input references (for calculation nodes)

        Returns:
            dict[str, Any]: Dictionary representation of the node.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.to_dict()[&#34;type&#34;]
            &#39;dummy&#39;
        &#34;&#34;&#34;

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the names of nodes this node depends on.

        Default implementation returns empty list. Override in nodes that have dependencies.

        Returns:
            list[str]: List of node names this node depends on.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def get_dependencies(self):
            ...         return [&#34;dep1&#34;, &#34;dep2&#34;]
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.get_dependencies()
            [&#39;dep1&#39;, &#39;dep2&#39;]
        &#34;&#34;&#34;
        return []

    @classmethod
    @abstractmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, &#34;Node&#34;] | None = None,
    ) -&gt; &#34;Node&#34;:
        &#34;&#34;&#34;Deserialize a node from its dictionary representation.

        Subclasses that support deserialization must override this method.
        Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the
        `context` argument to resolve them. Data nodes may ignore `context`.

        Args:
            data: The serialized node dictionary (usually produced by :py:meth:`to_dict`).
            context: Optional mapping of node names to node objects that have already been deserialized.

        Returns:
            Node: A fully instantiated node object.

        Raises:
            NotImplementedError: If not overridden in a subclass.

        Example:
            &gt;&gt;&gt; class DummyNode(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     @classmethod
            ...     def from_dict(cls, data, context=None):
            ...         return cls(data[&#34;name&#34;])
            &gt;&gt;&gt; node = DummyNode(&#34;Revenue&#34;)
            &gt;&gt;&gt; d = node.to_dict()
            &gt;&gt;&gt; DummyNode.from_dict(d).name
            &#39;Revenue&#39;
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{cls.__name__}.from_dict() is not implemented. Subclasses requiring deserialization must override this method.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Abstract base class for all nodes in the financial statement model.</p>
<p>This class defines the required interface for all node types, including calculation,
serialization, and dependency inspection. Subclasses must implement <code>calculate</code>, <code>to_dict</code>,
and (for deserializable nodes) <code>from_dict</code> as a classmethod.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node</code>:
Classmethod to deserialize a node from a dictionary. Nodes with dependencies
(e.g., calculation, forecast, stat nodes) must use the <code>context</code> argument to resolve them.
Data nodes may ignore <code>context</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node instance.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Optional mapping of period to value (for data nodes).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     @classmethod
...     def from_dict(cls, data, context=None):
...         return cls(data[&quot;name&quot;])
&gt;&gt;&gt; node = DummyNode(&quot;Revenue&quot;)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; DummyNode.from_dict(d).name
'Revenue'
</code></pre>
<p>Initialize the Node instance with a unique name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node. Must be a non-empty string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, not a string, or contains invalid characters.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Node(&quot;Revenue&quot;)  # doctest: +ELLIPSIS
Traceback (most recent call last):
...
TypeError: Can't instantiate abstract class Node...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode" href="nodes/calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode">CustomCalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="nodes/forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="nodes/item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode" href="nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></li>
<li>fin_statement_model.io.graph.definition_io.GraphDefinitionReader._TempNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.core.Node.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.core.Node.values"><code class="name">var <span class="ident">values</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.Node.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, '<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>'] | None = None) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize a node from its dictionary representation.</p>
<p>Subclasses that support deserialization must override this method.
Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the
<code>context</code> argument to resolve them. Data nodes may ignore <code>context</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The serialized node dictionary (usually produced by :py:meth:<code>to_dict</code>).</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional mapping of node names to node objects that have already been deserialized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>A fully instantiated node object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If not overridden in a subclass.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     @classmethod
...     def from_dict(cls, data, context=None):
...         return cls(data[&quot;name&quot;])
&gt;&gt;&gt; node = DummyNode(&quot;Revenue&quot;)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; DummyNode.from_dict(d).name
'Revenue'
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.Node.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Subclasses must override this method to implement specific calculation logic.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 2.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; Dummy(&#34;Test&#34;).calculate(&#34;2023&#34;)
        2.0
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Subclasses must override this method to implement specific calculation logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 2.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; Dummy(&quot;Test&quot;).calculate(&quot;2023&quot;)
2.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.Node.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached calculation results for this node.

    Subclasses with caching should override this method to clear their internal cache.

    Returns:
        None

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def clear_cache(self):
        ...         print(&#34;Cache cleared!&#34;)
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.clear_cache()
        Cache cleared!
    &#34;&#34;&#34;
    # Default: no cache to clear
    return None</code></pre>
</details>
<div class="desc"><p>Clear cached calculation results for this node.</p>
<p>Subclasses with caching should override this method to clear their internal cache.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def clear_cache(self):
...         print(&quot;Cache cleared!&quot;)
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.clear_cache()
Cache cleared!
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.Node.get_attribute"><code class="name flex">
<span>def <span class="ident">get_attribute</span></span>(<span>self, attribute_name: str) ‑> object</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute(self, attribute_name: str) -&gt; object:
    &#34;&#34;&#34;Get a named attribute from the node.

    Args:
        attribute_name (str): The name of the attribute to retrieve.

    Returns:
        object: The value of the specified attribute.

    Raises:
        AttributeError: If the attribute does not exist.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
        &#39;Test&#39;
    &#34;&#34;&#34;
    try:
        return getattr(self, attribute_name)
    except AttributeError as err:
        raise AttributeError(f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;) from err</code></pre>
</details>
<div class="desc"><p>Get a named attribute from the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the attribute to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The value of the specified attribute.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If the attribute does not exist.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.get_attribute(&quot;name&quot;)
'Test'
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.Node.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the names of nodes this node depends on.

    Default implementation returns empty list. Override in nodes that have dependencies.

    Returns:
        list[str]: List of node names this node depends on.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def get_dependencies(self):
        ...         return [&#34;dep1&#34;, &#34;dep2&#34;]
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.get_dependencies()
        [&#39;dep1&#39;, &#39;dep2&#39;]
    &#34;&#34;&#34;
    return []</code></pre>
</details>
<div class="desc"><p>Get the names of nodes this node depends on.</p>
<p>Default implementation returns empty list. Override in nodes that have dependencies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of node names this node depends on.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def get_dependencies(self):
...         return [&quot;dep1&quot;, &quot;dep2&quot;]
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.get_dependencies()
['dep1', 'dep2']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.Node.has_attribute"><code class="name flex">
<span>def <span class="ident">has_attribute</span></span>(<span>self, attr_name: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_attribute(self, attr_name: str) -&gt; bool:
    &#34;&#34;&#34;Check if the node has a specific attribute.

    Args:
        attr_name (str): The name of the attribute to check.

    Returns:
        bool: True if the attribute exists, otherwise False.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
        True
    &#34;&#34;&#34;
    return hasattr(self, attr_name)</code></pre>
</details>
<div class="desc"><p>Check if the node has a specific attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attr_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the attribute to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the attribute exists, otherwise False.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.has_attribute(&quot;name&quot;)
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.Node.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

    Override in subclasses to support mutating stored data.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Raises:
        NotImplementedError: Always in base class.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def set_value(self, period, value):
        ...         print(f&#34;Set {period} to {value}&#34;)
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.set_value(&#34;2023&#34;, 100)
        Set 2023 to 100
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)</code></pre>
</details>
<div class="desc"><p>Set a value for a specific period on data-bearing nodes.</p>
<p>Override in subclasses to support mutating stored data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Always in base class.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def set_value(self, period, value):
...         print(f&quot;Set {period} to {value}&quot;)
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.set_value(&quot;2023&quot;, 100)
Set 2023 to 100
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.Node.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    This method should return a dictionary containing all information
    necessary to reconstruct the node, including:
    - node type
    - name
    - any configuration parameters
    - values (for data nodes)
    - input references (for calculation nodes)

    Returns:
        dict[str, Any]: Dictionary representation of the node.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.to_dict()[&#34;type&#34;]
        &#39;dummy&#39;
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<p>This method should return a dictionary containing all information
necessary to reconstruct the node, including:
- node type
- name
- any configuration parameters
- values (for data nodes)
- input references (for calculation nodes)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary representation of the node.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.to_dict()[&quot;type&quot;]
'dummy'
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.NodeError"><code class="flex name class">
<span>class <span class="ident">NodeError</span></span>
<span>(</span><span>message: str, node_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeError(FinancialModelError):
    &#34;&#34;&#34;Error raised for issues related to graph nodes.

    Covers issues like trying to access a non-existent node,
    invalid node configurations, or type mismatches related to nodes.

    Examples:
        &gt;&gt;&gt; raise NodeError(&#34;Node not found&#34;, node_id=&#34;non_existent_node&#34;)
        &gt;&gt;&gt; raise NodeError(&#34;Invalid node type for operation&#34;, node_id=&#34;revenue&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str, node_id: str | None = None):
        &#34;&#34;&#34;Initialize the NodeError.

        Args:
            message: The base error message.
            node_id: Optional ID of the node related to the error.
        &#34;&#34;&#34;
        self.node_id = node_id

        full_message = f&#34;{message} for node &#39;{node_id}&#39;&#34; if node_id else message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for issues related to graph nodes.</p>
<p>Covers issues like trying to access a non-existent node,
invalid node configurations, or type mismatches related to nodes.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise NodeError(&quot;Node not found&quot;, node_id=&quot;non_existent_node&quot;)
&gt;&gt;&gt; raise NodeError(&quot;Invalid node type for operation&quot;, node_id=&quot;revenue&quot;)
</code></pre>
<p>Initialize the NodeError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node related to the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.NodeFactory"><code class="flex name class">
<span>class <span class="ident">NodeFactory</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeFactory:  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Static aggregation of builder, deserializer, and helper functions for node creation.

    This class exposes static methods for creating financial statement items, calculation nodes, forecast nodes,
    and for deserializing nodes from dictionaries. It also provides access to custom node creation helpers and
    legacy calculation method mappings.

    All methods are static and simply delegate to the underlying functional helpers. This allows both service-object
    and functional usage patterns.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory import NodeFactory
        &gt;&gt;&gt; node = NodeFactory.create_financial_statement_item(&#34;COGS&#34;, {&#34;2022&#34;: 50.0})
        &gt;&gt;&gt; node
        &lt;FinancialStatementItemNode name=&#39;COGS&#39;&gt;
    &#34;&#34;&#34;

    # ------------------------------------------------------------------
    # Builders
    # ------------------------------------------------------------------
    create_financial_statement_item = staticmethod(_builders.create_financial_statement_item)
    create_calculation_node = staticmethod(_builders.create_calculation_node)
    create_forecast_node = staticmethod(_builders.create_forecast_node)

    # ------------------------------------------------------------------
    # Deserialisation
    # ------------------------------------------------------------------
    create_from_dict = staticmethod(_deser.create_from_dict)

    # ------------------------------------------------------------------
    # Custom helper
    # ------------------------------------------------------------------
    _create_custom_node_from_callable = staticmethod(
        _custom._create_custom_node_from_callable  # pylint: disable=protected-access
    )

    # ------------------------------------------------------------------
    # Legacy attribute mapping used by existing code
    # ------------------------------------------------------------------
    _calculation_methods: ClassVar[dict[str, str]] = {
        alias: cls.__name__ for alias, cls in CalculationAliasRegistry.items()
    }</code></pre>
</details>
<div class="desc"><p>Static aggregation of builder, deserializer, and helper functions for node creation.</p>
<p>This class exposes static methods for creating financial statement items, calculation nodes, forecast nodes,
and for deserializing nodes from dictionaries. It also provides access to custom node creation helpers and
legacy calculation method mappings.</p>
<p>All methods are static and simply delegate to the underlying functional helpers. This allows both service-object
and functional usage patterns.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory import NodeFactory
&gt;&gt;&gt; node = NodeFactory.create_financial_statement_item(&quot;COGS&quot;, {&quot;2022&quot;: 50.0})
&gt;&gt;&gt; node
&lt;FinancialStatementItemNode name='COGS'&gt;
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.NodeFactory.create_calculation_node"><code class="name flex">
<span>def <span class="ident">create_calculation_node</span></span>(<span>*,<br>name: str,<br>inputs: list[<a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>],<br>calculation_type: str,<br>formula_variable_names: list[str] | None = None,<br>**calculation_kwargs: Any) ‑> <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_calculation_node(
    *,
    name: str,
    inputs: list[Node],
    calculation_type: str,
    formula_variable_names: list[str] | None = None,
    **calculation_kwargs: Any,
) -&gt; Node:
    &#34;&#34;&#34;Create a generic calculation node using alias lookup.

    Args:
        name: The name of the calculation node.
        inputs: List of input Node instances.
        calculation_type: Alias for the calculation type (e.g., &#39;addition&#39;, &#39;formula&#39;).
        formula_variable_names: Optional list of variable names for formula calculations.
        **calculation_kwargs: Additional keyword arguments for calculation or node attributes.

    Returns:
        Node: An instance of CalculationNode with the specified calculation logic.

    Raises:
        ConfigurationError: If the calculation_type is unknown or inputs are invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_calculation_node
        &gt;&gt;&gt; # Assume n1, n2 are Node instances
        &gt;&gt;&gt; node = create_calculation_node(name=&#34;GrossProfit&#34;, inputs=[n1, n2], calculation_type=&#34;addition&#34;)
        &gt;&gt;&gt; node.name
        &#39;GrossProfit&#39;
    &#34;&#34;&#34;
    # Lazy import to avoid heavy dependency when this builder is unused
    calculation_node_cls = _import_calculation_node()

    # Validate inputs are Node instances
    for n in inputs:
        _ensure_node_instance(n)

    try:
        calc_cls = CalculationAliasRegistry.get(calculation_type)
    except KeyError as exc:
        raise ConfigurationError(
            f&#34;Unknown calculation_type alias &#39;{calculation_type}&#39;. Registered: {CalculationAliasRegistry.list()}&#34;
        ) from exc

    # Special case: formula calculation needs variable names - tack them on via
    # kwargs so constructor signature remains flexible.
    if formula_variable_names is not None:
        calculation_kwargs.setdefault(&#34;input_variable_names&#34;, formula_variable_names)

    # Split kwargs between calculation-init and node extra attributes
    node_extra_kwargs = {}
    for key in (&#34;metric_name&#34;, &#34;metric_description&#34;):
        if key in calculation_kwargs:
            node_extra_kwargs[key] = calculation_kwargs.pop(key)

    calculation_instance = calc_cls(**calculation_kwargs)

    return cast(
        &#34;Node&#34;,
        calculation_node_cls(name, inputs, calculation_instance, **node_extra_kwargs),
    )</code></pre>
</details>
<div class="desc"><p>Create a generic calculation node using alias lookup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the calculation node.</dd>
<dt><strong><code>inputs</code></strong></dt>
<dd>List of input Node instances.</dd>
<dt><strong><code>calculation_type</code></strong></dt>
<dd>Alias for the calculation type (e.g., 'addition', 'formula').</dd>
<dt><strong><code>formula_variable_names</code></strong></dt>
<dd>Optional list of variable names for formula calculations.</dd>
<dt><strong><code>**calculation_kwargs</code></strong></dt>
<dd>Additional keyword arguments for calculation or node attributes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>An instance of CalculationNode with the specified calculation logic.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.ConfigurationError" href="#fin_statement_model.core.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If the calculation_type is unknown or inputs are invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_calculation_node
&gt;&gt;&gt; # Assume n1, n2 are Node instances
&gt;&gt;&gt; node = create_calculation_node(name=&quot;GrossProfit&quot;, inputs=[n1, n2], calculation_type=&quot;addition&quot;)
&gt;&gt;&gt; node.name
'GrossProfit'
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.NodeFactory.create_financial_statement_item"><code class="name flex">
<span>def <span class="ident">create_financial_statement_item</span></span>(<span>name: str, values: dict[str, float]) ‑> <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_financial_statement_item(name: str, values: dict[str, float]) -&gt; Node:
    &#34;&#34;&#34;Instantiate a FinancialStatementItemNode via the registry.

    Args:
        name: The name of the financial statement item (e.g., &#39;Revenue&#39;).
        values: A dictionary mapping period strings to float values.

    Returns:
        Node: An instance of FinancialStatementItemNode.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_financial_statement_item
        &gt;&gt;&gt; node = create_financial_statement_item(&#34;Revenue&#34;, {&#34;2022&#34;: 100.0})
        &gt;&gt;&gt; node.name
        &#39;Revenue&#39;
    &#34;&#34;&#34;
    try:
        node_cls = NodeTypeRegistry.get(&#34;financial_statement_item&#34;)
    except KeyError:
        # Fallback to direct import if not registered yet (pre-decorator phase)
        from fin_statement_model.core.nodes.item_node import (
            FinancialStatementItemNode,
        )  # pylint: disable=import-outside-toplevel

        node_cls = FinancialStatementItemNode

    return cast(&#34;Node&#34;, node_cls(name, values))</code></pre>
</details>
<div class="desc"><p>Instantiate a FinancialStatementItemNode via the registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the financial statement item (e.g., 'Revenue').</dd>
<dt><strong><code>values</code></strong></dt>
<dd>A dictionary mapping period strings to float values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>An instance of FinancialStatementItemNode.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_financial_statement_item
&gt;&gt;&gt; node = create_financial_statement_item(&quot;Revenue&quot;, {&quot;2022&quot;: 100.0})
&gt;&gt;&gt; node.name
'Revenue'
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.NodeFactory.create_forecast_node"><code class="name flex">
<span>def <span class="ident">create_forecast_node</span></span>(<span>*,<br>forecast_type: str | None = None,<br>input_node: <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a> | None = None,<br>base_period: str | None = None,<br>forecast_periods: list[str] | None = None,<br>growth_params: Any = None,<br>name: str | None = None,<br>base_node: <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a> | None = None,<br>forecast_config: Any | None = None,<br>**_extra: Any) ‑> <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_forecast_node(
    *,
    forecast_type: str | None = None,
    input_node: Node | None = None,
    base_period: str | None = None,
    forecast_periods: list[str] | None = None,
    growth_params: Any = None,
    name: str | None = None,
    base_node: Node | None = None,
    forecast_config: Any | None = None,
    **_extra: Any,
) -&gt; Node:
    &#34;&#34;&#34;Instantiate a forecast node using forecast_type registry lookup.

    Args:
        forecast_type: The type of forecast node to create (e.g., &#39;simple&#39;, &#39;curve&#39;).
        input_node: The input Node to forecast (or use base_node for legacy).
        base_period: The base period string (e.g., &#39;2022&#39;).
        forecast_periods: List of periods to forecast.
        growth_params: Parameters for the forecast method.
        name: (Legacy) Name of the node (ignored).
        base_node: (Legacy) Alias for input_node.
        forecast_config: (Not supported yet).
        **_extra: Additional keyword arguments (ignored).

    Returns:
        Node: An instance of the appropriate ForecastNode subclass.

    Raises:
        ConfigurationError: If required parameters are missing or instantiation fails.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_forecast_node
        &gt;&gt;&gt; # Assume n1 is a Node instance
        &gt;&gt;&gt; node = create_forecast_node(
        ...     forecast_type=&#34;simple&#34;, input_node=n1, base_period=&#34;2022&#34;, forecast_periods=[&#34;2023&#34;, &#34;2024&#34;]
        ... )
        &gt;&gt;&gt; node.name
        n1.name  # Typically inherits from input_node
    &#34;&#34;&#34;
    # Map legacy parameters -------------------------------------------------
    if input_node is None and base_node is not None:
        input_node = base_node

    if name is not None:
        logger.debug(&#34;create_forecast_node: received legacy &#39;name&#39; parameter (ignored): %s&#34;, name)

    if forecast_config is not None:
        # TODO: parse ForecastConfig in a later iteration
        raise ConfigurationError(&#34;create_forecast_node currently does not support &#39;forecast_config&#39; parameter.&#34;)

    if forecast_type is None:
        raise ConfigurationError(&#34;&#39;forecast_type&#39; must be provided.&#34;)
    if input_node is None:
        raise ConfigurationError(&#34;&#39;input_node&#39; (or &#39;base_node&#39;) must be provided.&#34;)
    if base_period is None or forecast_periods is None:
        raise ConfigurationError(&#34;&#39;base_period&#39; and &#39;forecast_periods&#39; are required.&#34;)

    _ensure_node_instance(input_node)

    try:
        forecast_cls = ForecastTypeRegistry.get(forecast_type)
    except KeyError as exc:
        raise ConfigurationError(
            f&#34;Unknown forecast_type &#39;{forecast_type}&#39;. Registered: {ForecastTypeRegistry.list()}&#34;
        ) from exc

    # ---------------------------------------------------------------------
    # Dynamic constructor handling via reflection
    # ---------------------------------------------------------------------
    # We inspect the __init__ signature of the forecast class to determine
    # whether it expects a fourth positional/keyword parameter (commonly
    # `growth_params`). This avoids hard-coding special cases for each
    # forecast_type and automatically works for any new classes added later.

    try:
        sig = inspect.signature(forecast_cls.__init__)
        # Drop the implicit &#39;self&#39;
        ctor_params = [p for p in sig.parameters.values() if p.name != &#34;self&#34;]

        # Base signature is (input_node, base_period, forecast_periods)
        args: list[Any] = [input_node, base_period, forecast_periods]

        # If the constructor defines a 4th parameter OR has a parameter named
        # &#39;growth_params&#39;, we append growth_params as the 4th argument.
        needs_growth = False
        if len(ctor_params) &gt; PARAMS_GROWTH_THRESHOLD:
            needs_growth = True
        else:
            needs_growth = any(p.name == &#34;growth_params&#34; for p in ctor_params)

        if needs_growth:
            args.append(growth_params)

        return cast(&#34;Node&#34;, forecast_cls(*args))

    except TypeError as exc:
        # Provide helpful context with expected signature
        expected = [p.name for p in ctor_params]
        raise ConfigurationError(
            f&#34;Failed to instantiate forecast node for type &#39;{forecast_type}&#39;: {exc}\nConstructor parameters: {expected}&#34;
        ) from exc</code></pre>
</details>
<div class="desc"><p>Instantiate a forecast node using forecast_type registry lookup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forecast_type</code></strong></dt>
<dd>The type of forecast node to create (e.g., 'simple', 'curve').</dd>
<dt><strong><code>input_node</code></strong></dt>
<dd>The input Node to forecast (or use base_node for legacy).</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>The base period string (e.g., '2022').</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
<dt><strong><code>growth_params</code></strong></dt>
<dd>Parameters for the forecast method.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>(Legacy) Name of the node (ignored).</dd>
<dt><strong><code>base_node</code></strong></dt>
<dd>(Legacy) Alias for input_node.</dd>
<dt><strong><code>forecast_config</code></strong></dt>
<dd>(Not supported yet).</dd>
<dt><strong><code>**_extra</code></strong></dt>
<dd>Additional keyword arguments (ignored).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>An instance of the appropriate ForecastNode subclass.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.ConfigurationError" href="#fin_statement_model.core.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If required parameters are missing or instantiation fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.builders import create_forecast_node
&gt;&gt;&gt; # Assume n1 is a Node instance
&gt;&gt;&gt; node = create_forecast_node(
...     forecast_type=&quot;simple&quot;, input_node=n1, base_period=&quot;2022&quot;, forecast_periods=[&quot;2023&quot;, &quot;2024&quot;]
... )
&gt;&gt;&gt; node.name
n1.name  # Typically inherits from input_node
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.NodeFactory.create_from_dict"><code class="name flex">
<span>def <span class="ident">create_from_dict</span></span>(<span>data: dict[str, Any],<br>ctx: dict[str, <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>] | None = None,<br>*,<br>context: dict[str, <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_from_dict(
    data: dict[str, Any],
    ctx: dict[str, Node] | None = None,
    *,
    context: dict[str, Node] | None = None,
) -&gt; Node:
    &#34;&#34;&#34;Rebuild a Node from its serialised data.

    Args:
        data: Mapping produced by Node.to_dict().
        ctx: Existing nodes (name ➜ Node) used to resolve dependencies.
        context: Alternative keyword for backward-compatibility.

    Returns:
        Node: A live Node instance reconstructed from the dictionary.

    Raises:
        TypeError: If data is not a dict.
        ConfigurationError: If the payload is invalid or type look-up fails.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.node_factory.deserialisers import create_from_dict
        &gt;&gt;&gt; # Assume dct is a valid node dict and ctx is a context dict
        &gt;&gt;&gt; node = create_from_dict(dct, ctx)
        &gt;&gt;&gt; node.name
        dct[&#39;name&#39;]
    &#34;&#34;&#34;
    # Support alternative keyword ``context`` for backward-compat
    if ctx is None and context is not None:
        ctx = context
    if ctx is None:
        ctx = {}

    if not isinstance(data, dict):
        raise TypeError(&#34;create_from_dict: &#39;data&#39; must be a dict&#34;)

    node_type_key = data.get(&#34;type&#34;)
    if not node_type_key or not isinstance(node_type_key, str):
        raise ConfigurationError(&#34;Serialised node missing &#39;type&#39; field.&#34;)

    # Special dispatch for forecasts - their *sub*-type is stored separately
    if node_type_key == &#34;forecast&#34;:
        node_cls = _get_forecast_node_cls(data)
    else:
        try:
            node_cls = NodeTypeRegistry.get(node_type_key)
        except KeyError as exc:
            raise ConfigurationError(
                f&#34;Unknown node &#39;type&#39; &#39;{node_type_key}&#39;. Registered: {NodeTypeRegistry.list()}&#34;
            ) from exc

    # Use unified from_dict API
    if hasattr(node_cls, &#34;from_dict&#34;):
        logger.debug(&#34;Deserialising %s via from_dict&#34;, node_cls)
        return node_cls.from_dict(data, ctx)

    # If we get here the node class does not support deserialisation via factory
    raise ConfigurationError(f&#34;Node class {node_cls.__name__} does not expose from_dict method.&#34;)</code></pre>
</details>
<div class="desc"><p>Rebuild a Node from its serialised data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Mapping produced by Node.to_dict().</dd>
<dt><strong><code>ctx</code></strong></dt>
<dd>Existing nodes (name ➜ Node) used to resolve dependencies.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Alternative keyword for backward-compatibility.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>A live Node instance reconstructed from the dictionary.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If data is not a dict.</dd>
<dt><code><a title="fin_statement_model.core.ConfigurationError" href="#fin_statement_model.core.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If the payload is invalid or type look-up fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.node_factory.deserialisers import create_from_dict
&gt;&gt;&gt; # Assume dct is a valid node dict and ctx is a context dict
&gt;&gt;&gt; node = create_from_dict(dct, ctx)
&gt;&gt;&gt; node.name
dct['name']
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.PeriodError"><code class="flex name class">
<span>class <span class="ident">PeriodError</span></span>
<span>(</span><span>message: str,<br>period: str | None = None,<br>available_periods: list[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PeriodError(FinancialModelError):
    &#34;&#34;&#34;Error raised for invalid or missing periods.

    Covers issues like requesting data for a non-existent period or
    using invalid period formats.

    Examples:
        &gt;&gt;&gt; raise PeriodError(&#34;Invalid period format&#34;, period=&#34;2023Q5&#34;)
        &gt;&gt;&gt; raise PeriodError(&#34;Period not found&#34;, period=&#34;2024-01-01&#34;, available_periods=[&#34;2023-12-31&#34;])
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        period: str | None = None,
        available_periods: list[str] | None = None,
    ):
        &#34;&#34;&#34;Initialize the PeriodError.

        Args:
            message: The base error message.
            period: Optional specific period involved in the error.
            available_periods: Optional list of valid periods.
        &#34;&#34;&#34;
        self.period = period
        self.available_periods = available_periods or []

        if period and available_periods:
            full_message = f&#34;{message} for period &#39;{period}&#39;. Available periods: {&#39;, &#39;.join(available_periods)}&#34;
        elif period:
            full_message = f&#34;{message} for period &#39;{period}&#39;&#34;
        else:
            full_message = message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for invalid or missing periods.</p>
<p>Covers issues like requesting data for a non-existent period or
using invalid period formats.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise PeriodError(&quot;Invalid period format&quot;, period=&quot;2023Q5&quot;)
&gt;&gt;&gt; raise PeriodError(&quot;Period not found&quot;, period=&quot;2024-01-01&quot;, available_periods=[&quot;2023-12-31&quot;])
</code></pre>
<p>Initialize the PeriodError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Optional specific period involved in the error.</dd>
<dt><strong><code>available_periods</code></strong></dt>
<dd>Optional list of valid periods.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.StatementError"><code class="flex name class">
<span>class <span class="ident">StatementError</span></span>
<span>(</span><span>message: str, statement_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementError(FinancialModelError):
    &#34;&#34;&#34;Error raised for issues related to financial statements.

    Used for errors specific to the structure, definition, or
    processing of financial statements (e.g., Balance Sheet, P&amp;L).

    Examples:
        &gt;&gt;&gt; raise StatementError(&#34;Balance sheet does not balance&#34;, statement_id=&#34;BS_2023&#34;)
        &gt;&gt;&gt; raise StatementError(&#34;Required account missing from P&amp;L&#34;, statement_id=&#34;PnL_Q1&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str, statement_id: str | None = None):
        &#34;&#34;&#34;Initialize the StatementError.

        Args:
            message: The base error message.
            statement_id: Optional ID or name of the statement involved.
        &#34;&#34;&#34;
        self.statement_id = statement_id

        full_message = f&#34;{message} for statement &#39;{statement_id}&#39;&#34; if statement_id else message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for issues related to financial statements.</p>
<p>Used for errors specific to the structure, definition, or
processing of financial statements (e.g., Balance Sheet, P&amp;L).</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise StatementError(&quot;Balance sheet does not balance&quot;, statement_id=&quot;BS_2023&quot;)
&gt;&gt;&gt; raise StatementError(&quot;Required account missing from P&amp;L&quot;, statement_id=&quot;PnL_Q1&quot;)
</code></pre>
<p>Initialize the StatementError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>statement_id</code></strong></dt>
<dd>Optional ID or name of the statement involved.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.errors.StatementBuilderError" href="../statements/errors.html#fin_statement_model.statements.errors.StatementBuilderError">StatementBuilderError</a></li>
<li><a title="fin_statement_model.statements.errors.StatementValidationError" href="../statements/errors.html#fin_statement_model.statements.errors.StatementValidationError">StatementValidationError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.core.StrategyError"><code class="flex name class">
<span>class <span class="ident">StrategyError</span></span>
<span>(</span><span>message: str, strategy_type: str | None = None, node_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrategyError(FinancialModelError):
    &#34;&#34;&#34;Error raised for issues related to calculation strategies.

    Indicates a problem with the configuration or execution of a
    specific calculation strategy (e.g., Summation, GrowthRate).

    Examples:
        &gt;&gt;&gt; raise StrategyError(
        ...     &#34;Invalid parameter for GrowthRate strategy&#34;, strategy_type=&#34;GrowthRate&#34;, node_id=&#34;revenue_forecast&#34;
        ... )
        &gt;&gt;&gt; raise StrategyError(
        ...     &#34;Strategy not applicable to node type&#34;, strategy_type=&#34;Summation&#34;, node_id=&#34;text_description&#34;
        ... )
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        strategy_type: str | None = None,
        node_id: str | None = None,
    ):
        &#34;&#34;&#34;Initialize the StrategyError.

        Args:
            message: The base error message.
            strategy_type: Optional name or type of the strategy involved.
            node_id: Optional ID of the node using the strategy.
        &#34;&#34;&#34;
        self.strategy_type = strategy_type
        self.node_id = node_id

        context = []
        if strategy_type:
            context.append(f&#34;strategy type &#39;{strategy_type}&#39;&#34;)
        if node_id:
            context.append(f&#34;node &#39;{node_id}&#39;&#34;)

        full_message = f&#34;{message} for {&#39; in &#39;.join(context)}&#34; if context else message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for issues related to calculation strategies.</p>
<p>Indicates a problem with the configuration or execution of a
specific calculation strategy (e.g., Summation, GrowthRate).</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise StrategyError(
...     &quot;Invalid parameter for GrowthRate strategy&quot;, strategy_type=&quot;GrowthRate&quot;, node_id=&quot;revenue_forecast&quot;
... )
&gt;&gt;&gt; raise StrategyError(
...     &quot;Strategy not applicable to node type&quot;, strategy_type=&quot;Summation&quot;, node_id=&quot;text_description&quot;
... )
</code></pre>
<p>Initialize the StrategyError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>strategy_type</code></strong></dt>
<dd>Optional name or type of the strategy involved.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node using the strategy.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.core.SubtractionCalculation"><code class="flex name class">
<span>class <span class="ident">SubtractionCalculation</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubtractionCalculation(Calculation):
    &#34;&#34;&#34;Implements a subtraction calculation: first input minus the sum of the rest.

    This calculation takes the calculated value of the first node in the input list
    and subtracts the sum of the calculated values of all subsequent nodes for
    a specific period.
    &#34;&#34;&#34;

    def calculate(self, inputs: list[Node], period: str) -&gt; float:
        &#34;&#34;&#34;Calculates the difference: value of the first input minus the sum of others.

        Args:
            inputs: A list of Node objects. Must contain at least one node.
            period: The time period string (e.g., &#34;2024Q1&#34;) for the calculation.

        Returns:
            The result of the subtraction. If only one input node is provided,
            its value is returned.

        Raises:
            CalculationError: If the `inputs` list is empty.

        Examples:
            &gt;&gt;&gt; class MockNode:
            ...     def __init__(self, value):
            ...         self._value = value
            ...
            ...     def calculate(self, period):
            ...         return self._value
            &gt;&gt;&gt; strategy = SubtractionCalculation()
            &gt;&gt;&gt; nodes = [MockNode(100), MockNode(20), MockNode(30)]
            &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
            50.0
            &gt;&gt;&gt; nodes_single = [MockNode(100)]
            &gt;&gt;&gt; strategy.calculate(nodes_single, &#34;2023&#34;)
            100.0
        &#34;&#34;&#34;
        if not inputs:
            raise CalculationError(
                &#34;Subtraction calculation requires at least one input node&#34;,
                details={&#34;strategy&#34;: &#34;SubtractionCalculation&#34;},
            )

        logger.debug(&#34;Applying subtraction calculation for period %s&#34;, period)
        # Calculate values first to avoid multiple calls if nodes are complex
        values = [node.calculate(period) for node in inputs]
        return values[0] - sum(values[1:])

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Returns a description of the subtraction calculation.&#34;&#34;&#34;
        return &#34;Subtraction (first input minus sum of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Implements a subtraction calculation: first input minus the sum of the rest.</p>
<p>This calculation takes the calculated value of the first node in the input list
and subtracts the sum of the calculated values of all subsequent nodes for
a specific period.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.calculations.calculation.Calculation" href="calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.core.SubtractionCalculation.description"><code class="name">prop <span class="ident">description</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Returns a description of the subtraction calculation.&#34;&#34;&#34;
    return &#34;Subtraction (first input minus sum of subsequent inputs)&#34;</code></pre>
</details>
<div class="desc"><p>Returns a description of the subtraction calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.SubtractionCalculation.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, inputs: list[Node], period: str) -&gt; float:
    &#34;&#34;&#34;Calculates the difference: value of the first input minus the sum of others.

    Args:
        inputs: A list of Node objects. Must contain at least one node.
        period: The time period string (e.g., &#34;2024Q1&#34;) for the calculation.

    Returns:
        The result of the subtraction. If only one input node is provided,
        its value is returned.

    Raises:
        CalculationError: If the `inputs` list is empty.

    Examples:
        &gt;&gt;&gt; class MockNode:
        ...     def __init__(self, value):
        ...         self._value = value
        ...
        ...     def calculate(self, period):
        ...         return self._value
        &gt;&gt;&gt; strategy = SubtractionCalculation()
        &gt;&gt;&gt; nodes = [MockNode(100), MockNode(20), MockNode(30)]
        &gt;&gt;&gt; strategy.calculate(nodes, &#34;2023&#34;)
        50.0
        &gt;&gt;&gt; nodes_single = [MockNode(100)]
        &gt;&gt;&gt; strategy.calculate(nodes_single, &#34;2023&#34;)
        100.0
    &#34;&#34;&#34;
    if not inputs:
        raise CalculationError(
            &#34;Subtraction calculation requires at least one input node&#34;,
            details={&#34;strategy&#34;: &#34;SubtractionCalculation&#34;},
        )

    logger.debug(&#34;Applying subtraction calculation for period %s&#34;, period)
    # Calculate values first to avoid multiple calls if nodes are complex
    values = [node.calculate(period) for node in inputs]
    return values[0] - sum(values[1:])</code></pre>
</details>
<div class="desc"><p>Calculates the difference: value of the first input minus the sum of others.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>A list of Node objects. Must contain at least one node.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The time period string (e.g., "2024Q1") for the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result of the subtraction. If only one input node is provided,
its value is returned.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>If the <code>inputs</code> list is empty.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MockNode:
...     def __init__(self, value):
...         self._value = value
...
...     def calculate(self, period):
...         return self._value
&gt;&gt;&gt; strategy = SubtractionCalculation()
&gt;&gt;&gt; nodes = [MockNode(100), MockNode(20), MockNode(30)]
&gt;&gt;&gt; strategy.calculate(nodes, &quot;2023&quot;)
50.0
&gt;&gt;&gt; nodes_single = [MockNode(100)]
&gt;&gt;&gt; strategy.calculate(nodes_single, &quot;2023&quot;)
100.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.TransformationError"><code class="flex name class">
<span>class <span class="ident">TransformationError</span></span>
<span>(</span><span>message: str,<br>transformer_type: str | None = None,<br>parameters: dict[str, typing.Any] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformationError(FinancialModelError):
    &#34;&#34;&#34;Error raised during data transformation.

    Occurs during preprocessing steps when a specific transformation
    (e.g., normalization, scaling) fails.

    Examples:
        &gt;&gt;&gt; raise TransformationError(&#34;Log transform requires positive values&#34;, transformer_type=&#34;LogTransformer&#34;)
        &gt;&gt;&gt; raise TransformationError(
        ...     &#34;Incompatible data type for scaling&#34;,
        ...     transformer_type=&#34;MinMaxScaler&#34;,
        ...     parameters={&#34;feature_range&#34;: (0, 1)},
        ... )
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        transformer_type: str | None = None,
        parameters: dict[str, Any] | None = None,
    ):
        &#34;&#34;&#34;Initialize the TransformationError.

        Args:
            message: The base error message.
            transformer_type: Optional name or type of the transformer involved.
            parameters: Optional dictionary of parameters used by the transformer.
        &#34;&#34;&#34;
        self.transformer_type = transformer_type
        self.parameters = parameters or {}

        if transformer_type:
            full_message = f&#34;{message} in transformer &#39;{transformer_type}&#39;&#34;
            if parameters:
                params_str = &#34;, &#34;.join(f&#34;{k}={v}&#34; for k, v in parameters.items())
                full_message = f&#34;{full_message} with parameters: {params_str}&#34;
        else:
            full_message = message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised during data transformation.</p>
<p>Occurs during preprocessing steps when a specific transformation
(e.g., normalization, scaling) fails.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise TransformationError(&quot;Log transform requires positive values&quot;, transformer_type=&quot;LogTransformer&quot;)
&gt;&gt;&gt; raise TransformationError(
...     &quot;Incompatible data type for scaling&quot;,
...     transformer_type=&quot;MinMaxScaler&quot;,
...     parameters={&quot;feature_range&quot;: (0, 1)},
... )
</code></pre>
<p>Initialize the TransformationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>transformer_type</code></strong></dt>
<dd>Optional name or type of the transformer involved.</dd>
<dt><strong><code>parameters</code></strong></dt>
<dd>Optional dictionary of parameters used by the transformer.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.preprocessing.errors.NormalizationError" href="../preprocessing/errors.html#fin_statement_model.preprocessing.errors.NormalizationError">NormalizationError</a></li>
<li><a title="fin_statement_model.preprocessing.errors.PeriodConversionError" href="../preprocessing/errors.html#fin_statement_model.preprocessing.errors.PeriodConversionError">PeriodConversionError</a></li>
<li><a title="fin_statement_model.preprocessing.errors.TimeSeriesError" href="../preprocessing/errors.html#fin_statement_model.preprocessing.errors.TimeSeriesError">TimeSeriesError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.core.TwoPeriodAverageNode"><code class="flex name class">
<span>class <span class="ident">TwoPeriodAverageNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>period1: str,<br>period2: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;two_period_average&#34;)
class TwoPeriodAverageNode(Node):
    &#34;&#34;&#34;Compute the average of an input node&#39;s values over two periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; TwoPeriodAverageNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        input_node (Node): Node supplying values.
        period1 (str): Identifier for the first period.
        period2 (str): Identifier for the second period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, TwoPeriodAverageNode
        &gt;&gt;&gt; data = {&#34;Jan&#34;: 10.0, &#34;Feb&#34;: 11.0}
        &gt;&gt;&gt; price = FinancialStatementItemNode(&#34;price&#34;, data)
        &gt;&gt;&gt; avg = TwoPeriodAverageNode(&#34;avg_price&#34;, input_node=price, period1=&#34;Jan&#34;, period2=&#34;Feb&#34;)
        &gt;&gt;&gt; d = avg.to_dict()
        &gt;&gt;&gt; avg2 = TwoPeriodAverageNode.from_dict(d, {&#34;price&#34;: price})
        &gt;&gt;&gt; avg2.calculate()
        10.5
    &#34;&#34;&#34;

    def __init__(self, name: str, input_node: Node, period1: str, period2: str):
        &#34;&#34;&#34;Create a TwoPeriodAverageNode.

        Args:
            name (str): Unique identifier for the node.
            input_node (Node): Node supplying values.
            period1 (str): Identifier for the first period.
            period2 (str): Identifier for the second period.

        Raises:
            TypeError: If `input_node` is not a Node or periods are not strings.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(f&#34;TwoPeriodAverageNode input_node must be a Node instance, got {type(input_node).__name__}&#34;)
        if not isinstance(period1, str) or not isinstance(period2, str):
            raise TypeError(&#34;TwoPeriodAverageNode period1 and period2 must be strings.&#34;)

        self.input_node = input_node
        self.period1 = period1
        self.period2 = period2

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the average value for the two configured periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: (value1 + value2) / 2, or NaN if either value is non-numeric.

        Raises:
            CalculationError: On errors retrieving input node values.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        try:
            val1 = self.input_node.calculate(self.period1)
            val2 = self.input_node.calculate(self.period2)

            # Ensure values are numeric and finite
            if not isinstance(val1, int | float) or not math.isfinite(val1):
                logger.warning(
                    &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.period1,
                    val1,
                )
                return float(&#34;nan&#34;)
            if not isinstance(val2, int | float) or not math.isfinite(val2):
                logger.warning(
                    &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.period2,
                    val2,
                )
                return float(&#34;nan&#34;)

            # Calculate the average
            return (float(val1) + float(val2)) / 2.0

        except Exception as e:
            # Wrap potential errors during input node calculation
            raise CalculationError(
                message=f&#34;Failed to calculate two-period average for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=f&#34;{self.period1}_and_{self.period2}&#34;,  # Indicate context
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;period1&#34;: self.period1,
                    &#34;period2&#34;: self.period2,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this average node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation with type, name, and periods.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;two_period_average&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;period1&#34;: self.period1,
            &#34;period2&#34;: self.period2,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;TwoPeriodAverageNode&#34;:
        &#34;&#34;&#34;Recreate a TwoPeriodAverageNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            TwoPeriodAverageNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;two_period_average&#34;:
            raise ValueError(f&#34;Invalid type for TwoPeriodAverageNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in TwoPeriodAverageNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in TwoPeriodAverageNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize TwoPeriodAverageNode&#34;)
        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        period1 = data.get(&#34;period1&#34;)
        period2 = data.get(&#34;period2&#34;)

        if not period1:
            raise ValueError(&#34;Missing &#39;period1&#39; field in TwoPeriodAverageNode data&#34;)
        if not period2:
            raise ValueError(&#34;Missing &#39;period2&#39; field in TwoPeriodAverageNode data&#34;)

        return cls(
            name=name,
            input_node=input_node,
            period1=period1,
            period2=period2,
        )</code></pre>
</details>
<div class="desc"><p>Compute the average of an input node's values over two periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; TwoPeriodAverageNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>period1</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the first period.</dd>
<dt><strong><code>period2</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the second period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, TwoPeriodAverageNode
&gt;&gt;&gt; data = {&quot;Jan&quot;: 10.0, &quot;Feb&quot;: 11.0}
&gt;&gt;&gt; price = FinancialStatementItemNode(&quot;price&quot;, data)
&gt;&gt;&gt; avg = TwoPeriodAverageNode(&quot;avg_price&quot;, input_node=price, period1=&quot;Jan&quot;, period2=&quot;Feb&quot;)
&gt;&gt;&gt; d = avg.to_dict()
&gt;&gt;&gt; avg2 = TwoPeriodAverageNode.from_dict(d, {&quot;price&quot;: price})
&gt;&gt;&gt; avg2.calculate()
10.5
</code></pre>
<p>Create a TwoPeriodAverageNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>period1</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the first period.</dd>
<dt><strong><code>period2</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the second period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or periods are not strings.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.TwoPeriodAverageNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode" href="nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a TwoPeriodAverageNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.TwoPeriodAverageNode" href="#fin_statement_model.core.TwoPeriodAverageNode">TwoPeriodAverageNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.TwoPeriodAverageNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the average value for the two configured periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: (value1 + value2) / 2, or NaN if either value is non-numeric.

    Raises:
        CalculationError: On errors retrieving input node values.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    try:
        val1 = self.input_node.calculate(self.period1)
        val2 = self.input_node.calculate(self.period2)

        # Ensure values are numeric and finite
        if not isinstance(val1, int | float) or not math.isfinite(val1):
            logger.warning(
                &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.period1,
                val1,
            )
            return float(&#34;nan&#34;)
        if not isinstance(val2, int | float) or not math.isfinite(val2):
            logger.warning(
                &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.period2,
                val2,
            )
            return float(&#34;nan&#34;)

        # Calculate the average
        return (float(val1) + float(val2)) / 2.0

    except Exception as e:
        # Wrap potential errors during input node calculation
        raise CalculationError(
            message=f&#34;Failed to calculate two-period average for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=f&#34;{self.period1}_and_{self.period2}&#34;,  # Indicate context
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;period1&#34;: self.period1,
                &#34;period2&#34;: self.period2,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the average value for the two configured periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>(value1 + value2) / 2, or NaN if either value is non-numeric.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>On errors retrieving input node values.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.TwoPeriodAverageNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this average node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this average node depends on.</p></div>
</dd>
<dt id="fin_statement_model.core.TwoPeriodAverageNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation with type, name, and periods.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;two_period_average&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;period1&#34;: self.period1,
        &#34;period2&#34;: self.period2,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation with type, name, and periods.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.YoYGrowthNode"><code class="flex name class">
<span>class <span class="ident">YoYGrowthNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>prior_period: str,<br>current_period: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;yoy_growth&#34;)
class YoYGrowthNode(Node):
    &#34;&#34;&#34;Compute year-over-year percentage growth.

    Compare values of an input node for two periods and compute
    (current_value - prior_value) / prior_value.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        input_node (Node): Node providing source values.
        prior_period (str): Identifier for the earlier period.
        current_period (str): Identifier for the later period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 100.0, &#34;2023&#34;: 120.0}
        &gt;&gt;&gt; base = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; yoy = YoYGrowthNode(&#34;rev_yoy&#34;, input_node=base, prior_period=&#34;2022&#34;, current_period=&#34;2023&#34;)
        &gt;&gt;&gt; d = yoy.to_dict()
        &gt;&gt;&gt; yoy2 = YoYGrowthNode.from_dict(d, {&#34;revenue&#34;: base})
        &gt;&gt;&gt; round(yoy2.calculate(), 2)
        0.2
    &#34;&#34;&#34;

    def __init__(self, name: str, input_node: Node, prior_period: str, current_period: str):
        &#34;&#34;&#34;Create a YoYGrowthNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values for comparison.
            prior_period (str): Identifier for the earlier period.
            current_period (str): Identifier for the later period.

        Raises:
            TypeError: If `input_node` is not a Node or periods are not strings.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;YoYGrowthNode input_node must be a Node instance.&#34;)
        if not isinstance(prior_period, str) or not isinstance(current_period, str):
            raise TypeError(&#34;YoYGrowthNode prior_period and current_period must be strings.&#34;)

        self.input_node = input_node
        self.prior_period = prior_period
        self.current_period = current_period

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the YoY growth rate.

        Ignore the `period` parameter; use configured periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: (current - prior) / prior, or NaN if prior is zero or non-finite.

        Raises:
            CalculationError: On errors retrieving or validating input values.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        try:
            prior_value = self.input_node.calculate(self.prior_period)
            current_value = self.input_node.calculate(self.current_period)

            # Validate input types
            if not isinstance(prior_value, int | float):
                raise TypeError(f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;)
            if not isinstance(current_value, int | float):
                raise TypeError(f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;)

            # Handle division by zero or non-finite prior value
            if prior_value == 0 or not math.isfinite(prior_value):
                logger.warning(
                    &#34;YoYGrowthNode &#39;%s&#39;: Prior period &#39;%s&#39; value is zero or non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.prior_period,
                    prior_value,
                )
                return float(&#34;nan&#34;)

            # Calculate growth
            growth = (float(current_value) - float(prior_value)) / float(prior_value)
        except Exception as e:
            # Wrap any exception during calculation
            raise CalculationError(
                message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;prior_period&#34;: self.prior_period,
                    &#34;current_period&#34;: self.current_period,
                    &#34;original_error&#34;: str(e),
                },
            ) from e
        else:
            return growth

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation with type, name, and periods.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;yoy_growth&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;prior_period&#34;: self.prior_period,
            &#34;current_period&#34;: self.current_period,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;YoYGrowthNode&#34;:
        &#34;&#34;&#34;Recreate a YoYGrowthNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            YoYGrowthNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;yoy_growth&#34;:
            raise ValueError(f&#34;Invalid type for YoYGrowthNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in YoYGrowthNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in YoYGrowthNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize YoYGrowthNode&#34;)
        input_node = context[input_node_name]

        prior_period = data.get(&#34;prior_period&#34;)
        current_period = data.get(&#34;current_period&#34;)

        if not prior_period:
            raise ValueError(&#34;Missing &#39;prior_period&#39; field in YoYGrowthNode data&#34;)
        if not current_period:
            raise ValueError(&#34;Missing &#39;current_period&#39; field in YoYGrowthNode data&#34;)

        return cls(
            name=name,
            input_node=input_node,
            prior_period=prior_period,
            current_period=current_period,
        )</code></pre>
</details>
<div class="desc"><p>Compute year-over-year percentage growth.</p>
<p>Compare values of an input node for two periods and compute
(current_value - prior_value) / prior_value.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 100.0, &quot;2023&quot;: 120.0}
&gt;&gt;&gt; base = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; yoy = YoYGrowthNode(&quot;rev_yoy&quot;, input_node=base, prior_period=&quot;2022&quot;, current_period=&quot;2023&quot;)
&gt;&gt;&gt; d = yoy.to_dict()
&gt;&gt;&gt; yoy2 = YoYGrowthNode.from_dict(d, {&quot;revenue&quot;: base})
&gt;&gt;&gt; round(yoy2.calculate(), 2)
0.2
</code></pre>
<p>Create a YoYGrowthNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></dt>
<dd>Node supplying values for comparison.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or periods are not strings.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.YoYGrowthNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="nodes/stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a YoYGrowthNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.YoYGrowthNode" href="#fin_statement_model.core.YoYGrowthNode">YoYGrowthNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.YoYGrowthNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the YoY growth rate.

    Ignore the `period` parameter; use configured periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: (current - prior) / prior, or NaN if prior is zero or non-finite.

    Raises:
        CalculationError: On errors retrieving or validating input values.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    try:
        prior_value = self.input_node.calculate(self.prior_period)
        current_value = self.input_node.calculate(self.current_period)

        # Validate input types
        if not isinstance(prior_value, int | float):
            raise TypeError(f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;)
        if not isinstance(current_value, int | float):
            raise TypeError(f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;)

        # Handle division by zero or non-finite prior value
        if prior_value == 0 or not math.isfinite(prior_value):
            logger.warning(
                &#34;YoYGrowthNode &#39;%s&#39;: Prior period &#39;%s&#39; value is zero or non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.prior_period,
                prior_value,
            )
            return float(&#34;nan&#34;)

        # Calculate growth
        growth = (float(current_value) - float(prior_value)) / float(prior_value)
    except Exception as e:
        # Wrap any exception during calculation
        raise CalculationError(
            message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;prior_period&#34;: self.prior_period,
                &#34;current_period&#34;: self.current_period,
                &#34;original_error&#34;: str(e),
            },
        ) from e
    else:
        return growth</code></pre>
</details>
<div class="desc"><p>Compute the YoY growth rate.</p>
<p>Ignore the <code>period</code> parameter; use configured periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>(current - prior) / prior, or NaN if prior is zero or non-finite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></dt>
<dd>On errors retrieving or validating input values.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.YoYGrowthNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this node depends on.</p></div>
</dd>
<dt id="fin_statement_model.core.YoYGrowthNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation with type, name, and periods.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;yoy_growth&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;prior_period&#34;: self.prior_period,
        &#34;current_period&#34;: self.current_period,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation with type, name, and periods.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="nodes/base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model" href="../index.html">fin_statement_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.core.adjustments" href="adjustments/index.html">fin_statement_model.core.adjustments</a></code></li>
<li><code><a title="fin_statement_model.core.calculations" href="calculations/index.html">fin_statement_model.core.calculations</a></code></li>
<li><code><a title="fin_statement_model.core.errors" href="errors.html">fin_statement_model.core.errors</a></code></li>
<li><code><a title="fin_statement_model.core.graph" href="graph/index.html">fin_statement_model.core.graph</a></code></li>
<li><code><a title="fin_statement_model.core.metrics" href="metrics/index.html">fin_statement_model.core.metrics</a></code></li>
<li><code><a title="fin_statement_model.core.node_factory" href="node_factory/index.html">fin_statement_model.core.node_factory</a></code></li>
<li><code><a title="fin_statement_model.core.nodes" href="nodes/index.html">fin_statement_model.core.nodes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.core.AdditionCalculation" href="#fin_statement_model.core.AdditionCalculation">AdditionCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.AdditionCalculation.calculate" href="#fin_statement_model.core.AdditionCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.AdditionCalculation.description" href="#fin_statement_model.core.AdditionCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.CalculationError" href="#fin_statement_model.core.CalculationError">CalculationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.CalculationNode" href="#fin_statement_model.core.CalculationNode">CalculationNode</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.core.CalculationNode.calculate" href="#fin_statement_model.core.CalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.CalculationNode.clear_cache" href="#fin_statement_model.core.CalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.CalculationNode.from_dict" href="#fin_statement_model.core.CalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.CalculationNode.get_dependencies" href="#fin_statement_model.core.CalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.CalculationNode.set_calculation" href="#fin_statement_model.core.CalculationNode.set_calculation">set_calculation</a></code></li>
<li><code><a title="fin_statement_model.core.CalculationNode.to_dict" href="#fin_statement_model.core.CalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.CircularDependencyError" href="#fin_statement_model.core.CircularDependencyError">CircularDependencyError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.ConfigurationError" href="#fin_statement_model.core.ConfigurationError">ConfigurationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.CustomCalculationNode" href="#fin_statement_model.core.CustomCalculationNode">CustomCalculationNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.CustomCalculationNode.calculate" href="#fin_statement_model.core.CustomCalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.CustomCalculationNode.clear_cache" href="#fin_statement_model.core.CustomCalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.CustomCalculationNode.from_dict" href="#fin_statement_model.core.CustomCalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.CustomCalculationNode.get_dependencies" href="#fin_statement_model.core.CustomCalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.CustomCalculationNode.to_dict" href="#fin_statement_model.core.CustomCalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.DataValidationError" href="#fin_statement_model.core.DataValidationError">DataValidationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.DivisionCalculation" href="#fin_statement_model.core.DivisionCalculation">DivisionCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.DivisionCalculation.calculate" href="#fin_statement_model.core.DivisionCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.DivisionCalculation.description" href="#fin_statement_model.core.DivisionCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.FinancialModelError" href="#fin_statement_model.core.FinancialModelError">FinancialModelError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.FinancialStatementItemNode" href="#fin_statement_model.core.FinancialStatementItemNode">FinancialStatementItemNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.FinancialStatementItemNode.calculate" href="#fin_statement_model.core.FinancialStatementItemNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.FinancialStatementItemNode.from_dict" href="#fin_statement_model.core.FinancialStatementItemNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.FinancialStatementItemNode.set_value" href="#fin_statement_model.core.FinancialStatementItemNode.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.core.FinancialStatementItemNode.to_dict" href="#fin_statement_model.core.FinancialStatementItemNode.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.core.FinancialStatementItemNode.values" href="#fin_statement_model.core.FinancialStatementItemNode.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.FormulaCalculationNode" href="#fin_statement_model.core.FormulaCalculationNode">FormulaCalculationNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.FormulaCalculationNode.from_dict" href="#fin_statement_model.core.FormulaCalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.FormulaCalculationNode.get_dependencies" href="#fin_statement_model.core.FormulaCalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.FormulaCalculationNode.to_dict" href="#fin_statement_model.core.FormulaCalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.Graph" href="#fin_statement_model.core.Graph">Graph</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.GraphError" href="#fin_statement_model.core.GraphError">GraphError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.MultiPeriodStatNode" href="#fin_statement_model.core.MultiPeriodStatNode">MultiPeriodStatNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.MultiPeriodStatNode.calculate" href="#fin_statement_model.core.MultiPeriodStatNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.MultiPeriodStatNode.from_dict" href="#fin_statement_model.core.MultiPeriodStatNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.MultiPeriodStatNode.get_dependencies" href="#fin_statement_model.core.MultiPeriodStatNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.MultiPeriodStatNode.to_dict" href="#fin_statement_model.core.MultiPeriodStatNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.MultiplicationCalculation" href="#fin_statement_model.core.MultiplicationCalculation">MultiplicationCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.MultiplicationCalculation.calculate" href="#fin_statement_model.core.MultiplicationCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.MultiplicationCalculation.description" href="#fin_statement_model.core.MultiplicationCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.Node" href="#fin_statement_model.core.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.core.Node.calculate" href="#fin_statement_model.core.Node.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.Node.clear_cache" href="#fin_statement_model.core.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.Node.from_dict" href="#fin_statement_model.core.Node.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.Node.get_attribute" href="#fin_statement_model.core.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.Node.get_dependencies" href="#fin_statement_model.core.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.Node.has_attribute" href="#fin_statement_model.core.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.Node.name" href="#fin_statement_model.core.Node.name">name</a></code></li>
<li><code><a title="fin_statement_model.core.Node.set_value" href="#fin_statement_model.core.Node.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.core.Node.to_dict" href="#fin_statement_model.core.Node.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.core.Node.values" href="#fin_statement_model.core.Node.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.NodeError" href="#fin_statement_model.core.NodeError">NodeError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.NodeFactory" href="#fin_statement_model.core.NodeFactory">NodeFactory</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.NodeFactory.create_calculation_node" href="#fin_statement_model.core.NodeFactory.create_calculation_node">create_calculation_node</a></code></li>
<li><code><a title="fin_statement_model.core.NodeFactory.create_financial_statement_item" href="#fin_statement_model.core.NodeFactory.create_financial_statement_item">create_financial_statement_item</a></code></li>
<li><code><a title="fin_statement_model.core.NodeFactory.create_forecast_node" href="#fin_statement_model.core.NodeFactory.create_forecast_node">create_forecast_node</a></code></li>
<li><code><a title="fin_statement_model.core.NodeFactory.create_from_dict" href="#fin_statement_model.core.NodeFactory.create_from_dict">create_from_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.PeriodError" href="#fin_statement_model.core.PeriodError">PeriodError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.StatementError" href="#fin_statement_model.core.StatementError">StatementError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.StrategyError" href="#fin_statement_model.core.StrategyError">StrategyError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.SubtractionCalculation" href="#fin_statement_model.core.SubtractionCalculation">SubtractionCalculation</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.SubtractionCalculation.calculate" href="#fin_statement_model.core.SubtractionCalculation.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.SubtractionCalculation.description" href="#fin_statement_model.core.SubtractionCalculation.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.TransformationError" href="#fin_statement_model.core.TransformationError">TransformationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.core.TwoPeriodAverageNode" href="#fin_statement_model.core.TwoPeriodAverageNode">TwoPeriodAverageNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.TwoPeriodAverageNode.calculate" href="#fin_statement_model.core.TwoPeriodAverageNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.TwoPeriodAverageNode.from_dict" href="#fin_statement_model.core.TwoPeriodAverageNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.TwoPeriodAverageNode.get_dependencies" href="#fin_statement_model.core.TwoPeriodAverageNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.TwoPeriodAverageNode.to_dict" href="#fin_statement_model.core.TwoPeriodAverageNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.YoYGrowthNode" href="#fin_statement_model.core.YoYGrowthNode">YoYGrowthNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.YoYGrowthNode.calculate" href="#fin_statement_model.core.YoYGrowthNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.YoYGrowthNode.from_dict" href="#fin_statement_model.core.YoYGrowthNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.YoYGrowthNode.get_dependencies" href="#fin_statement_model.core.YoYGrowthNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.YoYGrowthNode.to_dict" href="#fin_statement_model.core.YoYGrowthNode.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
