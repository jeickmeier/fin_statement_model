<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.forecasting API documentation</title>
<meta name="description" content="Provide forecasting capabilities for financial statement graphs …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.forecasting</code></h1>
</header>
<section id="section-intro">
<p>Provide forecasting capabilities for financial statement graphs.</p>
<p>This sub-module offers:
- Multiple forecast methods (simple, curve, statistical, average, historical_growth)
- Mutating and non-mutating forecast operations on graphs
- Extensible registry for custom forecast methods
- Utilities for period management and validation</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
&gt;&gt;&gt; forecaster = StatementForecaster(graph)
&gt;&gt;&gt;
&gt;&gt;&gt; # Mutating forecast - modifies the graph
&gt;&gt;&gt; forecaster.create_forecast(
...     forecast_periods=[&quot;2024&quot;, &quot;2025&quot;],
...     node_configs={
...         &quot;revenue&quot;: {&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05},
...         &quot;costs&quot;: {&quot;method&quot;: &quot;curve&quot;, &quot;config&quot;: [0.03, 0.04]},
...     },
... )
&gt;&gt;&gt;
&gt;&gt;&gt; # Non-mutating forecast - returns values without modifying graph
&gt;&gt;&gt; values = forecaster.forecast_value(
...     &quot;revenue&quot;, forecast_periods=[&quot;2024&quot;, &quot;2025&quot;], forecast_config={&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05}
... )
</code></pre>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.forecasting.errors" href="errors.html">fin_statement_model.forecasting.errors</a></code></dt>
<dd>
<div class="desc"><p>Custom exceptions for forecasting operations …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.forecaster" href="forecaster/index.html">fin_statement_model.forecasting.forecaster</a></code></dt>
<dd>
<div class="desc"><p>Forecaster sub-package entry-point …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.methods" href="methods/index.html">fin_statement_model.forecasting.methods</a></code></dt>
<dd>
<div class="desc"><p>Built-in forecast method implementations for financial statement modeling …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.period_manager" href="period_manager.html">fin_statement_model.forecasting.period_manager</a></code></dt>
<dd>
<div class="desc"><p>Period inference and management utilities for forecasting …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.strategies" href="strategies.html">fin_statement_model.forecasting.strategies</a></code></dt>
<dd>
<div class="desc"><p>Forecast method registry and selection strategies …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.types" href="types.html">fin_statement_model.forecasting.types</a></code></dt>
<dd>
<div class="desc"><p>Types and data structures for the forecasting module …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.forecasting.validators" href="validators.html">fin_statement_model.forecasting.validators</a></code></dt>
<dd>
<div class="desc"><p>Validation utilities for the forecasting module …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.forecasting.get_forecast_method"><code class="name flex">
<span>def <span class="ident">get_forecast_method</span></span>(<span>name: str) ‑> <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forecast_method(name: str) -&gt; ForecastMethod:
    &#34;&#34;&#34;Retrieve a forecast method from the global registry.

    Args:
        name: The name of the method to retrieve.

    Returns:
        The requested forecast method.

    Raises:
        ValueError: If the method is not registered.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.strategies import get_forecast_method
        &gt;&gt;&gt; method = get_forecast_method(&#34;simple&#34;)
        &gt;&gt;&gt; method.name
        &#39;simple&#39;
    &#34;&#34;&#34;
    return forecast_registry.get_method(name)</code></pre>
</details>
<div class="desc"><p>Retrieve a forecast method from the global registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested forecast method.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the method is not registered.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.strategies import get_forecast_method
&gt;&gt;&gt; method = get_forecast_method(&quot;simple&quot;)
&gt;&gt;&gt; method.name
'simple'
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.register_forecast_method"><code class="name flex">
<span>def <span class="ident">register_forecast_method</span></span>(<span>method: <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_forecast_method(method: ForecastMethod) -&gt; None:
    &#34;&#34;&#34;Register a custom forecast method in the global registry.

    Args:
        method: The forecast method to register.

    Raises:
        ValueError: If a method with the same name is already registered.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
        &gt;&gt;&gt; from fin_statement_model.forecasting.strategies import register_forecast_method
        &gt;&gt;&gt; register_forecast_method(SimpleForecastMethod())
    &#34;&#34;&#34;
    forecast_registry.register(method)</code></pre>
</details>
<div class="desc"><p>Register a custom forecast method in the global registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The forecast method to register.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a method with the same name is already registered.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
&gt;&gt;&gt; from fin_statement_model.forecasting.strategies import register_forecast_method
&gt;&gt;&gt; register_forecast_method(SimpleForecastMethod())
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.forecasting.AverageForecastMethod"><code class="flex name class">
<span>class <span class="ident">AverageForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AverageForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values as the historical average of available data.

    This method calculates forecast values as the historical average of available
    data points. Useful for stable metrics or when expecting mean reversion.

    Configuration:
        - Not required (pass None or 0)

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.average import AverageForecastMethod
        &gt;&gt;&gt; method = AverageForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; params[&#34;forecast_type&#34;]
        &#39;average&#39;
        &gt;&gt;&gt; params[&#34;growth_params&#34;] is None
        True
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (&#39;average&#39;).
        &#34;&#34;&#34;
        return &#34;average&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

        Returns:
            The internal type string used by the node factory (&#39;average&#39;).
        &#34;&#34;&#34;
        return &#34;average&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for average method.

        Args:
            config: Not used for average method, can be None or 0.

        Note:
            Average method doesn&#39;t require configuration as it uses
            historical data automatically.
        &#34;&#34;&#34;
        # Average method doesn&#39;t need specific configuration
        # Accept None, 0, or any placeholder value

    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Not used for average method.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            For average method, growth_params is None.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.methods.average import AverageForecastMethod
            &gt;&gt;&gt; method = AverageForecastMethod()
            &gt;&gt;&gt; method.normalize_params(None, [&#34;2024&#34;, &#34;2025&#34;])
            {&#39;forecast_type&#39;: &#39;average&#39;, &#39;growth_params&#39;: None}
        &#34;&#34;&#34;
        _ = (config, forecast_periods)  # Parameters intentionally unused
        return {
            &#34;forecast_type&#34;: self.internal_type,
            &#34;growth_params&#34;: None,  # Average method doesn&#39;t use growth params
        }

    def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
        &#34;&#34;&#34;Prepare historical data for average calculation.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of valid historical values.

        Raises:
            ValueError: If no valid historical data is available.

        Example:
            &gt;&gt;&gt; # This method is called internally by the forecasting engine.
        &#34;&#34;&#34;
        if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
            raise ValueError(f&#34;Node {node.name} cannot be calculated for average method&#34;)

        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ValueError(f&#34;Node {node.name} does not have values dictionary for average method&#34;)

        # Extract historical values
        historical_values = []
        for period in historical_periods:
            if period in node.values:
                try:
                    value = node.calculate(period)
                    if value is not None and not np.isnan(value) and not np.isinf(value):
                        historical_values.append(float(value))
                except (ValueError, TypeError, ArithmeticError) as e:
                    # Log the exception and skip this period
                    logger.debug(&#34;Skipping period %s for node %s in average calculation: %s&#34;, period, node.name, e)
                    continue

        if not historical_values:
            raise ValueError(f&#34;No valid historical data available for node {node.name} to compute average&#34;)

        return historical_values</code></pre>
</details>
<div class="desc"><p>Forecast future values as the historical average of available data.</p>
<p>This method calculates forecast values as the historical average of available
data points. Useful for stable metrics or when expecting mean reversion.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Not required (pass None or 0)</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.average import AverageForecastMethod
&gt;&gt;&gt; method = AverageForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(None, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; params[&quot;forecast_type&quot;]
'average'
&gt;&gt;&gt; params[&quot;growth_params&quot;] is None
True
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

    Returns:
        The internal type string used by the node factory (&#39;average&#39;).
    &#34;&#34;&#34;
    return &#34;average&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type for NodeFactory.</p>
<h2 id="returns">Returns</h2>
<p>The internal type string used by the node factory ('average').</p></div>
</dd>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (&#39;average&#39;).
    &#34;&#34;&#34;
    return &#34;average&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method ('average').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Not used for average method.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        For average method, growth_params is None.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.average import AverageForecastMethod
        &gt;&gt;&gt; method = AverageForecastMethod()
        &gt;&gt;&gt; method.normalize_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        {&#39;forecast_type&#39;: &#39;average&#39;, &#39;growth_params&#39;: None}
    &#34;&#34;&#34;
    _ = (config, forecast_periods)  # Parameters intentionally unused
    return {
        &#34;forecast_type&#34;: self.internal_type,
        &#34;growth_params&#34;: None,  # Average method doesn&#39;t use growth params
    }</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for average method.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
For average method, growth_params is None.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.average import AverageForecastMethod
&gt;&gt;&gt; method = AverageForecastMethod()
&gt;&gt;&gt; method.normalize_params(None, [&quot;2024&quot;, &quot;2025&quot;])
{'forecast_type': 'average', 'growth_params': None}
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
    &#34;&#34;&#34;Prepare historical data for average calculation.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of valid historical values.

    Raises:
        ValueError: If no valid historical data is available.

    Example:
        &gt;&gt;&gt; # This method is called internally by the forecasting engine.
    &#34;&#34;&#34;
    if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
        raise ValueError(f&#34;Node {node.name} cannot be calculated for average method&#34;)

    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ValueError(f&#34;Node {node.name} does not have values dictionary for average method&#34;)

    # Extract historical values
    historical_values = []
    for period in historical_periods:
        if period in node.values:
            try:
                value = node.calculate(period)
                if value is not None and not np.isnan(value) and not np.isinf(value):
                    historical_values.append(float(value))
            except (ValueError, TypeError, ArithmeticError) as e:
                # Log the exception and skip this period
                logger.debug(&#34;Skipping period %s for node %s in average calculation: %s&#34;, period, node.name, e)
                continue

    if not historical_values:
        raise ValueError(f&#34;No valid historical data available for node {node.name} to compute average&#34;)

    return historical_values</code></pre>
</details>
<div class="desc"><p>Prepare historical data for average calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of valid historical values.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no valid historical data is available.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # This method is called internally by the forecasting engine.
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.AverageForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for average method.

    Args:
        config: Not used for average method, can be None or 0.

    Note:
        Average method doesn&#39;t require configuration as it uses
        historical data automatically.
    &#34;&#34;&#34;
    # Average method doesn&#39;t need specific configuration
    # Accept None, 0, or any placeholder value</code></pre>
</details>
<div class="desc"><p>Validate the configuration for average method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for average method, can be None or 0.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Average method doesn't require configuration as it uses
historical data automatically.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod"><code class="flex name class">
<span>class <span class="ident">BaseForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseForecastMethod(ABC):
    &#34;&#34;&#34;Abstract base class for forecast methods.

    Enforces the forecast method interface and provides common functionality,
    including the get_forecast_params convenience method.

    Example:
        &gt;&gt;&gt; class Dummy(BaseForecastMethod):
        ...     @property
        ...     def name(self):
        ...         return &#34;dummy&#34;
        ...
        ...     @property
        ...     def internal_type(self):
        ...         return &#34;dummy_type&#34;
        ...
        ...     def validate_config(self, config):
        ...         pass
        ...
        ...     def normalize_params(self, config, forecast_periods):
        ...         return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: config}
        &gt;&gt;&gt; d = Dummy()
        &gt;&gt;&gt; d.get_forecast_params(0.1, [&#34;2024&#34;])
        {&#39;forecast_type&#39;: &#39;dummy_type&#39;, &#39;growth_params&#39;: 0.1}
    &#34;&#34;&#34;

    @property
    @abstractmethod
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (e.g., &#39;simple&#39;, &#39;curve&#39;).
        &#34;&#34;&#34;

    @property
    @abstractmethod
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

        Returns:
            The internal type string used by the node factory.
        &#34;&#34;&#34;

    @abstractmethod
    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for this method.

        Args:
            config: The method-specific configuration to validate.

        Raises:
            ValueError: If configuration is invalid.
        &#34;&#34;&#34;

    @abstractmethod
    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: The method-specific configuration.
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        &#34;&#34;&#34;

    def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
        &#34;&#34;&#34;Prepare historical data for methods that need it.

        Default implementation returns ``None`` (not needed). Override this
        method in subclasses that require historical data.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of historical values or ``None`` if no historical data is
            required.
        &#34;&#34;&#34;
        _ = (node, historical_periods)  # Parameters intentionally unused in the base implementation
        return None

    def get_forecast_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get complete forecast parameters.

        This is a convenience method that validates and normalizes in one call.

        Args:
            config: The method-specific configuration.
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

        Raises:
            ValueError: If configuration is invalid.

        Example:
            &gt;&gt;&gt; class Dummy(BaseForecastMethod):
            ...     @property
            ...     def name(self):
            ...         return &#34;dummy&#34;
            ...
            ...     @property
            ...     def internal_type(self):
            ...         return &#34;dummy_type&#34;
            ...
            ...     def validate_config(self, config):
            ...         pass
            ...
            ...     def normalize_params(self, config, forecast_periods):
            ...         return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: config}
            &gt;&gt;&gt; d = Dummy()
            &gt;&gt;&gt; d.get_forecast_params(0.1, [&#34;2024&#34;])
            {&#39;forecast_type&#39;: &#39;dummy_type&#39;, &#39;growth_params&#39;: 0.1}
        &#34;&#34;&#34;
        self.validate_config(config)
        return self.normalize_params(config, forecast_periods)</code></pre>
</details>
<div class="desc"><p>Abstract base class for forecast methods.</p>
<p>Enforces the forecast method interface and provides common functionality,
including the get_forecast_params convenience method.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(BaseForecastMethod):
...     @property
...     def name(self):
...         return &quot;dummy&quot;
...
...     @property
...     def internal_type(self):
...         return &quot;dummy_type&quot;
...
...     def validate_config(self, config):
...         pass
...
...     def normalize_params(self, config, forecast_periods):
...         return {&quot;forecast_type&quot;: self.internal_type, &quot;growth_params&quot;: config}
&gt;&gt;&gt; d = Dummy()
&gt;&gt;&gt; d.get_forecast_params(0.1, [&quot;2024&quot;])
{'forecast_type': 'dummy_type', 'growth_params': 0.1}
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.average.AverageForecastMethod" href="methods/average.html#fin_statement_model.forecasting.methods.average.AverageForecastMethod">AverageForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.curve.CurveForecastMethod" href="methods/curve.html#fin_statement_model.forecasting.methods.curve.CurveForecastMethod">CurveForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod" href="methods/historical_growth.html#fin_statement_model.forecasting.methods.historical_growth.HistoricalGrowthForecastMethod">HistoricalGrowthForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.simple.SimpleForecastMethod" href="methods/simple.html#fin_statement_model.forecasting.methods.simple.SimpleForecastMethod">SimpleForecastMethod</a></li>
<li><a title="fin_statement_model.forecasting.methods.statistical.StatisticalForecastMethod" href="methods/statistical.html#fin_statement_model.forecasting.methods.statistical.StatisticalForecastMethod">StatisticalForecastMethod</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

    Returns:
        The internal type string used by the node factory.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type for NodeFactory.</p>
<h2 id="returns">Returns</h2>
<p>The internal type string used by the node factory.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (e.g., &#39;simple&#39;, &#39;curve&#39;).
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method (e.g., 'simple', 'curve').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.get_forecast_params"><code class="name flex">
<span>def <span class="ident">get_forecast_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forecast_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get complete forecast parameters.

    This is a convenience method that validates and normalizes in one call.

    Args:
        config: The method-specific configuration.
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

    Raises:
        ValueError: If configuration is invalid.

    Example:
        &gt;&gt;&gt; class Dummy(BaseForecastMethod):
        ...     @property
        ...     def name(self):
        ...         return &#34;dummy&#34;
        ...
        ...     @property
        ...     def internal_type(self):
        ...         return &#34;dummy_type&#34;
        ...
        ...     def validate_config(self, config):
        ...         pass
        ...
        ...     def normalize_params(self, config, forecast_periods):
        ...         return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: config}
        &gt;&gt;&gt; d = Dummy()
        &gt;&gt;&gt; d.get_forecast_params(0.1, [&#34;2024&#34;])
        {&#39;forecast_type&#39;: &#39;dummy_type&#39;, &#39;growth_params&#39;: 0.1}
    &#34;&#34;&#34;
    self.validate_config(config)
    return self.normalize_params(config, forecast_periods)</code></pre>
</details>
<div class="desc"><p>Get complete forecast parameters.</p>
<p>This is a convenience method that validates and normalizes in one call.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(BaseForecastMethod):
...     @property
...     def name(self):
...         return &quot;dummy&quot;
...
...     @property
...     def internal_type(self):
...         return &quot;dummy_type&quot;
...
...     def validate_config(self, config):
...         pass
...
...     def normalize_params(self, config, forecast_periods):
...         return {&quot;forecast_type&quot;: self.internal_type, &quot;growth_params&quot;: config}
&gt;&gt;&gt; d = Dummy()
&gt;&gt;&gt; d.get_forecast_params(0.1, [&quot;2024&quot;])
{'forecast_type': 'dummy_type', 'growth_params': 0.1}
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: The method-specific configuration.
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
    &#34;&#34;&#34;Prepare historical data for methods that need it.

    Default implementation returns ``None`` (not needed). Override this
    method in subclasses that require historical data.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of historical values or ``None`` if no historical data is
        required.
    &#34;&#34;&#34;
    _ = (node, historical_periods)  # Parameters intentionally unused in the base implementation
    return None</code></pre>
</details>
<div class="desc"><p>Prepare historical data for methods that need it.</p>
<p>Default implementation returns <code>None</code> (not needed). Override this
method in subclasses that require historical data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of historical values or <code>None</code> if no historical data is
required.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.BaseForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for this method.

    Args:
        config: The method-specific configuration to validate.

    Raises:
        ValueError: If configuration is invalid.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Validate the configuration for this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration to validate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is invalid.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.CurveForecastMethod"><code class="flex name class">
<span>class <span class="ident">CurveForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurveForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values using variable growth rates per period.

    This method applies different growth rates for each forecast period,
    allowing non-linear growth patterns across periods.

    Configuration:
        - Single numeric value: Will be expanded to match forecast periods
        - List of numeric values: One growth rate per forecast period

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.curve import CurveForecastMethod
        &gt;&gt;&gt; method = CurveForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params([0.05, 0.04, 0.03], [&#34;2024&#34;, &#34;2025&#34;, &#34;2026&#34;])
        &gt;&gt;&gt; params[&#34;forecast_type&#34;]
        &#39;curve&#39;
        &gt;&gt;&gt; params[&#34;growth_params&#34;]
        [0.05, 0.04, 0.03]
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (&#39;curve&#39;).
        &#34;&#34;&#34;
        return &#34;curve&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

        Returns:
            The internal type string used by the node factory (&#39;curve&#39;).
        &#34;&#34;&#34;
        return &#34;curve&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for curve method.

        Args:
            config: Should be a numeric value or a list of numeric values.

        Raises:
            ValueError: If config is empty list.
            TypeError: If config is not numeric or list of numerics.
        &#34;&#34;&#34;
        if isinstance(config, list):
            if not config:
                raise ValueError(&#34;Curve method: empty list provided&#34;)
            for i, value in enumerate(config):
                if not isinstance(value, int | float):
                    raise TypeError(f&#34;Curve method: non-numeric value at index {i}: {type(value)}&#34;)
        elif not isinstance(config, int | float):
            raise TypeError(f&#34;Curve method requires numeric or list of numeric values, got {type(config)}&#34;)

    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Growth rates (single value or list).
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

        Raises:
            ValueError: If list length doesn&#39;t match forecast periods.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.methods.curve import CurveForecastMethod
            &gt;&gt;&gt; method = CurveForecastMethod()
            &gt;&gt;&gt; method.normalize_params([0.05, 0.04, 0.03], [&#34;2024&#34;, &#34;2025&#34;, &#34;2026&#34;])
            {&#39;forecast_type&#39;: &#39;curve&#39;, &#39;growth_params&#39;: [0.05, 0.04, 0.03]}
        &#34;&#34;&#34;
        if not isinstance(config, list):
            # Single value - expand to match forecast periods
            growth_rates = [float(config)] * len(forecast_periods)
        else:
            # List of values - must match forecast periods length
            if len(config) != len(forecast_periods):
                raise ValueError(
                    f&#34;Curve method: growth rate list length ({len(config)}) &#34;
                    f&#34;must match forecast periods ({len(forecast_periods)})&#34;
                )
            growth_rates = [float(x) for x in config]

        return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rates}</code></pre>
</details>
<div class="desc"><p>Forecast future values using variable growth rates per period.</p>
<p>This method applies different growth rates for each forecast period,
allowing non-linear growth patterns across periods.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Single numeric value: Will be expanded to match forecast periods</li>
<li>List of numeric values: One growth rate per forecast period</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.curve import CurveForecastMethod
&gt;&gt;&gt; method = CurveForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params([0.05, 0.04, 0.03], [&quot;2024&quot;, &quot;2025&quot;, &quot;2026&quot;])
&gt;&gt;&gt; params[&quot;forecast_type&quot;]
'curve'
&gt;&gt;&gt; params[&quot;growth_params&quot;]
[0.05, 0.04, 0.03]
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.CurveForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

    Returns:
        The internal type string used by the node factory (&#39;curve&#39;).
    &#34;&#34;&#34;
    return &#34;curve&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type for NodeFactory.</p>
<h2 id="returns">Returns</h2>
<p>The internal type string used by the node factory ('curve').</p></div>
</dd>
<dt id="fin_statement_model.forecasting.CurveForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (&#39;curve&#39;).
    &#34;&#34;&#34;
    return &#34;curve&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method ('curve').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.CurveForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Growth rates (single value or list).
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

    Raises:
        ValueError: If list length doesn&#39;t match forecast periods.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.curve import CurveForecastMethod
        &gt;&gt;&gt; method = CurveForecastMethod()
        &gt;&gt;&gt; method.normalize_params([0.05, 0.04, 0.03], [&#34;2024&#34;, &#34;2025&#34;, &#34;2026&#34;])
        {&#39;forecast_type&#39;: &#39;curve&#39;, &#39;growth_params&#39;: [0.05, 0.04, 0.03]}
    &#34;&#34;&#34;
    if not isinstance(config, list):
        # Single value - expand to match forecast periods
        growth_rates = [float(config)] * len(forecast_periods)
    else:
        # List of values - must match forecast periods length
        if len(config) != len(forecast_periods):
            raise ValueError(
                f&#34;Curve method: growth rate list length ({len(config)}) &#34;
                f&#34;must match forecast periods ({len(forecast_periods)})&#34;
            )
        growth_rates = [float(x) for x in config]

    return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rates}</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Growth rates (single value or list).</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If list length doesn't match forecast periods.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.curve import CurveForecastMethod
&gt;&gt;&gt; method = CurveForecastMethod()
&gt;&gt;&gt; method.normalize_params([0.05, 0.04, 0.03], [&quot;2024&quot;, &quot;2025&quot;, &quot;2026&quot;])
{'forecast_type': 'curve', 'growth_params': [0.05, 0.04, 0.03]}
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.CurveForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for curve method.

    Args:
        config: Should be a numeric value or a list of numeric values.

    Raises:
        ValueError: If config is empty list.
        TypeError: If config is not numeric or list of numerics.
    &#34;&#34;&#34;
    if isinstance(config, list):
        if not config:
            raise ValueError(&#34;Curve method: empty list provided&#34;)
        for i, value in enumerate(config):
            if not isinstance(value, int | float):
                raise TypeError(f&#34;Curve method: non-numeric value at index {i}: {type(value)}&#34;)
    elif not isinstance(config, int | float):
        raise TypeError(f&#34;Curve method requires numeric or list of numeric values, got {type(config)}&#34;)</code></pre>
</details>
<div class="desc"><p>Validate the configuration for curve method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Should be a numeric value or a list of numeric values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If config is empty list.</dd>
<dt><code>TypeError</code></dt>
<dd>If config is not numeric or list of numerics.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfig"><code class="flex name class">
<span>class <span class="ident">ForecastConfig</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastConfig(BaseModel):
    &#34;&#34;&#34;Configuration for a forecast operation.

    Enforces method selection and method-specific parameters.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastConfig
        &gt;&gt;&gt; ForecastConfig(method=&#34;simple&#34;, config=0.05)
        ForecastConfig(method=&#39;simple&#39;, config=0.05)
    &#34;&#34;&#34;

    method: ForecastMethodType
    config: Any  # Method-specific configuration

    model_config = ConfigDict(extra=&#34;forbid&#34;)

    @model_validator(mode=&#34;after&#34;)
    def _validate_config(self) -&gt; &#34;ForecastConfig&#34;:
        &#34;&#34;&#34;Validate ``self.method`` and its accompanying ``self.config``.

        This replaces the outdated two-parameter validator signature to avoid
        accidentally receiving a *ValidationInfo* object.
        &#34;&#34;&#34;
        method = self.method
        cfg = self.config or {}

        valid_methods = {
            &#34;simple&#34;,
            &#34;curve&#34;,
            &#34;statistical&#34;,
            &#34;average&#34;,
            &#34;historical_growth&#34;,
        }

        if method not in valid_methods:
            raise ForecastMethodError(
                &#34;Invalid forecast method&#34;,
                method=method,
                supported_methods=list(valid_methods),
            )

        if method == &#34;statistical&#34;:
            try:
                # Accept both raw dicts and already-validated StatisticalConfig instances
                if isinstance(cfg, StatisticalConfig):
                    pass  # Already validated
                else:
                    StatisticalConfig.model_validate(cfg)
            except (ForecastConfigurationError, ValidationError) as exc:
                raise ForecastConfigurationError(
                    &#34;Invalid statistical configuration&#34;,
                    config=cfg,
                ) from exc

        return self</code></pre>
</details>
<div class="desc"><p>Configuration for a forecast operation.</p>
<p>Enforces method selection and method-specific parameters.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastConfig
&gt;&gt;&gt; ForecastConfig(method=&quot;simple&quot;, config=0.05)
ForecastConfig(method='simple', config=0.05)
</code></pre>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastConfig.config"><code class="name">var <span class="ident">config</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfig.method"><code class="name">var <span class="ident">method</span> : Literal['simple', 'curve', 'statistical', 'average', 'historical_growth']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfig.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastConfigurationError"><code class="flex name class">
<span>class <span class="ident">ForecastConfigurationError</span></span>
<span>(</span><span>message: str,<br>config: dict[str, typing.Any] | None = None,<br>missing_params: list[str] | None = None,<br>invalid_params: dict[str, str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastConfigurationError(ForecastingError):
    &#34;&#34;&#34;Exception raised for invalid forecast configuration.

    This includes missing required parameters, invalid parameter values,
    or incompatible configuration combinations.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastConfigurationError
        &gt;&gt;&gt; raise ForecastConfigurationError(&#34;Missing config&#34;, missing_params=[&#34;growth_rate&#34;])
        Traceback (most recent call last):
            ...
        fin_statement_model.forecasting.errors.ForecastConfigurationError: Missing config - Missing parameters: growth_rate
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        config: dict[str, Any] | None = None,
        missing_params: list[str] | None = None,
        invalid_params: dict[str, str] | None = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastConfigurationError.

        Args:
            message: The primary error message.
            config: Optional configuration dictionary that caused the error.
            missing_params: Optional list of missing required parameters.
            invalid_params: Optional dict of parameter names to error descriptions.
        &#34;&#34;&#34;
        self.config = config
        self.missing_params = missing_params or []
        self.invalid_params = invalid_params or {}

        details = []
        if missing_params:
            details.append(f&#34;Missing parameters: {&#39;, &#39;.join(missing_params)}&#34;)
        if invalid_params:
            param_errors = [f&#34;{k}: {v}&#34; for k, v in invalid_params.items()]
            details.append(f&#34;Invalid parameters: {&#39;; &#39;.join(param_errors)}&#34;)

        full_message = message
        if details:
            full_message = f&#34;{message} - {&#39; | &#39;.join(details)}&#34;

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for invalid forecast configuration.</p>
<p>This includes missing required parameters, invalid parameter values,
or incompatible configuration combinations.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastConfigurationError
&gt;&gt;&gt; raise ForecastConfigurationError(&quot;Missing config&quot;, missing_params=[&quot;growth_rate&quot;])
Traceback (most recent call last):
    ...
fin_statement_model.forecasting.errors.ForecastConfigurationError: Missing config - Missing parameters: growth_rate
</code></pre>
<p>Initialize a ForecastConfigurationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Optional configuration dictionary that caused the error.</dd>
<dt><strong><code>missing_params</code></strong></dt>
<dd>Optional list of missing required parameters.</dd>
<dt><strong><code>invalid_params</code></strong></dt>
<dd>Optional dict of parameter names to error descriptions.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethod"><code class="flex name class">
<span>class <span class="ident">ForecastMethod</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class ForecastMethod(Protocol):
    &#34;&#34;&#34;Protocol for forecast methods to implement.

    All forecast methods must provide a name property and implement
    validate_config and normalize_params, optionally prepare_historical_data.

    Example:
        &gt;&gt;&gt; class Dummy:
        ...     @property
        ...     def name(self):
        ...         return &#34;dummy&#34;
        ...
        ...     def validate_config(self, config):
        ...         pass
        ...
        ...     def normalize_params(self, config, forecast_periods):
        ...         return {&#34;forecast_type&#34;: &#34;dummy&#34;, &#34;growth_params&#34;: config}
        ...
        ...     def prepare_historical_data(self, node, historical_periods):
        ...         return None
        &gt;&gt;&gt; isinstance(Dummy(), ForecastMethod)
        True
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (e.g., &#39;simple&#39;, &#39;curve&#39;).
        &#34;&#34;&#34;
        ...

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for this method.

        Args:
            config: The method-specific configuration to validate.

        Raises:
            ValueError: If configuration is invalid.
        &#34;&#34;&#34;
        ...

    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: The method-specific configuration.
            forecast_periods: List of periods to forecast.

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        &#34;&#34;&#34;
        ...

    def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
        &#34;&#34;&#34;Prepare historical data for methods that need it.

        Default implementation returns ``None`` (not needed). Override this
        method in subclasses that require historical data.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of historical values or ``None`` if no historical data is
            required.
        &#34;&#34;&#34;
        _ = (node, historical_periods)  # Parameters intentionally unused in the base implementation
        return None</code></pre>
</details>
<div class="desc"><p>Protocol for forecast methods to implement.</p>
<p>All forecast methods must provide a name property and implement
validate_config and normalize_params, optionally prepare_historical_data.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy:
...     @property
...     def name(self):
...         return &quot;dummy&quot;
...
...     def validate_config(self, config):
...         pass
...
...     def normalize_params(self, config, forecast_periods):
...         return {&quot;forecast_type&quot;: &quot;dummy&quot;, &quot;growth_params&quot;: config}
...
...     def prepare_historical_data(self, node, historical_periods):
...         return None
&gt;&gt;&gt; isinstance(Dummy(), ForecastMethod)
True
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (e.g., &#39;simple&#39;, &#39;curve&#39;).
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method (e.g., 'simple', 'curve').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: The method-specific configuration.
        forecast_periods: List of periods to forecast.

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
    &#34;&#34;&#34;Prepare historical data for methods that need it.

    Default implementation returns ``None`` (not needed). Override this
    method in subclasses that require historical data.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of historical values or ``None`` if no historical data is
        required.
    &#34;&#34;&#34;
    _ = (node, historical_periods)  # Parameters intentionally unused in the base implementation
    return None</code></pre>
</details>
<div class="desc"><p>Prepare historical data for methods that need it.</p>
<p>Default implementation returns <code>None</code> (not needed). Override this
method in subclasses that require historical data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of historical values or <code>None</code> if no historical data is
required.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for this method.

    Args:
        config: The method-specific configuration to validate.

    Raises:
        ValueError: If configuration is invalid.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
<div class="desc"><p>Validate the configuration for this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The method-specific configuration to validate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is invalid.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodError"><code class="flex name class">
<span>class <span class="ident">ForecastMethodError</span></span>
<span>(</span><span>message: str,<br>method: str | None = None,<br>supported_methods: list[str] | None = None,<br>node_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastMethodError(ForecastingError):
    &#34;&#34;&#34;Exception raised for invalid or unsupported forecast methods.

    This includes unknown method names, invalid method parameters,
    or methods incompatible with the data type.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastMethodError
        &gt;&gt;&gt; raise ForecastMethodError(&#34;Unknown method&#34;, method=&#34;foo&#34;, supported_methods=[&#34;simple&#34;])
        Traceback (most recent call last):
            ...
        fin_statement_model.forecasting.errors.ForecastMethodError: Unknown method: &#39;foo&#39;. Supported methods: simple
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        method: str | None = None,
        supported_methods: list[str] | None = None,
        node_id: str | None = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastMethodError.

        Args:
            message: The primary error message.
            method: Optional name of the invalid method.
            supported_methods: Optional list of supported methods.
            node_id: Optional ID of the node being forecasted.
        &#34;&#34;&#34;
        self.method = method
        self.supported_methods = supported_methods or []
        self.node_id = node_id

        full_message = message
        if method:
            full_message = f&#34;{message}: &#39;{method}&#39;&#34;
        if node_id:
            full_message = f&#34;{full_message} for node &#39;{node_id}&#39;&#34;
        if supported_methods:
            full_message = f&#34;{full_message}. Supported methods: {&#39;, &#39;.join(supported_methods)}&#34;

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for invalid or unsupported forecast methods.</p>
<p>This includes unknown method names, invalid method parameters,
or methods incompatible with the data type.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastMethodError
&gt;&gt;&gt; raise ForecastMethodError(&quot;Unknown method&quot;, method=&quot;foo&quot;, supported_methods=[&quot;simple&quot;])
Traceback (most recent call last):
    ...
fin_statement_model.forecasting.errors.ForecastMethodError: Unknown method: 'foo'. Supported methods: simple
</code></pre>
<p>Initialize a ForecastMethodError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Optional name of the invalid method.</dd>
<dt><strong><code>supported_methods</code></strong></dt>
<dd>Optional list of supported methods.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node being forecasted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry"><code class="flex name class">
<span>class <span class="ident">ForecastMethodRegistry</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastMethodRegistry:
    &#34;&#34;&#34;Manage forecast methods in a registry.

    Provides methods to register, unregister, retrieve, and list available
    forecast methods. Supports querying method metadata.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; method = registry.get_method(&#34;simple&#34;)
        &gt;&gt;&gt; print(registry.list_methods())
        [&#39;simple&#39;, &#39;curve&#39;, &#39;statistical&#39;, &#39;average&#39;, &#39;historical_growth&#39;]
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize the registry with built-in methods.&#34;&#34;&#34;
        self._methods: dict[str, ForecastMethod] = {}
        self._register_builtin_methods()

    def _register_builtin_methods(self) -&gt; None:
        &#34;&#34;&#34;Register all built-in forecast methods.&#34;&#34;&#34;
        builtin_methods = [
            SimpleForecastMethod(),
            CurveForecastMethod(),
            StatisticalForecastMethod(),
            AverageForecastMethod(),
            HistoricalGrowthForecastMethod(),
        ]

        for method in builtin_methods:
            self.register(method)
            logger.debug(&#34;Registered built-in forecast method: %s&#34;, method.name)

    def register(self, method: ForecastMethod) -&gt; None:
        &#34;&#34;&#34;Register a new forecast method.

        Args:
            method: The forecast method to register.

        Raises:
            ValueError: If a method with the same name is already registered.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
            &gt;&gt;&gt; registry = ForecastMethodRegistry()
            &gt;&gt;&gt; registry.register(SimpleForecastMethod())
        &#34;&#34;&#34;
        if method.name in self._methods:
            raise ValueError(f&#34;Forecast method &#39;{method.name}&#39; is already registered&#34;)

        self._methods[method.name] = method
        logger.info(&#34;Registered forecast method: %s&#34;, method.name)

    def unregister(self, name: str) -&gt; None:
        &#34;&#34;&#34;Unregister a forecast method.

        Args:
            name: The name of the method to unregister.

        Raises:
            KeyError: If the method is not registered.

        Example:
            &gt;&gt;&gt; registry = ForecastMethodRegistry()
            &gt;&gt;&gt; registry.unregister(&#34;simple&#34;)
        &#34;&#34;&#34;
        if name not in self._methods:
            raise KeyError(f&#34;Forecast method &#39;{name}&#39; is not registered&#34;)

        del self._methods[name]
        logger.info(&#34;Unregistered forecast method: %s&#34;, name)

    def get_method(self, name: str) -&gt; ForecastMethod:
        &#34;&#34;&#34;Get a forecast method by name.

        Args:
            name: The name of the method to retrieve.

        Returns:
            The requested forecast method.

        Raises:
            ValueError: If the method is not registered.

        Example:
            &gt;&gt;&gt; registry = ForecastMethodRegistry()
            &gt;&gt;&gt; method = registry.get_method(&#34;simple&#34;)
            &gt;&gt;&gt; method.name
            &#39;simple&#39;
        &#34;&#34;&#34;
        if name not in self._methods:
            available = &#34;, &#34;.join(sorted(self._methods.keys()))
            raise ValueError(f&#34;Unknown forecast method: &#39;{name}&#39;. Available methods: {available}&#34;)

        return self._methods[name]

    def list_methods(self) -&gt; list[str]:
        &#34;&#34;&#34;List all available forecast methods.

        Returns:
            Sorted list of registered method names.

        Example:
            &gt;&gt;&gt; registry = ForecastMethodRegistry()
            &gt;&gt;&gt; registry.list_methods()
            [&#39;average&#39;, &#39;curve&#39;, &#39;historical_growth&#39;, &#39;simple&#39;, &#39;statistical&#39;]
        &#34;&#34;&#34;
        return sorted(self._methods.keys())

    def has_method(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Check if a method is registered.

        Args:
            name: The name of the method to check.

        Returns:
            True if the method is registered, False otherwise.

        Example:
            &gt;&gt;&gt; registry = ForecastMethodRegistry()
            &gt;&gt;&gt; registry.has_method(&#34;simple&#34;)
            True
        &#34;&#34;&#34;
        return name in self._methods

    def get_method_info(self, name: str) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get information about a forecast method.

        Args:
            name: The name of the method.

        Returns:
            Dictionary with method information including docstring.

        Raises:
            ValueError: If the method is not registered.

        Example:
            &gt;&gt;&gt; registry = ForecastMethodRegistry()
            &gt;&gt;&gt; info = registry.get_method_info(&#34;simple&#34;)
            &gt;&gt;&gt; &#34;name&#34; in info and &#34;description&#34; in info
            True
        &#34;&#34;&#34;
        method = self.get_method(name)
        return {
            &#34;name&#34;: method.name,
            &#34;class&#34;: method.__class__.__name__,
            &#34;description&#34;: method.__class__.__doc__ or &#34;No description available&#34;,
            &#34;module&#34;: method.__class__.__module__,
        }</code></pre>
</details>
<div class="desc"><p>Manage forecast methods in a registry.</p>
<p>Provides methods to register, unregister, retrieve, and list available
forecast methods. Supports querying method metadata.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; method = registry.get_method(&quot;simple&quot;)
&gt;&gt;&gt; print(registry.list_methods())
['simple', 'curve', 'statistical', 'average', 'historical_growth']
</code></pre>
<p>Initialize the registry with built-in methods.</p></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.get_method"><code class="name flex">
<span>def <span class="ident">get_method</span></span>(<span>self, name: str) ‑> <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method(self, name: str) -&gt; ForecastMethod:
    &#34;&#34;&#34;Get a forecast method by name.

    Args:
        name: The name of the method to retrieve.

    Returns:
        The requested forecast method.

    Raises:
        ValueError: If the method is not registered.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; method = registry.get_method(&#34;simple&#34;)
        &gt;&gt;&gt; method.name
        &#39;simple&#39;
    &#34;&#34;&#34;
    if name not in self._methods:
        available = &#34;, &#34;.join(sorted(self._methods.keys()))
        raise ValueError(f&#34;Unknown forecast method: &#39;{name}&#39;. Available methods: {available}&#34;)

    return self._methods[name]</code></pre>
</details>
<div class="desc"><p>Get a forecast method by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested forecast method.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the method is not registered.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; method = registry.get_method(&quot;simple&quot;)
&gt;&gt;&gt; method.name
'simple'
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.get_method_info"><code class="name flex">
<span>def <span class="ident">get_method_info</span></span>(<span>self, name: str) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method_info(self, name: str) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get information about a forecast method.

    Args:
        name: The name of the method.

    Returns:
        Dictionary with method information including docstring.

    Raises:
        ValueError: If the method is not registered.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; info = registry.get_method_info(&#34;simple&#34;)
        &gt;&gt;&gt; &#34;name&#34; in info and &#34;description&#34; in info
        True
    &#34;&#34;&#34;
    method = self.get_method(name)
    return {
        &#34;name&#34;: method.name,
        &#34;class&#34;: method.__class__.__name__,
        &#34;description&#34;: method.__class__.__doc__ or &#34;No description available&#34;,
        &#34;module&#34;: method.__class__.__module__,
    }</code></pre>
</details>
<div class="desc"><p>Get information about a forecast method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with method information including docstring.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the method is not registered.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; info = registry.get_method_info(&quot;simple&quot;)
&gt;&gt;&gt; &quot;name&quot; in info and &quot;description&quot; in info
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.has_method"><code class="name flex">
<span>def <span class="ident">has_method</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_method(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Check if a method is registered.

    Args:
        name: The name of the method to check.

    Returns:
        True if the method is registered, False otherwise.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; registry.has_method(&#34;simple&#34;)
        True
    &#34;&#34;&#34;
    return name in self._methods</code></pre>
</details>
<div class="desc"><p>Check if a method is registered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the method is registered, False otherwise.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; registry.has_method(&quot;simple&quot;)
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.list_methods"><code class="name flex">
<span>def <span class="ident">list_methods</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_methods(self) -&gt; list[str]:
    &#34;&#34;&#34;List all available forecast methods.

    Returns:
        Sorted list of registered method names.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; registry.list_methods()
        [&#39;average&#39;, &#39;curve&#39;, &#39;historical_growth&#39;, &#39;simple&#39;, &#39;statistical&#39;]
    &#34;&#34;&#34;
    return sorted(self._methods.keys())</code></pre>
</details>
<div class="desc"><p>List all available forecast methods.</p>
<h2 id="returns">Returns</h2>
<p>Sorted list of registered method names.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; registry.list_methods()
['average', 'curve', 'historical_growth', 'simple', 'statistical']
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self,<br>method: <a title="fin_statement_model.forecasting.methods.base.ForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.ForecastMethod">ForecastMethod</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, method: ForecastMethod) -&gt; None:
    &#34;&#34;&#34;Register a new forecast method.

    Args:
        method: The forecast method to register.

    Raises:
        ValueError: If a method with the same name is already registered.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; registry.register(SimpleForecastMethod())
    &#34;&#34;&#34;
    if method.name in self._methods:
        raise ValueError(f&#34;Forecast method &#39;{method.name}&#39; is already registered&#34;)

    self._methods[method.name] = method
    logger.info(&#34;Registered forecast method: %s&#34;, method.name)</code></pre>
</details>
<div class="desc"><p>Register a new forecast method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The forecast method to register.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a method with the same name is already registered.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; registry.register(SimpleForecastMethod())
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastMethodRegistry.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, name: str) -&gt; None:
    &#34;&#34;&#34;Unregister a forecast method.

    Args:
        name: The name of the method to unregister.

    Raises:
        KeyError: If the method is not registered.

    Example:
        &gt;&gt;&gt; registry = ForecastMethodRegistry()
        &gt;&gt;&gt; registry.unregister(&#34;simple&#34;)
    &#34;&#34;&#34;
    if name not in self._methods:
        raise KeyError(f&#34;Forecast method &#39;{name}&#39; is not registered&#34;)

    del self._methods[name]
    logger.info(&#34;Unregistered forecast method: %s&#34;, name)</code></pre>
</details>
<div class="desc"><p>Unregister a forecast method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the method to unregister.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If the method is not registered.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = ForecastMethodRegistry()
&gt;&gt;&gt; registry.unregister(&quot;simple&quot;)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastNodeError"><code class="flex name class">
<span>class <span class="ident">ForecastNodeError</span></span>
<span>(</span><span>message: str,<br>node_id: str | None,<br>available_nodes: list[str] | None = None,<br>reason: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastNodeError(ForecastingError):
    &#34;&#34;&#34;Exception raised for node-related forecast errors.

    This includes nodes not found in the graph, nodes without historical data,
    or nodes that cannot be forecasted.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastNodeError
        &gt;&gt;&gt; raise ForecastNodeError(&#34;Node not found&#34;, node_id=&#34;revenue&#34;, available_nodes=[&#34;revenue&#34;, &#34;costs&#34;])
        Traceback (most recent call last):
            ...
        fin_statement_model.forecasting.errors.ForecastNodeError: Node not found for node &#39;revenue&#39;. Available nodes: revenue, costs
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        node_id: str | None,
        available_nodes: list[str] | None = None,
        reason: str | None = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastNodeError.

        Args:
            message: The primary error message.
            node_id: The ID of the problematic node.
            available_nodes: Optional list of available node IDs.
            reason: Optional specific reason why the node cannot be forecasted.
        &#34;&#34;&#34;
        self.node_id = node_id
        self.available_nodes = available_nodes or []
        self.reason = reason

        full_message = f&#34;{message} for node &#39;{node_id}&#39;&#34;
        if reason:
            full_message = f&#34;{full_message}: {reason}&#34;
        if available_nodes and len(available_nodes) &lt; MAX_PREVIEW_ITEMS:  # Only show if list is small
            full_message = f&#34;{full_message}. Available nodes: {&#39;, &#39;.join(available_nodes)}&#34;

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for node-related forecast errors.</p>
<p>This includes nodes not found in the graph, nodes without historical data,
or nodes that cannot be forecasted.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastNodeError
&gt;&gt;&gt; raise ForecastNodeError(&quot;Node not found&quot;, node_id=&quot;revenue&quot;, available_nodes=[&quot;revenue&quot;, &quot;costs&quot;])
Traceback (most recent call last):
    ...
fin_statement_model.forecasting.errors.ForecastNodeError: Node not found for node 'revenue'. Available nodes: revenue, costs
</code></pre>
<p>Initialize a ForecastNodeError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>The ID of the problematic node.</dd>
<dt><strong><code>available_nodes</code></strong></dt>
<dd>Optional list of available node IDs.</dd>
<dt><strong><code>reason</code></strong></dt>
<dd>Optional specific reason why the node cannot be forecasted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult"><code class="flex name class">
<span>class <span class="ident">ForecastResult</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastResult(BaseModel):
    &#34;&#34;&#34;Forecast results for a node.

    Contains the node name, forecast periods, result values, method, and base period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastResult
        &gt;&gt;&gt; result = ForecastResult(
        ...     node_name=&#34;revenue&#34;,
        ...     periods=[&#34;2024&#34;, &#34;2025&#34;],
        ...     values={&#34;2024&#34;: 1050.0, &#34;2025&#34;: 1102.5},
        ...     method=&#34;simple&#34;,
        ...     base_period=&#34;2023&#34;,
        ... )
        &gt;&gt;&gt; result.get_value(&#34;2024&#34;)
        1050.0
    &#34;&#34;&#34;

    node_name: str
    periods: list[str]
    values: PeriodValue
    method: ForecastMethodType
    base_period: str

    model_config = ConfigDict(extra=&#34;forbid&#34;)

    def get_value(self, period: str) -&gt; float:
        &#34;&#34;&#34;Get the forecast value for a specific period.

        Args:
            period: The period to retrieve the value for.

        Returns:
            The forecast value for the specified period.

        Raises:
            ForecastResultError: If the period is not found in the results.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastResult
            &gt;&gt;&gt; result = ForecastResult(
            ...     node_name=&#34;revenue&#34;, periods=[&#34;2024&#34;], values={&#34;2024&#34;: 1050.0}, method=&#34;simple&#34;, base_period=&#34;2023&#34;
            ... )
            &gt;&gt;&gt; result.get_value(&#34;2024&#34;)
            1050.0
        &#34;&#34;&#34;
        if period not in self.values:
            raise ForecastResultError(
                f&#34;Period {period} not found in forecast results&#34;,
                period=period,
                available_periods=list(self.values.keys()),
            )
        return self.values[period]</code></pre>
</details>
<div class="desc"><p>Forecast results for a node.</p>
<p>Contains the node name, forecast periods, result values, method, and base period.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastResult
&gt;&gt;&gt; result = ForecastResult(
...     node_name=&quot;revenue&quot;,
...     periods=[&quot;2024&quot;, &quot;2025&quot;],
...     values={&quot;2024&quot;: 1050.0, &quot;2025&quot;: 1102.5},
...     method=&quot;simple&quot;,
...     base_period=&quot;2023&quot;,
... )
&gt;&gt;&gt; result.get_value(&quot;2024&quot;)
1050.0
</code></pre>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastResult.base_period"><code class="name">var <span class="ident">base_period</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.method"><code class="name">var <span class="ident">method</span> : Literal['simple', 'curve', 'statistical', 'average', 'historical_growth']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.node_name"><code class="name">var <span class="ident">node_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.periods"><code class="name">var <span class="ident">periods</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResult.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastResult.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, period: str) -&gt; float:
    &#34;&#34;&#34;Get the forecast value for a specific period.

    Args:
        period: The period to retrieve the value for.

    Returns:
        The forecast value for the specified period.

    Raises:
        ForecastResultError: If the period is not found in the results.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastResult
        &gt;&gt;&gt; result = ForecastResult(
        ...     node_name=&#34;revenue&#34;, periods=[&#34;2024&#34;], values={&#34;2024&#34;: 1050.0}, method=&#34;simple&#34;, base_period=&#34;2023&#34;
        ... )
        &gt;&gt;&gt; result.get_value(&#34;2024&#34;)
        1050.0
    &#34;&#34;&#34;
    if period not in self.values:
        raise ForecastResultError(
            f&#34;Period {period} not found in forecast results&#34;,
            period=period,
            available_periods=list(self.values.keys()),
        )
    return self.values[period]</code></pre>
</details>
<div class="desc"><p>Get the forecast value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong></dt>
<dd>The period to retrieve the value for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The forecast value for the specified period.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastResultError" href="#fin_statement_model.forecasting.ForecastResultError">ForecastResultError</a></code></dt>
<dd>If the period is not found in the results.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.types import ForecastResult
&gt;&gt;&gt; result = ForecastResult(
...     node_name=&quot;revenue&quot;, periods=[&quot;2024&quot;], values={&quot;2024&quot;: 1050.0}, method=&quot;simple&quot;, base_period=&quot;2023&quot;
... )
&gt;&gt;&gt; result.get_value(&quot;2024&quot;)
1050.0
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastResultError"><code class="flex name class">
<span>class <span class="ident">ForecastResultError</span></span>
<span>(</span><span>message: str,<br>period: str | None = None,<br>available_periods: list[str] | None = None,<br>node_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastResultError(ForecastingError):
    &#34;&#34;&#34;Exception raised for forecast result access or manipulation errors.

    This includes accessing results for non-existent periods, invalid result
    formats, or result validation failures.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastResultError
        &gt;&gt;&gt; raise ForecastResultError(&#34;Period not found&#34;, period=&#34;2024&#34;, available_periods=[&#34;2023&#34;, &#34;2024&#34;])
        Traceback (most recent call last):
            ...
        fin_statement_model.forecasting.errors.ForecastResultError: Period not found for period &#39;2024&#39;. Available periods: 2023, 2024
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        period: str | None = None,
        available_periods: list[str] | None = None,
        node_id: str | None = None,
    ):
        &#34;&#34;&#34;Initialize a ForecastResultError.

        Args:
            message: The primary error message.
            period: Optional period that caused the error.
            available_periods: Optional list of available periods.
            node_id: Optional ID of the node whose results are being accessed.
        &#34;&#34;&#34;
        self.period = period
        self.available_periods = available_periods or []
        self.node_id = node_id

        context = []
        if node_id:
            context.append(f&#34;node &#39;{node_id}&#39;&#34;)
        if period:
            context.append(f&#34;period &#39;{period}&#39;&#34;)

        full_message = message
        if context:
            full_message = f&#34;{message} for {&#39; and &#39;.join(context)}&#34;
        if available_periods and len(available_periods) &lt; MAX_PREVIEW_ITEMS:
            full_message = f&#34;{full_message}. Available periods: {&#39;, &#39;.join(available_periods)}&#34;

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Exception raised for forecast result access or manipulation errors.</p>
<p>This includes accessing results for non-existent periods, invalid result
formats, or result validation failures.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.errors import ForecastResultError
&gt;&gt;&gt; raise ForecastResultError(&quot;Period not found&quot;, period=&quot;2024&quot;, available_periods=[&quot;2023&quot;, &quot;2024&quot;])
Traceback (most recent call last):
    ...
fin_statement_model.forecasting.errors.ForecastResultError: Period not found for period '2024'. Available periods: 2023, 2024
</code></pre>
<p>Initialize a ForecastResultError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The primary error message.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Optional period that caused the error.</dd>
<dt><strong><code>available_periods</code></strong></dt>
<dd>Optional list of available periods.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>Optional ID of the node whose results are being accessed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastingError" href="errors.html#fin_statement_model.forecasting.errors.ForecastingError">ForecastingError</a></li>
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator"><code class="flex name class">
<span>class <span class="ident">ForecastValidator</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastValidator:
    &#34;&#34;&#34;Validator for forecast inputs, configurations, and results.

    Provides static methods to check the validity of forecast periods,
    node configurations, and forecast results. Raises descriptive errors
    for invalid input or output.
    &#34;&#34;&#34;

    @staticmethod
    def validate_forecast_inputs(
        historical_periods: list[str],
        forecast_periods: list[str],
        node_configs: dict[str, dict[str, Any]] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Validate forecast input periods and node configurations.

        Args:
            historical_periods: List of historical periods to use as base.
            forecast_periods: List of periods to forecast.
            node_configs: Optional mapping of node names to forecast configs.

        Raises:
            ForecastNodeError: If no historical or forecast periods are provided.
            ForecastConfigurationError: If node_configs is not a dict.

        Example:
            &gt;&gt;&gt; ForecastValidator.validate_forecast_inputs([&#34;2022&#34;], [&#34;2023&#34;])
            # No exception means validation passed
        &#34;&#34;&#34;
        if not historical_periods:
            raise ForecastNodeError(
                &#34;No historical periods provided for forecasting&#34;,
                node_id=None,
            )
        if not forecast_periods:
            raise ForecastNodeError(
                &#34;No forecast periods provided&#34;,
                node_id=None,
            )
        if node_configs is not None and not isinstance(node_configs, dict):
            raise ForecastConfigurationError(
                &#34;node_configs must be a dictionary&#34;,
                config=node_configs,
            )

    @staticmethod
    def validate_node_config(node_name: str, config: dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;Validate configuration for a single node.

        Args:
            node_name: Name of the node being configured.
            config: Configuration dictionary for the node.

        Raises:
            ValueError: If configuration is logically invalid.
            TypeError: If configuration is of wrong type.
        &#34;&#34;&#34;
        if not isinstance(config, dict):
            raise TypeError(f&#34;Configuration for node &#39;{node_name}&#39; must be a dict, got {type(config)}&#34;)

        # Validate method
        if &#34;method&#34; not in config:
            raise ValueError(f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;method&#39; key&#34;)

        method = config[&#34;method&#34;]
        valid_methods: list[ForecastMethodType] = [
            &#34;simple&#34;,
            &#34;curve&#34;,
            &#34;statistical&#34;,
            &#34;average&#34;,
            &#34;historical_growth&#34;,
        ]
        if method not in valid_methods:
            raise ValueError(
                f&#34;Invalid forecast method &#39;{method}&#39; for node &#39;{node_name}&#39;. Valid methods: {valid_methods}&#34;
            )

        # Validate config exists (can be None for some methods)
        if &#34;config&#34; not in config:
            raise ValueError(f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;config&#39; key&#34;)

    @staticmethod
    def validate_node_for_forecast(node: Node, method: str) -&gt; None:
        &#34;&#34;&#34;Validate that a node is forecastable with the given method.

        Args:
            node: The node object to check.
            method: The forecast method to use.

        Raises:
            ForecastNodeError: If the node is not forecastable.

        Example:
            &gt;&gt;&gt; class DummyNode:
            ...     values = {&#34;2022&#34;: 100.0}
            &gt;&gt;&gt; ForecastValidator.validate_node_for_forecast(DummyNode(), &#34;simple&#34;)
            # No exception means validation passed
        &#34;&#34;&#34;
        # Reference the supplied `method` argument for transparency and to comply with linters.
        logger.debug(
            &#34;Validating node &#39;%s&#39; for forecast method &#39;%s&#39;&#34;,
            node.name,
            method,
        )

        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ForecastNodeError(
                f&#34;Node {node.name} is not forecastable (missing &#39;values&#39; dict)&#34;,
                node_id=node.name,
            )

    @staticmethod
    def validate_forecast_config(config: dict[str, Any]) -&gt; ForecastConfig:
        &#34;&#34;&#34;Validate and parse a forecast configuration dictionary.

        Args:
            config: Dictionary with &#39;method&#39; and method-specific &#39;config&#39;.

        Returns:
            ForecastConfig: Validated and parsed configuration object.

        Raises:
            ForecastMethodError: If method is missing or invalid.
            ForecastConfigurationError: If config is missing or invalid.

        Example:
            &gt;&gt;&gt; ForecastValidator.validate_forecast_config({&#34;method&#34;: &#34;simple&#34;, &#34;config&#34;: 0.05})
            ForecastConfig(method=&#39;simple&#39;, config=0.05)
        &#34;&#34;&#34;
        if not isinstance(config, dict):
            raise ForecastConfigurationError(
                &#34;Forecast config must be a dictionary&#34;,
                config=config,
            )
        if &#34;method&#34; not in config:
            raise ForecastMethodError(
                &#34;Forecast config missing &#39;method&#39; key&#34;,
                method=None,
            )

        # Short-circuit: ensure the method itself is recognised so we raise the
        # domain-specific *ForecastMethodError* instead of a generic
        # ValidationError coming from pydantic.
        supported_methods: list[str] = [
            &#34;simple&#34;,
            &#34;curve&#34;,
            &#34;statistical&#34;,
            &#34;average&#34;,
            &#34;historical_growth&#34;,
        ]

        method_name: str = config[&#34;method&#34;]
        if method_name not in supported_methods:
            raise ForecastMethodError(
                &#34;Invalid forecast method&#34;,
                method=method_name,
                supported_methods=supported_methods,
            )

        # Create and validate using dataclass - ValidationError is converted to
        # a ForecastConfigurationError for consistency with the public API.
        try:
            return ForecastConfig(method=method_name, config=config[&#34;config&#34;])
        except ValidationError as exc:
            raise ForecastConfigurationError(
                &#34;Invalid forecast configuration&#34;,
                config=config,
            ) from exc

    @staticmethod
    def validate_base_period(base_period: str, available_periods: list[str], node_name: str) -&gt; None:
        &#34;&#34;&#34;Validate that a base period is valid for forecasting.

        Args:
            base_period: The proposed base period.
            available_periods: List of available periods.
            node_name: Name of the node (for error messages).

        Raises:
            ValueError: If base period is invalid.
        &#34;&#34;&#34;
        if not base_period:
            raise ValueError(f&#34;No base period determined for node &#39;{node_name}&#39;&#34;)

        if base_period not in available_periods:
            raise ValueError(f&#34;Base period &#39;{base_period}&#39; for node &#39;{node_name}&#39; not found in available periods&#34;)

    @staticmethod
    def validate_forecast_result(
        results: dict[str, float],
        forecast_periods: list[str],
        node_name: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Validate forecast result values for completeness and type.

        Args:
            results: Dictionary mapping periods to forecast values.
            forecast_periods: List of periods that should be present in results.
            node_name: Optional name of the node for error context.

        Raises:
            ForecastResultError: If any forecast period is missing or value is not a float.

        Example:
            &gt;&gt;&gt; ForecastValidator.validate_forecast_result({&#34;2023&#34;: 1050.0}, [&#34;2023&#34;])
            # No exception means validation passed
        &#34;&#34;&#34;
        missing = [p for p in forecast_periods if p not in results]
        if missing:
            raise ForecastResultError(
                f&#34;Missing forecast results for periods: {&#39;, &#39;.join(missing)}&#34;,
                period=missing[0],
                available_periods=list(results.keys()),
                node_id=node_name,
            )
        for period, value in results.items():
            if not isinstance(value, int | float):
                raise ForecastResultError(
                    f&#34;Forecast value for period {period} is not a number&#34;,
                    period=period,
                    node_id=node_name,
                )</code></pre>
</details>
<div class="desc"><p>Validator for forecast inputs, configurations, and results.</p>
<p>Provides static methods to check the validity of forecast periods,
node configurations, and forecast results. Raises descriptive errors
for invalid input or output.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_base_period"><code class="name flex">
<span>def <span class="ident">validate_base_period</span></span>(<span>base_period: str, available_periods: list[str], node_name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_base_period(base_period: str, available_periods: list[str], node_name: str) -&gt; None:
    &#34;&#34;&#34;Validate that a base period is valid for forecasting.

    Args:
        base_period: The proposed base period.
        available_periods: List of available periods.
        node_name: Name of the node (for error messages).

    Raises:
        ValueError: If base period is invalid.
    &#34;&#34;&#34;
    if not base_period:
        raise ValueError(f&#34;No base period determined for node &#39;{node_name}&#39;&#34;)

    if base_period not in available_periods:
        raise ValueError(f&#34;Base period &#39;{base_period}&#39; for node &#39;{node_name}&#39; not found in available periods&#34;)</code></pre>
</details>
<div class="desc"><p>Validate that a base period is valid for forecasting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_period</code></strong></dt>
<dd>The proposed base period.</dd>
<dt><strong><code>available_periods</code></strong></dt>
<dd>List of available periods.</dd>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node (for error messages).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If base period is invalid.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_forecast_config"><code class="name flex">
<span>def <span class="ident">validate_forecast_config</span></span>(<span>config: dict[str, typing.Any]) ‑> <a title="fin_statement_model.forecasting.types.ForecastConfig" href="types.html#fin_statement_model.forecasting.types.ForecastConfig">ForecastConfig</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_forecast_config(config: dict[str, Any]) -&gt; ForecastConfig:
    &#34;&#34;&#34;Validate and parse a forecast configuration dictionary.

    Args:
        config: Dictionary with &#39;method&#39; and method-specific &#39;config&#39;.

    Returns:
        ForecastConfig: Validated and parsed configuration object.

    Raises:
        ForecastMethodError: If method is missing or invalid.
        ForecastConfigurationError: If config is missing or invalid.

    Example:
        &gt;&gt;&gt; ForecastValidator.validate_forecast_config({&#34;method&#34;: &#34;simple&#34;, &#34;config&#34;: 0.05})
        ForecastConfig(method=&#39;simple&#39;, config=0.05)
    &#34;&#34;&#34;
    if not isinstance(config, dict):
        raise ForecastConfigurationError(
            &#34;Forecast config must be a dictionary&#34;,
            config=config,
        )
    if &#34;method&#34; not in config:
        raise ForecastMethodError(
            &#34;Forecast config missing &#39;method&#39; key&#34;,
            method=None,
        )

    # Short-circuit: ensure the method itself is recognised so we raise the
    # domain-specific *ForecastMethodError* instead of a generic
    # ValidationError coming from pydantic.
    supported_methods: list[str] = [
        &#34;simple&#34;,
        &#34;curve&#34;,
        &#34;statistical&#34;,
        &#34;average&#34;,
        &#34;historical_growth&#34;,
    ]

    method_name: str = config[&#34;method&#34;]
    if method_name not in supported_methods:
        raise ForecastMethodError(
            &#34;Invalid forecast method&#34;,
            method=method_name,
            supported_methods=supported_methods,
        )

    # Create and validate using dataclass - ValidationError is converted to
    # a ForecastConfigurationError for consistency with the public API.
    try:
        return ForecastConfig(method=method_name, config=config[&#34;config&#34;])
    except ValidationError as exc:
        raise ForecastConfigurationError(
            &#34;Invalid forecast configuration&#34;,
            config=config,
        ) from exc</code></pre>
</details>
<div class="desc"><p>Validate and parse a forecast configuration dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Dictionary with 'method' and method-specific 'config'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastConfig" href="#fin_statement_model.forecasting.ForecastConfig">ForecastConfig</a></code></dt>
<dd>Validated and parsed configuration object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastMethodError" href="#fin_statement_model.forecasting.ForecastMethodError">ForecastMethodError</a></code></dt>
<dd>If method is missing or invalid.</dd>
<dt><code><a title="fin_statement_model.forecasting.ForecastConfigurationError" href="#fin_statement_model.forecasting.ForecastConfigurationError">ForecastConfigurationError</a></code></dt>
<dd>If config is missing or invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ForecastValidator.validate_forecast_config({&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05})
ForecastConfig(method='simple', config=0.05)
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_forecast_inputs"><code class="name flex">
<span>def <span class="ident">validate_forecast_inputs</span></span>(<span>historical_periods: list[str],<br>forecast_periods: list[str],<br>node_configs: dict[str, dict[str, typing.Any]] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_forecast_inputs(
    historical_periods: list[str],
    forecast_periods: list[str],
    node_configs: dict[str, dict[str, Any]] | None = None,
) -&gt; None:
    &#34;&#34;&#34;Validate forecast input periods and node configurations.

    Args:
        historical_periods: List of historical periods to use as base.
        forecast_periods: List of periods to forecast.
        node_configs: Optional mapping of node names to forecast configs.

    Raises:
        ForecastNodeError: If no historical or forecast periods are provided.
        ForecastConfigurationError: If node_configs is not a dict.

    Example:
        &gt;&gt;&gt; ForecastValidator.validate_forecast_inputs([&#34;2022&#34;], [&#34;2023&#34;])
        # No exception means validation passed
    &#34;&#34;&#34;
    if not historical_periods:
        raise ForecastNodeError(
            &#34;No historical periods provided for forecasting&#34;,
            node_id=None,
        )
    if not forecast_periods:
        raise ForecastNodeError(
            &#34;No forecast periods provided&#34;,
            node_id=None,
        )
    if node_configs is not None and not isinstance(node_configs, dict):
        raise ForecastConfigurationError(
            &#34;node_configs must be a dictionary&#34;,
            config=node_configs,
        )</code></pre>
</details>
<div class="desc"><p>Validate forecast input periods and node configurations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods to use as base.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
<dt><strong><code>node_configs</code></strong></dt>
<dd>Optional mapping of node names to forecast configs.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If no historical or forecast periods are provided.</dd>
<dt><code><a title="fin_statement_model.forecasting.ForecastConfigurationError" href="#fin_statement_model.forecasting.ForecastConfigurationError">ForecastConfigurationError</a></code></dt>
<dd>If node_configs is not a dict.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ForecastValidator.validate_forecast_inputs([&quot;2022&quot;], [&quot;2023&quot;])
# No exception means validation passed
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_forecast_result"><code class="name flex">
<span>def <span class="ident">validate_forecast_result</span></span>(<span>results: dict[str, float],<br>forecast_periods: list[str],<br>node_name: str | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_forecast_result(
    results: dict[str, float],
    forecast_periods: list[str],
    node_name: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Validate forecast result values for completeness and type.

    Args:
        results: Dictionary mapping periods to forecast values.
        forecast_periods: List of periods that should be present in results.
        node_name: Optional name of the node for error context.

    Raises:
        ForecastResultError: If any forecast period is missing or value is not a float.

    Example:
        &gt;&gt;&gt; ForecastValidator.validate_forecast_result({&#34;2023&#34;: 1050.0}, [&#34;2023&#34;])
        # No exception means validation passed
    &#34;&#34;&#34;
    missing = [p for p in forecast_periods if p not in results]
    if missing:
        raise ForecastResultError(
            f&#34;Missing forecast results for periods: {&#39;, &#39;.join(missing)}&#34;,
            period=missing[0],
            available_periods=list(results.keys()),
            node_id=node_name,
        )
    for period, value in results.items():
        if not isinstance(value, int | float):
            raise ForecastResultError(
                f&#34;Forecast value for period {period} is not a number&#34;,
                period=period,
                node_id=node_name,
            )</code></pre>
</details>
<div class="desc"><p>Validate forecast result values for completeness and type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>Dictionary mapping periods to forecast values.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods that should be present in results.</dd>
<dt><strong><code>node_name</code></strong></dt>
<dd>Optional name of the node for error context.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastResultError" href="#fin_statement_model.forecasting.ForecastResultError">ForecastResultError</a></code></dt>
<dd>If any forecast period is missing or value is not a float.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ForecastValidator.validate_forecast_result({&quot;2023&quot;: 1050.0}, [&quot;2023&quot;])
# No exception means validation passed
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_node_config"><code class="name flex">
<span>def <span class="ident">validate_node_config</span></span>(<span>node_name: str, config: dict[str, typing.Any]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_node_config(node_name: str, config: dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Validate configuration for a single node.

    Args:
        node_name: Name of the node being configured.
        config: Configuration dictionary for the node.

    Raises:
        ValueError: If configuration is logically invalid.
        TypeError: If configuration is of wrong type.
    &#34;&#34;&#34;
    if not isinstance(config, dict):
        raise TypeError(f&#34;Configuration for node &#39;{node_name}&#39; must be a dict, got {type(config)}&#34;)

    # Validate method
    if &#34;method&#34; not in config:
        raise ValueError(f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;method&#39; key&#34;)

    method = config[&#34;method&#34;]
    valid_methods: list[ForecastMethodType] = [
        &#34;simple&#34;,
        &#34;curve&#34;,
        &#34;statistical&#34;,
        &#34;average&#34;,
        &#34;historical_growth&#34;,
    ]
    if method not in valid_methods:
        raise ValueError(
            f&#34;Invalid forecast method &#39;{method}&#39; for node &#39;{node_name}&#39;. Valid methods: {valid_methods}&#34;
        )

    # Validate config exists (can be None for some methods)
    if &#34;config&#34; not in config:
        raise ValueError(f&#34;Configuration for node &#39;{node_name}&#39; missing required &#39;config&#39; key&#34;)</code></pre>
</details>
<div class="desc"><p>Validate configuration for a single node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node being configured.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Configuration dictionary for the node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If configuration is logically invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If configuration is of wrong type.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.forecasting.ForecastValidator.validate_node_for_forecast"><code class="name flex">
<span>def <span class="ident">validate_node_for_forecast</span></span>(<span>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>method: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_node_for_forecast(node: Node, method: str) -&gt; None:
    &#34;&#34;&#34;Validate that a node is forecastable with the given method.

    Args:
        node: The node object to check.
        method: The forecast method to use.

    Raises:
        ForecastNodeError: If the node is not forecastable.

    Example:
        &gt;&gt;&gt; class DummyNode:
        ...     values = {&#34;2022&#34;: 100.0}
        &gt;&gt;&gt; ForecastValidator.validate_node_for_forecast(DummyNode(), &#34;simple&#34;)
        # No exception means validation passed
    &#34;&#34;&#34;
    # Reference the supplied `method` argument for transparency and to comply with linters.
    logger.debug(
        &#34;Validating node &#39;%s&#39; for forecast method &#39;%s&#39;&#34;,
        node.name,
        method,
    )

    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ForecastNodeError(
            f&#34;Node {node.name} is not forecastable (missing &#39;values&#39; dict)&#34;,
            node_id=node.name,
        )</code></pre>
</details>
<div class="desc"><p>Validate that a node is forecastable with the given method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node object to check.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>The forecast method to use.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If the node is not forecastable.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode:
...     values = {&quot;2022&quot;: 100.0}
&gt;&gt;&gt; ForecastValidator.validate_node_for_forecast(DummyNode(), &quot;simple&quot;)
# No exception means validation passed
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.ForecastingError"><code class="flex name class">
<span>class <span class="ident">ForecastingError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastingError(FinancialModelError):
    &#34;&#34;&#34;Base exception for all forecasting-related errors.

    All custom forecasting exceptions inherit from this class.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Base exception for all forecasting-related errors.</p>
<p>All custom forecasting exceptions inherit from this class.</p>
<p>Initialize the FinancialModelError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>A human-readable description of the error.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.errors.ForecastConfigurationError" href="errors.html#fin_statement_model.forecasting.errors.ForecastConfigurationError">ForecastConfigurationError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastMethodError" href="errors.html#fin_statement_model.forecasting.errors.ForecastMethodError">ForecastMethodError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastNodeError" href="errors.html#fin_statement_model.forecasting.errors.ForecastNodeError">ForecastNodeError</a></li>
<li><a title="fin_statement_model.forecasting.errors.ForecastResultError" href="errors.html#fin_statement_model.forecasting.errors.ForecastResultError">ForecastResultError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod"><code class="flex name class">
<span>class <span class="ident">HistoricalGrowthForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HistoricalGrowthForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values based on average historical growth patterns.

    This method calculates the average historical growth rate and applies it to
    forecast future values. Useful when past growth patterns are expected to
    continue.

    Configuration:
        - Not required (pass None or 0)
        - Growth is automatically calculated from historical data

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.historical_growth import HistoricalGrowthForecastMethod
        &gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; params[&#34;forecast_type&#34;]
        &#39;historical_growth&#39;
        &gt;&gt;&gt; params[&#34;growth_params&#34;] is None
        True
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (&#39;historical_growth&#39;).
        &#34;&#34;&#34;
        return &#34;historical_growth&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type used by ``NodeFactory``.

        The historical-growth calculation re-uses the *Average-Growth* forecast
        node implementation, so we have to return ``&#34;average_growth&#34;`` - that is
        the key registered in ``ForecastTypeRegistry``.  Mapping the public
        method name (``historical_growth``) to this internal type allows the
        validator/registry look-up to succeed.
        &#34;&#34;&#34;
        return &#34;average_growth&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for historical growth method.

        Args:
            config: Not used for historical growth method, can be None or 0.

        Note:
            Historical growth method doesn&#39;t require configuration as it
            calculates growth from historical data automatically.
        &#34;&#34;&#34;
        # Historical growth method doesn&#39;t need specific configuration
        # Accept None, 0, or any placeholder value

    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Not used for historical growth method.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            For historical growth method, growth_params is None.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.methods.historical_growth import HistoricalGrowthForecastMethod
            &gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
            &gt;&gt;&gt; method.normalize_params(None, [&#34;2024&#34;, &#34;2025&#34;])
            {&#39;forecast_type&#39;: &#39;historical_growth&#39;, &#39;growth_params&#39;: None}
        &#34;&#34;&#34;
        _ = (config, forecast_periods)  # Parameters intentionally unused
        return {
            &#34;forecast_type&#34;: self.internal_type,
            &#34;growth_params&#34;: None,  # Historical growth method calculates internally
        }

    def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
        &#34;&#34;&#34;Prepare historical data for growth calculation.

        Args:
            node: The node to extract historical data from.
            historical_periods: List of historical periods.

        Returns:
            List of valid historical values (at least 2 needed for growth).

        Raises:
            ValueError: If insufficient historical data is available.

        Example:
            &gt;&gt;&gt; # This method is called internally by the forecasting engine.
        &#34;&#34;&#34;
        if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
            raise ValueError(f&#34;Node {node.name} cannot be calculated for historical growth method&#34;)

        if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
            raise ValueError(f&#34;Node {node.name} does not have values dictionary for historical growth method&#34;)

        # Extract historical values in chronological order
        historical_values = []
        for period in historical_periods:
            if period in node.values:
                try:
                    value = node.calculate(period)
                    if value is not None and not np.isnan(value) and not np.isinf(value):
                        historical_values.append(float(value))
                except (ValueError, TypeError, ArithmeticError) as e:
                    # Log the exception and skip this period
                    logger.debug(
                        &#34;Skipping period %s for node %s in historical growth calculation: %s&#34;, period, node.name, e
                    )
                    continue

        min_periods = cfg(&#34;forecasting.min_historical_periods&#34;)
        if len(historical_values) &lt; min_periods:
            raise ValueError(
                f&#34;Need at least {min_periods} historical data points for node {node.name} &#34;
                f&#34;to compute growth rate, found {len(historical_values)}&#34;
            )

        return historical_values

    def calculate_average_growth_rate(self, historical_values: list[float]) -&gt; float:
        &#34;&#34;&#34;Calculate the average growth rate from historical values.

        Args:
            historical_values: List of historical values in chronological order.

        Returns:
            Average growth rate.

        Note:
            This is a helper method that can be used by the forecast node
            implementation to calculate the growth rate.

        Example:
            &gt;&gt;&gt; # This method is called internally by the forecasting engine.
        &#34;&#34;&#34;
        # Calculate period-over-period growth rates
        if len(historical_values) &lt; MIN_HISTORY_POINTS:
            return 0.0

        growth_rates: list[float] = []
        for i in range(1, len(historical_values)):
            previous_value = historical_values[i - 1]
            if previous_value != 0:
                growth_rates.append((historical_values[i] - previous_value) / previous_value)

        if not growth_rates:
            return 0.0

        # Determine aggregation method: &#39;mean&#39; or &#39;median&#39;
        agg_method = cfg(&#34;forecasting.historical_growth_aggregation&#34;)
        if agg_method == &#34;median&#34;:
            try:
                result = float(np.median(growth_rates))
            except (ValueError, TypeError) as e:
                logger.warning(
                    &#34;Failed to calculate median growth rate, falling back to mean: %s&#34;,
                    e,
                )
                result = float(np.mean(growth_rates))
        else:
            # Default to mean aggregation
            result = float(np.mean(growth_rates))

        # Mitigate floating-point artefacts so equality comparisons in tests
        # (e.g. 0.15000000000000002 vs. 0.15) do not fail spuriously.
        return float(round(result, 12))</code></pre>
</details>
<div class="desc"><p>Forecast future values based on average historical growth patterns.</p>
<p>This method calculates the average historical growth rate and applies it to
forecast future values. Useful when past growth patterns are expected to
continue.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Not required (pass None or 0)</li>
<li>Growth is automatically calculated from historical data</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.historical_growth import HistoricalGrowthForecastMethod
&gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(None, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; params[&quot;forecast_type&quot;]
'historical_growth'
&gt;&gt;&gt; params[&quot;growth_params&quot;] is None
True
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type used by ``NodeFactory``.

    The historical-growth calculation re-uses the *Average-Growth* forecast
    node implementation, so we have to return ``&#34;average_growth&#34;`` - that is
    the key registered in ``ForecastTypeRegistry``.  Mapping the public
    method name (``historical_growth``) to this internal type allows the
    validator/registry look-up to succeed.
    &#34;&#34;&#34;
    return &#34;average_growth&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type used by <code>NodeFactory</code>.</p>
<p>The historical-growth calculation re-uses the <em>Average-Growth</em> forecast
node implementation, so we have to return <code>"average_growth"</code> - that is
the key registered in <code>ForecastTypeRegistry</code>.
Mapping the public
method name (<code>historical_growth</code>) to this internal type allows the
validator/registry look-up to succeed.</p></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (&#39;historical_growth&#39;).
    &#34;&#34;&#34;
    return &#34;historical_growth&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method ('historical_growth').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.calculate_average_growth_rate"><code class="name flex">
<span>def <span class="ident">calculate_average_growth_rate</span></span>(<span>self, historical_values: list[float]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_average_growth_rate(self, historical_values: list[float]) -&gt; float:
    &#34;&#34;&#34;Calculate the average growth rate from historical values.

    Args:
        historical_values: List of historical values in chronological order.

    Returns:
        Average growth rate.

    Note:
        This is a helper method that can be used by the forecast node
        implementation to calculate the growth rate.

    Example:
        &gt;&gt;&gt; # This method is called internally by the forecasting engine.
    &#34;&#34;&#34;
    # Calculate period-over-period growth rates
    if len(historical_values) &lt; MIN_HISTORY_POINTS:
        return 0.0

    growth_rates: list[float] = []
    for i in range(1, len(historical_values)):
        previous_value = historical_values[i - 1]
        if previous_value != 0:
            growth_rates.append((historical_values[i] - previous_value) / previous_value)

    if not growth_rates:
        return 0.0

    # Determine aggregation method: &#39;mean&#39; or &#39;median&#39;
    agg_method = cfg(&#34;forecasting.historical_growth_aggregation&#34;)
    if agg_method == &#34;median&#34;:
        try:
            result = float(np.median(growth_rates))
        except (ValueError, TypeError) as e:
            logger.warning(
                &#34;Failed to calculate median growth rate, falling back to mean: %s&#34;,
                e,
            )
            result = float(np.mean(growth_rates))
    else:
        # Default to mean aggregation
        result = float(np.mean(growth_rates))

    # Mitigate floating-point artefacts so equality comparisons in tests
    # (e.g. 0.15000000000000002 vs. 0.15) do not fail spuriously.
    return float(round(result, 12))</code></pre>
</details>
<div class="desc"><p>Calculate the average growth rate from historical values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>historical_values</code></strong></dt>
<dd>List of historical values in chronological order.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Average growth rate.</p>
<h2 id="note">Note</h2>
<p>This is a helper method that can be used by the forecast node
implementation to calculate the growth rate.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # This method is called internally by the forecasting engine.
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Not used for historical growth method.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        For historical growth method, growth_params is None.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.historical_growth import HistoricalGrowthForecastMethod
        &gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
        &gt;&gt;&gt; method.normalize_params(None, [&#34;2024&#34;, &#34;2025&#34;])
        {&#39;forecast_type&#39;: &#39;historical_growth&#39;, &#39;growth_params&#39;: None}
    &#34;&#34;&#34;
    _ = (config, forecast_periods)  # Parameters intentionally unused
    return {
        &#34;forecast_type&#34;: self.internal_type,
        &#34;growth_params&#34;: None,  # Historical growth method calculates internally
    }</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for historical growth method.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
For historical growth method, growth_params is None.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.historical_growth import HistoricalGrowthForecastMethod
&gt;&gt;&gt; method = HistoricalGrowthForecastMethod()
&gt;&gt;&gt; method.normalize_params(None, [&quot;2024&quot;, &quot;2025&quot;])
{'forecast_type': 'historical_growth', 'growth_params': None}
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.prepare_historical_data"><code class="name flex">
<span>def <span class="ident">prepare_historical_data</span></span>(<span>self,<br>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str]) ‑> list[float] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_historical_data(self, node: Node, historical_periods: list[str]) -&gt; list[float] | None:
    &#34;&#34;&#34;Prepare historical data for growth calculation.

    Args:
        node: The node to extract historical data from.
        historical_periods: List of historical periods.

    Returns:
        List of valid historical values (at least 2 needed for growth).

    Raises:
        ValueError: If insufficient historical data is available.

    Example:
        &gt;&gt;&gt; # This method is called internally by the forecasting engine.
    &#34;&#34;&#34;
    if not hasattr(node, &#34;calculate&#34;) or not callable(node.calculate):
        raise ValueError(f&#34;Node {node.name} cannot be calculated for historical growth method&#34;)

    if not hasattr(node, &#34;values&#34;) or not isinstance(node.values, dict):
        raise ValueError(f&#34;Node {node.name} does not have values dictionary for historical growth method&#34;)

    # Extract historical values in chronological order
    historical_values = []
    for period in historical_periods:
        if period in node.values:
            try:
                value = node.calculate(period)
                if value is not None and not np.isnan(value) and not np.isinf(value):
                    historical_values.append(float(value))
            except (ValueError, TypeError, ArithmeticError) as e:
                # Log the exception and skip this period
                logger.debug(
                    &#34;Skipping period %s for node %s in historical growth calculation: %s&#34;, period, node.name, e
                )
                continue

    min_periods = cfg(&#34;forecasting.min_historical_periods&#34;)
    if len(historical_values) &lt; min_periods:
        raise ValueError(
            f&#34;Need at least {min_periods} historical data points for node {node.name} &#34;
            f&#34;to compute growth rate, found {len(historical_values)}&#34;
        )

    return historical_values</code></pre>
</details>
<div class="desc"><p>Prepare historical data for growth calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to extract historical data from.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of valid historical values (at least 2 needed for growth).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If insufficient historical data is available.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # This method is called internally by the forecasting engine.
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for historical growth method.

    Args:
        config: Not used for historical growth method, can be None or 0.

    Note:
        Historical growth method doesn&#39;t require configuration as it
        calculates growth from historical data automatically.
    &#34;&#34;&#34;
    # Historical growth method doesn&#39;t need specific configuration
    # Accept None, 0, or any placeholder value</code></pre>
</details>
<div class="desc"><p>Validate the configuration for historical growth method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Not used for historical growth method, can be None or 0.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Historical growth method doesn't require configuration as it
calculates growth from historical data automatically.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager"><code class="flex name class">
<span>class <span class="ident">PeriodManager</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PeriodManager:
    &#34;&#34;&#34;Infer and manage forecasting periods.

    Provides utilities to infer historical periods, determine base periods,
    validate period sequences, and manage period transitions on the graph.
    &#34;&#34;&#34;

    @staticmethod
    def infer_historical_periods(
        graph: Any,
        forecast_periods: list[str],
        provided_periods: list[str] | None = None,
    ) -&gt; list[str]:
        &#34;&#34;&#34;Infer historical periods from graph state.

        Args:
            graph: The financial statement graph instance.
            forecast_periods: List of periods to forecast.
            provided_periods: Optional explicitly provided historical periods.

        Returns:
            List of historical periods.

        Raises:
            ValueError: If historical periods cannot be determined.

        Example:
            &gt;&gt;&gt; class DummyGraph:
            ...     periods = [&#34;2022&#34;, &#34;2023&#34;, &#34;2024&#34;]
            &gt;&gt;&gt; PeriodManager.infer_historical_periods(DummyGraph, [&#34;2024&#34;])
            [&#39;2022&#39;, &#39;2023&#39;]
        &#34;&#34;&#34;
        # If explicitly provided, use them
        if provided_periods is not None:
            logger.debug(
                &#34;Using explicitly provided historical periods: %s&#34;,
                provided_periods,
            )
            return provided_periods

        # Infer from graph periods and forecast periods
        if not hasattr(graph, &#34;periods&#34;) or not graph.periods:
            raise ValueError(&#34;Cannot infer historical periods: graph has no periods attribute&#34;)

        if not forecast_periods:
            raise ValueError(&#34;Cannot infer historical periods: no forecast periods provided&#34;)

        # Try to find where forecast periods start
        first_forecast = forecast_periods[0]
        try:
            idx = graph.periods.index(first_forecast)
            historical_periods = cast(&#34;list[str]&#34;, graph.periods[:idx])
            logger.debug(
                &#34;Inferred historical periods by splitting at %s: %s&#34;,
                first_forecast,
                historical_periods,
            )
        except ValueError:
            # First forecast period not in graph periods
            # Assume all current periods are historical
            historical_periods = cast(&#34;list[str]&#34;, list(graph.periods))
            logger.warning(
                &#34;First forecast period %s not found in graph periods. Using all existing periods as historical: %s&#34;,
                first_forecast,
                historical_periods,
            )

        if not historical_periods:
            raise ValueError(&#34;No historical periods found. Ensure graph has periods before the first forecast period.&#34;)

        return historical_periods

    @staticmethod
    def determine_base_period(
        node: Node,
        historical_periods: list[str],
        preferred_period: str | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Determine the base period for forecasting a node.

        Args:
            node: The node to forecast.
            historical_periods: List of available historical periods.
            preferred_period: Optional preferred base period.

        Returns:
            The base period to use for forecasting.

        Raises:
            ValueError: If no valid base period can be determined.

        Example:
            &gt;&gt;&gt; class DummyNode:
            ...     name = &#34;revenue&#34;
            ...     values = {&#34;2022&#34;: 100, &#34;2023&#34;: 110}
            &gt;&gt;&gt; PeriodManager.determine_base_period(DummyNode, [&#34;2022&#34;, &#34;2023&#34;])
            &#39;2023&#39;
        &#34;&#34;&#34;
        if not historical_periods:
            raise ValueError(&#34;No historical periods provided&#34;)

        # Determine strategy for selecting base period
        strategy = cfg(&#34;forecasting.base_period_strategy&#34;)

        # Validate strategy
        valid_strategies = {
            &#34;preferred_then_most_recent&#34;,
            &#34;most_recent&#34;,
            &#34;last_historical&#34;,
        }
        if strategy not in valid_strategies:
            logger.warning(
                &#34;Unknown base period strategy &#39;%s&#39;, falling back to &#39;preferred_then_most_recent&#39;&#34;,
                strategy,
            )
            strategy = &#34;preferred_then_most_recent&#34;

        # 1. preferred_then_most_recent: check preferred first
        if (
            strategy == &#34;preferred_then_most_recent&#34;
            and preferred_period
            and preferred_period in historical_periods
            and hasattr(node, &#34;values&#34;)
            and isinstance(getattr(node, &#34;values&#34;, {}), dict)
            and preferred_period in getattr(node, &#34;values&#34;, {})
        ):
            return preferred_period

        # 2. most_recent: pick most recent available data
        if (
            strategy in (&#34;preferred_then_most_recent&#34;, &#34;most_recent&#34;)
            and hasattr(node, &#34;values&#34;)
            and isinstance(getattr(node, &#34;values&#34;, None), dict)
        ):
            values_dict = node.values
            available_periods = [p for p in historical_periods if p in values_dict]
            if available_periods:
                return available_periods[-1]

        # 3. last_historical: always use last in historical_periods
        if strategy == &#34;last_historical&#34;:
            return historical_periods[-1]

        # Final fallback: use last historical period
        base_period = historical_periods[-1]
        logger.info(
            &#34;Using last historical period as base for %s: %s (node may lack values)&#34;,
            node.name,
            base_period,
        )
        return base_period

    @staticmethod
    def validate_period_sequence(periods: list[str]) -&gt; None:
        &#34;&#34;&#34;Validate that a period sequence is valid.

        Args:
            periods: List of periods to validate.

        Raises:
            ValueError: If the period sequence is invalid.

        Example:
            &gt;&gt;&gt; PeriodManager.validate_period_sequence([&#34;2022&#34;, &#34;2023&#34;, &#34;2024&#34;])
            &gt;&gt;&gt; PeriodManager.validate_period_sequence([&#34;2022&#34;, &#34;2022&#34;])
            Traceback (most recent call last):
                ...
            ValueError: Period sequence contains duplicates: {&#39;2022&#39;}
        &#34;&#34;&#34;
        if not periods:
            raise ValueError(&#34;Period sequence cannot be empty&#34;)

        if len(periods) != len(set(periods)):
            duplicates = [p for p in periods if periods.count(p) &gt; 1]
            raise ValueError(f&#34;Period sequence contains duplicates: {set(duplicates)}&#34;)

    @staticmethod
    def get_period_index(period: str, periods: list[str]) -&gt; int:
        &#34;&#34;&#34;Get the index of a period in a period list.

        Args:
            period: The period to find.
            periods: List of periods.

        Returns:
            The index of the period.

        Raises:
            ValueError: If period not found in list.

        Example:
            &gt;&gt;&gt; PeriodManager.get_period_index(&#34;2023&#34;, [&#34;2022&#34;, &#34;2023&#34;, &#34;2024&#34;])
            1
        &#34;&#34;&#34;
        try:
            return periods.index(period)
        except ValueError:
            raise ValueError(f&#34;Period &#39;{period}&#39; not found in period list&#34;) from None

    @staticmethod
    def ensure_periods_exist(graph: Any, periods: list[str], add_missing: bool = True) -&gt; list[str]:
        &#34;&#34;&#34;Ensure periods exist in the graph.

        Args:
            graph: The financial statement graph instance.
            periods: List of periods that should exist.
            add_missing: Whether to add missing periods to the graph.

        Returns:
            List of periods that were added (empty if none).

        Raises:
            ValueError: If add_missing is False and periods are missing.

        Example:
            &gt;&gt;&gt; class DummyGraph:
            ...     periods = [&#34;2022&#34;, &#34;2023&#34;]
            ...
            ...     def add_periods(self, periods):
            ...         self.periods.extend(periods)
            &gt;&gt;&gt; graph = DummyGraph()
            &gt;&gt;&gt; PeriodManager.ensure_periods_exist(graph, [&#34;2024&#34;], add_missing=True)
            [&#39;2024&#39;]
        &#34;&#34;&#34;
        if not hasattr(graph, &#34;periods&#34;):
            raise ValueError(&#34;Graph does not have a periods attribute&#34;)

        existing_periods = set(graph.periods)
        missing_periods = [p for p in periods if p not in existing_periods]

        if missing_periods:
            if add_missing:
                # Add missing periods to graph
                if hasattr(graph, &#34;add_periods&#34;) and callable(graph.add_periods):
                    graph.add_periods(missing_periods)
                    logger.info(&#34;Added missing periods to graph: %s&#34;, missing_periods)
                else:
                    raise ValueError(f&#34;Graph is missing periods {missing_periods} but has no add_periods method&#34;)
            else:
                raise ValueError(f&#34;The following periods do not exist in the graph: {missing_periods}&#34;)

        return missing_periods</code></pre>
</details>
<div class="desc"><p>Infer and manage forecasting periods.</p>
<p>Provides utilities to infer historical periods, determine base periods,
validate period sequences, and manage period transitions on the graph.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.PeriodManager.determine_base_period"><code class="name flex">
<span>def <span class="ident">determine_base_period</span></span>(<span>node: <a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>historical_periods: list[str],<br>preferred_period: str | None = None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def determine_base_period(
    node: Node,
    historical_periods: list[str],
    preferred_period: str | None = None,
) -&gt; str:
    &#34;&#34;&#34;Determine the base period for forecasting a node.

    Args:
        node: The node to forecast.
        historical_periods: List of available historical periods.
        preferred_period: Optional preferred base period.

    Returns:
        The base period to use for forecasting.

    Raises:
        ValueError: If no valid base period can be determined.

    Example:
        &gt;&gt;&gt; class DummyNode:
        ...     name = &#34;revenue&#34;
        ...     values = {&#34;2022&#34;: 100, &#34;2023&#34;: 110}
        &gt;&gt;&gt; PeriodManager.determine_base_period(DummyNode, [&#34;2022&#34;, &#34;2023&#34;])
        &#39;2023&#39;
    &#34;&#34;&#34;
    if not historical_periods:
        raise ValueError(&#34;No historical periods provided&#34;)

    # Determine strategy for selecting base period
    strategy = cfg(&#34;forecasting.base_period_strategy&#34;)

    # Validate strategy
    valid_strategies = {
        &#34;preferred_then_most_recent&#34;,
        &#34;most_recent&#34;,
        &#34;last_historical&#34;,
    }
    if strategy not in valid_strategies:
        logger.warning(
            &#34;Unknown base period strategy &#39;%s&#39;, falling back to &#39;preferred_then_most_recent&#39;&#34;,
            strategy,
        )
        strategy = &#34;preferred_then_most_recent&#34;

    # 1. preferred_then_most_recent: check preferred first
    if (
        strategy == &#34;preferred_then_most_recent&#34;
        and preferred_period
        and preferred_period in historical_periods
        and hasattr(node, &#34;values&#34;)
        and isinstance(getattr(node, &#34;values&#34;, {}), dict)
        and preferred_period in getattr(node, &#34;values&#34;, {})
    ):
        return preferred_period

    # 2. most_recent: pick most recent available data
    if (
        strategy in (&#34;preferred_then_most_recent&#34;, &#34;most_recent&#34;)
        and hasattr(node, &#34;values&#34;)
        and isinstance(getattr(node, &#34;values&#34;, None), dict)
    ):
        values_dict = node.values
        available_periods = [p for p in historical_periods if p in values_dict]
        if available_periods:
            return available_periods[-1]

    # 3. last_historical: always use last in historical_periods
    if strategy == &#34;last_historical&#34;:
        return historical_periods[-1]

    # Final fallback: use last historical period
    base_period = historical_periods[-1]
    logger.info(
        &#34;Using last historical period as base for %s: %s (node may lack values)&#34;,
        node.name,
        base_period,
    )
    return base_period</code></pre>
</details>
<div class="desc"><p>Determine the base period for forecasting a node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node to forecast.</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>List of available historical periods.</dd>
<dt><strong><code>preferred_period</code></strong></dt>
<dd>Optional preferred base period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The base period to use for forecasting.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no valid base period can be determined.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode:
...     name = &quot;revenue&quot;
...     values = {&quot;2022&quot;: 100, &quot;2023&quot;: 110}
&gt;&gt;&gt; PeriodManager.determine_base_period(DummyNode, [&quot;2022&quot;, &quot;2023&quot;])
'2023'
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.ensure_periods_exist"><code class="name flex">
<span>def <span class="ident">ensure_periods_exist</span></span>(<span>graph: Any, periods: list[str], add_missing: bool = True) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ensure_periods_exist(graph: Any, periods: list[str], add_missing: bool = True) -&gt; list[str]:
    &#34;&#34;&#34;Ensure periods exist in the graph.

    Args:
        graph: The financial statement graph instance.
        periods: List of periods that should exist.
        add_missing: Whether to add missing periods to the graph.

    Returns:
        List of periods that were added (empty if none).

    Raises:
        ValueError: If add_missing is False and periods are missing.

    Example:
        &gt;&gt;&gt; class DummyGraph:
        ...     periods = [&#34;2022&#34;, &#34;2023&#34;]
        ...
        ...     def add_periods(self, periods):
        ...         self.periods.extend(periods)
        &gt;&gt;&gt; graph = DummyGraph()
        &gt;&gt;&gt; PeriodManager.ensure_periods_exist(graph, [&#34;2024&#34;], add_missing=True)
        [&#39;2024&#39;]
    &#34;&#34;&#34;
    if not hasattr(graph, &#34;periods&#34;):
        raise ValueError(&#34;Graph does not have a periods attribute&#34;)

    existing_periods = set(graph.periods)
    missing_periods = [p for p in periods if p not in existing_periods]

    if missing_periods:
        if add_missing:
            # Add missing periods to graph
            if hasattr(graph, &#34;add_periods&#34;) and callable(graph.add_periods):
                graph.add_periods(missing_periods)
                logger.info(&#34;Added missing periods to graph: %s&#34;, missing_periods)
            else:
                raise ValueError(f&#34;Graph is missing periods {missing_periods} but has no add_periods method&#34;)
        else:
            raise ValueError(f&#34;The following periods do not exist in the graph: {missing_periods}&#34;)

    return missing_periods</code></pre>
</details>
<div class="desc"><p>Ensure periods exist in the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The financial statement graph instance.</dd>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods that should exist.</dd>
<dt><strong><code>add_missing</code></strong></dt>
<dd>Whether to add missing periods to the graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of periods that were added (empty if none).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If add_missing is False and periods are missing.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyGraph:
...     periods = [&quot;2022&quot;, &quot;2023&quot;]
...
...     def add_periods(self, periods):
...         self.periods.extend(periods)
&gt;&gt;&gt; graph = DummyGraph()
&gt;&gt;&gt; PeriodManager.ensure_periods_exist(graph, [&quot;2024&quot;], add_missing=True)
['2024']
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.get_period_index"><code class="name flex">
<span>def <span class="ident">get_period_index</span></span>(<span>period: str, periods: list[str]) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_period_index(period: str, periods: list[str]) -&gt; int:
    &#34;&#34;&#34;Get the index of a period in a period list.

    Args:
        period: The period to find.
        periods: List of periods.

    Returns:
        The index of the period.

    Raises:
        ValueError: If period not found in list.

    Example:
        &gt;&gt;&gt; PeriodManager.get_period_index(&#34;2023&#34;, [&#34;2022&#34;, &#34;2023&#34;, &#34;2024&#34;])
        1
    &#34;&#34;&#34;
    try:
        return periods.index(period)
    except ValueError:
        raise ValueError(f&#34;Period &#39;{period}&#39; not found in period list&#34;) from None</code></pre>
</details>
<div class="desc"><p>Get the index of a period in a period list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong></dt>
<dd>The period to find.</dd>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The index of the period.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If period not found in list.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; PeriodManager.get_period_index(&quot;2023&quot;, [&quot;2022&quot;, &quot;2023&quot;, &quot;2024&quot;])
1
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.infer_historical_periods"><code class="name flex">
<span>def <span class="ident">infer_historical_periods</span></span>(<span>graph: Any,<br>forecast_periods: list[str],<br>provided_periods: list[str] | None = None) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def infer_historical_periods(
    graph: Any,
    forecast_periods: list[str],
    provided_periods: list[str] | None = None,
) -&gt; list[str]:
    &#34;&#34;&#34;Infer historical periods from graph state.

    Args:
        graph: The financial statement graph instance.
        forecast_periods: List of periods to forecast.
        provided_periods: Optional explicitly provided historical periods.

    Returns:
        List of historical periods.

    Raises:
        ValueError: If historical periods cannot be determined.

    Example:
        &gt;&gt;&gt; class DummyGraph:
        ...     periods = [&#34;2022&#34;, &#34;2023&#34;, &#34;2024&#34;]
        &gt;&gt;&gt; PeriodManager.infer_historical_periods(DummyGraph, [&#34;2024&#34;])
        [&#39;2022&#39;, &#39;2023&#39;]
    &#34;&#34;&#34;
    # If explicitly provided, use them
    if provided_periods is not None:
        logger.debug(
            &#34;Using explicitly provided historical periods: %s&#34;,
            provided_periods,
        )
        return provided_periods

    # Infer from graph periods and forecast periods
    if not hasattr(graph, &#34;periods&#34;) or not graph.periods:
        raise ValueError(&#34;Cannot infer historical periods: graph has no periods attribute&#34;)

    if not forecast_periods:
        raise ValueError(&#34;Cannot infer historical periods: no forecast periods provided&#34;)

    # Try to find where forecast periods start
    first_forecast = forecast_periods[0]
    try:
        idx = graph.periods.index(first_forecast)
        historical_periods = cast(&#34;list[str]&#34;, graph.periods[:idx])
        logger.debug(
            &#34;Inferred historical periods by splitting at %s: %s&#34;,
            first_forecast,
            historical_periods,
        )
    except ValueError:
        # First forecast period not in graph periods
        # Assume all current periods are historical
        historical_periods = cast(&#34;list[str]&#34;, list(graph.periods))
        logger.warning(
            &#34;First forecast period %s not found in graph periods. Using all existing periods as historical: %s&#34;,
            first_forecast,
            historical_periods,
        )

    if not historical_periods:
        raise ValueError(&#34;No historical periods found. Ensure graph has periods before the first forecast period.&#34;)

    return historical_periods</code></pre>
</details>
<div class="desc"><p>Infer historical periods from graph state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The financial statement graph instance.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast.</dd>
<dt><strong><code>provided_periods</code></strong></dt>
<dd>Optional explicitly provided historical periods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of historical periods.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If historical periods cannot be determined.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyGraph:
...     periods = [&quot;2022&quot;, &quot;2023&quot;, &quot;2024&quot;]
&gt;&gt;&gt; PeriodManager.infer_historical_periods(DummyGraph, [&quot;2024&quot;])
['2022', '2023']
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.PeriodManager.validate_period_sequence"><code class="name flex">
<span>def <span class="ident">validate_period_sequence</span></span>(<span>periods: list[str]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_period_sequence(periods: list[str]) -&gt; None:
    &#34;&#34;&#34;Validate that a period sequence is valid.

    Args:
        periods: List of periods to validate.

    Raises:
        ValueError: If the period sequence is invalid.

    Example:
        &gt;&gt;&gt; PeriodManager.validate_period_sequence([&#34;2022&#34;, &#34;2023&#34;, &#34;2024&#34;])
        &gt;&gt;&gt; PeriodManager.validate_period_sequence([&#34;2022&#34;, &#34;2022&#34;])
        Traceback (most recent call last):
            ...
        ValueError: Period sequence contains duplicates: {&#39;2022&#39;}
    &#34;&#34;&#34;
    if not periods:
        raise ValueError(&#34;Period sequence cannot be empty&#34;)

    if len(periods) != len(set(periods)):
        duplicates = [p for p in periods if periods.count(p) &gt; 1]
        raise ValueError(f&#34;Period sequence contains duplicates: {set(duplicates)}&#34;)</code></pre>
</details>
<div class="desc"><p>Validate that a period sequence is valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods to validate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the period sequence is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; PeriodManager.validate_period_sequence([&quot;2022&quot;, &quot;2023&quot;, &quot;2024&quot;])
&gt;&gt;&gt; PeriodManager.validate_period_sequence([&quot;2022&quot;, &quot;2022&quot;])
Traceback (most recent call last):
    ...
ValueError: Period sequence contains duplicates: {'2022'}
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod"><code class="flex name class">
<span>class <span class="ident">SimpleForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values using a constant growth rate.

    This method applies a constant growth rate to the base value for all forecast
    periods.

    Configuration:
        - Single numeric value: The growth rate (e.g., 0.05 for 5% growth)
        - List with single value: Will use the first value

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
        &gt;&gt;&gt; method = SimpleForecastMethod()
        &gt;&gt;&gt; params = method.get_forecast_params(0.05, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; params[&#34;forecast_type&#34;]
        &#39;simple&#39;
        &gt;&gt;&gt; params[&#34;growth_params&#34;]
        0.05
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (&#39;simple&#39;).
        &#34;&#34;&#34;
        return &#34;simple&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

        Returns:
            The internal type string used by the node factory (&#39;simple&#39;).
        &#34;&#34;&#34;
        return &#34;simple&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for simple method.

        Args:
            config: Should be a numeric value or a list containing a numeric value.

        Raises:
            ValueError: If config is empty list.
            TypeError: If config is not numeric or a list with numeric value.
        &#34;&#34;&#34;
        if isinstance(config, list):
            if not config:
                raise ValueError(&#34;Simple method: empty list provided&#34;)
            if not isinstance(config[0], int | float):
                raise TypeError(f&#34;Simple method requires numeric growth rate, got {type(config[0])}&#34;)
        elif not isinstance(config, int | float):
            raise TypeError(f&#34;Simple method requires numeric growth rate, got {type(config)}&#34;)

    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: The growth rate (numeric or list with numeric).
            forecast_periods: List of periods to forecast (not used for simple method).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
            &gt;&gt;&gt; method = SimpleForecastMethod()
            &gt;&gt;&gt; method.normalize_params(0.05, [&#34;2024&#34;, &#34;2025&#34;])
            {&#39;forecast_type&#39;: &#39;simple&#39;, &#39;growth_params&#39;: 0.05}
        &#34;&#34;&#34;
        _ = (forecast_periods,)  # Parameter intentionally unused (config is used)
        # Handle list input - take first value
        growth_rate = float(config[0]) if isinstance(config, list) else float(config)

        return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rate}</code></pre>
</details>
<div class="desc"><p>Forecast future values using a constant growth rate.</p>
<p>This method applies a constant growth rate to the base value for all forecast
periods.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Single numeric value: The growth rate (e.g., 0.05 for 5% growth)</li>
<li>List with single value: Will use the first value</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
&gt;&gt;&gt; method = SimpleForecastMethod()
&gt;&gt;&gt; params = method.get_forecast_params(0.05, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; params[&quot;forecast_type&quot;]
'simple'
&gt;&gt;&gt; params[&quot;growth_params&quot;]
0.05
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

    Returns:
        The internal type string used by the node factory (&#39;simple&#39;).
    &#34;&#34;&#34;
    return &#34;simple&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type for NodeFactory.</p>
<h2 id="returns">Returns</h2>
<p>The internal type string used by the node factory ('simple').</p></div>
</dd>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (&#39;simple&#39;).
    &#34;&#34;&#34;
    return &#34;simple&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method ('simple').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: The growth rate (numeric or list with numeric).
        forecast_periods: List of periods to forecast (not used for simple method).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
        &gt;&gt;&gt; method = SimpleForecastMethod()
        &gt;&gt;&gt; method.normalize_params(0.05, [&#34;2024&#34;, &#34;2025&#34;])
        {&#39;forecast_type&#39;: &#39;simple&#39;, &#39;growth_params&#39;: 0.05}
    &#34;&#34;&#34;
    _ = (forecast_periods,)  # Parameter intentionally unused (config is used)
    # Handle list input - take first value
    growth_rate = float(config[0]) if isinstance(config, list) else float(config)

    return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: growth_rate}</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The growth rate (numeric or list with numeric).</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used for simple method).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.simple import SimpleForecastMethod
&gt;&gt;&gt; method = SimpleForecastMethod()
&gt;&gt;&gt; method.normalize_params(0.05, [&quot;2024&quot;, &quot;2025&quot;])
{'forecast_type': 'simple', 'growth_params': 0.05}
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.SimpleForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for simple method.

    Args:
        config: Should be a numeric value or a list containing a numeric value.

    Raises:
        ValueError: If config is empty list.
        TypeError: If config is not numeric or a list with numeric value.
    &#34;&#34;&#34;
    if isinstance(config, list):
        if not config:
            raise ValueError(&#34;Simple method: empty list provided&#34;)
        if not isinstance(config[0], int | float):
            raise TypeError(f&#34;Simple method requires numeric growth rate, got {type(config[0])}&#34;)
    elif not isinstance(config, int | float):
        raise TypeError(f&#34;Simple method requires numeric growth rate, got {type(config)}&#34;)</code></pre>
</details>
<div class="desc"><p>Validate the configuration for simple method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Should be a numeric value or a list containing a numeric value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If config is empty list.</dd>
<dt><code>TypeError</code></dt>
<dd>If config is not numeric or a list with numeric value.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster"><code class="flex name class">
<span>class <span class="ident">StatementForecaster</span></span>
<span>(</span><span>fsg: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementForecaster:
    &#34;&#34;&#34;Coordinate forecasting operations on a FinancialStatementGraph.

    This controller provides three high-level entry points:

    1. ``create_forecast`` - Mutates the graph and adds forecast values.
    2. ``forecast_value`` - Returns forecast values for a node without mutating the graph.
    3. ``forecast_multiple`` - Returns forecast results for multiple nodes in a batch.

    Args:
        fsg: The FinancialStatementGraph instance to operate on.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
        &gt;&gt;&gt; forecaster = StatementForecaster(graph)
        &gt;&gt;&gt; # Mutating forecast
        &gt;&gt;&gt; forecaster.create_forecast(
        ...     forecast_periods=[&#34;2024&#34;, &#34;2025&#34;], node_configs={&#34;revenue&#34;: {&#34;method&#34;: &#34;simple&#34;, &#34;config&#34;: 0.05}}
        ... )
        &gt;&gt;&gt; # Non-mutating forecast
        &gt;&gt;&gt; values = forecaster.forecast_value(&#34;revenue&#34;, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; assert isinstance(values, dict)
    &#34;&#34;&#34;

    def __init__(self, fsg: Any) -&gt; None:
        &#34;&#34;&#34;Initialize the StatementForecaster.

        Args:
            fsg: The FinancialStatementGraph instance this forecaster will operate on.
        &#34;&#34;&#34;
        self.fsg = fsg

    def create_forecast(
        self,
        forecast_periods: list[str],
        node_configs: dict[str, dict[str, Any]] | None = None,
        historical_periods: list[str] | None = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Add forecast data to the underlying graph (in-place).

        This method mutates the graph by adding new forecast periods and updating node values.
        It is suitable for scenarios where you want to persist forecast results.

        Args:
            forecast_periods: List of future periods to forecast (e.g., [&#34;2024&#34;, &#34;2025&#34;]).
            node_configs: Mapping of node names to their forecast configurations.
                Each config should contain:
                    - &#39;method&#39;: Forecasting method (e.g., &#39;simple&#39;, &#39;curve&#39;).
                    - &#39;config&#39;: Method-specific parameters (e.g., growth rate).
            historical_periods: Optional list of historical periods to use as base.
            **kwargs: Additional arguments (e.g., add_missing_periods: bool).

        Returns:
            None. The graph is modified in-place.

        Raises:
            ForecastNodeError: If a node is not found or configuration is invalid.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
            &gt;&gt;&gt; forecaster = StatementForecaster(graph)
            &gt;&gt;&gt; forecaster.create_forecast(
            ...     forecast_periods=[&#34;2024&#34;], node_configs={&#34;revenue&#34;: {&#34;method&#34;: &#34;simple&#34;, &#34;config&#34;: 0.05}}
            ... )
        &#34;&#34;&#34;
        logger.info(&#34;Creating forecast for periods %s&#34;, forecast_periods)
        historical_periods = PeriodManager.infer_historical_periods(self.fsg, forecast_periods, historical_periods)
        ForecastValidator.validate_forecast_inputs(historical_periods, forecast_periods, node_configs)
        add_missing = kwargs.get(&#34;add_missing_periods&#34;, cfg(&#34;forecasting.add_missing_periods&#34;))
        PeriodManager.ensure_periods_exist(self.fsg, forecast_periods, add_missing=add_missing)
        node_configs = node_configs or {}
        for node_name, raw_config in node_configs.items():
            node: Node | None = self.fsg.get_node(node_name)
            if node is None:
                raise ForecastNodeError(
                    f&#34;Node {node_name} not found in graph&#34;,
                    node_id=node_name,
                    available_nodes=list(self.fsg.nodes.keys()),
                )
            forecast_config = ForecastValidator.validate_forecast_config(raw_config)
            ForecastValidator.validate_node_for_forecast(node, forecast_config.method)
            _forecast_node_mutating(
                node=node,
                historical_periods=historical_periods,
                forecast_periods=forecast_periods,
                forecast_config=forecast_config,
                **kwargs,
            )

    def forecast_value(
        self,
        node_name: str,
        forecast_periods: list[str],
        base_period: str | None = None,
        forecast_config: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Return forecast values for a single node without mutating the graph.

        This method is ideal for what-if analysis, scenario comparison, or retrieving
        forecast values without persisting them to the graph.

        Args:
            node_name: Name of the node to forecast (e.g., &#39;revenue&#39;).
            forecast_periods: List of future periods to forecast.
            base_period: Optional base period to use for forecasting.
            forecast_config: Optional forecast configuration dict.
            **kwargs: Additional arguments (e.g., bad_forecast_value, allow_negative_forecasts).

        Returns:
            Dictionary mapping forecast periods to their calculated values.
            Example: {&#34;2024&#34;: 1050.0, &#34;2025&#34;: 1102.5}

        Raises:
            ForecastNodeError: If the node is not found or configuration is invalid.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
            &gt;&gt;&gt; forecaster = StatementForecaster(graph)
            &gt;&gt;&gt; values = forecaster.forecast_value(&#34;revenue&#34;, [&#34;2024&#34;, &#34;2025&#34;])
            &gt;&gt;&gt; assert isinstance(values, dict)
        &#34;&#34;&#34;
        return forecast_node_non_mutating(
            self.fsg,
            node_name=node_name,
            forecast_periods=forecast_periods,
            base_period=base_period,
            forecast_config=forecast_config,
            **kwargs,
        )

    def forecast_multiple(
        self,
        node_names: list[str],
        forecast_periods: list[str],
        forecast_configs: dict[str, dict[str, Any]] | None = None,
        base_period: str | None = None,
        **kwargs: Any,
    ) -&gt; dict[str, ForecastResult]:
        &#34;&#34;&#34;Return forecast results for multiple nodes without mutating the graph.

        This method is a convenience wrapper for batch forecasting. It returns a dictionary
        mapping node names to ForecastResult objects, each containing forecasted values and metadata.

        Args:
            node_names: List of node names to forecast.
            forecast_periods: List of future periods to forecast.
            forecast_configs: Optional mapping of node names to their forecast configs.
            base_period: Optional base period to use for all nodes.
            **kwargs: Additional arguments (e.g., continue_on_error).

        Returns:
            Dictionary mapping node names to ForecastResult objects.

        Raises:
            ForecastNodeError: If a node is not found and continue_on_error is False.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
            &gt;&gt;&gt; forecaster = StatementForecaster(graph)
            &gt;&gt;&gt; results = forecaster.forecast_multiple([&#34;revenue&#34;, &#34;costs&#34;], [&#34;2024&#34;, &#34;2025&#34;])
            &gt;&gt;&gt; assert &#34;revenue&#34; in results
            &gt;&gt;&gt; assert hasattr(results[&#34;revenue&#34;], &#34;values&#34;)
        &#34;&#34;&#34;
        return batch_forecast_values(
            fsg=self.fsg,
            node_names=node_names,
            forecast_periods=forecast_periods,
            forecast_configs=forecast_configs,
            base_period=base_period,
            **kwargs,
        )</code></pre>
</details>
<div class="desc"><p>Coordinate forecasting operations on a FinancialStatementGraph.</p>
<p>This controller provides three high-level entry points:</p>
<ol>
<li><code>create_forecast</code> - Mutates the graph and adds forecast values.</li>
<li><code>forecast_value</code> - Returns forecast values for a node without mutating the graph.</li>
<li><code>forecast_multiple</code> - Returns forecast results for multiple nodes in a batch.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fsg</code></strong></dt>
<dd>The FinancialStatementGraph instance to operate on.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
&gt;&gt;&gt; forecaster = StatementForecaster(graph)
&gt;&gt;&gt; # Mutating forecast
&gt;&gt;&gt; forecaster.create_forecast(
...     forecast_periods=[&quot;2024&quot;, &quot;2025&quot;], node_configs={&quot;revenue&quot;: {&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05}}
... )
&gt;&gt;&gt; # Non-mutating forecast
&gt;&gt;&gt; values = forecaster.forecast_value(&quot;revenue&quot;, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; assert isinstance(values, dict)
</code></pre>
<p>Initialize the StatementForecaster.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>fsg</code></strong></dt>
<dd>The FinancialStatementGraph instance this forecaster will operate on.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatementForecaster.create_forecast"><code class="name flex">
<span>def <span class="ident">create_forecast</span></span>(<span>self,<br>forecast_periods: list[str],<br>node_configs: dict[str, dict[str, Any]] | None = None,<br>historical_periods: list[str] | None = None,<br>**kwargs: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_forecast(
    self,
    forecast_periods: list[str],
    node_configs: dict[str, dict[str, Any]] | None = None,
    historical_periods: list[str] | None = None,
    **kwargs: Any,
) -&gt; None:
    &#34;&#34;&#34;Add forecast data to the underlying graph (in-place).

    This method mutates the graph by adding new forecast periods and updating node values.
    It is suitable for scenarios where you want to persist forecast results.

    Args:
        forecast_periods: List of future periods to forecast (e.g., [&#34;2024&#34;, &#34;2025&#34;]).
        node_configs: Mapping of node names to their forecast configurations.
            Each config should contain:
                - &#39;method&#39;: Forecasting method (e.g., &#39;simple&#39;, &#39;curve&#39;).
                - &#39;config&#39;: Method-specific parameters (e.g., growth rate).
        historical_periods: Optional list of historical periods to use as base.
        **kwargs: Additional arguments (e.g., add_missing_periods: bool).

    Returns:
        None. The graph is modified in-place.

    Raises:
        ForecastNodeError: If a node is not found or configuration is invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
        &gt;&gt;&gt; forecaster = StatementForecaster(graph)
        &gt;&gt;&gt; forecaster.create_forecast(
        ...     forecast_periods=[&#34;2024&#34;], node_configs={&#34;revenue&#34;: {&#34;method&#34;: &#34;simple&#34;, &#34;config&#34;: 0.05}}
        ... )
    &#34;&#34;&#34;
    logger.info(&#34;Creating forecast for periods %s&#34;, forecast_periods)
    historical_periods = PeriodManager.infer_historical_periods(self.fsg, forecast_periods, historical_periods)
    ForecastValidator.validate_forecast_inputs(historical_periods, forecast_periods, node_configs)
    add_missing = kwargs.get(&#34;add_missing_periods&#34;, cfg(&#34;forecasting.add_missing_periods&#34;))
    PeriodManager.ensure_periods_exist(self.fsg, forecast_periods, add_missing=add_missing)
    node_configs = node_configs or {}
    for node_name, raw_config in node_configs.items():
        node: Node | None = self.fsg.get_node(node_name)
        if node is None:
            raise ForecastNodeError(
                f&#34;Node {node_name} not found in graph&#34;,
                node_id=node_name,
                available_nodes=list(self.fsg.nodes.keys()),
            )
        forecast_config = ForecastValidator.validate_forecast_config(raw_config)
        ForecastValidator.validate_node_for_forecast(node, forecast_config.method)
        _forecast_node_mutating(
            node=node,
            historical_periods=historical_periods,
            forecast_periods=forecast_periods,
            forecast_config=forecast_config,
            **kwargs,
        )</code></pre>
</details>
<div class="desc"><p>Add forecast data to the underlying graph (in-place).</p>
<p>This method mutates the graph by adding new forecast periods and updating node values.
It is suitable for scenarios where you want to persist forecast results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of future periods to forecast (e.g., ["2024", "2025"]).</dd>
<dt><strong><code>node_configs</code></strong></dt>
<dd>Mapping of node names to their forecast configurations.
Each config should contain:
- 'method': Forecasting method (e.g., 'simple', 'curve').
- 'config': Method-specific parameters (e.g., growth rate).</dd>
<dt><strong><code>historical_periods</code></strong></dt>
<dd>Optional list of historical periods to use as base.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments (e.g., add_missing_periods: bool).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. The graph is modified in-place.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If a node is not found or configuration is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
&gt;&gt;&gt; forecaster = StatementForecaster(graph)
&gt;&gt;&gt; forecaster.create_forecast(
...     forecast_periods=[&quot;2024&quot;], node_configs={&quot;revenue&quot;: {&quot;method&quot;: &quot;simple&quot;, &quot;config&quot;: 0.05}}
... )
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.forecast_multiple"><code class="name flex">
<span>def <span class="ident">forecast_multiple</span></span>(<span>self,<br>node_names: list[str],<br>forecast_periods: list[str],<br>forecast_configs: dict[str, dict[str, Any]] | None = None,<br>base_period: str | None = None,<br>**kwargs: Any) ‑> dict[str, <a title="fin_statement_model.forecasting.ForecastResult" href="#fin_statement_model.forecasting.ForecastResult">ForecastResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_multiple(
    self,
    node_names: list[str],
    forecast_periods: list[str],
    forecast_configs: dict[str, dict[str, Any]] | None = None,
    base_period: str | None = None,
    **kwargs: Any,
) -&gt; dict[str, ForecastResult]:
    &#34;&#34;&#34;Return forecast results for multiple nodes without mutating the graph.

    This method is a convenience wrapper for batch forecasting. It returns a dictionary
    mapping node names to ForecastResult objects, each containing forecasted values and metadata.

    Args:
        node_names: List of node names to forecast.
        forecast_periods: List of future periods to forecast.
        forecast_configs: Optional mapping of node names to their forecast configs.
        base_period: Optional base period to use for all nodes.
        **kwargs: Additional arguments (e.g., continue_on_error).

    Returns:
        Dictionary mapping node names to ForecastResult objects.

    Raises:
        ForecastNodeError: If a node is not found and continue_on_error is False.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
        &gt;&gt;&gt; forecaster = StatementForecaster(graph)
        &gt;&gt;&gt; results = forecaster.forecast_multiple([&#34;revenue&#34;, &#34;costs&#34;], [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; assert &#34;revenue&#34; in results
        &gt;&gt;&gt; assert hasattr(results[&#34;revenue&#34;], &#34;values&#34;)
    &#34;&#34;&#34;
    return batch_forecast_values(
        fsg=self.fsg,
        node_names=node_names,
        forecast_periods=forecast_periods,
        forecast_configs=forecast_configs,
        base_period=base_period,
        **kwargs,
    )</code></pre>
</details>
<div class="desc"><p>Return forecast results for multiple nodes without mutating the graph.</p>
<p>This method is a convenience wrapper for batch forecasting. It returns a dictionary
mapping node names to ForecastResult objects, each containing forecasted values and metadata.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_names</code></strong></dt>
<dd>List of node names to forecast.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of future periods to forecast.</dd>
<dt><strong><code>forecast_configs</code></strong></dt>
<dd>Optional mapping of node names to their forecast configs.</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>Optional base period to use for all nodes.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments (e.g., continue_on_error).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping node names to ForecastResult objects.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If a node is not found and continue_on_error is False.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
&gt;&gt;&gt; forecaster = StatementForecaster(graph)
&gt;&gt;&gt; results = forecaster.forecast_multiple([&quot;revenue&quot;, &quot;costs&quot;], [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; assert &quot;revenue&quot; in results
&gt;&gt;&gt; assert hasattr(results[&quot;revenue&quot;], &quot;values&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.StatementForecaster.forecast_value"><code class="name flex">
<span>def <span class="ident">forecast_value</span></span>(<span>self,<br>node_name: str,<br>forecast_periods: list[str],<br>base_period: str | None = None,<br>forecast_config: dict[str, Any] | None = None,<br>**kwargs: Any) ‑> dict[str, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_value(
    self,
    node_name: str,
    forecast_periods: list[str],
    base_period: str | None = None,
    forecast_config: dict[str, Any] | None = None,
    **kwargs: Any,
) -&gt; dict[str, float]:
    &#34;&#34;&#34;Return forecast values for a single node without mutating the graph.

    This method is ideal for what-if analysis, scenario comparison, or retrieving
    forecast values without persisting them to the graph.

    Args:
        node_name: Name of the node to forecast (e.g., &#39;revenue&#39;).
        forecast_periods: List of future periods to forecast.
        base_period: Optional base period to use for forecasting.
        forecast_config: Optional forecast configuration dict.
        **kwargs: Additional arguments (e.g., bad_forecast_value, allow_negative_forecasts).

    Returns:
        Dictionary mapping forecast periods to their calculated values.
        Example: {&#34;2024&#34;: 1050.0, &#34;2025&#34;: 1102.5}

    Raises:
        ForecastNodeError: If the node is not found or configuration is invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
        &gt;&gt;&gt; forecaster = StatementForecaster(graph)
        &gt;&gt;&gt; values = forecaster.forecast_value(&#34;revenue&#34;, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; assert isinstance(values, dict)
    &#34;&#34;&#34;
    return forecast_node_non_mutating(
        self.fsg,
        node_name=node_name,
        forecast_periods=forecast_periods,
        base_period=base_period,
        forecast_config=forecast_config,
        **kwargs,
    )</code></pre>
</details>
<div class="desc"><p>Return forecast values for a single node without mutating the graph.</p>
<p>This method is ideal for what-if analysis, scenario comparison, or retrieving
forecast values without persisting them to the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_name</code></strong></dt>
<dd>Name of the node to forecast (e.g., 'revenue').</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of future periods to forecast.</dd>
<dt><strong><code>base_period</code></strong></dt>
<dd>Optional base period to use for forecasting.</dd>
<dt><strong><code>forecast_config</code></strong></dt>
<dd>Optional forecast configuration dict.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments (e.g., bad_forecast_value, allow_negative_forecasts).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>Dictionary mapping forecast periods to their calculated values.</dt>
<dt><code>Example</code></dt>
<dd>{"2024": 1050.0, "2025": 1102.5}</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></dt>
<dd>If the node is not found or configuration is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting import StatementForecaster
&gt;&gt;&gt; forecaster = StatementForecaster(graph)
&gt;&gt;&gt; values = forecaster.forecast_value(&quot;revenue&quot;, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; assert isinstance(values, dict)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalConfig"><code class="flex name class">
<span>class <span class="ident">StatisticalConfig</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatisticalConfig(BaseModel):
    &#34;&#34;&#34;Configuration schema for statistical forecasting method.

    Validates &#39;distribution&#39; and &#39;params&#39; based on the distribution type.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.types import StatisticalConfig
        &gt;&gt;&gt; StatisticalConfig(distribution=&#34;normal&#34;, params={&#34;mean&#34;: 0.05, &#34;std&#34;: 0.02})
        StatisticalConfig(distribution=&#39;normal&#39;, params={&#39;mean&#39;: 0.05, &#39;std&#39;: 0.02})
    &#34;&#34;&#34;

    distribution: str
    params: dict[str, float]

    model_config = ConfigDict(extra=&#34;forbid&#34;)

    @model_validator(mode=&#34;after&#34;)
    def _validate_distribution(self) -&gt; &#34;StatisticalConfig&#34;:
        &#34;&#34;&#34;Validate that *self.params* contains the required keys for *self.distribution*.

        Pydantic&#39;s **after** validators receive the fully-initialised *instance* so
        we can reference ``self`` directly.  Using the two-parameter signature
        that previous Pydantic &lt;2 examples relied on now yields a
        *ValidationInfo* object, which caused the attribute access errors
        observed in the test-suite.
        &#34;&#34;&#34;
        distribution = self.distribution
        params = self.params

        if distribution == &#34;normal&#34;:
            required = {&#34;mean&#34;, &#34;std&#34;}
        elif distribution == &#34;uniform&#34;:
            required = {&#34;low&#34;, &#34;high&#34;}
        else:
            raise ForecastConfigurationError(
                f&#34;Unsupported distribution: {distribution}&#34;,
                config=params,
                invalid_params={&#34;distribution&#34;: f&#34;&#39;{distribution}&#39; is not supported&#34;},
            )

        missing = required - params.keys()
        if missing:
            raise ForecastConfigurationError(
                f&#34;{distribution.capitalize()} distribution requires {&#39;, &#39;.join(sorted(required))} parameters&#34;,
                config=params,
                missing_params=list(missing),
            )

        return self</code></pre>
</details>
<div class="desc"><p>Configuration schema for statistical forecasting method.</p>
<p>Validates 'distribution' and 'params' based on the distribution type.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.types import StatisticalConfig
&gt;&gt;&gt; StatisticalConfig(distribution=&quot;normal&quot;, params={&quot;mean&quot;: 0.05, &quot;std&quot;: 0.02})
StatisticalConfig(distribution='normal', params={'mean': 0.05, 'std': 0.02})
</code></pre>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatisticalConfig.distribution"><code class="name">var <span class="ident">distribution</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalConfig.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalConfig.params"><code class="name">var <span class="ident">params</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod"><code class="flex name class">
<span>class <span class="ident">StatisticalForecastMethod</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatisticalForecastMethod(BaseForecastMethod):
    &#34;&#34;&#34;Forecast future values by sampling from statistical distributions.

    This method generates forecast values by sampling from specified statistical
    distributions, useful for Monte Carlo simulations and uncertainty analysis.

    Configuration:
        - &#39;distribution&#39;: &#39;normal&#39; or &#39;uniform&#39;
        - &#39;params&#39;: Distribution-specific parameters
            - For &#39;normal&#39;: {&#39;mean&#39;: float, &#39;std&#39;: float}
            - For &#39;uniform&#39;: {&#39;low&#39;: float, &#39;high&#39;: float}

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.statistical import StatisticalForecastMethod
        &gt;&gt;&gt; method = StatisticalForecastMethod()
        &gt;&gt;&gt; config = {&#34;distribution&#34;: &#34;normal&#34;, &#34;params&#34;: {&#34;mean&#34;: 0.05, &#34;std&#34;: 0.02}}
        &gt;&gt;&gt; params = method.get_forecast_params(config, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; params[&#34;forecast_type&#34;]
        &#39;statistical&#39;
        &gt;&gt;&gt; callable(params[&#34;growth_params&#34;])
        True
    &#34;&#34;&#34;

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Return the method name.

        Returns:
            The unique name of the forecast method (&#39;statistical&#39;).
        &#34;&#34;&#34;
        return &#34;statistical&#34;

    @property
    def internal_type(self) -&gt; str:
        &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

        Returns:
            The internal type string used by the node factory (&#39;statistical&#39;).
        &#34;&#34;&#34;
        return &#34;statistical&#34;

    def validate_config(self, config: Any) -&gt; None:
        &#34;&#34;&#34;Validate the configuration for statistical method.

        Args:
            config: Should be a dict with &#39;distribution&#39; and &#39;params&#39; keys.

        Raises:
            TypeError: If config is invalid.
            ValueError: If required keys or values are missing or invalid.
        &#34;&#34;&#34;
        if not isinstance(config, dict):
            raise TypeError(f&#34;Statistical method requires dict configuration, got {type(config)}&#34;)

        if &#34;distribution&#34; not in config:
            raise ValueError(&#34;Statistical method requires &#39;distribution&#39; key&#34;)

        if &#34;params&#34; not in config:
            raise ValueError(&#34;Statistical method requires &#39;params&#39; key&#34;)

        # Validate using StatisticalConfig model (raises ValidationError or ForecastConfigurationError)
        try:
            StatisticalConfig(distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;])
        except (ValueError, TypeError, ValidationError) as e:
            raise ValueError(f&#34;Invalid statistical configuration: {e}&#34;) from e

    def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Normalize parameters for the NodeFactory.

        Args:
            config: Statistical distribution configuration.
            forecast_periods: List of periods to forecast (not used).

        Returns:
            Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
            The &#39;growth_params&#39; value is a callable that generates random values.

        Example:
            &gt;&gt;&gt; from fin_statement_model.forecasting.methods.statistical import StatisticalForecastMethod
            &gt;&gt;&gt; method = StatisticalForecastMethod()
            &gt;&gt;&gt; config = {&#34;distribution&#34;: &#34;normal&#34;, &#34;params&#34;: {&#34;mean&#34;: 0.05, &#34;std&#34;: 0.02}}
            &gt;&gt;&gt; out = method.normalize_params(config, [&#34;2024&#34;, &#34;2025&#34;])
            &gt;&gt;&gt; out[&#34;forecast_type&#34;]
            &#39;statistical&#39;
            &gt;&gt;&gt; callable(out[&#34;growth_params&#34;])
            True
        &#34;&#34;&#34;
        _ = forecast_periods  # Parameter intentionally unused
        # Create validated config
        stat_config = StatisticalConfig(distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;])

        # Seed RNG if configured
        seed = cfg(&#34;forecasting.random_seed&#34;)
        rng = np.random.RandomState(seed) if seed is not None else np.random.RandomState()

        # Create generator function based on distribution
        def generator() -&gt; float:
            &#34;&#34;&#34;Generate a random growth rate from the specified distribution.&#34;&#34;&#34;
            if stat_config.distribution == &#34;normal&#34;:
                return float(rng.normal(stat_config.params[&#34;mean&#34;], stat_config.params[&#34;std&#34;]))
            elif stat_config.distribution == &#34;uniform&#34;:
                return float(rng.uniform(stat_config.params[&#34;low&#34;], stat_config.params[&#34;high&#34;]))
            else:
                # This shouldn&#39;t happen due to validation, but just in case
                raise ValueError(f&#34;Unsupported distribution: {stat_config.distribution}&#34;)

        return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: generator}</code></pre>
</details>
<div class="desc"><p>Forecast future values by sampling from statistical distributions.</p>
<p>This method generates forecast values by sampling from specified statistical
distributions, useful for Monte Carlo simulations and uncertainty analysis.</p>
<h2 id="configuration">Configuration</h2>
<ul>
<li>'distribution': 'normal' or 'uniform'</li>
<li>'params': Distribution-specific parameters<ul>
<li>For 'normal': {'mean': float, 'std': float}</li>
<li>For 'uniform': {'low': float, 'high': float}</li>
</ul>
</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.statistical import StatisticalForecastMethod
&gt;&gt;&gt; method = StatisticalForecastMethod()
&gt;&gt;&gt; config = {&quot;distribution&quot;: &quot;normal&quot;, &quot;params&quot;: {&quot;mean&quot;: 0.05, &quot;std&quot;: 0.02}}
&gt;&gt;&gt; params = method.get_forecast_params(config, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; params[&quot;forecast_type&quot;]
'statistical'
&gt;&gt;&gt; callable(params[&quot;growth_params&quot;])
True
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod.internal_type"><code class="name">prop <span class="ident">internal_type</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_type(self) -&gt; str:
    &#34;&#34;&#34;Return the internal forecast type for NodeFactory.

    Returns:
        The internal type string used by the node factory (&#39;statistical&#39;).
    &#34;&#34;&#34;
    return &#34;statistical&#34;</code></pre>
</details>
<div class="desc"><p>Return the internal forecast type for NodeFactory.</p>
<h2 id="returns">Returns</h2>
<p>The internal type string used by the node factory ('statistical').</p></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Return the method name.

    Returns:
        The unique name of the forecast method (&#39;statistical&#39;).
    &#34;&#34;&#34;
    return &#34;statistical&#34;</code></pre>
</details>
<div class="desc"><p>Return the method name.</p>
<h2 id="returns">Returns</h2>
<p>The unique name of the forecast method ('statistical').</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod.normalize_params"><code class="name flex">
<span>def <span class="ident">normalize_params</span></span>(<span>self, config: Any, forecast_periods: list[str]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_params(self, config: Any, forecast_periods: list[str]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Normalize parameters for the NodeFactory.

    Args:
        config: Statistical distribution configuration.
        forecast_periods: List of periods to forecast (not used).

    Returns:
        Dict with &#39;forecast_type&#39; and &#39;growth_params&#39; keys.
        The &#39;growth_params&#39; value is a callable that generates random values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.forecasting.methods.statistical import StatisticalForecastMethod
        &gt;&gt;&gt; method = StatisticalForecastMethod()
        &gt;&gt;&gt; config = {&#34;distribution&#34;: &#34;normal&#34;, &#34;params&#34;: {&#34;mean&#34;: 0.05, &#34;std&#34;: 0.02}}
        &gt;&gt;&gt; out = method.normalize_params(config, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; out[&#34;forecast_type&#34;]
        &#39;statistical&#39;
        &gt;&gt;&gt; callable(out[&#34;growth_params&#34;])
        True
    &#34;&#34;&#34;
    _ = forecast_periods  # Parameter intentionally unused
    # Create validated config
    stat_config = StatisticalConfig(distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;])

    # Seed RNG if configured
    seed = cfg(&#34;forecasting.random_seed&#34;)
    rng = np.random.RandomState(seed) if seed is not None else np.random.RandomState()

    # Create generator function based on distribution
    def generator() -&gt; float:
        &#34;&#34;&#34;Generate a random growth rate from the specified distribution.&#34;&#34;&#34;
        if stat_config.distribution == &#34;normal&#34;:
            return float(rng.normal(stat_config.params[&#34;mean&#34;], stat_config.params[&#34;std&#34;]))
        elif stat_config.distribution == &#34;uniform&#34;:
            return float(rng.uniform(stat_config.params[&#34;low&#34;], stat_config.params[&#34;high&#34;]))
        else:
            # This shouldn&#39;t happen due to validation, but just in case
            raise ValueError(f&#34;Unsupported distribution: {stat_config.distribution}&#34;)

    return {&#34;forecast_type&#34;: self.internal_type, &#34;growth_params&#34;: generator}</code></pre>
</details>
<div class="desc"><p>Normalize parameters for the NodeFactory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Statistical distribution configuration.</dd>
<dt><strong><code>forecast_periods</code></strong></dt>
<dd>List of periods to forecast (not used).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict with 'forecast_type' and 'growth_params' keys.
The 'growth_params' value is a callable that generates random values.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.forecasting.methods.statistical import StatisticalForecastMethod
&gt;&gt;&gt; method = StatisticalForecastMethod()
&gt;&gt;&gt; config = {&quot;distribution&quot;: &quot;normal&quot;, &quot;params&quot;: {&quot;mean&quot;: 0.05, &quot;std&quot;: 0.02}}
&gt;&gt;&gt; out = method.normalize_params(config, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; out[&quot;forecast_type&quot;]
'statistical'
&gt;&gt;&gt; callable(out[&quot;growth_params&quot;])
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.forecasting.StatisticalForecastMethod.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self, config: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self, config: Any) -&gt; None:
    &#34;&#34;&#34;Validate the configuration for statistical method.

    Args:
        config: Should be a dict with &#39;distribution&#39; and &#39;params&#39; keys.

    Raises:
        TypeError: If config is invalid.
        ValueError: If required keys or values are missing or invalid.
    &#34;&#34;&#34;
    if not isinstance(config, dict):
        raise TypeError(f&#34;Statistical method requires dict configuration, got {type(config)}&#34;)

    if &#34;distribution&#34; not in config:
        raise ValueError(&#34;Statistical method requires &#39;distribution&#39; key&#34;)

    if &#34;params&#34; not in config:
        raise ValueError(&#34;Statistical method requires &#39;params&#39; key&#34;)

    # Validate using StatisticalConfig model (raises ValidationError or ForecastConfigurationError)
    try:
        StatisticalConfig(distribution=config[&#34;distribution&#34;], params=config[&#34;params&#34;])
    except (ValueError, TypeError, ValidationError) as e:
        raise ValueError(f&#34;Invalid statistical configuration: {e}&#34;) from e</code></pre>
</details>
<div class="desc"><p>Validate the configuration for statistical method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Should be a dict with 'distribution' and 'params' keys.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If config is invalid.</dd>
<dt><code>ValueError</code></dt>
<dd>If required keys or values are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod">BaseForecastMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data" href="methods/base.html#fin_statement_model.forecasting.methods.base.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model" href="../index.html">fin_statement_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.forecasting.errors" href="errors.html">fin_statement_model.forecasting.errors</a></code></li>
<li><code><a title="fin_statement_model.forecasting.forecaster" href="forecaster/index.html">fin_statement_model.forecasting.forecaster</a></code></li>
<li><code><a title="fin_statement_model.forecasting.methods" href="methods/index.html">fin_statement_model.forecasting.methods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.period_manager" href="period_manager.html">fin_statement_model.forecasting.period_manager</a></code></li>
<li><code><a title="fin_statement_model.forecasting.strategies" href="strategies.html">fin_statement_model.forecasting.strategies</a></code></li>
<li><code><a title="fin_statement_model.forecasting.types" href="types.html">fin_statement_model.forecasting.types</a></code></li>
<li><code><a title="fin_statement_model.forecasting.validators" href="validators.html">fin_statement_model.forecasting.validators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.get_forecast_method" href="#fin_statement_model.forecasting.get_forecast_method">get_forecast_method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.register_forecast_method" href="#fin_statement_model.forecasting.register_forecast_method">register_forecast_method</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.forecasting.AverageForecastMethod" href="#fin_statement_model.forecasting.AverageForecastMethod">AverageForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.internal_type" href="#fin_statement_model.forecasting.AverageForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.name" href="#fin_statement_model.forecasting.AverageForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.normalize_params" href="#fin_statement_model.forecasting.AverageForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.AverageForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.AverageForecastMethod.validate_config" href="#fin_statement_model.forecasting.AverageForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.BaseForecastMethod" href="#fin_statement_model.forecasting.BaseForecastMethod">BaseForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.get_forecast_params" href="#fin_statement_model.forecasting.BaseForecastMethod.get_forecast_params">get_forecast_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.internal_type" href="#fin_statement_model.forecasting.BaseForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.name" href="#fin_statement_model.forecasting.BaseForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.normalize_params" href="#fin_statement_model.forecasting.BaseForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.BaseForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.BaseForecastMethod.validate_config" href="#fin_statement_model.forecasting.BaseForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.CurveForecastMethod" href="#fin_statement_model.forecasting.CurveForecastMethod">CurveForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.CurveForecastMethod.internal_type" href="#fin_statement_model.forecasting.CurveForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.CurveForecastMethod.name" href="#fin_statement_model.forecasting.CurveForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.CurveForecastMethod.normalize_params" href="#fin_statement_model.forecasting.CurveForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.CurveForecastMethod.validate_config" href="#fin_statement_model.forecasting.CurveForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastConfig" href="#fin_statement_model.forecasting.ForecastConfig">ForecastConfig</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.ForecastConfig.config" href="#fin_statement_model.forecasting.ForecastConfig.config">config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastConfig.method" href="#fin_statement_model.forecasting.ForecastConfig.method">method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastConfig.model_config" href="#fin_statement_model.forecasting.ForecastConfig.model_config">model_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastConfigurationError" href="#fin_statement_model.forecasting.ForecastConfigurationError">ForecastConfigurationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastMethod" href="#fin_statement_model.forecasting.ForecastMethod">ForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.name" href="#fin_statement_model.forecasting.ForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.normalize_params" href="#fin_statement_model.forecasting.ForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.ForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethod.validate_config" href="#fin_statement_model.forecasting.ForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastMethodError" href="#fin_statement_model.forecasting.ForecastMethodError">ForecastMethodError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry" href="#fin_statement_model.forecasting.ForecastMethodRegistry">ForecastMethodRegistry</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.get_method" href="#fin_statement_model.forecasting.ForecastMethodRegistry.get_method">get_method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.get_method_info" href="#fin_statement_model.forecasting.ForecastMethodRegistry.get_method_info">get_method_info</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.has_method" href="#fin_statement_model.forecasting.ForecastMethodRegistry.has_method">has_method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.list_methods" href="#fin_statement_model.forecasting.ForecastMethodRegistry.list_methods">list_methods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.register" href="#fin_statement_model.forecasting.ForecastMethodRegistry.register">register</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastMethodRegistry.unregister" href="#fin_statement_model.forecasting.ForecastMethodRegistry.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastNodeError" href="#fin_statement_model.forecasting.ForecastNodeError">ForecastNodeError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastResult" href="#fin_statement_model.forecasting.ForecastResult">ForecastResult</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.forecasting.ForecastResult.base_period" href="#fin_statement_model.forecasting.ForecastResult.base_period">base_period</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.get_value" href="#fin_statement_model.forecasting.ForecastResult.get_value">get_value</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.method" href="#fin_statement_model.forecasting.ForecastResult.method">method</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.model_config" href="#fin_statement_model.forecasting.ForecastResult.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.node_name" href="#fin_statement_model.forecasting.ForecastResult.node_name">node_name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.periods" href="#fin_statement_model.forecasting.ForecastResult.periods">periods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastResult.values" href="#fin_statement_model.forecasting.ForecastResult.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastResultError" href="#fin_statement_model.forecasting.ForecastResultError">ForecastResultError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastValidator" href="#fin_statement_model.forecasting.ForecastValidator">ForecastValidator</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_base_period" href="#fin_statement_model.forecasting.ForecastValidator.validate_base_period">validate_base_period</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_forecast_config" href="#fin_statement_model.forecasting.ForecastValidator.validate_forecast_config">validate_forecast_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_forecast_inputs" href="#fin_statement_model.forecasting.ForecastValidator.validate_forecast_inputs">validate_forecast_inputs</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_forecast_result" href="#fin_statement_model.forecasting.ForecastValidator.validate_forecast_result">validate_forecast_result</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_node_config" href="#fin_statement_model.forecasting.ForecastValidator.validate_node_config">validate_node_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.ForecastValidator.validate_node_for_forecast" href="#fin_statement_model.forecasting.ForecastValidator.validate_node_for_forecast">validate_node_for_forecast</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.ForecastingError" href="#fin_statement_model.forecasting.ForecastingError">ForecastingError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod">HistoricalGrowthForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.calculate_average_growth_rate" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.calculate_average_growth_rate">calculate_average_growth_rate</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.internal_type" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.name" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.normalize_params" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.prepare_historical_data" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.prepare_historical_data">prepare_historical_data</a></code></li>
<li><code><a title="fin_statement_model.forecasting.HistoricalGrowthForecastMethod.validate_config" href="#fin_statement_model.forecasting.HistoricalGrowthForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.PeriodManager" href="#fin_statement_model.forecasting.PeriodManager">PeriodManager</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.PeriodManager.determine_base_period" href="#fin_statement_model.forecasting.PeriodManager.determine_base_period">determine_base_period</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.ensure_periods_exist" href="#fin_statement_model.forecasting.PeriodManager.ensure_periods_exist">ensure_periods_exist</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.get_period_index" href="#fin_statement_model.forecasting.PeriodManager.get_period_index">get_period_index</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.infer_historical_periods" href="#fin_statement_model.forecasting.PeriodManager.infer_historical_periods">infer_historical_periods</a></code></li>
<li><code><a title="fin_statement_model.forecasting.PeriodManager.validate_period_sequence" href="#fin_statement_model.forecasting.PeriodManager.validate_period_sequence">validate_period_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.SimpleForecastMethod" href="#fin_statement_model.forecasting.SimpleForecastMethod">SimpleForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.SimpleForecastMethod.internal_type" href="#fin_statement_model.forecasting.SimpleForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.SimpleForecastMethod.name" href="#fin_statement_model.forecasting.SimpleForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.SimpleForecastMethod.normalize_params" href="#fin_statement_model.forecasting.SimpleForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.SimpleForecastMethod.validate_config" href="#fin_statement_model.forecasting.SimpleForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.StatementForecaster" href="#fin_statement_model.forecasting.StatementForecaster">StatementForecaster</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.create_forecast" href="#fin_statement_model.forecasting.StatementForecaster.create_forecast">create_forecast</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.forecast_multiple" href="#fin_statement_model.forecasting.StatementForecaster.forecast_multiple">forecast_multiple</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatementForecaster.forecast_value" href="#fin_statement_model.forecasting.StatementForecaster.forecast_value">forecast_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.StatisticalConfig" href="#fin_statement_model.forecasting.StatisticalConfig">StatisticalConfig</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.StatisticalConfig.distribution" href="#fin_statement_model.forecasting.StatisticalConfig.distribution">distribution</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalConfig.model_config" href="#fin_statement_model.forecasting.StatisticalConfig.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalConfig.params" href="#fin_statement_model.forecasting.StatisticalConfig.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod" href="#fin_statement_model.forecasting.StatisticalForecastMethod">StatisticalForecastMethod</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod.internal_type" href="#fin_statement_model.forecasting.StatisticalForecastMethod.internal_type">internal_type</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod.name" href="#fin_statement_model.forecasting.StatisticalForecastMethod.name">name</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod.normalize_params" href="#fin_statement_model.forecasting.StatisticalForecastMethod.normalize_params">normalize_params</a></code></li>
<li><code><a title="fin_statement_model.forecasting.StatisticalForecastMethod.validate_config" href="#fin_statement_model.forecasting.StatisticalForecastMethod.validate_config">validate_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
