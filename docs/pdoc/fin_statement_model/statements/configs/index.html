<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.statements.configs API documentation</title>
<meta name="description" content="Configuration handling for financial statements …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.statements.configs</code></h1>
</header>
<section id="section-intro">
<p>Configuration handling for financial statements.</p>
<p>This package provides:
- Pydantic models for configuration validation
- Configuration file loading utilities
- StatementConfig class for managing configurations</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.statements.configs.models" href="models.html">fin_statement_model.statements.configs.models</a></code></dt>
<dd>
<div class="desc"><p>Define Pydantic models for statement configuration …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.configs.validator" href="validator.html">fin_statement_model.statements.configs.validator</a></code></dt>
<dd>
<div class="desc"><p>Statement configuration handling for Financial Statement Model …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec"><code class="flex name class">
<span>class <span class="ident">AdjustmentFilterSpec</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdjustmentFilterSpec(BaseModel):
    &#34;&#34;&#34;Define an adjustment filter specification for configuration.

    This model represents the adjustment filter options that can be specified
    in configuration files. It maps to the core AdjustmentFilter model but
    uses serializable types suitable for YAML/JSON.

    Args:
        include_scenarios: Only include adjustments from these scenarios.
        exclude_scenarios: Exclude adjustments from these scenarios.
        include_tags: Include adjustments matching any of these tag prefixes.
        exclude_tags: Exclude adjustments matching any of these tag prefixes.
        require_all_tags: Include only adjustments having all these exact tags.
        include_types: Only include adjustments of these types.
        exclude_types: Exclude adjustments of these types.
        period: The specific period context for effective window checks.
    &#34;&#34;&#34;

    include_scenarios: list[str] | None = Field(None, description=&#34;Only include adjustments from these scenarios.&#34;)
    exclude_scenarios: list[str] | None = Field(None, description=&#34;Exclude adjustments from these scenarios.&#34;)
    include_tags: list[str] | None = Field(None, description=&#34;Include adjustments matching any of these tag prefixes.&#34;)
    exclude_tags: list[str] | None = Field(None, description=&#34;Exclude adjustments matching any of these tag prefixes.&#34;)
    require_all_tags: list[str] | None = Field(
        None, description=&#34;Include only adjustments having all these exact tags.&#34;
    )
    include_types: list[str] | None = Field(
        None,
        description=&#34;Only include adjustments of these types (additive, multiplicative, replacement).&#34;,
    )
    exclude_types: list[str] | None = Field(
        None,
        description=&#34;Exclude adjustments of these types (additive, multiplicative, replacement).&#34;,
    )
    period: str | None = Field(None, description=&#34;The specific period context for effective window checks.&#34;)

    @field_validator(&#34;include_types&#34;, &#34;exclude_types&#34;, mode=&#34;before&#34;)
    @classmethod
    def validate_adjustment_types(cls, value: list[str] | None) -&gt; list[str] | None:
        &#34;&#34;&#34;Validate adjustment types are valid.&#34;&#34;&#34;
        if value is not None:
            valid_types = {&#34;additive&#34;, &#34;multiplicative&#34;, &#34;replacement&#34;}
            for adj_type in value:
                if adj_type not in valid_types:
                    raise ValueError(f&#34;Invalid adjustment type &#39;{adj_type}&#39;. Must be one of: {valid_types}&#34;)
        return value

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define an adjustment filter specification for configuration.</p>
<p>This model represents the adjustment filter options that can be specified
in configuration files. It maps to the core AdjustmentFilter model but
uses serializable types suitable for YAML/JSON.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_scenarios</code></strong></dt>
<dd>Only include adjustments from these scenarios.</dd>
<dt><strong><code>exclude_scenarios</code></strong></dt>
<dd>Exclude adjustments from these scenarios.</dd>
<dt><strong><code>include_tags</code></strong></dt>
<dd>Include adjustments matching any of these tag prefixes.</dd>
<dt><strong><code>exclude_tags</code></strong></dt>
<dd>Exclude adjustments matching any of these tag prefixes.</dd>
<dt><strong><code>require_all_tags</code></strong></dt>
<dd>Include only adjustments having all these exact tags.</dd>
<dt><strong><code>include_types</code></strong></dt>
<dd>Only include adjustments of these types.</dd>
<dt><strong><code>exclude_types</code></strong></dt>
<dd>Exclude adjustments of these types.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The specific period context for effective window checks.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_scenarios"><code class="name">var <span class="ident">exclude_scenarios</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_tags"><code class="name">var <span class="ident">exclude_tags</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_types"><code class="name">var <span class="ident">exclude_types</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.include_scenarios"><code class="name">var <span class="ident">include_scenarios</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.include_tags"><code class="name">var <span class="ident">include_tags</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.include_types"><code class="name">var <span class="ident">include_types</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.period"><code class="name">var <span class="ident">period</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.require_all_tags"><code class="name">var <span class="ident">require_all_tags</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.AdjustmentFilterSpec.validate_adjustment_types"><code class="name flex">
<span>def <span class="ident">validate_adjustment_types</span></span>(<span>value: list[str] | None) ‑> list[str] | None</span>
</code></dt>
<dd>
<div class="desc"><p>Validate adjustment types are valid.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel"><code class="flex name class">
<span>class <span class="ident">BaseItemModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseItemModel(BaseModel):
    &#34;&#34;&#34;Define common fields for all statement items.

    Args:
        id: Unique identifier for the item. Must not contain spaces.
        name: Human-readable name of the item.
        description: Optional description for the item.
        metadata: Optional metadata dictionary for the item.
        sign_convention: Sign convention for the item (1 or -1).
        default_adjustment_filter: Optional default adjustment filter for this item.
        display_format: Optional specific number format string (e.g., &#34;,.2f&#34;, &#34;,.0f&#34;).
        hide_if_all_zero: Whether to hide this item if all values are zero.
        css_class: Optional CSS class name for HTML/web outputs.
        notes_references: List of footnote/note IDs referenced by this item.
        units: Optional unit description (e.g., &#34;USD Thousands&#34;, &#34;Percentage&#34;).
        display_scale_factor: Factor to scale values for display (e.g., 0.001 for thousands).
    &#34;&#34;&#34;

    id: str = Field(
        ...,
        description=&#34;Unique identifier for the item. Must not contain spaces.&#34;,
    )
    name: str = Field(..., description=&#34;Human-readable name of the item.&#34;)
    description: str | None = Field(&#34;&#34;, description=&#34;Optional description for the item.&#34;)
    metadata: dict[str, Any] = Field(default_factory=dict, description=&#34;Optional metadata for the item.&#34;)
    sign_convention: int = Field(1, description=&#34;Sign convention for the item (1 or -1).&#34;)
    default_adjustment_filter: AdjustmentFilterSpec | list[str] | None = Field(
        None,
        description=&#34;Optional default adjustment filter for this item. Can be a filter specification or list of tags.&#34;,
    )

    # Enhanced Display Control Fields
    display_format: str | None = Field(
        None,
        description=&#34;Specific number format string for this item (e.g., &#39;,.2f&#39;, &#39;,.0f&#39;, &#39;.1%&#39;).&#34;,
    )
    hide_if_all_zero: bool = Field(
        False,
        description=&#34;Whether to hide this item from display if all values are zero or null.&#34;,
    )
    css_class: str | None = Field(
        None,
        description=&#34;CSS class name to apply to this item in HTML/web outputs.&#34;,
    )
    notes_references: list[str] = Field(
        default_factory=list,
        description=&#34;List of footnote or note IDs that reference this item.&#34;,
    )

    # Contra Item Support
    is_contra: bool = Field(
        False,
        description=&#34;Whether this is a contra item (e.g., Accumulated Depreciation, Treasury Stock, Sales Returns) that naturally reduces the balance of its category for display purposes.&#34;,
    )

    # Units and Scaling Fields
    units: str | None = Field(
        None,
        description=&#34;Unit description for this item (e.g., &#39;USD Thousands&#39;, &#39;Percentage&#39;, &#39;Days&#39;).&#34;,
    )
    display_scale_factor: float = Field(
        1.0,
        description=&#34;Factor to scale values for display purposes (e.g., 0.001 to show in thousands).&#34;,
    )

    @field_validator(&#34;id&#34;, mode=&#34;before&#34;)
    @classmethod
    def id_must_not_contain_spaces(cls, value: str) -&gt; str:
        &#34;&#34;&#34;Ensure that &#39;id&#39; does not contain spaces.&#34;&#34;&#34;
        if &#34; &#34; in value:
            raise ValueError(&#34;must not contain spaces&#34;)
        return value

    @field_validator(&#34;display_scale_factor&#34;, mode=&#34;before&#34;)
    @classmethod
    def validate_display_scale_factor(cls, value: float) -&gt; float:
        &#34;&#34;&#34;Ensure display_scale_factor is positive and non-zero.&#34;&#34;&#34;
        if value &lt;= 0:
            raise ValueError(&#34;display_scale_factor must be positive and non-zero&#34;)
        return value

    @field_validator(&#34;display_format&#34;, mode=&#34;before&#34;)
    @classmethod
    def validate_display_format(cls, value: str | None) -&gt; str | None:
        &#34;&#34;&#34;Validate that display_format is a reasonable format string.&#34;&#34;&#34;
        if value is not None:
            # Basic validation - try to format a test number
            try:
                test_format = f&#34;{12345.67:{value}}&#34;
                # Basic sanity check that it produced something reasonable
                if not test_format or len(test_format) &gt; MAX_FORMAT_LENGTH:
                    raise ValueError(&#34;Invalid or problematic format string&#34;)
            except (ValueError, TypeError) as e:
                raise ValueError(f&#34;Invalid display_format &#39;{value}&#39;: {e}&#34;) from e
        return value

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define common fields for all statement items.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the item. Must not contain spaces.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name of the item.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description for the item.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata dictionary for the item.</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>Sign convention for the item (1 or -1).</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item.</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string (e.g., ",.2f", ",.0f").</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero.</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs.</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description (e.g., "USD Thousands", "Percentage").</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display (e.g., 0.001 for thousands).</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.configs.models.CalculatedItemModel" href="models.html#fin_statement_model.statements.configs.models.CalculatedItemModel">CalculatedItemModel</a></li>
<li><a title="fin_statement_model.statements.configs.models.LineItemModel" href="models.html#fin_statement_model.statements.configs.models.LineItemModel">LineItemModel</a></li>
<li><a title="fin_statement_model.statements.configs.models.MetricItemModel" href="models.html#fin_statement_model.statements.configs.models.MetricItemModel">MetricItemModel</a></li>
<li><a title="fin_statement_model.statements.configs.models.SectionModel" href="models.html#fin_statement_model.statements.configs.models.SectionModel">SectionModel</a></li>
<li><a title="fin_statement_model.statements.configs.models.SubtotalModel" href="models.html#fin_statement_model.statements.configs.models.SubtotalModel">SubtotalModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.BaseItemModel.css_class"><code class="name">var <span class="ident">css_class</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.default_adjustment_filter"><code class="name">var <span class="ident">default_adjustment_filter</span> : <a title="fin_statement_model.statements.configs.models.AdjustmentFilterSpec" href="models.html#fin_statement_model.statements.configs.models.AdjustmentFilterSpec">AdjustmentFilterSpec</a> | list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.description"><code class="name">var <span class="ident">description</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.display_format"><code class="name">var <span class="ident">display_format</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.display_scale_factor"><code class="name">var <span class="ident">display_scale_factor</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.hide_if_all_zero"><code class="name">var <span class="ident">hide_if_all_zero</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.is_contra"><code class="name">var <span class="ident">is_contra</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.metadata"><code class="name">var <span class="ident">metadata</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.notes_references"><code class="name">var <span class="ident">notes_references</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.sign_convention"><code class="name">var <span class="ident">sign_convention</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.units"><code class="name">var <span class="ident">units</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.BaseItemModel.id_must_not_contain_spaces"><code class="name flex">
<span>def <span class="ident">id_must_not_contain_spaces</span></span>(<span>value: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that 'id' does not contain spaces.</p></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.validate_display_format"><code class="name flex">
<span>def <span class="ident">validate_display_format</span></span>(<span>value: str | None) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that display_format is a reasonable format string.</p></div>
</dd>
<dt id="fin_statement_model.statements.configs.BaseItemModel.validate_display_scale_factor"><code class="name flex">
<span>def <span class="ident">validate_display_scale_factor</span></span>(<span>value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure display_scale_factor is positive and non-zero.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.configs.CalculatedItemModel"><code class="flex name class">
<span>class <span class="ident">CalculatedItemModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculatedItemModel(BaseItemModel):
    &#34;&#34;&#34;Define a calculated line item configuration model.

    Args:
        type: Must be &#39;calculated&#39; for this model.
        calculation: Calculation specification for the calculated item.
    &#34;&#34;&#34;

    type: Literal[&#34;calculated&#34;] = Field(&#34;calculated&#34;, description=&#34;Discriminator for calculated items.&#34;)
    calculation: CalculationSpec = Field(..., description=&#34;Calculation specification for the calculated item.&#34;)

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define a calculated line item configuration model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>Must be 'calculated' for this model.</dd>
<dt><strong><code>calculation</code></strong></dt>
<dd>Calculation specification for the calculated item.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.CalculatedItemModel.calculation"><code class="name">var <span class="ident">calculation</span> : <a title="fin_statement_model.statements.configs.models.CalculationSpec" href="models.html#fin_statement_model.statements.configs.models.CalculationSpec">CalculationSpec</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.CalculatedItemModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.CalculatedItemModel.type"><code class="name">var <span class="ident">type</span> : Literal['calculated']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format">validate_display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.configs.CalculationSpec"><code class="flex name class">
<span>class <span class="ident">CalculationSpec</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculationSpec(BaseModel):
    &#34;&#34;&#34;Define a calculation specification.

    Args:
        type: Type identifier for the calculation (e.g., &#39;addition&#39;, &#39;subtraction&#39;).
        inputs: List of input node or line item IDs referenced by this calculation.
    &#34;&#34;&#34;

    type: str = Field(
        ...,
        description=&#34;Type identifier for the calculation (e.g., &#39;addition&#39;, &#39;subtraction&#39;).&#34;,
    )
    inputs: list[str] = Field(
        ...,
        description=&#34;List of input node or line item IDs referenced by this calculation.&#34;,
    )

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define a calculation specification.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier for the calculation (e.g., 'addition', 'subtraction').</dd>
<dt><strong><code>inputs</code></strong></dt>
<dd>List of input node or line item IDs referenced by this calculation.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.CalculationSpec.inputs"><code class="name">var <span class="ident">inputs</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.CalculationSpec.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.CalculationSpec.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.configs.LineItemModel"><code class="flex name class">
<span>class <span class="ident">LineItemModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineItemModel(BaseItemModel):
    &#34;&#34;&#34;Define a basic line item configuration model.

    Args:
        type: Must be &#39;line_item&#39; for this model.
        node_id: ID of the core node this line item maps to.
        standard_node_ref: Optional reference to a standard node name from the registry.
    &#34;&#34;&#34;

    type: Literal[&#34;line_item&#34;] = Field(&#34;line_item&#34;, description=&#34;Discriminator for basic line items.&#34;)
    node_id: str | None = Field(None, description=&#34;ID of the core node this line item maps to.&#34;)
    standard_node_ref: str | None = Field(
        None,
        description=&#34;Reference to a standard node name from the standard_node_registry.&#34;,
    )

    @model_validator(mode=&#34;before&#34;)
    @classmethod
    def exactly_one_node_reference(cls, values: dict[str, Any]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Ensure exactly one of &#39;node_id&#39; or &#39;standard_node_ref&#39; is provided.&#34;&#34;&#34;
        node_id = values.get(&#34;node_id&#34;)
        standard_ref = values.get(&#34;standard_node_ref&#34;)

        if not node_id and not standard_ref:
            raise ValueError(&#34;must provide either &#39;node_id&#39; or &#39;standard_node_ref&#39;&#34;)
        if node_id and standard_ref:
            raise ValueError(&#34;cannot provide both &#39;node_id&#39; and &#39;standard_node_ref&#39; - use only one&#34;)
        return values

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define a basic line item configuration model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>Must be 'line_item' for this model.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>ID of the core node this line item maps to.</dd>
<dt><strong><code>standard_node_ref</code></strong></dt>
<dd>Optional reference to a standard node name from the registry.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.LineItemModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.LineItemModel.node_id"><code class="name">var <span class="ident">node_id</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.LineItemModel.standard_node_ref"><code class="name">var <span class="ident">standard_node_ref</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.LineItemModel.type"><code class="name">var <span class="ident">type</span> : Literal['line_item']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.LineItemModel.exactly_one_node_reference"><code class="name flex">
<span>def <span class="ident">exactly_one_node_reference</span></span>(<span>values: dict[str, Any]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure exactly one of 'node_id' or 'standard_node_ref' is provided.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format">validate_display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.configs.MetricItemModel"><code class="flex name class">
<span>class <span class="ident">MetricItemModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricItemModel(BaseItemModel):
    &#34;&#34;&#34;Define a metric-based line item configuration model.

    Args:
        type: Must be &#39;metric&#39; for this model.
        metric_id: ID of the metric in the core registry.
        inputs: Mapping of metric input names to statement item IDs.
    &#34;&#34;&#34;

    type: Literal[&#34;metric&#34;] = Field(&#34;metric&#34;, description=&#34;Discriminator for metric-based items.&#34;)
    metric_id: str = Field(..., description=&#34;ID of the metric in the core.metrics.registry.&#34;)
    inputs: dict[str, str] = Field(..., description=&#34;Mapping of metric input names to statement item IDs.&#34;)

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define a metric-based line item configuration model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>Must be 'metric' for this model.</dd>
<dt><strong><code>metric_id</code></strong></dt>
<dd>ID of the metric in the core registry.</dd>
<dt><strong><code>inputs</code></strong></dt>
<dd>Mapping of metric input names to statement item IDs.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.MetricItemModel.inputs"><code class="name">var <span class="ident">inputs</span> : dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.MetricItemModel.metric_id"><code class="name">var <span class="ident">metric_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.MetricItemModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.MetricItemModel.type"><code class="name">var <span class="ident">type</span> : Literal['metric']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format">validate_display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.configs.SectionModel"><code class="flex name class">
<span>class <span class="ident">SectionModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SectionModel(BaseItemModel):
    &#34;&#34;&#34;Define a nested section within the statement configuration.

    Args:
        type: Must be &#39;section&#39; for this model.
        items: List of line items, calculated items, subtotals, or nested sections.
        subsections: List of nested sections.
        subtotal: Optional subtotal configuration for this section.
        default_adjustment_filter: Optional default adjustment filter for this section.
    &#34;&#34;&#34;

    type: Literal[&#34;section&#34;] = Field(&#34;section&#34;, description=&#34;Discriminator for nested sections.&#34;)
    items: list[LineItemModel | CalculatedItemModel | MetricItemModel | SubtotalModel | SectionModel] = Field(
        default_factory=list,
        description=(&#34;List of line items, calculated items, subtotals, or nested sections.&#34;),
    )
    subsections: list[SectionModel] = Field(
        default_factory=list,
        description=&#34;List of nested sections.&#34;,
    )
    subtotal: SubtotalModel | None = Field(None, description=&#34;Optional subtotal configuration for this section.&#34;)

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)

    @model_validator(mode=&#34;after&#34;)
    def check_unique_item_ids(self: SectionModel) -&gt; SectionModel:
        &#34;&#34;&#34;Ensure that item and subsection IDs within a section are unique and subtotal refs valid.&#34;&#34;&#34;
        ids = [item.id for item in self.items] + [sub.id for sub in self.subsections]
        duplicates = {item_id for item_id in ids if ids.count(item_id) &gt; 1}
        if duplicates:
            raise ValueError(f&#34;Duplicate item id(s) in section &#39;{self.id}&#39;: {&#39;, &#39;.join(duplicates)}&#34;)
        if self.subtotal and self.subtotal.items_to_sum is not None:
            valid_ids = [item.id for item in self.items]
            missing = [i for i in self.subtotal.items_to_sum if i not in valid_ids]
            if missing:
                raise ValueError(f&#34;Section &#39;{self.id}&#39; subtotal references undefined ids: {&#39;, &#39;.join(missing)}&#34;)
        return self</code></pre>
</details>
<div class="desc"><p>Define a nested section within the statement configuration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>Must be 'section' for this model.</dd>
<dt><strong><code>items</code></strong></dt>
<dd>List of line items, calculated items, subtotals, or nested sections.</dd>
<dt><strong><code>subsections</code></strong></dt>
<dd>List of nested sections.</dd>
<dt><strong><code>subtotal</code></strong></dt>
<dd>Optional subtotal configuration for this section.</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this section.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.SectionModel.items"><code class="name">var <span class="ident">items</span> : list[<a title="fin_statement_model.statements.configs.models.LineItemModel" href="models.html#fin_statement_model.statements.configs.models.LineItemModel">LineItemModel</a> | <a title="fin_statement_model.statements.configs.models.CalculatedItemModel" href="models.html#fin_statement_model.statements.configs.models.CalculatedItemModel">CalculatedItemModel</a> | <a title="fin_statement_model.statements.configs.models.MetricItemModel" href="models.html#fin_statement_model.statements.configs.models.MetricItemModel">MetricItemModel</a> | <a title="fin_statement_model.statements.configs.models.SubtotalModel" href="models.html#fin_statement_model.statements.configs.models.SubtotalModel">SubtotalModel</a> | <a title="fin_statement_model.statements.configs.models.SectionModel" href="models.html#fin_statement_model.statements.configs.models.SectionModel">SectionModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SectionModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SectionModel.subsections"><code class="name">var <span class="ident">subsections</span> : list[<a title="fin_statement_model.statements.configs.models.SectionModel" href="models.html#fin_statement_model.statements.configs.models.SectionModel">SectionModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SectionModel.subtotal"><code class="name">var <span class="ident">subtotal</span> : <a title="fin_statement_model.statements.configs.models.SubtotalModel" href="models.html#fin_statement_model.statements.configs.models.SubtotalModel">SubtotalModel</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SectionModel.type"><code class="name">var <span class="ident">type</span> : Literal['section']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.SectionModel.check_unique_item_ids"><code class="name flex">
<span>def <span class="ident">check_unique_item_ids</span></span>(<span>self: <a title="fin_statement_model.statements.configs.SectionModel" href="#fin_statement_model.statements.configs.SectionModel">SectionModel</a>) ‑> <a title="fin_statement_model.statements.configs.models.SectionModel" href="models.html#fin_statement_model.statements.configs.models.SectionModel">SectionModel</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@model_validator(mode=&#34;after&#34;)
def check_unique_item_ids(self: SectionModel) -&gt; SectionModel:
    &#34;&#34;&#34;Ensure that item and subsection IDs within a section are unique and subtotal refs valid.&#34;&#34;&#34;
    ids = [item.id for item in self.items] + [sub.id for sub in self.subsections]
    duplicates = {item_id for item_id in ids if ids.count(item_id) &gt; 1}
    if duplicates:
        raise ValueError(f&#34;Duplicate item id(s) in section &#39;{self.id}&#39;: {&#39;, &#39;.join(duplicates)}&#34;)
    if self.subtotal and self.subtotal.items_to_sum is not None:
        valid_ids = [item.id for item in self.items]
        missing = [i for i in self.subtotal.items_to_sum if i not in valid_ids]
        if missing:
            raise ValueError(f&#34;Section &#39;{self.id}&#39; subtotal references undefined ids: {&#39;, &#39;.join(missing)}&#34;)
    return self</code></pre>
</details>
<div class="desc"><p>Ensure that item and subsection IDs within a section are unique and subtotal refs valid.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format">validate_display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.configs.StatementConfig"><code class="flex name class">
<span>class <span class="ident">StatementConfig</span></span>
<span>(</span><span>config_data: dict[str, typing.Any],<br>enable_node_validation: bool = False,<br>node_validation_strict: bool = False,<br>node_validator: <a title="fin_statement_model.statements.validation.UnifiedNodeValidator" href="../validation.html#fin_statement_model.statements.validation.UnifiedNodeValidator">UnifiedNodeValidator</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementConfig:
    &#34;&#34;&#34;Manages configuration parsing and building for financial statement structures.

    This class handles validating statement configuration data (provided as a dictionary)
    and building StatementStructure objects from these configurations.
    It does NOT handle file loading.
    &#34;&#34;&#34;

    def __init__(
        self,
        config_data: dict[str, Any],
        enable_node_validation: bool = False,
        node_validation_strict: bool = False,
        node_validator: UnifiedNodeValidator | None = None,
    ):
        &#34;&#34;&#34;Initialize a statement configuration processor.

        Args:
            config_data: Dictionary containing the raw configuration data.
            enable_node_validation: If True, validates node IDs using UnifiedNodeValidator.
            node_validation_strict: If True, treats node validation failures as errors.
                                   If False, treats them as warnings.
            node_validator: Optional pre-configured UnifiedNodeValidator instance.
                           If None and enable_node_validation is True, creates a default instance.

        Raises:
            ValueError: If config_data is not a non-empty dictionary.
        &#34;&#34;&#34;
        if not config_data or not isinstance(config_data, dict):
            raise ValueError(&#34;config_data must be a non-empty dictionary.&#34;)

        self.config_data = config_data
        self.model: StatementModel | None = None  # Store validated model

        # Node validation configuration
        self.enable_node_validation = enable_node_validation
        self.node_validation_strict = node_validation_strict

        # Initialize node_validator attribute
        self.node_validator: UnifiedNodeValidator | None = None
        if enable_node_validation:
            if node_validator is not None:
                self.node_validator = node_validator
            else:
                # Create default validator
                self.node_validator = UnifiedNodeValidator(
                    standard_node_registry,
                    strict_mode=node_validation_strict,
                    auto_standardize=True,
                    warn_on_non_standard=True,
                    enable_patterns=True,
                )

    def validate_config(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Validate the configuration data using Pydantic models and optional node validation.

        Returns:
            list[ErrorDetail]: List of validation errors, or empty list if valid.
                     Stores the validated model in self.model on success.
        &#34;&#34;&#34;
        error_collector = ErrorCollector()

        try:
            # First perform Pydantic validation
            self.model = StatementModel.model_validate(self.config_data)

            # If node validation is enabled, perform additional validation
            if self.enable_node_validation and self.node_validator:
                self._validate_node_ids(self.model, error_collector)

            # Collect structured errors (always include errors)
            errors: list[ErrorDetail] = error_collector.get_errors()
            warnings: list[ErrorDetail] = error_collector.get_warnings()

            if self.node_validation_strict:
                result: list[ErrorDetail] = errors + warnings
            else:
                # Log warnings but exclude from returned errors
                for warning in warnings:
                    logger.warning(&#34;Node validation warning: %s&#34;, warning)
                result = errors

        except ValidationError as ve:
            # Convert Pydantic errors to structured ErrorDetail list
            error_details: list[ErrorDetail] = []
            for err in ve.errors():
                loc = &#34;.&#34;.join(str(x) for x in err.get(&#34;loc&#34;, []))
                msg = err.get(&#34;msg&#34;, &#34;&#34;)
                error_details.append(
                    ErrorDetail(
                        code=&#34;pydantic_validation&#34;,
                        message=msg,
                        context=loc,
                        severity=ErrorSeverity.ERROR,
                    )
                )
            self.model = None  # Ensure model is not set on validation error
            return error_details
        except Exception as e:
            # Catch other potential validation issues
            logger.exception(&#34;Unexpected error during configuration validation&#34;)
            self.model = None
            return [
                ErrorDetail(
                    code=&#34;unexpected_validation_error&#34;,
                    message=str(e),
                    severity=ErrorSeverity.ERROR,
                )
            ]
        else:
            return result

    def _validate_node_ids(self, model: StatementModel, error_collector: ErrorCollector) -&gt; None:
        &#34;&#34;&#34;Validate all node IDs in the statement model using UnifiedNodeValidator.

        Args:
            model: The validated StatementModel to check.
            error_collector: ErrorCollector to accumulate validation issues.
        &#34;&#34;&#34;
        logger.debug(&#34;Starting node ID validation for statement &#39;%s&#39;&#34;, model.id)

        # Validate statement ID itself
        self._validate_single_node_id(model.id, &#34;statement&#34;, &#34;statement.id&#34;, error_collector)

        # Validate all sections recursively
        for section in model.sections:
            self._validate_section_node_ids(section, error_collector, f&#34;statement.{model.id}&#34;)

    def _validate_section_node_ids(
        self,
        section: SectionModel,
        error_collector: ErrorCollector,
        parent_context: str,
    ) -&gt; None:
        &#34;&#34;&#34;Validate node IDs within a section and its items.

        Args:
            section: The section model to validate.
            error_collector: ErrorCollector to accumulate validation issues.
            parent_context: Context string for error reporting.
        &#34;&#34;&#34;
        section_context = f&#34;{parent_context}.section.{section.id}&#34;

        # Validate section ID
        self._validate_single_node_id(section.id, &#34;section&#34;, f&#34;{section_context}.id&#34;, error_collector)

        # Validate all items in the section
        for item in section.items:
            self._validate_item_node_ids(item, error_collector, section_context)

        # Validate subsections recursively
        for subsection in section.subsections:
            self._validate_section_node_ids(subsection, error_collector, section_context)

        # Validate section subtotal if present
        if section.subtotal:
            self._validate_item_node_ids(section.subtotal, error_collector, section_context)

    def _validate_item_node_ids(
        self, item: BaseItemModel, error_collector: ErrorCollector, parent_context: str
    ) -&gt; None:
        &#34;&#34;&#34;Validate node IDs within a specific item.

        Args:
            item: The item model to validate.
            error_collector: ErrorCollector to accumulate validation issues.
            parent_context: Context string for error reporting.
        &#34;&#34;&#34;
        item_context = f&#34;{parent_context}.item.{item.id}&#34;

        # Validate the item ID itself
        self._validate_single_node_id(item.id, &#34;item&#34;, f&#34;{item_context}.id&#34;, error_collector)

        # Type-specific validation
        if isinstance(item, LineItemModel):
            # Validate node_id if present
            if item.node_id:
                self._validate_single_node_id(item.node_id, &#34;node&#34;, f&#34;{item_context}.node_id&#34;, error_collector)

            # Validate standard_node_ref if present
            if item.standard_node_ref:
                self._validate_single_node_id(
                    item.standard_node_ref,
                    &#34;standard_node&#34;,
                    f&#34;{item_context}.standard_node_ref&#34;,
                    error_collector,
                )

        elif isinstance(item, CalculatedItemModel):
            # Validate calculation inputs
            self._validate_calculation_inputs(item.calculation, error_collector, item_context)

        elif isinstance(item, MetricItemModel):
            # Validate metric inputs (the values, not the keys)
            for input_key, input_id in item.inputs.items():
                self._validate_single_node_id(
                    input_id,
                    &#34;metric_input&#34;,
                    f&#34;{item_context}.inputs.{input_key}&#34;,
                    error_collector,
                )

        elif isinstance(item, SubtotalModel):
            # Validate items_to_sum if present
            if item.items_to_sum:
                for i, input_id in enumerate(item.items_to_sum):
                    self._validate_single_node_id(
                        input_id,
                        &#34;subtotal_input&#34;,
                        f&#34;{item_context}.items_to_sum[{i}]&#34;,
                        error_collector,
                    )

            # Validate calculation inputs if present
            if item.calculation:
                self._validate_calculation_inputs(item.calculation, error_collector, item_context)

        elif isinstance(item, SectionModel):
            # Recursive validation for nested sections
            self._validate_section_node_ids(item, error_collector, parent_context)

    def _validate_calculation_inputs(
        self,
        calculation: CalculationSpec,
        error_collector: ErrorCollector,
        parent_context: str,
    ) -&gt; None:
        &#34;&#34;&#34;Validate inputs within a calculation specification.

        Args:
            calculation: The calculation specification to validate.
            error_collector: ErrorCollector to accumulate validation issues.
            parent_context: Context string for error reporting.
        &#34;&#34;&#34;
        for i, input_id in enumerate(calculation.inputs):
            self._validate_single_node_id(
                input_id,
                &#34;calculation_input&#34;,
                f&#34;{parent_context}.calculation.inputs[{i}]&#34;,
                error_collector,
            )

    def _validate_single_node_id(
        self,
        node_id: str,
        node_type: str,
        context: str,
        error_collector: ErrorCollector,
    ) -&gt; None:
        &#34;&#34;&#34;Validate a single node ID using the UnifiedNodeValidator.

        Args:
            node_id: The node ID to validate.
            node_type: Type description for error messages.
            context: Context string for error reporting.
            error_collector: ErrorCollector to accumulate validation issues.
        &#34;&#34;&#34;
        if not self.node_validator:
            return

        try:
            validation_result = self.node_validator.validate(
                node_id,
                node_type=node_type,
                parent_nodes=None,  # Could be enhanced to track parent context
                use_cache=True,
            )

            # Determine severity based on validation result and configuration
            if not validation_result.is_valid:
                severity = ErrorSeverity.ERROR if self.node_validation_strict else ErrorSeverity.WARNING
                message = f&#34;Invalid {node_type} ID &#39;{node_id}&#39;: {validation_result.message}&#34;
                if severity == ErrorSeverity.ERROR:
                    error_collector.add_error(
                        code=&#34;invalid_node_id&#34;,
                        message=message,
                        context=context,
                        source=node_id,
                    )
                else:
                    error_collector.add_warning(
                        code=&#34;invalid_node_id&#34;,
                        message=message,
                        context=context,
                        source=node_id,
                    )

            elif validation_result.category in [
                &#34;alternate&#34;,
                &#34;subnode_nonstandard&#34;,
                &#34;custom&#34;,
            ]:
                # These are valid but could be improved
                error_collector.add_warning(
                    code=&#34;non_standard_node_id&#34;,
                    message=f&#34;Non-standard {node_type} ID &#39;{node_id}&#39;: {validation_result.message}&#34;,
                    context=context,
                    source=node_id,
                )

            # Add suggestions if available
            if validation_result.suggestions:
                suggestion_msg = (
                    f&#34;Suggestions for {node_type} ID &#39;{node_id}&#39;: {&#39;; &#39;.join(validation_result.suggestions)}&#34;
                )
                error_collector.add_warning(
                    code=&#34;node_id_suggestions&#34;,
                    message=suggestion_msg,
                    context=context,
                    source=node_id,
                )

        except Exception as e:
            logger.exception(&#34;Error validating node ID &#39;%s&#39; in context &#39;%s&#39;&#34;, node_id, context)
            error_collector.add_warning(
                code=&#34;node_validation_error&#34;,
                message=f&#34;Failed to validate {node_type} ID &#39;{node_id}&#39;: {e}&#34;,
                context=context,
                source=node_id,
            )</code></pre>
</details>
<div class="desc"><p>Manages configuration parsing and building for financial statement structures.</p>
<p>This class handles validating statement configuration data (provided as a dictionary)
and building StatementStructure objects from these configurations.
It does NOT handle file loading.</p>
<p>Initialize a statement configuration processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_data</code></strong></dt>
<dd>Dictionary containing the raw configuration data.</dd>
<dt><strong><code>enable_node_validation</code></strong></dt>
<dd>If True, validates node IDs using UnifiedNodeValidator.</dd>
<dt><strong><code>node_validation_strict</code></strong></dt>
<dd>If True, treats node validation failures as errors.
If False, treats them as warnings.</dd>
<dt><strong><code>node_validator</code></strong></dt>
<dd>Optional pre-configured UnifiedNodeValidator instance.
If None and enable_node_validation is True, creates a default instance.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If config_data is not a non-empty dictionary.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.StatementConfig.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self) ‑> list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="../utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Validate the configuration data using Pydantic models and optional node validation.

    Returns:
        list[ErrorDetail]: List of validation errors, or empty list if valid.
                 Stores the validated model in self.model on success.
    &#34;&#34;&#34;
    error_collector = ErrorCollector()

    try:
        # First perform Pydantic validation
        self.model = StatementModel.model_validate(self.config_data)

        # If node validation is enabled, perform additional validation
        if self.enable_node_validation and self.node_validator:
            self._validate_node_ids(self.model, error_collector)

        # Collect structured errors (always include errors)
        errors: list[ErrorDetail] = error_collector.get_errors()
        warnings: list[ErrorDetail] = error_collector.get_warnings()

        if self.node_validation_strict:
            result: list[ErrorDetail] = errors + warnings
        else:
            # Log warnings but exclude from returned errors
            for warning in warnings:
                logger.warning(&#34;Node validation warning: %s&#34;, warning)
            result = errors

    except ValidationError as ve:
        # Convert Pydantic errors to structured ErrorDetail list
        error_details: list[ErrorDetail] = []
        for err in ve.errors():
            loc = &#34;.&#34;.join(str(x) for x in err.get(&#34;loc&#34;, []))
            msg = err.get(&#34;msg&#34;, &#34;&#34;)
            error_details.append(
                ErrorDetail(
                    code=&#34;pydantic_validation&#34;,
                    message=msg,
                    context=loc,
                    severity=ErrorSeverity.ERROR,
                )
            )
        self.model = None  # Ensure model is not set on validation error
        return error_details
    except Exception as e:
        # Catch other potential validation issues
        logger.exception(&#34;Unexpected error during configuration validation&#34;)
        self.model = None
        return [
            ErrorDetail(
                code=&#34;unexpected_validation_error&#34;,
                message=str(e),
                severity=ErrorSeverity.ERROR,
            )
        ]
    else:
        return result</code></pre>
</details>
<div class="desc"><p>Validate the configuration data using Pydantic models and optional node validation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[ErrorDetail]</code></dt>
<dd>List of validation errors, or empty list if valid.
Stores the validated model in self.model on success.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel"><code class="flex name class">
<span>class <span class="ident">StatementModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementModel(BaseModel):
    &#34;&#34;&#34;Define the top-level statement configuration model.

    Args:
        id: Unique identifier for the statement. Must not contain spaces.
        name: Human-readable name of the statement.
        description: Optional description of the statement.
        metadata: Optional metadata dictionary.
        sections: List of top-level sections in the statement.
        units: Optional default unit description for the entire statement.
        display_scale_factor: Optional default scale factor for the entire statement.
    &#34;&#34;&#34;

    id: str = Field(..., description=&#34;Unique statement identifier. Must not contain spaces.&#34;)
    name: str = Field(..., description=&#34;Human-readable statement name.&#34;)
    description: str | None = Field(&#34;&#34;, description=&#34;Optional statement description.&#34;)
    metadata: dict[str, Any] = Field(default_factory=dict, description=&#34;Optional metadata dictionary.&#34;)
    sections: list[SectionModel] = Field(..., description=&#34;List of top-level sections in the statement.&#34;)

    # Statement-level units and scaling
    units: str | None = Field(
        None,
        description=&#34;Default unit description for the statement (e.g., &#39;USD Thousands&#39;).&#34;,
    )
    display_scale_factor: float = Field(
        1.0,
        description=&#34;Default scale factor for displaying values in this statement.&#34;,
    )

    @field_validator(&#34;id&#34;, mode=&#34;before&#34;)
    @classmethod
    def id_must_not_contain_spaces(cls, value: str) -&gt; str:
        &#34;&#34;&#34;Ensure that statement &#39;id&#39; does not contain spaces.&#34;&#34;&#34;
        if &#34; &#34; in value:
            raise ValueError(&#34;must not contain spaces&#34;)
        return value

    @field_validator(&#34;display_scale_factor&#34;, mode=&#34;before&#34;)
    @classmethod
    def validate_display_scale_factor(cls, value: float) -&gt; float:
        &#34;&#34;&#34;Ensure display_scale_factor is positive and non-zero.&#34;&#34;&#34;
        if value &lt;= 0:
            raise ValueError(&#34;display_scale_factor must be positive and non-zero&#34;)
        return value

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)

    @model_validator(mode=&#34;after&#34;)
    def check_unique_section_ids(self: StatementModel) -&gt; StatementModel:
        &#34;&#34;&#34;Ensure that top-level section IDs are unique.&#34;&#34;&#34;
        ids = [section.id for section in self.sections]
        duplicates = {sec_id for sec_id in ids if ids.count(sec_id) &gt; 1}
        if duplicates:
            raise ValueError(f&#34;Duplicate section id(s): {&#39;, &#39;.join(duplicates)}&#34;)
        return self</code></pre>
</details>
<div class="desc"><p>Define the top-level statement configuration model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the statement. Must not contain spaces.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name of the statement.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description of the statement.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata dictionary.</dd>
<dt><strong><code>sections</code></strong></dt>
<dd>List of top-level sections in the statement.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional default unit description for the entire statement.</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Optional default scale factor for the entire statement.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.StatementModel.description"><code class="name">var <span class="ident">description</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.display_scale_factor"><code class="name">var <span class="ident">display_scale_factor</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.metadata"><code class="name">var <span class="ident">metadata</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.sections"><code class="name">var <span class="ident">sections</span> : list[<a title="fin_statement_model.statements.configs.models.SectionModel" href="models.html#fin_statement_model.statements.configs.models.SectionModel">SectionModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.units"><code class="name">var <span class="ident">units</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.StatementModel.id_must_not_contain_spaces"><code class="name flex">
<span>def <span class="ident">id_must_not_contain_spaces</span></span>(<span>value: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that statement 'id' does not contain spaces.</p></div>
</dd>
<dt id="fin_statement_model.statements.configs.StatementModel.validate_display_scale_factor"><code class="name flex">
<span>def <span class="ident">validate_display_scale_factor</span></span>(<span>value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure display_scale_factor is positive and non-zero.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.StatementModel.check_unique_section_ids"><code class="name flex">
<span>def <span class="ident">check_unique_section_ids</span></span>(<span>self: <a title="fin_statement_model.statements.configs.StatementModel" href="#fin_statement_model.statements.configs.StatementModel">StatementModel</a>) ‑> <a title="fin_statement_model.statements.configs.models.StatementModel" href="models.html#fin_statement_model.statements.configs.models.StatementModel">StatementModel</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@model_validator(mode=&#34;after&#34;)
def check_unique_section_ids(self: StatementModel) -&gt; StatementModel:
    &#34;&#34;&#34;Ensure that top-level section IDs are unique.&#34;&#34;&#34;
    ids = [section.id for section in self.sections]
    duplicates = {sec_id for sec_id in ids if ids.count(sec_id) &gt; 1}
    if duplicates:
        raise ValueError(f&#34;Duplicate section id(s): {&#39;, &#39;.join(duplicates)}&#34;)
    return self</code></pre>
</details>
<div class="desc"><p>Ensure that top-level section IDs are unique.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.configs.SubtotalModel"><code class="flex name class">
<span>class <span class="ident">SubtotalModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubtotalModel(BaseItemModel):
    &#34;&#34;&#34;Define a subtotal configuration model.

    Args:
        type: Must be &#39;subtotal&#39; for this model.
        calculation: Optional calculation specification for the subtotal.
        items_to_sum: Optional list of item IDs to sum for the subtotal.
    &#34;&#34;&#34;

    type: Literal[&#34;subtotal&#34;] = Field(&#34;subtotal&#34;, description=&#34;Discriminator for subtotal items.&#34;)
    calculation: CalculationSpec | None = Field(None, description=&#34;Calculation specification for the subtotal.&#34;)
    items_to_sum: list[str] | None = Field(None, description=&#34;List of item IDs to sum for the subtotal.&#34;)

    @model_validator(mode=&#34;before&#34;)
    @classmethod
    def exactly_one_of_calculation_or_items(cls, values: dict[str, Any]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Ensure exactly one of &#39;calculation&#39; or &#39;items_to_sum&#39; is provided.&#34;&#34;&#34;
        calc, items = values.get(&#34;calculation&#34;), values.get(&#34;items_to_sum&#34;)
        if bool(calc) == bool(items):
            raise ValueError(&#34;must provide exactly one of &#39;calculation&#39; or &#39;items_to_sum&#39;&#34;)
        return values

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define a subtotal configuration model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>Must be 'subtotal' for this model.</dd>
<dt><strong><code>calculation</code></strong></dt>
<dd>Optional calculation specification for the subtotal.</dd>
<dt><strong><code>items_to_sum</code></strong></dt>
<dd>Optional list of item IDs to sum for the subtotal.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.configs.SubtotalModel.calculation"><code class="name">var <span class="ident">calculation</span> : <a title="fin_statement_model.statements.configs.models.CalculationSpec" href="models.html#fin_statement_model.statements.configs.models.CalculationSpec">CalculationSpec</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SubtotalModel.items_to_sum"><code class="name">var <span class="ident">items_to_sum</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SubtotalModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.configs.SubtotalModel.type"><code class="name">var <span class="ident">type</span> : Literal['subtotal']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.configs.SubtotalModel.exactly_one_of_calculation_or_items"><code class="name flex">
<span>def <span class="ident">exactly_one_of_calculation_or_items</span></span>(<span>values: dict[str, Any]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure exactly one of 'calculation' or 'items_to_sum' is provided.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.configs.models.BaseItemModel" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel">BaseItemModel</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_format">validate_display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor" href="models.html#fin_statement_model.statements.configs.models.BaseItemModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.statements" href="../index.html">fin_statement_model.statements</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.statements.configs.models" href="models.html">fin_statement_model.statements.configs.models</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.validator" href="validator.html">fin_statement_model.statements.configs.validator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec">AdjustmentFilterSpec</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_scenarios" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_scenarios">exclude_scenarios</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_tags" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_tags">exclude_tags</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_types" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.exclude_types">exclude_types</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.include_scenarios" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.include_scenarios">include_scenarios</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.include_tags" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.include_tags">include_tags</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.include_types" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.include_types">include_types</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.model_config" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.period" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.period">period</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.require_all_tags" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.require_all_tags">require_all_tags</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.AdjustmentFilterSpec.validate_adjustment_types" href="#fin_statement_model.statements.configs.AdjustmentFilterSpec.validate_adjustment_types">validate_adjustment_types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.BaseItemModel" href="#fin_statement_model.statements.configs.BaseItemModel">BaseItemModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.css_class" href="#fin_statement_model.statements.configs.BaseItemModel.css_class">css_class</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.default_adjustment_filter" href="#fin_statement_model.statements.configs.BaseItemModel.default_adjustment_filter">default_adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.description" href="#fin_statement_model.statements.configs.BaseItemModel.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.display_format" href="#fin_statement_model.statements.configs.BaseItemModel.display_format">display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.display_scale_factor" href="#fin_statement_model.statements.configs.BaseItemModel.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.hide_if_all_zero" href="#fin_statement_model.statements.configs.BaseItemModel.hide_if_all_zero">hide_if_all_zero</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.id" href="#fin_statement_model.statements.configs.BaseItemModel.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.id_must_not_contain_spaces" href="#fin_statement_model.statements.configs.BaseItemModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.is_contra" href="#fin_statement_model.statements.configs.BaseItemModel.is_contra">is_contra</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.metadata" href="#fin_statement_model.statements.configs.BaseItemModel.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.model_config" href="#fin_statement_model.statements.configs.BaseItemModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.name" href="#fin_statement_model.statements.configs.BaseItemModel.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.notes_references" href="#fin_statement_model.statements.configs.BaseItemModel.notes_references">notes_references</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.sign_convention" href="#fin_statement_model.statements.configs.BaseItemModel.sign_convention">sign_convention</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.units" href="#fin_statement_model.statements.configs.BaseItemModel.units">units</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.validate_display_format" href="#fin_statement_model.statements.configs.BaseItemModel.validate_display_format">validate_display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.BaseItemModel.validate_display_scale_factor" href="#fin_statement_model.statements.configs.BaseItemModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.CalculatedItemModel" href="#fin_statement_model.statements.configs.CalculatedItemModel">CalculatedItemModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.CalculatedItemModel.calculation" href="#fin_statement_model.statements.configs.CalculatedItemModel.calculation">calculation</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.CalculatedItemModel.model_config" href="#fin_statement_model.statements.configs.CalculatedItemModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.CalculatedItemModel.type" href="#fin_statement_model.statements.configs.CalculatedItemModel.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.CalculationSpec" href="#fin_statement_model.statements.configs.CalculationSpec">CalculationSpec</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.CalculationSpec.inputs" href="#fin_statement_model.statements.configs.CalculationSpec.inputs">inputs</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.CalculationSpec.model_config" href="#fin_statement_model.statements.configs.CalculationSpec.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.CalculationSpec.type" href="#fin_statement_model.statements.configs.CalculationSpec.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.LineItemModel" href="#fin_statement_model.statements.configs.LineItemModel">LineItemModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.LineItemModel.exactly_one_node_reference" href="#fin_statement_model.statements.configs.LineItemModel.exactly_one_node_reference">exactly_one_node_reference</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.LineItemModel.model_config" href="#fin_statement_model.statements.configs.LineItemModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.LineItemModel.node_id" href="#fin_statement_model.statements.configs.LineItemModel.node_id">node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.LineItemModel.standard_node_ref" href="#fin_statement_model.statements.configs.LineItemModel.standard_node_ref">standard_node_ref</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.LineItemModel.type" href="#fin_statement_model.statements.configs.LineItemModel.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.MetricItemModel" href="#fin_statement_model.statements.configs.MetricItemModel">MetricItemModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.MetricItemModel.inputs" href="#fin_statement_model.statements.configs.MetricItemModel.inputs">inputs</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.MetricItemModel.metric_id" href="#fin_statement_model.statements.configs.MetricItemModel.metric_id">metric_id</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.MetricItemModel.model_config" href="#fin_statement_model.statements.configs.MetricItemModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.MetricItemModel.type" href="#fin_statement_model.statements.configs.MetricItemModel.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.SectionModel" href="#fin_statement_model.statements.configs.SectionModel">SectionModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.SectionModel.check_unique_item_ids" href="#fin_statement_model.statements.configs.SectionModel.check_unique_item_ids">check_unique_item_ids</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SectionModel.items" href="#fin_statement_model.statements.configs.SectionModel.items">items</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SectionModel.model_config" href="#fin_statement_model.statements.configs.SectionModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SectionModel.subsections" href="#fin_statement_model.statements.configs.SectionModel.subsections">subsections</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SectionModel.subtotal" href="#fin_statement_model.statements.configs.SectionModel.subtotal">subtotal</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SectionModel.type" href="#fin_statement_model.statements.configs.SectionModel.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.StatementConfig" href="#fin_statement_model.statements.configs.StatementConfig">StatementConfig</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.StatementConfig.validate_config" href="#fin_statement_model.statements.configs.StatementConfig.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.StatementModel" href="#fin_statement_model.statements.configs.StatementModel">StatementModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.StatementModel.check_unique_section_ids" href="#fin_statement_model.statements.configs.StatementModel.check_unique_section_ids">check_unique_section_ids</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.description" href="#fin_statement_model.statements.configs.StatementModel.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.display_scale_factor" href="#fin_statement_model.statements.configs.StatementModel.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.id" href="#fin_statement_model.statements.configs.StatementModel.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.id_must_not_contain_spaces" href="#fin_statement_model.statements.configs.StatementModel.id_must_not_contain_spaces">id_must_not_contain_spaces</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.metadata" href="#fin_statement_model.statements.configs.StatementModel.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.model_config" href="#fin_statement_model.statements.configs.StatementModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.name" href="#fin_statement_model.statements.configs.StatementModel.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.sections" href="#fin_statement_model.statements.configs.StatementModel.sections">sections</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.units" href="#fin_statement_model.statements.configs.StatementModel.units">units</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.StatementModel.validate_display_scale_factor" href="#fin_statement_model.statements.configs.StatementModel.validate_display_scale_factor">validate_display_scale_factor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.configs.SubtotalModel" href="#fin_statement_model.statements.configs.SubtotalModel">SubtotalModel</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.configs.SubtotalModel.calculation" href="#fin_statement_model.statements.configs.SubtotalModel.calculation">calculation</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SubtotalModel.exactly_one_of_calculation_or_items" href="#fin_statement_model.statements.configs.SubtotalModel.exactly_one_of_calculation_or_items">exactly_one_of_calculation_or_items</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SubtotalModel.items_to_sum" href="#fin_statement_model.statements.configs.SubtotalModel.items_to_sum">items_to_sum</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SubtotalModel.model_config" href="#fin_statement_model.statements.configs.SubtotalModel.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.configs.SubtotalModel.type" href="#fin_statement_model.statements.configs.SubtotalModel.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
