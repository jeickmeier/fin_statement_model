===== fin_statement_model/metrics.py =====
METRIC_DEFINITIONS = {
    # Profitability Metrics

    "gross_profit": {
        "inputs": ["revenue", "cost_of_goods_sold"],
        "formula": "revenue - cost_of_goods_sold",
        "metric_type": "profitability",
        "metric_description": "The profit a company makes after deducting the costs directly associated with making and selling its products or services."
    },

    "operating_income": {
        "inputs": ["gross_profit", "operating_expenses"],
        "formula": "gross_profit - operating_expenses",
        "metric_type": "profitability",
        "metric_description": "Profit generated from core business operations, excluding interest and taxes."
    },

    "total_interest_expense": {
        "inputs": ["other_interest_expenses","interest_income","interest_expense"],
        "formula": "interest_income - interest_expense-other_interest_expenses",
        "metric_type": "profitability",
        "metric_description": "Income generated from interest-bearing assets minus interest expenses."
    },

    "pre_tax_income": {
        "inputs": ["operating_income","total_interest_expense"],
        "formula": "operating_income + total_interest_expense",
        "metric_type": "profitability",
        "metric_description": "Profit before taxes."
    },

    "net_income": {
        "inputs": ["pre_tax_income", "tax_expense"],
        "formula": "pre_tax_income - tax_expense",
        "metric_type": "profitability", 
        "metric_description": "The company's total earnings or profit after all expenses, interest, and taxes have been deducted."
    },

    "ebit": {
        "inputs": ["net_income","tax_expense","total_interest_expense"],
        "formula": "net_income - total_interest_expense + tax_expense",
        "metric_type": "profitability",
        "metric_description": "Earnings Before Interest and Taxes; measures company's operating performance without considering financial and tax-related decisions."
    },

    "ebitda": {
        "inputs": ["ebit", "depreciation_and_amortization"],
        "formula": "ebit + depreciation_and_amortization",
        "metric_type": "profitability",
        "metric_description": "Earnings Before Interest, Taxes, Depreciation, and Amortization; indicates operational performance excluding non-cash expenses."
    },

    "nopat": {
        "inputs": ["net_income", "total_interest_expense"],
        "formula": "net_income - total_interest_expense",
        "metric_type": "profitability",
        "metric_description": "Net Operating Profit After Taxes; shows operating performance after tax adjustments but before financing costs."
    },



    # Margin Metrics
    "gross_profit_margin": {
        "inputs": ["gross_profit", "revenue"],
        "formula": "gross_profit / revenue",
        "metric_type": "margin",
        "metric_description": "Percentage of revenue remaining after deducting cost of goods sold; indicates pricing strategy and production efficiency."
    },

    "operating_margin": {
        "inputs": ["operating_income", "revenue"],
        "formula": "operating_income / revenue",
        "metric_type": "margin",
        "metric_description": "Percentage of revenue remaining after operating expenses; measures operational efficiency."
    },

    "net_profit_margin": {
        "inputs": ["net_income", "revenue"],
        "formula": "net_income / revenue",
        "metric_type": "margin",
        "metric_description": "Percentage of revenue that becomes profit after all expenses; indicates overall profitability."
    },

    "ebit_margin": {
        "inputs": ["ebit", "revenue"],
        "formula": "ebit / revenue",
        "metric_type": "margin",
        "metric_description": "Operating profitability as a percentage of revenue before interest and taxes."
    },

    "ebitda_margin": {
        "inputs": ["ebitda", "revenue"],
        "formula": "ebitda / revenue",
        "metric_type": "margin",
        "metric_description": "Operating performance as a percentage of revenue before financial, tax, and non-cash items."
    },

    "nopat_margin": {
        "inputs": ["nopat", "revenue"],
        "formula": "nopat / revenue",
        "metric_type": "margin",
        "metric_description": "After-tax operating profit as a percentage of revenue."
    },

    # Asset Metrics
    "average_total_assets": {
        "inputs": ["total_assets", "total_assets_previous"],
        "formula": "(total_assets + total_assets_previous) / 2",
        "metric_type": "asset",
        "metric_description": "Mean value of assets between two periods; used for various return calculations."
    },

    "average_shareholders_equity": {
        "inputs": ["total_equity", "total_equity_previous"],
        "formula": "(total_equity + total_equity_previous) / 2",
        "metric_type": "asset",
        "metric_description": "Mean value of shareholders' equity between two periods; used for return calculations."
    },

    # Return Metrics
    "return_on_assets": {
        "inputs": ["net_income", "average_total_assets"],
        "formula": "net_income / average_total_assets",
        "metric_type": "return",
        "metric_description": "Measures how efficiently a company uses its assets to generate profits."
    },
    "return_on_equity": {
        "inputs": ["net_income", "average_shareholders_equity"],
        "formula": "net_income / average_shareholders_equity",
        "metric_type": "return",
        "metric_description": "Measures how efficiently a company uses shareholders' investments to generate profits."
    },
    "temp_debt_equity": {
        "inputs": ["total_debt", "total_equity"],
        "formula": "total_debt + total_equity",
        "metric_type": "return",
        "metric_description": "Temporary calculation for invested capital computation."
    },
    "invested_capital": {
        "inputs": ["total_debt", "total_equity", "cash"],
        "formula": "total_debt + total_equity - cash",
        "metric_type": "return",
        "metric_description": "Total investment in the business excluding excess cash; used for ROIC calculation."
    },
    "roic": {
        "inputs": ["nopat", "average_invested_capital"],
        "formula": "nopat / average_invested_capital",
        "metric_type": "return",
        "metric_description": "Return on Invested Capital; measures how efficiently a company uses all capital to generate profits."
    },
    "capital_employed": {
        "inputs": ["total_assets", "current_liabilities"],
        "formula": "total_assets - current_liabilities",
        "metric_type": "return",
        "metric_description": "Long-term capital invested in the business; used for ROCE calculation."
    },
    "roce": {
        "inputs": ["ebit", "average_capital_employed"],
        "formula": "ebit / average_capital_employed",
        "metric_type": "return",
        "metric_description": "Return on Capital Employed; measures profitability relative to long-term financing."
    },

    # Liquidity Metrics
    "current_ratio": {
        "inputs": ["current_assets", "current_liabilities"],
        "formula": "current_assets / current_liabilities",
        "metric_type": "liquidity",
        "metric_description": "Measures company's ability to pay short-term obligations with short-term assets."
    },
    "quick_assets": {
        "inputs": ["current_assets", "inventory"],
        "formula": "current_assets - inventory",
        "metric_type": "liquidity",
        "metric_description": "Most liquid assets; used in quick ratio calculation."
    },
    "quick_ratio": {
        "inputs": ["quick_assets", "current_liabilities"],
        "formula": "quick_assets / current_liabilities",
        "metric_type": "liquidity",
        "metric_description": "More conservative measure of liquidity that excludes inventory from current assets."
    },
    "cash_ratio": {
        "inputs": ["cash", "current_liabilities"],
        "formula": "cash / current_liabilities",
        "metric_type": "liquidity",
        "metric_description": "Most conservative liquidity measure; shows ability to cover short-term debt with cash only."
    },

    # Leverage Metrics
    "debt_to_equity": {
        "inputs": ["total_debt", "total_shareholders_equity"],
        "formula": "total_debt / total_shareholders_equity",
        "metric_type": "leverage",
        "metric_description": "Measures extent of debt financing relative to equity financing."
    },
    "debt_to_assets": {
        "inputs": ["total_debt", "total_assets"],
        "formula": "total_debt / total_assets",
        "metric_type": "leverage",
        "metric_description": "Indicates percentage of assets financed through debt."
    },
    "interest_coverage": {
        "inputs": ["ebit", "interest_expense"],
        "formula": "ebit / interest_expense",
        "metric_type": "leverage",
        "metric_description": "Indicates ability to meet interest payments from operating earnings."
    },
    "financial_leverage": {
        "inputs": ["average_total_assets", "average_shareholders_equity"],
        "formula": "average_total_assets / average_shareholders_equity",
        "metric_type": "leverage",
        "metric_description": "Measures total assets relative to shareholders' equity; indicates leverage level."
    },
    "equity_multiplier": {
        "inputs": ["total_assets", "total_equity"],
        "formula": "total_assets / total_equity",
        "metric_type": "leverage",
        "metric_description": "Alternative measure of financial leverage; shows assets funded by each dollar of equity."
    },

    # Debt Service Metrics
    "cash_available_for_debt_service": {
        "inputs": ["operating_cash_flow", "interest_expense", "taxes"],
        "formula": "operating_cash_flow + interest_expense + taxes",
        "metric_type": "debt_service",
        "metric_description": "Cash available to service debt obligations after operations."
    },
    "debt_service_coverage_ratio": {
        "inputs": ["cash_available_for_debt_service", "debt_service"],
        "formula": "cash_available_for_debt_service / debt_service",
        "metric_type": "debt_service",
        "metric_description": "Measures ability to service debt obligations from operating cash flow."
    },
    "ebit_plus_fixed_charges": {
        "inputs": ["ebit", "fixed_charges_before_tax"],
        "formula": "ebit + fixed_charges_before_tax",
        "metric_type": "debt_service",
        "metric_description": "Operating earnings plus fixed charges; used in fixed charge coverage ratio."
    },
    "fixed_charge_coverage_ratio": {
        "inputs": ["ebit", "fixed_charges_before_tax", "fixed_charges"],
        "formula": "(ebit + fixed_charges_before_tax) / fixed_charges",
        "metric_type": "debt_service",
        "metric_description": "Measures ability to meet fixed payment obligations from earnings."
    },

    # Efficiency Metrics
    "asset_turnover": {
        "inputs": ["revenue", "average_total_assets"],
        "formula": "revenue / average_total_assets",
        "metric_type": "efficiency",
        "metric_description": "Measures how efficiently assets are used to generate revenue."
    },
    "inventory_turnover": {
        "inputs": ["cost_of_goods_sold", "average_inventory"],
        "formula": "cost_of_goods_sold / average_inventory",
        "metric_type": "efficiency",
        "metric_description": "Indicates how many times inventory is sold and replaced over a period."
    },
    "receivables_turnover": {
        "inputs": ["revenue", "average_accounts_receivable"],
        "formula": "revenue / average_accounts_receivable",
        "metric_type": "efficiency",
        "metric_description": "Measures how quickly customers pay their bills."
    },
    "payables_turnover": {
        "inputs": ["cost_of_goods_sold", "average_accounts_payable"],
        "formula": "cost_of_goods_sold / average_accounts_payable",
        "metric_type": "efficiency",
        "metric_description": "Measures how quickly the company pays its suppliers."
    },

    # Working Capital Metrics
    "ar_over_revenue": {
        "inputs": ["average_accounts_receivable", "revenue"],
        "formula": "(average_accounts_receivable / revenue) * 365",
        "metric_type": "working_capital",
        "metric_description": "Proportion of receivables to revenue; used in DSO calculation."
    },
    "dso": {
        "inputs": ["average_accounts_receivable", "revenue"],
        "formula": "(average_accounts_receivable / revenue) * 365",
        "metric_type": "working_capital",
        "metric_description": "Days Sales Outstanding; average number of days to collect payment."
    },
    "inv_over_cogs": {
        "inputs": ["average_inventory", "cost_of_goods_sold"],
        "formula": "(average_inventory / cost_of_goods_sold) * 365",
        "metric_type": "working_capital",
        "metric_description": "Proportion of inventory to COGS; used in DIO calculation."
    },
    "dio": {
        "inputs": ["average_inventory", "cost_of_goods_sold"],
        "formula": "(average_inventory / cost_of_goods_sold) * 365",
        "metric_type": "working_capital",
        "metric_description": "Days Inventory Outstanding; average days to sell inventory."
    },
    "ap_over_cogs": {
        "inputs": ["average_accounts_payable", "cost_of_goods_sold"],
        "formula": "(average_accounts_payable / cost_of_goods_sold) * 365",
        "metric_type": "working_capital",
        "metric_description": "Proportion of payables to COGS; used in DPO calculation."
    },
    "dpo": {
        "inputs": ["average_accounts_payable", "cost_of_goods_sold"],
        "formula": "(average_accounts_payable / cost_of_goods_sold) * 365",
        "metric_type": "working_capital",
        "metric_description": "Days Payables Outstanding; average days to pay suppliers."
    },
    "temp_dso_dio": {
        "inputs": ["dso", "dio"],
        "formula": "dso + dio",
        "metric_type": "working_capital",
        "metric_description": "Temporary calculation for cash conversion cycle."
    },
    "cash_conversion_cycle": {
        "inputs": ["temp_dso_dio", "dpo"],
        "formula": "temp_dso_dio - dpo",
        "metric_type": "working_capital",
        "metric_description": "Number of days to convert resource inputs into cash flows."
    },

    # Asset Utilization Metrics
    "working_capital_turnover": {
        "inputs": ["revenue", "average_working_capital"],
        "formula": "revenue / average_working_capital",
        "metric_type": "asset_utilization",
        "metric_description": "Measures how efficiently working capital is used to generate sales."
    },
    "fixed_asset_turnover": {
        "inputs": ["revenue", "average_net_fixed_assets"],
        "formula": "revenue / average_net_fixed_assets",
        "metric_type": "asset_utilization",
        "metric_description": "Measures how efficiently fixed assets are used to generate sales."
    },

    # Market Metrics
    "eps": {
        "inputs": ["net_income", "shares_outstanding"],
        "formula": "net_income / shares_outstanding",
        "metric_type": "market",
        "metric_description": "Earnings Per Share; profit allocated to each outstanding share."
    },
    "p_e_ratio": {
        "inputs": ["share_price", "eps"],
        "formula": "share_price / eps",
        "metric_type": "market",
        "metric_description": "Price-to-Earnings ratio; indicates market value relative to earnings."
    },
    "p_s_ratio": {
        "inputs": ["market_capitalization", "revenue"],
        "formula": "market_capitalization / revenue",
        "metric_type": "market",
        "metric_description": "Price-to-Sales ratio; indicates market value relative to revenue."
    },
    "ev_ebitda": {
        "inputs": ["enterprise_value", "ebitda"],
        "formula": "enterprise_value / ebitda",
        "metric_type": "market",
        "metric_description": "Enterprise Value to EBITDA; indicates company value relative to operating performance."
    },
    "ev_ebit": {
        "inputs": ["enterprise_value", "ebit"],
        "formula": "enterprise_value / ebit",
        "metric_type": "market",
        "metric_description": "Enterprise Value to EBIT; indicates company value relative to operating earnings."
    },

    # Dividend Metrics
    "dividends_per_share": {
        "inputs": ["annual_dividends", "shares_outstanding"],
        "formula": "annual_dividends / shares_outstanding",
        "metric_type": "dividend",
        "metric_description": "Total dividends paid divided by number of shares outstanding."
    },
    "dividend_yield": {
        "inputs": ["dividends_per_share", "share_price"],
        "formula": "dividends_per_share / share_price",
        "metric_type": "dividend",
        "metric_description": "Dividend return relative to share price."
    },
    "dividend_payout_ratio": {
        "inputs": ["dividends", "net_income"],
        "formula": "dividends / net_income",
        "metric_type": "dividend",
        "metric_description": "Proportion of earnings paid out as dividends."
    },

    # Cash Flow Metrics
    "free_cash_flow": {
        "inputs": ["operating_cash_flow", "capex"],
        "formula": "operating_cash_flow - capex",
        "metric_type": "cash_flow",
        "metric_description": "Cash available after operating expenses and capital investments."
    },
    "p_fcf": {
        "inputs": ["market_capitalization", "free_cash_flow"],
        "formula": "market_capitalization / free_cash_flow",
        "metric_type": "cash_flow",
        "metric_description": "Price to Free Cash Flow; indicates market value relative to cash generation."
    },
    "ev_sales": {
        "inputs": ["enterprise_value", "revenue"],
        "formula": "enterprise_value / revenue",
        "metric_type": "cash_flow",
        "metric_description": "Enterprise Value to Sales ratio; indicates company value relative to revenue."
    },

    # Growth Metrics
    "revenue_change": {
        "inputs": ["revenue_current", "revenue_previous"],
        "formula": "revenue_current - revenue_previous",
        "metric_type": "growth",
        "metric_description": "Absolute change in revenue between periods."
    },
    "revenue_growth": {
        "inputs": ["revenue", "revenue_previous"],
        "formula": "(revenue - revenue_previous) / revenue_previous",
        "metric_type": "growth",
        "metric_description": "Percentage change in revenue between periods."
    },
    "eps_change": {
        "inputs": ["eps_current", "eps_previous"],
        "formula": "eps_current - eps_previous",
        "metric_type": "growth",
        "metric_description": "Absolute change in EPS between periods."
    },
    "eps_growth": {
        "inputs": ["eps", "eps_previous"],
        "formula": "(eps - eps_previous) / eps_previous",
        "metric_type": "growth",
        "metric_description": "Percentage change in EPS between periods."
    },
    "peg_ratio": {
        "inputs": ["p_e_ratio", "eps_growth"],
        "formula": "p_e_ratio / eps_growth",
        "metric_type": "growth",
        "metric_description": "P/E ratio relative to EPS growth rate; indicates value considering growth."
    },
    "net_income_change": {
        "inputs": ["net_income_current", "net_income_previous"],
        "formula": "net_income_current - net_income_previous",
        "metric_type": "growth",
        "metric_description": "Absolute change in net income between periods."
    },
    "net_income_growth": {
        "inputs": ["net_income", "net_income_previous"],
        "formula": "(net_income - net_income_previous) / net_income_previous",
        "metric_type": "growth",
        "metric_description": "Percentage change in net income between periods."
    },
    "dividend_change": {
        "inputs": ["dividends_current", "dividends_previous"],
        "formula": "dividends_current - dividends_previous",
        "metric_type": "growth",
        "metric_description": "Absolute change in dividends between periods."
    },
    "dividend_growth": {
        "inputs": ["dividend_change", "dividends_previous"],
        "formula": "dividend_change / dividends_previous",
        "metric_type": "growth",
        "metric_description": "Percentage change in dividends between periods."
    },

    # Additional Performance Metrics
    "return_on_sales": {
        "inputs": ["ebit", "revenue"],
        "formula": "ebit / revenue",
        "metric_type": "performance",
        "metric_description": "Operating profit as a percentage of sales; indicates operational efficiency."
    },
    "gross_profit_change": {
        "inputs": ["gross_profit_current", "gross_profit_previous"],
        "formula": "gross_profit_current - gross_profit_previous",
        "metric_type": "performance",
        "metric_description": "Absolute change in gross profit between periods."
    },
    "gross_profit_growth": {
        "inputs": ["gross_profit_change", "gross_profit_previous"],
        "formula": "gross_profit_change / gross_profit_previous",
        "metric_type": "performance",
        "metric_description": "Percentage change in gross profit between periods."
    },
    "cash_return_on_assets": {
        "inputs": ["operating_cash_flow", "average_total_assets"],
        "formula": "operating_cash_flow / average_total_assets",
        "metric_type": "performance",
        "metric_description": "Cash-based return on assets; indicates asset efficiency in generating cash."
    },
    "ocf_minus_capex": {
        "inputs": ["operating_cash_flow", "capex"],
        "formula": "operating_cash_flow - capex",
        "metric_type": "performance",
        "metric_description": "Operating cash flow less capital expenditures; used in FCFE calculation."
    },
    "fcfe": {
        "inputs": ["ocf_minus_capex", "net_borrowings"],
        "formula": "ocf_minus_capex + net_borrowings",
        "metric_type": "performance",
        "metric_description": "Free Cash Flow to Equity; cash available to equity holders."
    },
    "free_cash_flow_per_share": {
        "inputs": ["free_cash_flow", "shares_outstanding"],
        "formula": "free_cash_flow / shares_outstanding",
        "metric_type": "performance",
        "metric_description": "Free cash flow allocated to each outstanding share."
    },
    "fcf_yield": {
        "inputs": ["free_cash_flow_per_share", "share_price"],
        "formula": "free_cash_flow_per_share / share_price",
        "metric_type": "performance",
        "metric_description": "Free cash flow return relative to share price."
    },
    "dupont_roe": {
        "inputs": ["net_profit_margin", "asset_turnover", "equity_multiplier"],
        "formula": "net_profit_margin * asset_turnover * equity_multiplier",
        "metric_type": "performance",
        "metric_description": "Detailed breakdown of ROE into operational efficiency, asset use efficiency, and leverage."
    }
}

===== fin_statement_model/llm/__pycache__/llm_client.cpython-39.pyc =====
a
    ô<ûg}  „                   @   sí   d dl Z d dlZd dlZd dlmZ d dlmZmZmZ d dl	m
Z
 e †e°ZeG ddÑ dÉÉZG ddÑ deÉZG d	d
Ñ d
eÉZG ddÑ dÉZdS )È    N)⁄	dataclass)⁄Optional⁄Dict⁄Any)⁄ThreadPoolExecutorc                   @   sR   e Zd ZU eed< dZeed< dZeed< dZe	ed< dZ
e	ed	< d
Ze	ed< dS )⁄	LLMConfig⁄api_keyzgpt-3.5-turbo⁄
model_namegffffffÊ?⁄temperatureÈñ   ⁄
max_tokensÈ   ⁄timeoutÈ   ⁄max_retriesN)⁄__name__⁄
__module__⁄__qualname__⁄str⁄__annotations__r	   r
   ⁄floatr   ⁄intr   r   © r   r   ˙M/Users/joneickmeier/fin_statement_model/fin_statement_model/llm/llm_client.pyr   
   s   
r   c                   @   s   e Zd ZdZdS )⁄LLMClientErrorz%Base exception for LLM client errors.N©r   r   r   ⁄__doc__r   r   r   r   r      s   r   c                   @   s   e Zd ZdZdS )⁄LLMTimeoutErrorzException for timeout errors.Nr   r   r   r   r   r      s   r   c                   @   st   e Zd Zdee dúddÑZejeje	e
fdddÑ dçeeeef d	úd
dÑÉZeed	úddÑZddÑ ZddÑ ZdS )⁄	LLMClientN)⁄configc                 C   s*   |pt ddç| _| jjt_tddç| _dS )zì
        Initialize the LLM client with configuration.
        
        Args:
            config: LLMConfig object containing API settings
        ⁄ )r   r   )⁄max_workersN)r   r   r   ⁄openair   ⁄	_executor)⁄selfr   r   r   r   ⁄__init__   s    
zLLMClient.__init__r   c                 C   s
   t | tÉS ©N)⁄
isinstancer   )⁄er   r   r   ⁄<lambda>-   Û    zLLMClient.<lambda>)⁄	max_triesZgiveup)⁄prompt⁄returnc              
   C   s÷   zdt †d| jjõ ù° tjj| jjd|dúg| jj| jj| jj	dç}|†
d°s`t †d° tdÉÇ|W S  ty– } zTdt|É†° v ròt †d	° td	É|Çt †d
t|É° tdt|Éõ ùÉ|ÇW Y d}~n
d}~0 0 dS )aJ  
        Make the API call to OpenAI with retry logic.
        
        Args:
            prompt: The input prompt for the LLM
            
        Returns:
            Dict containing the API response
            
        Raises:
            LLMClientError: For any client-related errors, including timeout if applicable
        z)Sending request to OpenAI API with model ⁄user)Zrole⁄content)⁄model⁄messagesr
   r   r   ⁄choicesz'No suggestions received from OpenAI APIz No suggestions received from APIr   zRequest timed outzOpenAI API request failed: %szAPI request failed: N)⁄logger⁄debugr   r	   r"   ZChatCompletion⁄creater
   r   r   ⁄get⁄errorr   ⁄	Exceptionr   ⁄lowerr   )r$   r,   ⁄responser(   r   r   r   ⁄_make_api_call)   s&    
˚



zLLMClient._make_api_callc              
   C   s†   zRt †d° | j†| j|°}|j| jjdç}|d d d d †° }t †d° |W S  t	yö } z0t †
dt|É° td	t|Éõ ùÉ|ÇW Y d
}~n
d
}~0 0 d
S )a<  
        Get a mapping suggestion from the LLM.
        
        Args:
            prompt: The input prompt describing the mapping request
            
        Returns:
            str: The suggested mapping from the LLM
            
        Raises:
            LLMClientError: For any client-related errors
        z-Requesting mapping suggestion from OpenAI API)r   r2   r   ⁄messager/   z(Successfully received mapping suggestionz$Error getting mapping suggestion: %sz"Failed to get mapping suggestion: N)r3   ⁄infor#   ⁄submitr;   ⁄resultr   r   ⁄stripr8   r7   r   r   )r$   r,   ⁄futurer:   ⁄
suggestionr(   r   r   r   ⁄get_mapping_suggestionT   s    

z LLMClient.get_mapping_suggestionc                 C   s   | S r&   r   )r$   r   r   r   ⁄	__enter__o   s    zLLMClient.__enter__c                 C   s   | j jddç d S )NT)⁄wait)r#   ⁄shutdown)r$   ⁄exc_type⁄exc_val⁄exc_tbr   r   r   ⁄__exit__r   s    zLLMClient.__exit__)N)r   r   r   r   r   r%   ⁄backoffZon_exceptionZexpor8   r   r   r   r   r;   rC   rD   rJ   r   r   r   r   r      s   ¸%r   )⁄loggingr"   rK   ⁄dataclassesr   ⁄typingr   r   r   ⁄concurrent.futuresr   ⁄	getLoggerr   r3   r   r8   r   r   r   r   r   r   r   ⁄<module>   s   
	

===== fin_statement_model/llm/llm_client.py =====
import logging
import openai
import backoff
from dataclasses import dataclass
from typing import Optional, Dict, Any
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)

@dataclass
class LLMConfig:
    api_key: str
    model_name: str = "gpt-3.5-turbo"
    temperature: float = 0.7
    max_tokens: int = 150
    timeout: int = 30
    max_retries: int = 3
    # base_url is no longer needed as the openai library handles the endpoint configuration.

class LLMClientError(Exception):
    """Base exception for LLM client errors."""
    pass

class LLMTimeoutError(LLMClientError):
    """Exception for timeout errors."""
    pass

class LLMClient:
    def __init__(self, config: Optional[LLMConfig] = None):
        """
        Initialize the LLM client with configuration.
        
        Args:
            config: LLMConfig object containing API settings
        """
        self.config = config or LLMConfig(api_key="")
        openai.api_key = self.config.api_key
        # Removed openai.api_base configuration as it's handled by openai library
        self._executor = ThreadPoolExecutor(max_workers=3)

    @backoff.on_exception(
        backoff.expo,
        (Exception, LLMTimeoutError),
        max_tries=3,
        giveup=lambda e: isinstance(e, LLMTimeoutError)
    )
    def _make_api_call(self, prompt: str) -> Dict[str, Any]:
        """
        Make the API call to OpenAI with retry logic.
        
        Args:
            prompt: The input prompt for the LLM
            
        Returns:
            Dict containing the API response
            
        Raises:
            LLMClientError: For any client-related errors, including timeout if applicable
        """
        try:
            logger.debug(f"Sending request to OpenAI API with model {self.config.model_name}")
            response = openai.ChatCompletion.create(
                model=self.config.model_name,
                messages=[{"role": "user", "content": prompt}],
                temperature=self.config.temperature,
                max_tokens=self.config.max_tokens,
                timeout=self.config.timeout
            )
            
            if not response.get("choices"):
                logger.error("No suggestions received from OpenAI API")
                raise LLMClientError("No suggestions received from API")
                
            return response
            
        except Exception as e:
            # Check if the error message indicates a timeout
            if "timeout" in str(e).lower():
                logger.error("Request timed out")
                raise LLMTimeoutError("Request timed out") from e
            logger.error("OpenAI API request failed: %s", str(e))
            raise LLMClientError(f"API request failed: {str(e)}") from e

    def get_mapping_suggestion(self, prompt: str) -> str:
        """
        Get a mapping suggestion from the LLM.
        
        Args:
            prompt: The input prompt describing the mapping request
            
        Returns:
            str: The suggested mapping from the LLM
            
        Raises:
            LLMClientError: For any client-related errors
        """
        try:
            logger.info("Requesting mapping suggestion from OpenAI API")
            future = self._executor.submit(self._make_api_call, prompt)
            response = future.result(timeout=self.config.timeout)
            
            suggestion = response["choices"][0]["message"]["content"].strip()
            logger.info("Successfully received mapping suggestion")
            
            return suggestion
            
        except Exception as e:
            logger.error("Error getting mapping suggestion: %s", str(e))
            raise LLMClientError(f"Failed to get mapping suggestion: {str(e)}") from e

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._executor.shutdown(wait=True)

===== fin_statement_model/importers/fmp.py =====
import requests
from typing import Dict
import pandas as pd
from ..financial_statement import FinancialStatementGraph

class FMPAdapter:
    """
    Financial Modeling Prep API adapter for fetching financial statement data
    and converting it to FinancialStatementGraph format.
    """
    
    def __init__(self, api_key: str):
        """
        Initialize the FMP adapter with an API key.
        
        Args:
            api_key (str): FMP API key
        """
        self.api_key = api_key
        self.base_url = "https://financialmodelingprep.com/stable"
        
        # Mapping of FMP field names to standardized node names
        self.income_statement_field_mapping = {
            # Income Statement mappings
            "revenue": "revenue",
            "costOfRevenue": "cost_of_goods_sold",

            "researchAndDevelopmentExpenses": "research_and_development_expenses",
            "generalAndAdministrativeExpenses": "general_and_administrative_expenses",
            "sellingAndMarketingExpenses": "selling_and_marketing_expenses",
            "sellingGeneralAndAdministrativeExpenses": "selling_general_and_administrative_expenses",

            "otherExpenses": "other_interest_expenses",
            "interestIncome": "interest_income",
            "interestExpense": "interest_expense",

            "incomeTaxExpense": "tax_expense",
            "depreciationAndAmortization": "depreciation_and_amortization",
        }

        self.balance_sheet_field_mapping = {
            # Balance Sheet mappings
            "cashAndCashEquivalents": "cash_and_cash_equivalents",
            "shortTermInvestments": "short_term_investments", 

            "netReceivables": "net_receivables",
            "accountsReceivables": "accounts_receivables",
            "otherReceivables": "other_receivables",
            "inventory": "inventory",
            "prepaids": "prepaids",
            "otherCurrentAssets": "other_current_assets",

            "propertyPlantEquipmentNet": "property_plant_equipment_net",
            "goodwill": "goodwill",
            "intangibleAssets": "intangible_assets",
            "goodwillAndIntangibleAssets": "goodwill_and_intangible_assets",
            "longTermInvestments": "long_term_investments",
            "taxAssets": "tax_assets",
            "otherNonCurrentAssets": "other_non_current_assets", 

            "otherAssets": "other_assets",

            "totalPayables": "total_payables",
            "accountPayables": "account_payables",
            "otherPayables": "other_payables",
            "accruedExpenses": "accrued_expenses",
            "shortTermDebt": "short_term_debt",
            "capitalLeaseObligationsCurrent": "capital_lease_obligations_current",
            "taxPayables": "tax_payables",
            "deferredRevenue": "deferred_revenue",
            "otherCurrentLiabilities": "other_current_liabilities",
            "longTermDebt": "long_term_debt",
            "deferredRevenueNonCurrent": "deferred_revenue_non_current",
            "deferredTaxLiabilitiesNonCurrent": "deferred_tax_liabilities_non_current",
            "otherNonCurrentLiabilities": "other_non_current_liabilities",
            "otherLiabilities": "other_liabilities",
            "capitalLeaseObligations": "capital_lease_obligations",

            "treasuryStock": "treasury_stock",
            "preferredStock": "preferred_stock", 
            "commonStock": "common_stock",
            "retainedEarnings": "retained_earnings",
            "additionalPaidInCapital": "additional_paid_in_capital",
            "accumulatedOtherComprehensiveIncomeLoss": "accumulated_other_comprehensive_income_loss",
            "otherTotalStockholdersEquity": "other_total_stockholders_equity"
        }

        self.cash_flow_field_mapping = {
            # Cash Flow mappings
            "operatingCashFlow": "operating_cash_flow",
            "investingCashFlow": "investing_cash_flow",
            "financingCashFlow": "financing_cash_flow",
        }


    def fetch_statement(self, ticker: str, period: str = 'FY', limit: int = 50, statement_type: str = 'income_statement') -> Dict:
        """
        Fetch financial statement data from FMP API.
        
        Args:
            ticker (str): Company ticker symbol (e.g., 'AAPL')
            period (str): 'FY' or 'QTR'
            limit (int): Maximum number of periods to fetch
            
        Returns:
            Dict: Raw financial statement data from FMP
        """
        if statement_type == 'income_statement':
            url = f"{self.base_url}/income-statement?apikey={self.api_key}&symbol={ticker}&period={period}"
        elif statement_type == 'balance_sheet':
            url = f"{self.base_url}/balance-sheet-statement?apikey={self.api_key}&symbol={ticker}&period={period}"
        elif statement_type == 'cash_flow':
            url = f"{self.base_url}/cash-flow-statement?apikey={self.api_key}&symbol={ticker}&period={period}"
        else:
            raise ValueError(f"Invalid statement type: {statement_type}")
        
        #print(url)
        response = requests.get(url)
        if response.status_code != 200:
            raise Exception(f"Failed to fetch data: {response.status_code}")
            
        return response.json()
    
    def create_statement_graph(self, 
                                      ticker: str, 
                                      period: str = 'FY', 
                                      limit: int = 50,
                                      statement_type: str = 'income_statement') -> FinancialStatementGraph:
        """
        Create a FinancialStatementGraph from FMP financial statement data.
        
        Args:
            ticker (str): Company ticker symbol (e.g., 'AAPL')
            period (str): 'FY' or 'QTR'
            limit (int): Maximum number of periods to fetch
            
        Returns:
            FinancialStatementGraph: Graph containing the financial statement data
        """
        # Fetch raw data
        if statement_type == 'income_statement':
            data = self.fetch_statement(ticker, period, limit, statement_type='income_statement')
            mapping = self.income_statement_field_mapping
        elif statement_type == 'balance_sheet':
            data = self.fetch_statement(ticker, period, limit, statement_type='balance_sheet')
            mapping = self.balance_sheet_field_mapping
        elif statement_type == 'cash_flow':
            data = self.fetch_statement(ticker, period, limit, statement_type='cash_flow')
            mapping = self.cash_flow_field_mapping
        
        # Extract periods
        periods = []
        for statement in data:
            date = statement['date']
            if period == 'FY':
                period_label = f"FY{date[:4]}"
            else:
                quarter = pd.Timestamp(date).quarter
                period_label = f"{date[:4]}Q{quarter}"
            periods.append(period_label)
        periods = sorted(list(set(periods)))
        
        # Initialize graph
        fsg = FinancialStatementGraph(periods=periods)
        
        # Process each mapped field
        for fmp_field, node_name in mapping.items():
            values = {}
            for statement in data:
                date = statement['date']
                if period == 'FY':
                    period_label = f"FY{date[:4]}"
                else:
                    quarter = pd.Timestamp(date).quarter
                    period_label = f"{date[:4]}Q{quarter}"
                    
                if fmp_field in statement:
                    value = statement[fmp_field]
                    if value is not None:
                        values[period_label] = float(value)
            
            if values:  # Only add node if we have values
                fsg.add_financial_statement_item(node_name, values)
        
        # Add common calculations and metrics
        if statement_type == 'income_statement':
            try:
                fsg.add_calculation("operating_expenses", ["research_and_development_expenses", "general_and_administrative_expenses","selling_and_marketing_expenses","selling_general_and_administrative_expenses"], "addition")      
            except Exception as e:
                print(f"Error adding operating expenses: {e}", data)
                print(fsg)
        elif statement_type == 'balance_sheet':
            try:
                fsg.add_calculation("cash_and_short_term_investments", ["cash_and_cash_equivalents", "short_term_investments"], "addition")
                fsg.add_calculation("total_current_assets", ["cash_and_cash_equivalents", "short_term_investments", "net_receivables","accounts_receivables","other_receivables", "inventory", "prepaids", "other_current_assets"], "addition")
                fsg.add_calculation("total_non_current_assets", ["property_plant_equipment_net", "goodwill", "intangible_assets", "goodwill_and_intangible_assets", "long_term_investments", "tax_assets", "other_non_current_assets"], "addition")
                fsg.add_calculation("total_assets", ["total_current_assets", "total_non_current_assets"], "addition")

            except Exception as e:
                print(f"Error adding total liabilities: {e}", data)
                print(fsg)
        
        return fsg


===== fin_statement_model/importers/mapping_service.py =====
"""
Mapping service for converting non-standard metric names to standard metric names using LLM.
"""
from typing import Dict, List, Tuple, Optional
import difflib
import logging
import json
import threading
from pathlib import Path
from .exceptions import MappingError
from ..llm.llm_client import LLMClient

class MappingService:
    """Service for mapping non-standard metric names to standard metric names."""
    
    def __init__(self, metric_definitions: Dict, similarity_threshold: float = 0.85):
        """
        Initialize the mapping service.
        
        Args:
            metric_definitions: Dictionary of standard metric definitions
            similarity_threshold: Minimum similarity score to consider a match
        """
        self.metric_definitions = metric_definitions
        self.similarity_threshold = similarity_threshold
        self.standard_metrics = set(metric_definitions.keys())
        self.logger = logging.getLogger(__name__)
        self.llm_client = LLMClient()
        self.dynamic_mappings_path = Path("dynamic_mappings.json")
        self._load_dynamic_mappings()
        self._lock = threading.Lock()
        
    def map_metric_name(self, input_name: str) -> Tuple[str, float]:
        """
        Map a single non-standard metric name to the closest standard metric name.
        
        Args:
            input_name: Non-standard metric name to map
            
        Returns:
            Tuple of (mapped_name, confidence_score)
            
        Raises:
            MappingError: If no suitable mapping is found
        """
        input_name = self._normalize_metric_name(input_name)
        
        # Check dynamic mappings first
        if input_name in self.dynamic_mappings:
            return self.dynamic_mappings[input_name], 1.0
        
        # Direct match check
        if input_name in self.standard_metrics:
            return input_name, 1.0
            
        # Find closest matches using similarity scoring
        matches = []
        for standard_name in self.standard_metrics:
            score = self._calculate_similarity(input_name, standard_name)
            if score >= self.similarity_threshold:
                matches.append((standard_name, score))
                
        if matches:
            # Sort by similarity score
            matches.sort(key=lambda x: x[1], reverse=True)
            
            # Check for ambiguous matches
            if len(matches) > 1 and self._is_ambiguous(matches):
                self.logger.warning(f"Ambiguous mapping for {input_name}: {matches[:3]}")
                
            return matches[0]
        
        # If no matches found, try LLM-based mapping
        try:
            context = {"mapped_metrics": self.dynamic_mappings}
            mapped_name, confidence = self._map_with_llm(input_name, context)
            return mapped_name, confidence
        except Exception as e:
            self.logger.error(f"LLM mapping failed for {input_name}: {str(e)}")
            raise MappingError(f"No suitable mapping found for metric: {input_name}")
        
    def map_metric_names(self, input_names: List[str]) -> Dict[str, Tuple[str, float]]:
        """
        Map multiple non-standard metric names to standard names.
        
        Args:
            input_names: List of non-standard metric names
            
        Returns:
            Dictionary mapping input names to (standard_name, confidence_score) tuples
        """
        mappings = {}
        unmapped = []
        
        for name in input_names:
            try:
                mapped_name, score = self.map_metric_name(name)
                mappings[name] = (mapped_name, score)
            except MappingError as e:
                unmapped.append(name)
                self.logger.error(f"Failed to map metric: {e}")
                
        if unmapped:
            self.logger.warning(f"Failed to map metrics: {unmapped}")
            
        return mappings
        
    def validate_mapping(self, input_name: str, mapped_name: str) -> bool:
        """
        Validate if a mapping is acceptable based on metric definitions.
        
        Args:
            input_name: Original input name
            mapped_name: Proposed standard metric name
            
        Returns:
            Boolean indicating if mapping is valid
        """
        if mapped_name not in self.metric_definitions:
            return False
            
        # Additional validation could be added here based on metric properties
        return True
        
    def _normalize_metric_name(self, name: str) -> str:
        """Normalize metric name for comparison."""
        return name.lower().replace(' ', '_').strip()
        
    def _calculate_similarity(self, name1: str, name2: str) -> float:
        """Calculate similarity score between two metric names."""
        return difflib.SequenceMatcher(None, name1, name2).ratio()
        
    def _is_ambiguous(self, matches: List[Tuple[str, float]], 
                     threshold: float = 0.05) -> bool:
        """
        Check if matches are ambiguous based on score differences.
        
        Args:
            matches: List of (name, score) tuples
            threshold: Maximum score difference to consider ambiguous
            
        Returns:
            Boolean indicating if matches are ambiguous
        """
        if len(matches) < 2:
            return False
            
        return (matches[0][1] - matches[1][1]) < threshold
        
    def get_metric_info(self, metric_name: str) -> Optional[Dict]:
        """
        Get detailed information about a standard metric.
        
        Args:
            metric_name: Standard metric name
            
        Returns:
            Dictionary containing metric information or None if not found
        """
        return self.metric_definitions.get(metric_name)

    def _map_with_llm(self, input_name: str, context: Dict) -> Tuple[str, float]:
        """
        Use LLM to map an unknown metric name to a standard metric.
        
        Args:
            input_name: Non-standard metric name to map
            context: Dictionary containing mapping context
            
        Returns:
            Tuple of (mapped_name, confidence_score)
            
        Raises:
            MappingError: If LLM mapping fails or produces invalid result
        """
        prompt = self._generate_mapping_prompt(input_name, context)
        
        try:
            llm_response = self.llm_client.generate_mapping(prompt)
            mapped_name = self._normalize_metric_name(llm_response['mapped_name'])
            confidence = float(llm_response['confidence'])
            
            if not self.validate_mapping(input_name, mapped_name):
                raise MappingError(f"LLM suggested invalid mapping: {mapped_name}")
            
            # Store the new mapping
            with self._lock:
                self.dynamic_mappings[input_name] = mapped_name
                self._save_dynamic_mappings()
            
            return mapped_name, confidence
            
        except Exception as e:
            raise MappingError(f"LLM mapping failed: {str(e)}")

    def _generate_mapping_prompt(self, input_name: str, context: Dict) -> str:
        """Generate context-aware prompt for LLM mapping."""
        prompt = f"""Map the financial metric name '{input_name}' to one of the following standard metrics:
        {', '.join(sorted(self.standard_metrics))}
        
        Previously mapped examples:
        {json.dumps(context['mapped_metrics'], indent=2)}
        
        Return a JSON object with:
        - mapped_name: The standard metric name
        - confidence: A float between 0 and 1
        """
        return prompt

    def _load_dynamic_mappings(self):
        """Load dynamic mappings from file."""
        self.dynamic_mappings = {}
        if self.dynamic_mappings_path.exists():
            try:
                with open(self.dynamic_mappings_path, 'r') as f:
                    self.dynamic_mappings = json.load(f)
            except Exception as e:
                self.logger.error(f"Failed to load dynamic mappings: {str(e)}")

    def _save_dynamic_mappings(self):
        """Save dynamic mappings to file."""
        try:
            with open(self.dynamic_mappings_path, 'w') as f:
                json.dump(self.dynamic_mappings, f, indent=2)
        except Exception as e:
            self.logger.error(f"Failed to save dynamic mappings: {str(e)}")


===== fin_statement_model/importers/excel_importer.py =====
import pandas as pd
import numpy as np
from typing import Dict, List, Union, Tuple
from pathlib import Path
import re
from datetime import datetime

class ExcelImporter:
    """
    A class to handle importing financial data from Excel files.
    
    This class provides functionality to:
    - Read Excel files with multiple worksheets
    - Extract financial data regardless of format variations
    - Clean and validate the extracted data
    - Prepare data for mapping to standard financial statement items
    
    Attributes:
        file_path (Path): Path to the Excel file
        sheet_names (List[str]): List of sheet names to process
        date_format (str): Expected format for date columns
    """
    
    def __init__(self, file_path: Union[str, Path], sheet_names: List[str] = None, 
                 date_format: str = "%Y-%m-%d"):
        """
        Initialize the ExcelImporter with file path and optional parameters.
        
        Args:
            file_path: Path to the Excel file
            sheet_names: Optional list of specific sheets to process. If None, processes all sheets.
            date_format: Format string for parsing date columns
        
        Raises:
            FileNotFoundError: If the specified Excel file doesn't exist
            ValueError: If the file is not a valid Excel file
        """
        self.file_path = Path(file_path)
        if not self.file_path.exists():
            raise FileNotFoundError(f"Excel file not found: {file_path}")
        
        if self.file_path.suffix not in ['.xlsx', '.xls', '.xlsm']:
            raise ValueError(f"Invalid file format. Expected Excel file, got: {self.file_path.suffix}")
        
        self.sheet_names = sheet_names
        self.date_format = date_format
        self._data = None
    
    def read_excel(self) -> Dict[str, pd.DataFrame]:
        """
        Read the Excel file and return data from all relevant sheets.
        
        Returns:
            Dict mapping sheet names to their corresponding DataFrames
        
        Raises:
            ValueError: If no valid data is found in the Excel file
        """
        try:
            if self.sheet_names:
                sheets_dict = pd.read_excel(self.file_path, sheet_name=self.sheet_names)
            else:
                sheets_dict = pd.read_excel(self.file_path, sheet_name=None)
            
            if not sheets_dict:
                raise ValueError("No data found in Excel file")
            
            self._data = sheets_dict
            return sheets_dict
        
        except Exception as e:
            raise ValueError(f"Error reading Excel file: {str(e)}")
    
    def detect_data_structure(self, df: pd.DataFrame) -> Dict[str, Union[str, List[int]]]:
        """
        Analyze the structure of a DataFrame to determine its layout.
        
        Args:
            df: DataFrame to analyze
        
        Returns:
            Dict containing:
                'orientation': 'vertical' or 'horizontal'
                'header_rows': List of row indices containing headers
                'data_start': Index where actual data begins
        """
        structure = {
            'orientation': 'vertical',
            'header_rows': [],
            'data_start': 0
        }
        
        # Check for date-like columns (vertical orientation)
        date_cols = []
        for col in df.columns:
            if isinstance(col, (datetime, pd.Timestamp)) or (
                isinstance(col, str) and bool(re.search(r'\d{4}', col))
            ):
                date_cols.append(col)
        
        if date_cols:
            structure['orientation'] = 'vertical'
            return structure
        
        # Look for date-like values in first column (horizontal orientation)
        first_col = df.iloc[:, 0]
        date_rows = []
        for idx, val in enumerate(first_col):
            if isinstance(val, (datetime, pd.Timestamp)) or (
                isinstance(val, str) and bool(re.search(r'\d{4}', str(val)))
            ):
                date_rows.append(idx)
        
        if date_rows:
            structure['orientation'] = 'horizontal'
            structure['header_rows'] = list(range(min(date_rows)))
            structure['data_start'] = min(date_rows)
        
        return structure
    
    def standardize_dataframe(self, df: pd.DataFrame, 
                            structure: Dict[str, Union[str, List[int]]]) -> pd.DataFrame:
        """
        Convert DataFrame to a standardized format with items as rows and periods as columns.
        
        Args:
            df: Input DataFrame
            structure: Data structure information from detect_data_structure()
        
        Returns:
            Standardized DataFrame
        """
        if structure['orientation'] == 'horizontal':
            # Transpose if data is in horizontal format
            header_rows = structure['header_rows']
            data_start = structure['data_start']
            
            # Extract headers
            headers = df.iloc[header_rows].fillna(method='ffill', axis=1)
            header_names = ['_'.join(str(x) for x in col).strip('_') 
                          for col in zip(*headers.values)]
            
            # Extract data
            data = df.iloc[data_start:]
            data.columns = header_names
            
            # Set index from first column
            data = data.set_index(data.columns[0])
            
            return data.T
        
        return df
    
    def clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Clean and prepare the data for further processing.
        
        Performs the following operations:
        - Removes empty rows and columns
        - Standardizes column names
        - Converts numeric values
        - Handles missing values
        
        Args:
            df: DataFrame to clean
        
        Returns:
            Cleaned DataFrame
        """
        # Remove completely empty rows and columns
        df = df.dropna(how='all').dropna(axis=1, how='all')
        
        # Standardize column names
        df.columns = [str(col).strip() for col in df.columns]
        
        # Convert numeric values
        for col in df.columns:
            # Skip date columns
            if isinstance(col, (datetime, pd.Timestamp)):
                continue
                
            # Convert string numbers (handle parentheses for negative values)
            if df[col].dtype == object:
                df[col] = df[col].apply(lambda x: self._convert_to_number(x))
        
        return df
    
    def _convert_to_number(self, value: Union[str, float, int]) -> float:
        """
        Convert various number formats to float.
        
        Handles:
        - Parentheses for negative numbers: (100) -> -100
        - Currency symbols: $100 -> 100
        - Thousands separators: 1,000 -> 1000
        - Percentage values: 10% -> 0.1
        
        Args:
            value: Value to convert
        
        Returns:
            Converted float value or np.nan if conversion fails
        """
        if pd.isna(value):
            return np.nan
        
        if isinstance(value, (int, float)):
            return float(value)
        
        try:
            # Remove currency symbols and thousands separators
            value = str(value).strip()
            value = re.sub(r'[,$]', '', value)
            
            # Handle parentheses (negative numbers)
            if value.startswith('(') and value.endswith(')'):
                value = '-' + value[1:-1]
            
            # Handle percentages
            if value.endswith('%'):
                return float(value.rstrip('%')) / 100
            
            return float(value)
        except (ValueError, TypeError):
            return np.nan
    
    def extract_periods(self, df: pd.DataFrame) -> List[str]:
        """
        Extract and standardize period identifiers from the DataFrame.
        
        Args:
            df: DataFrame containing financial data
        
        Returns:
            List of standardized period identifiers
        """
        periods = []
        for col in df.columns:
            if isinstance(col, (datetime, pd.Timestamp)):
                # Convert datetime to string format
                periods.append(col.strftime('%Y-%m-%d'))
            elif isinstance(col, str):
                # Extract year from string (e.g., "FY2022", "2022", "Dec 2022")
                year_match = re.search(r'\d{4}', col)
                if year_match:
                    periods.append(year_match.group(0))
        
        return sorted(list(set(periods)))
    
    def get_financial_data(self) -> Tuple[Dict[str, Dict[str, float]], List[str]]:
        """
        Process the Excel file and return financial data in a format ready for FinancialStatementGraph.
        
        Returns:
            Tuple containing:
            - Dict mapping item names to their period values
            - List of standardized period identifiers
        
        Raises:
            ValueError: If no valid financial data is found
        """
        if self._data is None:
            self.read_excel()
        
        all_items = {}
        all_periods = set()
        
        for sheet_name, df in self._data.items():
            # Detect structure and standardize
            structure = self.detect_data_structure(df)
            df = self.standardize_dataframe(df, structure)
            
            # Clean the data
            df = self.clean_data(df)
            
            # Extract periods
            periods = self.extract_periods(df)
            all_periods.update(periods)
            
            # Extract items and their values
            for idx, row in df.iterrows():
                item_name = str(idx).strip()
                if item_name:
                    values = {}
                    for col, val in row.items():
                        if isinstance(col, (datetime, pd.Timestamp)):
                            period = col.strftime('%Y-%m-%d')
                        else:
                            year_match = re.search(r'\d{4}', str(col))
                            if year_match:
                                period = year_match.group(0)
                            else:
                                continue
                        
                        if not pd.isna(val):
                            values[period] = float(val)
                    
                    if values:
                        all_items[item_name] = values
        
        if not all_items:
            raise ValueError("No valid financial data found in Excel file")
        
        return all_items, sorted(list(all_periods))


===== fin_statement_model/importers/__pycache__/exceptions.cpython-39.pyc =====
a
    ı6ûg4  „                   @   s   G d dÑ de ÉZdS )c                       s0   e Zd ZdZdedúá fddÑZddÑ Zá  ZS )	⁄MappingErrorz:Exception raised for errors in the metric mapping process.N)⁄messagec                    s   t É †|° d S )N)⁄super⁄__init__)⁄selfr   ©⁄	__class__© ˙S/Users/joneickmeier/fin_statement_model/fin_statement_model/importers/exceptions.pyr      s    zMappingError.__init__c                 C   s   d| j r| j d ndõ ùS )NzMappingError: È    z$An error occurred in metric mapping.)⁄args)r   r   r   r	   ⁄__str__   s    zMappingError.__str__)N)⁄__name__⁄
__module__⁄__qualname__⁄__doc__⁄strr   r   ⁄__classcell__r   r   r   r	   r      s   r   N)⁄	Exceptionr   r   r   r   r	   ⁄<module>   Û    

===== fin_statement_model/importers/__pycache__/mapping_service.cpython-39.pyc =====
a
    p5ûg]!  „                   @   sr   d Z ddlmZmZmZmZ ddlZddlZddlZddl	Z	ddl
mZ ddlmZ ddlmZ G d	d
Ñ d
ÉZdS )z^
Mapping service for converting non-standard metric names to standard metric names using LLM.
È    )⁄Dict⁄List⁄Tuple⁄OptionalN)⁄PathÈ   )⁄MappingErrorÈ   )⁄	LLMClientc                   @   s  e Zd ZdZd&eedúddÑZeeeef dúddÑZ	e
e eeeeef f d	úd
dÑZeeedúddÑZeedúddÑZeeedúddÑZd'e
eeef  eedúddÑZeee dúddÑZeeeeef dúddÑZeeedúdd ÑZd!d"Ñ Zd#d$Ñ Zd%S )(⁄MappingServicezGService for mapping non-standard metric names to standard metric names.Á333333Î?)⁄metric_definitions⁄similarity_thresholdc                 C   sN   || _ || _t|†° É| _t†t°| _t	É | _
tdÉ| _| †°  t†° | _dS )z·
        Initialize the mapping service.
        
        Args:
            metric_definitions: Dictionary of standard metric definitions
            similarity_threshold: Minimum similarity score to consider a match
        zdynamic_mappings.jsonN)r   r   ⁄set⁄keys⁄standard_metrics⁄logging⁄	getLogger⁄__name__⁄loggerr
   ⁄
llm_clientr   ⁄dynamic_mappings_path⁄_load_dynamic_mappings⁄	threading⁄Lock⁄_lock)⁄selfr   r   © r   ˙X/Users/joneickmeier/fin_statement_model/fin_statement_model/importers/mapping_service.py⁄__init__   s    
zMappingService.__init__)⁄
input_name⁄returnc           	   
   C   s6  | † |°}|| jv r"| j| dfS || jv r4|dfS g }| jD ](}| †||°}|| jkr>|†||f° q>|rº|jddÑ ddç t|Édkr¥| †|°r¥| j	†
d|õ d|d	d
Ö õ ù° |d S z$d| ji}| †||°\}}||fW S  têy0 } z6| j	†d|õ dt|Éõ ù° td|õ ùÉÇW Y d	}~n
d	}~0 0 d	S )aU  
        Map a single non-standard metric name to the closest standard metric name.
        
        Args:
            input_name: Non-standard metric name to map
            
        Returns:
            Tuple of (mapped_name, confidence_score)
            
        Raises:
            MappingError: If no suitable mapping is found
        g      ?c                 S   s   | d S )Nr   r   )⁄xr   r   r   ⁄<lambda>A   Û    z0MappingService.map_metric_name.<locals>.<lambda>T)⁄key⁄reverser   zAmbiguous mapping for z: NÈ   r   ⁄mapped_metricszLLM mapping failed for z&No suitable mapping found for metric: )⁄_normalize_metric_name⁄dynamic_mappingsr   ⁄_calculate_similarityr   ⁄append⁄sort⁄len⁄_is_ambiguousr   ⁄warning⁄_map_with_llm⁄	Exception⁄error⁄strr   )	r   r    ⁄matchesZstandard_name⁄score⁄context⁄mapped_name⁄
confidence⁄er   r   r   ⁄map_metric_name!   s,    




 

zMappingService.map_metric_name)⁄input_namesr!   c                 C   så   i }g }|D ]d}z| † |°\}}||f||< W q tyn } z(|†|° | j†d|õ ù° W Y d}~qd}~0 0 q|rà| j†d|õ ù° |S )a  
        Map multiple non-standard metric names to standard names.
        
        Args:
            input_names: List of non-standard metric names
            
        Returns:
            Dictionary mapping input names to (standard_name, confidence_score) tuples
        zFailed to map metric: NzFailed to map metrics: )r;   r   r,   r   r3   r0   )r   r<   ⁄mappingsZunmapped⁄namer8   r6   r:   r   r   r   ⁄map_metric_namesR   s    

*zMappingService.map_metric_names)r    r8   r!   c                 C   s   || j vrdS dS )a  
        Validate if a mapping is acceptable based on metric definitions.
        
        Args:
            input_name: Original input name
            mapped_name: Proposed standard metric name
            
        Returns:
            Boolean indicating if mapping is valid
        FT)r   )r   r    r8   r   r   r   ⁄validate_mappingl   s    
zMappingService.validate_mapping)r>   r!   c                 C   s   |† ° †dd°†° S )z%Normalize metric name for comparison.˙ ⁄_)⁄lower⁄replace⁄strip)r   r>   r   r   r   r)   }   s    z%MappingService._normalize_metric_name)⁄name1⁄name2r!   c                 C   s   t †d||°†° S )z4Calculate similarity score between two metric names.N)⁄difflib⁄SequenceMatcher⁄ratio)r   rF   rG   r   r   r   r+   Å   s    z$MappingService._calculate_similarityÁöôôôôô©?)r5   ⁄	thresholdr!   c                 C   s,   t |Édk rdS |d d |d d  |k S )a1  
        Check if matches are ambiguous based on score differences.
        
        Args:
            matches: List of (name, score) tuples
            threshold: Maximum score difference to consider ambiguous
            
        Returns:
            Boolean indicating if matches are ambiguous
        r	   Fr   r   )r.   )r   r5   rL   r   r   r   r/   Ö   s    zMappingService._is_ambiguous)⁄metric_namer!   c                 C   s   | j †|°S )z
        Get detailed information about a standard metric.
        
        Args:
            metric_name: Standard metric name
            
        Returns:
            Dictionary containing metric information or None if not found
        )r   ⁄get)r   rM   r   r   r   ⁄get_metric_infoñ   s    
zMappingService.get_metric_info)r    r7   r!   c              
   C   s    | † ||°}zÇ| j†|°}| †|d °}t|d É}| †||°sNtd|õ ùÉÇ| jè" || j|< | †	°  W d  É n1 s|0    Y  ||fW S  t
yƒ } ztdt|Éõ ùÉÇW Y d}~n
d}~0 0 dS )aë  
        Use LLM to map an unknown metric name to a standard metric.
        
        Args:
            input_name: Non-standard metric name to map
            context: Dictionary containing mapping context
            
        Returns:
            Tuple of (mapped_name, confidence_score)
            
        Raises:
            MappingError: If LLM mapping fails or produces invalid result
        r8   r9   zLLM suggested invalid mapping: NzLLM mapping failed: )⁄_generate_mapping_promptr   Zgenerate_mappingr)   ⁄floatr@   r   r   r*   ⁄_save_dynamic_mappingsr2   r4   )r   r    r7   ⁄promptZllm_responser8   r9   r:   r   r   r   r1   ¢   s    
&
zMappingService._map_with_llmc              	   C   s6   d|õ dd† t| jÉ°õ dtj|d ddçõ dù}|S )	z.Generate context-aware prompt for LLM mapping.zMap the financial metric name 'z4' to one of the following standard metrics:
        z, z6
        
        Previously mapped examples:
        r(   r	   ©⁄indentzì
        
        Return a JSON object with:
        - mapped_name: The standard metric name
        - confidence: A float between 0 and 1
        )⁄join⁄sortedr   ⁄json⁄dumps)r   r    r7   rS   r   r   r   rP   ƒ   s    ˇ¸
z'MappingService._generate_mapping_promptc              
   C   så   i | _ | j†° ràz<t| jdÉè}t†|°| _ W d  É n1 s@0    Y  W n: tyÜ } z"| j†dt	|Éõ ù° W Y d}~n
d}~0 0 dS )z Load dynamic mappings from file.⁄rNz!Failed to load dynamic mappings: )
r*   r   ⁄exists⁄openrX   ⁄loadr2   r   r3   r4   ©r   ⁄fr:   r   r   r   r   “   s    
.z%MappingService._load_dynamic_mappingsc              
   C   sÇ   zBt | jdÉè"}tj| j|ddç W d  É n1 s60    Y  W n: ty| } z"| j†dt|Éõ ù° W Y d}~n
d}~0 0 dS )zSave dynamic mappings to file.⁄wr	   rT   Nz!Failed to save dynamic mappings: )	r\   r   rX   ⁄dumpr*   r2   r   r3   r4   r^   r   r   r   rR   ‹   s
    4z%MappingService._save_dynamic_mappingsN)r   )rK   )r   ⁄
__module__⁄__qualname__⁄__doc__r   rQ   r   r4   r   r;   r   r?   ⁄boolr@   r)   r+   r/   r   rO   r1   rP   r   rR   r   r   r   r   r      s    1$ ˇˇ"
r   )rd   ⁄typingr   r   r   r   rH   r   rX   r   ⁄pathlibr   ⁄
exceptionsr   ⁄llm.llm_clientr
   r   r   r   r   r   ⁄<module>   s   

===== fin_statement_model/importers/__pycache__/excel_importer.cpython-39.pyc =====
a
    U7ûgB*  „                   @   sZ   d dl Zd dlZd dlmZmZmZmZ d dl	m
Z
 d dlZd dlmZ G ddÑ dÉZdS )È    N)⁄Dict⁄List⁄Union⁄Tuple)⁄Path)⁄datetimec                   @   s  e Zd ZdZdeeef ee edúddÑZe	ee
jf dúdd	ÑZe
je	eeeee f f d
úddÑZe
je	eeeee f f e
jdúddÑZe
je
jd
úddÑZeeeef edúddÑZe
jee d
úddÑZee	ee	eef f ee f dúddÑZdS )⁄ExcelImportera  
    A class to handle importing financial data from Excel files.
    
    This class provides functionality to:
    - Read Excel files with multiple worksheets
    - Extract financial data regardless of format variations
    - Clean and validate the extracted data
    - Prepare data for mapping to standard financial statement items
    
    Attributes:
        file_path (Path): Path to the Excel file
        sheet_names (List[str]): List of sheet names to process
        date_format (str): Expected format for date columns
    N˙%Y-%m-%d)⁄	file_path⁄sheet_names⁄date_formatc                 C   sV   t |É| _| j†° s"td|õ ùÉÇ| jjdvr@td| jjõ ùÉÇ|| _|| _d| _dS )a‡  
        Initialize the ExcelImporter with file path and optional parameters.
        
        Args:
            file_path: Path to the Excel file
            sheet_names: Optional list of specific sheets to process. If None, processes all sheets.
            date_format: Format string for parsing date columns
        
        Raises:
            FileNotFoundError: If the specified Excel file doesn't exist
            ValueError: If the file is not a valid Excel file
        zExcel file not found: )z.xlsxz.xlsz.xlsmz/Invalid file format. Expected Excel file, got: N)	r   r
   ⁄exists⁄FileNotFoundError⁄suffix⁄
ValueErrorr   r   ⁄_data)⁄selfr
   r   r   © r   ˙W/Users/joneickmeier/fin_statement_model/fin_statement_model/importers/excel_importer.py⁄__init__   s    

zExcelImporter.__init__)⁄returnc              
   C   s~   zB| j rtj| j| j dç}ntj| jddç}|s8tdÉÇ|| _|W S  tyx } ztdt|Éõ ùÉÇW Y d}~n
d}~0 0 dS )a  
        Read the Excel file and return data from all relevant sheets.
        
        Returns:
            Dict mapping sheet names to their corresponding DataFrames
        
        Raises:
            ValueError: If no valid data is found in the Excel file
        )⁄
sheet_nameNzNo data found in Excel filezError reading Excel file: )r   ⁄pd⁄
read_excelr
   r   r   ⁄	Exception⁄str)r   Zsheets_dict⁄er   r   r   r   1   s    
zExcelImporter.read_excel)⁄dfr   c           	      C   s   dg ddú}g }|j D ]8}t|ttjfÉsDt|tÉrtt†d|°Ér|†	|° q|r`d|d< |S |j
ddÖdf }g }t|ÉD ]@\}}t|ttjfÉs¥t|tÉr~tt†dt|É°Ér~|†	|° q~|rÏd|d< ttt|ÉÉÉ|d< t|É|d	< |S )
a  
        Analyze the structure of a DataFrame to determine its layout.
        
        Args:
            df: DataFrame to analyze
        
        Returns:
            Dict containing:
                'orientation': 'vertical' or 'horizontal'
                'header_rows': List of row indices containing headers
                'data_start': Index where actual data begins
        ⁄verticalr   )⁄orientation⁄header_rows⁄
data_start˙\d{4}r   N⁄
horizontalr    r!   )⁄columns⁄
isinstancer   r   ⁄	Timestampr   ⁄bool⁄re⁄search⁄append⁄iloc⁄	enumerate⁄list⁄range⁄min)	r   r   ⁄	structure⁄	date_cols⁄col⁄	first_colZ	date_rows⁄idx⁄valr   r   r   ⁄detect_data_structureJ   s:    ˝
ˇˇˇˇz#ExcelImporter.detect_data_structure)r   r0   r   c                 C   sr   |d dkrn|d }|d }|j | jdddç}dd	Ñ t|jé D É}|j |d
Ö }||_|†|jd °}|jS |S )a*  
        Convert DataFrame to a standardized format with items as rows and periods as columns.
        
        Args:
            df: Input DataFrame
            structure: Data structure information from detect_data_structure()
        
        Returns:
            Standardized DataFrame
        r   r#   r    r!   ⁄ffillÈ   )⁄method⁄axisc                 S   s&   g | ]}d † ddÑ |D É°†d °ëqS )⁄_c                 s   s   | ]}t |ÉV  qd S ©N)r   )⁄.0⁄xr   r   r   ⁄	<genexpr>å   Û    zAExcelImporter.standardize_dataframe.<locals>.<listcomp>.<genexpr>)⁄join⁄strip©r=   r2   r   r   r   ⁄
<listcomp>å   s   ˇz7ExcelImporter.standardize_dataframe.<locals>.<listcomp>Nr   )r+   ⁄fillna⁄zip⁄valuesr$   ⁄	set_index⁄T)r   r   r0   r    r!   ⁄headers⁄header_names⁄datar   r   r   ⁄standardize_dataframey   s    ˇz#ExcelImporter.standardize_dataframec                    sr   |j ddçj dddç}ddÑ |jD É|_|jD ]>}t|ttjfÉrDq.|| jtkr.|| †á fddÑ°||< q.|S )	az  
        Clean and prepare the data for further processing.
        
        Performs the following operations:
        - Removes empty rows and columns
        - Standardizes column names
        - Converts numeric values
        - Handles missing values
        
        Args:
            df: DataFrame to clean
        
        Returns:
            Cleaned DataFrame
        ⁄all)⁄howr8   )r:   rO   c                 S   s   g | ]}t |É†° ëqS r   )r   rB   rC   r   r   r   rD   Æ   r@   z,ExcelImporter.clean_data.<locals>.<listcomp>c                    s
   à † | °S r<   )⁄_convert_to_number)r>   ©r   r   r   ⁄<lambda>∏   r@   z*ExcelImporter.clean_data.<locals>.<lambda>)	⁄dropnar$   r%   r   r   r&   ⁄dtype⁄object⁄apply)r   r   r2   r   rQ   r   ⁄
clean_dataö   s    
zExcelImporter.clean_data)⁄valuer   c              	   C   sÆ   t †|°rtjS t|ttfÉr&t|ÉS zft|É†° }t	†
dd|°}|†d°rf|†d°rfd|ddÖ  }|†d°rÑt|†d°Éd	 W S t|ÉW S  ttfy®   tj Y S 0 d
S )a°  
        Convert various number formats to float.
        
        Handles:
        - Parentheses for negative numbers: (100) -> -100
        - Currency symbols: $100 -> 100
        - Thousands separators: 1,000 -> 1000
        - Percentage values: 10% -> 0.1
        
        Args:
            value: Value to convert
        
        Returns:
            Converted float value or np.nan if conversion fails
        z[,$]⁄ ˙(˙)⁄-r8   Èˇˇˇˇ˙%Èd   N)r   ⁄isna⁄np⁄nanr%   ⁄int⁄floatr   rB   r(   ⁄sub⁄
startswith⁄endswith⁄rstripr   ⁄	TypeError)r   rX   r   r   r   rP   º   s    


z ExcelImporter._convert_to_numberc                 C   sl   g }|j D ]P}t|ttjfÉr0|†|†d°° q
t|tÉr
t†	d|°}|r
|†|†
d°° q
ttt|ÉÉÉS )zÈ
        Extract and standardize period identifiers from the DataFrame.
        
        Args:
            df: DataFrame containing financial data
        
        Returns:
            List of standardized period identifiers
        r	   r"   r   )r$   r%   r   r   r&   r*   ⁄strftimer   r(   r)   ⁄group⁄sortedr-   ⁄set)r   r   ⁄periodsr2   ⁄
year_matchr   r   r   ⁄extract_periods„   s    


zExcelImporter.extract_periodsc                 C   s  | j du r| †°  i }tÉ }| j †° D ]‘\}}| †|°}| †||°}| †|°}| †|°}|†|° |†	° D ]é\}}t
|É†° }	|	rji }
|†° D ]\\}}t|ttjfÉr≤|†d°}n"t†dt
|É°}|ré|†d°}nqét†|°sét|É|
|< qé|
rj|
||	< qjq&|ês
tdÉÇ|tt|ÉÉfS )aq  
        Process the Excel file and return financial data in a format ready for FinancialStatementGraph.
        
        Returns:
            Tuple containing:
            - Dict mapping item names to their period values
            - List of standardized period identifiers
        
        Raises:
            ValueError: If no valid financial data is found
        Nr	   r"   r   z+No valid financial data found in Excel file)r   r   rm   ⁄itemsr6   rM   rW   rp   ⁄update⁄iterrowsr   rB   r%   r   r   r&   rj   r(   r)   rk   r`   rd   r   rl   r-   )r   ⁄	all_items⁄all_periodsr   r   r0   rn   r4   ⁄row⁄	item_namerG   r2   r5   ⁄periodro   r   r   r   ⁄get_financial_data˙   s8    





z ExcelImporter.get_financial_data)Nr	   )⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r   r   r   r   r   r   ⁄	DataFramer   rc   r6   rM   rW   rd   rP   rp   r   ry   r   r   r   r   r      s     ˇˇ&/ˇ!"'r   )⁄pandasr   ⁄numpyra   ⁄typingr   r   r   r   ⁄pathlibr   r(   r   r   r   r   r   r   ⁄<module>   s   

===== fin_statement_model/importers/exceptions.py =====
class MappingError(Exception):
    """Exception raised for errors in the metric mapping process."""

    def __init__(self, message: str = None):
        super().__init__(message)

    def __str__(self):
        return f"MappingError: {self.args[0] if self.args else 'An error occurred in metric mapping.'}" 

===== fin_statement_model/config/dynamic_mappings.json =====
{
    "version": "1.0",
    "last_updated": "2024-01-01T00:00:00Z",
    "description": "Dynamic mappings for metric aliases that are discovered and validated at runtime",
    "mappings": {}
}

===== fin_statement_model/config/metric_mappings.py =====
"""
Standard metric names and their common aliases for financial statement mapping.
This configuration assists in mapping various naming conventions to standardized metrics.
"""

import json
import os
from pathlib import Path
from typing import Dict, List

class MetricMappingConfig:
    """Manages metric mappings combining static and dynamic configurations."""
    
    def __init__(self):
        self._static_mappings = STATIC_METRIC_ALIASES
        self._dynamic_mappings = {}
        self._dynamic_file = Path(__file__).parent / "dynamic_mappings.json"
        self.load_dynamic_mappings()
    
    @property
    def mappings(self) -> Dict[str, List[str]]:
        """Returns combined static and dynamic mappings."""
        combined = self._static_mappings.copy()
        for metric, aliases in self._dynamic_mappings.items():
            if metric in combined:
                # Merge aliases, keeping unique values
                combined[metric] = list(set(combined[metric] + aliases))
            else:
                combined[metric] = aliases
        return combined
    
    def load_dynamic_mappings(self) -> None:
        """Load dynamic mappings from JSON file if it exists."""
        try:
            if self._dynamic_file.exists():
                with open(self._dynamic_file, 'r') as f:
                    self._dynamic_mappings = json.load(f)
        except Exception as e:
            print(f"Warning: Failed to load dynamic mappings: {e}")
            self._dynamic_mappings = {}
    
    def save_dynamic_mappings(self, new_mappings: Dict[str, List[str]]) -> None:
        """Save new mappings to dynamic mappings file."""
        try:
            # Merge new mappings with existing dynamic mappings
            for metric, aliases in new_mappings.items():
                if metric in self._dynamic_mappings:
                    self._dynamic_mappings[metric] = list(set(self._dynamic_mappings[metric] + aliases))
                else:
                    self._dynamic_mappings[metric] = aliases
            
            # Save to file
            with open(self._dynamic_file, 'w') as f:
                json.dump(self._dynamic_mappings, f, indent=4)
        except Exception as e:
            raise RuntimeError(f"Failed to save dynamic mappings: {e}")

# Static mappings definition
STATIC_METRIC_ALIASES = {
    # Revenue related
    "revenue": [
        "sales",
        "net sales",
        "total revenue",
        "gross revenue",
        "operating revenue",
        "net revenue",
        "turnover"
    ],

    # Cost related
    "cost_of_goods_sold": [
        "cogs",
        "cost of sales",
        "cost of revenue",
        "direct costs",
        "cost of products",
        "cost of services"
    ],

    # Operating expenses
    "operating_expenses": [
        "opex",
        "operating costs",
        "total operating expenses",
        "operational expenses",
        "selling general and administrative",
        "sga",
        "operating expense"
    ],

    # Interest related
    "interest_expense": [
        "interest costs",
        "financing costs",
        "interest charges",
        "debt expense"
    ],

    "interest_income": [
        "interest earned",
        "interest revenue",
        "investment income"
    ],

    # Tax related
    "tax_expense": [
        "income tax",
        "income tax expense",
        "tax provision",
        "income taxes",
        "tax charge"
    ],

    # Asset related
    "total_assets": [
        "assets",
        "total assets",
        "assets total",
        "gross assets"
    ],

    "current_assets": [
        "total current assets",
        "current assets total",
        "short term assets"
    ],

    # Liability related
    "current_liabilities": [
        "total current liabilities",
        "short term liabilities",
        "current obligations"
    ],

    # Equity related
    "total_equity": [
        "shareholders equity",
        "stockholders equity",
        "net worth",
        "book value",
        "total shareholders equity"
    ],

    # Working capital components
    "inventory": [
        "inventories",
        "stock",
        "merchandise inventory",
        "goods inventory"
    ],

    "accounts_receivable": [
        "ar",
        "trade receivables",
        "receivables",
        "debtors"
    ],

    "accounts_payable": [
        "ap",
        "trade payables",
        "payables",
        "creditors"
    ],

    # Cash related
    "cash": [
        "cash and cash equivalents",
        "cash & equivalents",
        "cash and equivalents",
        "cash & cash equivalents"
    ],

    "operating_cash_flow": [
        "cash from operations",
        "operating activities",
        "net cash from operations",
        "ocf"
    ],

    # Debt related
    "total_debt": [
        "debt",
        "total borrowings",
        "financial liabilities",
        "interest bearing debt"
    ],

    # Fixed assets
    "net_fixed_assets": [
        "property plant and equipment",
        "ppe",
        "fixed assets",
        "tangible assets"
    ],

    # Market related
    "market_capitalization": [
        "market cap",
        "market value",
        "market worth"
    ],

    "enterprise_value": [
        "ev",
        "firm value",
        "total enterprise value"
    ],

    # Share related
    "shares_outstanding": [
        "outstanding shares",
        "common shares outstanding",
        "number of shares"
    ],

    "share_price": [
        "stock price",
        "price per share",
        "market price"
    ],

    # Capital expenditure
    "capex": [
        "capital expenditure",
        "capital spending",
        "capital investments",
        "capital expenditures"
    ],

    # Depreciation and Amortization
    "depreciation_and_amortization": [
        "d&a",
        "depreciation & amortization",
        "depreciation and amortisation",
        "depreciation amortization"
    ],

    # Working capital
    "working_capital": [
        "net working capital",
        "operating working capital",
        "working cap"
    ],

    # Dividend related
    "dividends": [
        "dividend payments",
        "total dividends",
        "dividend payout",
        "cash dividends"
    ],

    # Growth metrics
    "revenue_previous": [
        "prior year revenue",
        "last year revenue",
        "previous period revenue"
    ],

    "net_income_previous": [
        "prior year net income",
        "last year net income",
        "previous period net income"
    ]
}

# Initialize the mapping configuration
mapping_config = MetricMappingConfig()


===== fin_statement_model/create_financial_statement.py =====
from fin_statement_model.financial_statement import FinancialStatementGraph


def create_financial_statement(cells_info):
    """
    Create a FinancialStatementGraph object from a list of cell dictionaries.
    Each cell dict is expected to have keys such as 'row_name', 'column_name', and 'value'.

    This function groups cells by the 'row_name' (representing the financial statement item) and
    constructs a mapping of periods (from 'column_name') to values.
    
    Args:
        cells_info (list): List of dictionaries representing Excel cells.
            Example entry:
            {
                'cell_location': 'H63',
                'column': 'H',
                'row': 63,
                'value': 22,
                'formula': '=G63',
                'precedents': ['I63', 'H66'],
                'dependencies': ['G63'],
                'column_name': '2024',
                'row_name': 'Other Income / (Expense):',
                'formula_with_row_names': '=Other Income / (Expense):',
                'precedents_names': ['Other Income / (Expense):', 'Pre-Tax Income:'],
                'dependent_names': ['Other Income / (Expense):']
            },
            ...

    Returns:
        FinancialStatementGraph: The populated financial statement graph.
    """
    # Group cells by row_name to aggregate values per financial statement item
    items = {}
    unique_periods = set()
    for cell in cells_info:
        # Clean the item name and period
        item_name = cell.get('row_name', '').strip()
        period = cell.get('column_name', '').strip()
        value = cell.get('value')

        if not item_name or not period:
            continue

        unique_periods.add(period)

        if item_name not in items:
            items[item_name] = {}
        items[item_name][period] = value

    # Sort periods (assuming they are sortable, e.g., year strings) to pass to FinancialStatementGraph
    sorted_periods = sorted(unique_periods)

    # Create the FinancialStatementGraph with the detected periods
    fsg = FinancialStatementGraph(periods=sorted_periods)

    # Add each financial statement item with its period-value mapping
    for item, values in items.items():
        fsg.add_financial_statement_item(item, values)

    return fsg


# If run as a script, example usage:
if __name__ == '__main__':
    # Example cells_info list
    cells_info = [
        {
            'cell_location': 'H63',
            'column': 'H',
            'row': 63,
            'value': 22,
            'formula': '=G63',
            'precedents': ['I63', 'H66'],
            'dependencies': ['G63'],
            'column_name': '2024',
            'row_name': 'Other Income / (Expense):',
            'formula_with_row_names': '=Other Income / (Expense):',
            'precedents_names': ['Other Income / (Expense):', 'Pre-Tax Income:'],
            'dependent_names': ['Other Income / (Expense):']
        },
        {
            'cell_location': 'H64',
            'column': 'H',
            'row': 64,
            'value': 50,
            'formula': '',
            'precedents': [],
            'dependencies': [],
            'column_name': '2024',
            'row_name': 'Revenue:',
            'formula_with_row_names': '',
            'precedents_names': [],
            'dependent_names': []
        }
    ]

    # Create the financial statement object
    fs = create_financial_statement(cells_info)
    print("Financial Statement periods:", fs.graph.periods)
    # For demonstration, try calculating a dummy statement (actual calculation requires properly setup nodes)
    # This only shows the stored items
    for node in fs.graph.nodes.values():
        print(f"Item: {node.name}, Values: {getattr(node, 'values', {})}") 

===== fin_statement_model/graph.py =====
from typing import Dict, Optional
from .nodes import Node, CalculationNode

class Graph:
    """
    A Graph holds nodes and their relationships, enabling calculation of financial metrics across multiple periods.

    The Graph class provides the core data structure for representing financial statements and calculations as a directed graph.
    Each node in the graph represents either a raw financial statement item (like revenue or expenses) or a calculation
    between other nodes (like profit = revenue - expenses).

    The graph structure ensures proper dependency management and calculation order, allowing complex financial metrics
    to be derived from raw financial data across multiple time periods.

    Attributes:
        nodes (Dict[str, Node]): Dictionary mapping node names to Node objects

    Example:
        graph = Graph()
        revenue_node = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        expenses_node = FinancialStatementItemNode("expenses", {"2022": 600.0})
        graph.add_node(revenue_node)
        graph.add_node(expenses_node)
        profit = graph.calculate("revenue", "2022") - graph.calculate("expenses", "2022")
    """
    def __init__(self):
        self.nodes: Dict[str, Node] = {}

    def add_node(self, node: Node):
        """
        Add a node to the graph.

        Args:
            node (Node): The node object to add to the graph. Must be a subclass of Node.

        Raises:
            ValueError: If a node with the same name already exists in the graph.
            TypeError: If the provided node is not a subclass of Node.

        Example:
            # Add a financial statement item node
            revenue_node = FinancialStatementItemNode("revenue", {"2022": 1000.0})
            graph.add_node(revenue_node)

            # Add a calculation node
            profit_node = SubtractionCalculationNode("profit", [revenue_node, expenses_node])
            graph.add_node(profit_node)
        """
        old_node = self.nodes.get(node.name)
        self.nodes[node.name] = node
        
        # If we're replacing a node, update any calculation nodes that depend on it
        if old_node is not None:
            self._update_calculation_nodes()

    def _update_calculation_nodes(self):
        """Update calculation nodes when their input nodes change."""
        for node in self.nodes.values():
            if isinstance(node, CalculationNode) and hasattr(node, 'input_names'):
                # Update the inputs list with current nodes
                node.inputs = [self.get_node(name) for name in node.input_names]

    def get_node(self, name: str) -> Optional[Node]:
        """
        Retrieve a node from the graph by its name.

        Args:
            name (str): The name/identifier of the node to retrieve

        Returns:
            Optional[Node]: The node with the given name if it exists, None otherwise

        Example:
            # Get a node by name
            revenue_node = graph.get_node("revenue")
            if revenue_node:
                value = revenue_node.calculate("2022")

            # Handle missing node
            expenses_node = graph.get_node("expenses") 
            if expenses_node is None:
                print("Expenses node not found")
        """
        return self.nodes.get(name)

    def calculate(self, node_name: str, period: str) -> float:
        """
        Calculate the value of a node for a given period.

        Args:
            node_name (str): The name/identifier of the node to calculate
            period (str): The time period to calculate the value for (e.g. "FY2022")

        Returns:
            float: The calculated value for the specified node and period

        Raises:
            ValueError: If the node does not exist in the graph
            ValueError: If the period is not found in the node's data
            ValueError: If there is an error performing the calculation (e.g. division by zero)

        Example:
            # Calculate revenue for FY2022
            revenue = graph.calculate("revenue", "FY2022")

            # Calculate gross profit margin for FY2021
            gpm = graph.calculate("gross_profit_margin", "FY2021")
        """
        node = self.get_node(node_name)
        if node is None:
            raise ValueError(f"Node '{node_name}' not found.")
        return node.calculate(period)


    def clear_all_caches(self):
        """
        Clear calculation caches for all nodes in the graph.

        This method iterates through all nodes in the graph and calls their clear_cache() 
        method, removing any cached calculation results. This ensures future calculations
        will be recomputed rather than using cached values.

        Example:
            # Clear all node caches
            graph.clear_all_caches()
            
            # Future calculations will be recomputed
            revenue = graph.calculate("revenue", "FY2022")
        """
        for node in self.nodes.values():
            node.clear_cache()


    def topological_sort(self):
        """
        Perform a topological sort of the nodes in the graph.

        This method analyzes the dependencies between nodes and returns them in a valid
        processing order where each node appears after all of its dependencies. The sort
        is based on the input nodes referenced by calculation and metric nodes.

        Returns:
            List[str]: A list of node names in topologically sorted order

        Raises:
            ValueError: If a cycle is detected in the node dependencies

        Example:
            # Get nodes in dependency order
            sorted_nodes = graph.topological_sort()
            
            # Process nodes in correct order
            for node_name in sorted_nodes:
                node = graph.get_node(node_name)
                value = node.calculate("2022")
        """
        # Build adjacency (reverse: from inputs to node)
        in_degree = {node_name:0 for node_name in self.nodes}
        adjacency = {node_name:[] for node_name in self.nodes}

        # Determine dependencies:
        for node_name, node in self.nodes.items():
            # Identify input nodes if this is a calculation node
            if hasattr(node, 'inputs'):
                for inp in node.inputs:
                    # inp is a Node, adjacency from inp to node_name
                    adjacency[inp.name].append(node_name)
                    in_degree[node_name] += 1

        # Topological sort using Kahn's algorithm
        queue = [n for n in in_degree if in_degree[n] == 0]
        topo_order = []
        while queue:
            current = queue.pop()
            topo_order.append(current)
            for nbr in adjacency[current]:
                in_degree[nbr] -= 1
                if in_degree[nbr] == 0:
                    queue.append(nbr)

        if len(topo_order) != len(self.nodes):
            raise ValueError("Cycle detected in graph, can't do a valid topological sort.")

        return topo_order


    def recalculate_all(self, period: str):
        """
        Recalculate all nodes for the given period.

        This method clears all node caches and recalculates values for every node in the graph
        in topologically sorted order to ensure dependencies are handled correctly.

        Args:
            period (str): The time period to recalculate values for (e.g. "2022")
        """
        # Clear all caches first
        self.clear_all_caches()
        
        # Get topologically sorted order to ensure proper calculation order
        order = self.topological_sort()
        
        # Force recalculation of each node
        for node_name in order:
            node = self.get_node(node_name)
            try:
                # Force recalculation by clearing individual node cache
                if hasattr(node, '_cache'):
                    node._cache.clear()
                value = node.calculate(period)
                # Store the result back in cache if needed
                if hasattr(node, '_cache'):
                    node._cache[period] = value
            except ValueError:
                # Skip if period not valid for this node
                continue

    def replace_node(self, node_name: str, new_node: Node):
        """
        Replace a node in the graph while updating any calculation nodes that reference it.
        
        Args:
            node_name: The name of the node to replace
            new_node: The new node instance
        """
        self.nodes[node_name] = new_node
        self._update_calculation_nodes()

===== fin_statement_model/__init__.py =====
"""
finlib - A Python library for financial statement analysis and forecasting.
"""

__all__ = ['LLMClient', 'LLMConfig', 'Graph', 'Node', 'FinancialStatementItemNode',
           'CalculationNode', 'AdditionCalculationNode', 'SubtractionCalculationNode',
           'MultiplicationCalculationNode', 'DivisionCalculationNode',
           'MetricCalculationNode', 'FinancialStatementGraph', 'ForecastNode',
           'FixedGrowthForecastNode', 'CurveGrowthForecastNode', 'StatisticalGrowForecastNode',
           'CustomGrowForecastNode', 'YoYGrowthNode', 'MultiPeriodStatNode', 'METRIC_DEFINITIONS']

from .llm.llm_client import LLMClient, LLMConfig
from .graph import Graph
from .nodes import (Node, FinancialStatementItemNode, CalculationNode,
                    AdditionCalculationNode, SubtractionCalculationNode,
                    MultiplicationCalculationNode, DivisionCalculationNode,
                    MetricCalculationNode)
from .financial_statement import FinancialStatementGraph
from .forecasts import (ForecastNode, FixedGrowthForecastNode, CurveGrowthForecastNode,
                        StatisticalGrowForecastNode, CustomGrowForecastNode)
from .stats import YoYGrowthNode, MultiPeriodStatNode
from .metrics import METRIC_DEFINITIONS


===== fin_statement_model/__pycache__/__init__.cpython-39.pyc =====
a
    ·7ûgÁ  „                   @   sò   d Z g d¢ZddlmZmZ ddlmZ ddlmZm	Z	m
Z
mZmZmZmZmZ ddlmZ ddlmZmZmZmZmZ ddlmZmZ dd	lmZ d
S )zM
finlib - A Python library for financial statement analysis and forecasting.
)⁄	LLMClient⁄	LLMConfig⁄Graph⁄Node⁄FinancialStatementItemNode⁄CalculationNode⁄AdditionCalculationNode⁄SubtractionCalculationNode⁄MultiplicationCalculationNode⁄DivisionCalculationNode⁄MetricCalculationNode⁄FinancialStatementGraph⁄ForecastNode⁄FixedGrowthForecastNode⁄CurveGrowthForecastNode⁄StatisticalGrowForecastNode⁄CustomGrowForecastNode⁄YoYGrowthNode⁄MultiPeriodStatNode⁄METRIC_DEFINITIONSÈ   )r   r   )r   )r   r   r   r   r   r	   r
   r   )r   )r   r   r   r   r   )r   r   )r   N)⁄__doc__⁄__all__Zllm.llm_clientr   r   Zgraphr   ⁄nodesr   r   r   r   r   r	   r
   r   Zfinancial_statementr   Z	forecastsr   r   r   r   r   ⁄statsr   r   ⁄metricsr   © r   r   ˙G/Users/joneickmeier/fin_statement_model/fin_statement_model/__init__.py⁄<module>   s   (

===== fin_statement_model/__pycache__/graph.cpython-39.pyc =====
a
    H˙Vgª!  „                   @   s2   d dl mZmZ ddlmZmZ G ddÑ dÉZdS )È    )⁄Dict⁄OptionalÈ   )⁄Node⁄CalculationNodec                   @   sÇ   e Zd ZdZddÑ ZedúddÑZddÑ Zee	e d	úd
dÑZ
eeedúddÑZddÑ ZddÑ ZedúddÑZeedúddÑZdS )⁄Grapha9  
    A Graph holds nodes and their relationships, enabling calculation of financial metrics across multiple periods.

    The Graph class provides the core data structure for representing financial statements and calculations as a directed graph.
    Each node in the graph represents either a raw financial statement item (like revenue or expenses) or a calculation
    between other nodes (like profit = revenue - expenses).

    The graph structure ensures proper dependency management and calculation order, allowing complex financial metrics
    to be derived from raw financial data across multiple time periods.

    Attributes:
        nodes (Dict[str, Node]): Dictionary mapping node names to Node objects

    Example:
        graph = Graph()
        revenue_node = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        expenses_node = FinancialStatementItemNode("expenses", {"2022": 600.0})
        graph.add_node(revenue_node)
        graph.add_node(expenses_node)
        profit = graph.calculate("revenue", "2022") - graph.calculate("expenses", "2022")
    c                 C   s
   i | _ d S )N)⁄nodes©⁄self© r   ˙D/Users/joneickmeier/fin_statement_model/fin_statement_model/graph.py⁄__init__   s    zGraph.__init__)⁄nodec                 C   s.   | j †|j°}|| j |j< |dur*| †°  dS )a©  
        Add a node to the graph.

        Args:
            node (Node): The node object to add to the graph. Must be a subclass of Node.

        Raises:
            ValueError: If a node with the same name already exists in the graph.
            TypeError: If the provided node is not a subclass of Node.

        Example:
            # Add a financial statement item node
            revenue_node = FinancialStatementItemNode("revenue", {"2022": 1000.0})
            graph.add_node(revenue_node)

            # Add a calculation node
            profit_node = SubtractionCalculationNode("profit", [revenue_node, expenses_node])
            graph.add_node(profit_node)
        N)r   ⁄get⁄name⁄_update_calculation_nodes)r
   r   ⁄old_noder   r   r   ⁄add_node   s    zGraph.add_nodec                    s>   à j †° D ].}t|tÉr
t|dÉr
á fddÑ|jD É|_q
dS )z7Update calculation nodes when their input nodes change.⁄input_namesc                    s   g | ]}à † |°ëqS r   )⁄get_node)⁄.0r   r	   r   r   ⁄
<listcomp>=   Û    z3Graph._update_calculation_nodes.<locals>.<listcomp>N)r   ⁄values⁄
isinstancer   ⁄hasattrr   ⁄inputs©r
   r   r   r	   r   r   8   s    zGraph._update_calculation_nodes)r   ⁄returnc                 C   s   | j †|°S )af  
        Retrieve a node from the graph by its name.

        Args:
            name (str): The name/identifier of the node to retrieve

        Returns:
            Optional[Node]: The node with the given name if it exists, None otherwise

        Example:
            # Get a node by name
            revenue_node = graph.get_node("revenue")
            if revenue_node:
                value = revenue_node.calculate("2022")

            # Handle missing node
            expenses_node = graph.get_node("expenses") 
            if expenses_node is None:
                print("Expenses node not found")
        )r   r   )r
   r   r   r   r   r   ?   s    zGraph.get_node)⁄	node_name⁄periodr   c                 C   s,   | † |°}|du r"td|õ dùÉÇ|†|°S )a7  
        Calculate the value of a node for a given period.

        Args:
            node_name (str): The name/identifier of the node to calculate
            period (str): The time period to calculate the value for (e.g. "FY2022")

        Returns:
            float: The calculated value for the specified node and period

        Raises:
            ValueError: If the node does not exist in the graph
            ValueError: If the period is not found in the node's data
            ValueError: If there is an error performing the calculation (e.g. division by zero)

        Example:
            # Calculate revenue for FY2022
            revenue = graph.calculate("revenue", "FY2022")

            # Calculate gross profit margin for FY2021
            gpm = graph.calculate("gross_profit_margin", "FY2021")
        NzNode 'z' not found.)r   ⁄
ValueError⁄	calculate)r
   r   r    r   r   r   r   r"   V   s    
zGraph.calculatec                 C   s   | j †° D ]}|†°  q
dS )a  
        Clear calculation caches for all nodes in the graph.

        This method iterates through all nodes in the graph and calls their clear_cache() 
        method, removing any cached calculation results. This ensures future calculations
        will be recomputed rather than using cached values.

        Example:
            # Clear all node caches
            graph.clear_all_caches()
            
            # Future calculations will be recomputed
            revenue = graph.calculate("revenue", "FY2022")
        N)r   r   ⁄clear_cacher   r   r   r   ⁄clear_all_cachess   s    zGraph.clear_all_cachesc           	         sÍ   ddÑ | j D Éâ ddÑ | j D É}| j †° D ]>\}}t|dÉr*|jD ]$}||j †|° à |  d7  < qBq*á fddÑà D É}g }|rÃ|†° }|†|° || D ]*}à |  d8  < à | dkrû|†|° qûqÄt|Ét| j ÉkrÊtd	ÉÇ|S )
a5  
        Perform a topological sort of the nodes in the graph.

        This method analyzes the dependencies between nodes and returns them in a valid
        processing order where each node appears after all of its dependencies. The sort
        is based on the input nodes referenced by calculation and metric nodes.

        Returns:
            List[str]: A list of node names in topologically sorted order

        Raises:
            ValueError: If a cycle is detected in the node dependencies

        Example:
            # Get nodes in dependency order
            sorted_nodes = graph.topological_sort()
            
            # Process nodes in correct order
            for node_name in sorted_nodes:
                node = graph.get_node(node_name)
                value = node.calculate("2022")
        c                 S   s   i | ]
}|d ìqS ©r   r   ©r   r   r   r   r   ⁄
<dictcomp>û   r   z*Graph.topological_sort.<locals>.<dictcomp>c                 S   s   i | ]
}|g ìqS r   r   r&   r   r   r   r'   ü   r   r   r   c                    s   g | ]}à | d kr|ëqS r%   r   )r   ⁄n©Z	in_degreer   r   r   ´   r   z*Graph.topological_sort.<locals>.<listcomp>r   z;Cycle detected in graph, can't do a valid topological sort.)	r   ⁄itemsr   r   r   ⁄append⁄pop⁄lenr!   )	r
   Z	adjacencyr   r   ⁄inp⁄queueZ
topo_order⁄currentZnbrr   r)   r   ⁄topological_sortÜ   s&    


zGraph.topological_sort)r    c              	   C   sv   | † °  | †° }|D ]\}| †|°}z6t|dÉr8|j†°  |†|°}t|dÉrV||j|< W q tyn   Y qY q0 qdS )aR  
        Recalculate all nodes for the given period.

        This method clears all node caches and recalculates values for every node in the graph
        in topologically sorted order to ensure dependencies are handled correctly.

        Args:
            period (str): The time period to recalculate values for (e.g. "2022")
        ⁄_cacheN)r$   r1   r   r   r2   ⁄clearr"   r!   )r
   r    ⁄orderr   r   ⁄valuer   r   r   ⁄recalculate_allª   s    




zGraph.recalculate_all)r   ⁄new_nodec                 C   s   || j |< | †°  dS )zﬂ
        Replace a node in the graph while updating any calculation nodes that reference it.
        
        Args:
            node_name: The name of the node to replace
            new_node: The new node instance
        N)r   r   )r
   r   r7   r   r   r   ⁄replace_node⁄   s    
zGraph.replace_nodeN)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r   r   r   ⁄strr   r   ⁄floatr"   r$   r1   r6   r8   r   r   r   r   r      s   5r   N)⁄typingr   r   r   r   r   r   r   r   r   r   ⁄<module>   s   

===== fin_statement_model/__pycache__/stats.cpython-39.pyc =====
a
    PfTg¥  „                   @   sD   d dl Z d dlmZ ddlmZ G ddÑ deÉZG ddÑ deÉZdS )	È    N)⁄ListÈ   )⁄Nodec                   @   s6   e Zd ZdZeeeedúddÑZd	eedúddÑZdS )
⁄YoYGrowthNodeaú  
    A node that calculates year-over-year growth between two periods.

    This node takes an input node and calculates the percentage growth between a prior period
    and current period. The growth is calculated as: (current_value - prior_value) / prior_value.

    If the prior period value is zero, returns NaN to avoid division by zero.

    Args:
        name (str): The name/identifier for this growth calculation node
        input_node (Node): The node whose values will be used to calculate growth
        prior_period (str): The earlier time period (e.g. "2021")
        current_period (str): The later time period (e.g. "2022")

    Attributes:
        name (str): The node's name/identifier
        input_node (Node): Reference to the input node
        prior_period (str): The earlier period for growth calculation
        current_period (str): The later period for growth calculation

    Example:
        # Create growth node to calculate revenue growth
        revenue = FinancialStatementItemNode("revenue", {
            "2021": 1000.0,
            "2022": 1200.0
        })
        revenue_growth = YoYGrowthNode("revenue_growth", revenue, "2021", "2022")
        
        # Calculate growth
        growth = revenue_growth.calculate()  # Returns 0.2 (20% growth)

    Returns:
        float: The calculated growth rate as a decimal (e.g. 0.2 for 20% growth)
        float('nan'): If prior period value is zero
    ©⁄name⁄
input_node⁄prior_period⁄current_periodc                 C   s   || _ || _|| _|| _d S ©Nr   )⁄selfr   r   r	   r
   © r   ˙D/Users/joneickmeier/fin_statement_model/fin_statement_model/stats.py⁄__init__)   s    zYoYGrowthNode.__init__N©⁄period⁄returnc                 C   s8   | j †| j°}| j †| j°}|dkr,tdÉS || | S )a±  
        Calculate the year-over-year growth rate.

        This method calculates the growth rate between the prior period and current period,
        ignoring the period parameter passed in since the periods are fixed at initialization.
        The growth rate is calculated as: (current_value - prior_value) / prior_value.

        Args:
            period (str, optional): Ignored parameter to match Node interface. The periods
                used for calculation are set during initialization.

        Returns:
            float: The calculated growth rate as a decimal (e.g. 0.2 for 20% growth)
            float('nan'): If the prior period value is zero to avoid division by zero

        Example:
            # Create growth node
            revenue = FinancialStatementItemNode("revenue", {
                "2021": 1000.0,
                "2022": 1200.0
            })
            growth = YoYGrowthNode("revenue_growth", revenue, "2021", "2022")
            
            # Calculate growth rate
            rate = growth.calculate()  # Returns 0.2 (20% growth)
            
            # Period parameter is ignored
            rate = growth.calculate("2022")  # Still returns 0.2
        r   ⁄nan)r   ⁄	calculater	   r
   ⁄float)r   r   Zprior_value⁄current_valuer   r   r   r   /   s
    zYoYGrowthNode.calculate)N)	⁄__name__⁄
__module__⁄__qualname__⁄__doc__⁄strr   r   r   r   r   r   r   r   r      s   #r   c                   @   s>   e Zd ZdZejfeeee dúddÑZ	d	ee
dúddÑZdS )
⁄MultiPeriodStatNodea  
    A node that calculates statistical measures across multiple time periods.

    This node takes an input node and calculates statistical measures (like standard deviation,
    mean, etc.) across a list of time periods. The specific statistical function is configurable
    via the stat_func parameter, defaulting to standard deviation.

    The node is useful for analyzing the variability or central tendency of financial metrics
    across multiple periods, such as revenue volatility or average profit margins.

    Args:
        name (str): The name/identifier for this statistical node
        input_node (Node): The node whose values will be analyzed across periods
        periods (List[str]): List of time periods to include in the statistical calculation
        stat_func (callable, optional): Statistical function to apply. Defaults to statistics.stdev.
            Must accept a list of numbers and return a single number.

    Attributes:
        name (str): The node's name/identifier
        input_node (Node): The source node for values
        periods (List[str]): The time periods to analyze
        stat_func (callable): The statistical function to apply

    Returns:
        float: The calculated statistical measure
        float('nan'): If fewer than 2 periods are provided

    Example:
        # Create node to calculate revenue volatility
        revenue = FinancialStatementItemNode("revenue", {
            "2020": 1000.0,
            "2021": 1200.0,
            "2022": 1100.0
        })
        volatility = MultiPeriodStatNode(
            "revenue_volatility",
            revenue,
            ["2020", "2021", "2022"]
        )
        
        # Calculate standard deviation
        std_dev = volatility.calculate()  # Returns standard deviation of revenue
    )r   r   ⁄periodsc                 C   s   || _ || _|| _|| _d S r   )r   r   r   ⁄	stat_func)r   r   r   r   r   r   r   r   r      s    zMultiPeriodStatNode.__init__Nr   c                    s2   á fddÑà j D É}t|Édk r(tdÉS à †|°S )aæ  
        Calculate the statistical measure across the configured time periods.

        This method retrieves values from the input node for each configured period and applies
        the statistical function to analyze those values. The period parameter is ignored since
        this node operates across multiple periods rather than a single period.

        Args:
            period (str, optional): Ignored. This node operates across the periods configured at initialization.

        Returns:
            float: The calculated statistical measure (e.g. standard deviation) across periods
            float('nan'): If fewer than 2 periods are provided (insufficient for statistical calculation)

        Example:
            # Create revenue volatility node
            revenue = FinancialStatementItemNode("revenue", {
                "2020": 1000.0,
                "2021": 1200.0,
                "2022": 1100.0
            })
            volatility = MultiPeriodStatNode(
                "revenue_volatility", 
                revenue,
                ["2020", "2021", "2022"]
            )

            # Calculate standard deviation
            std_dev = volatility.calculate()  # Returns ~100.0
        c                    s   g | ]}à j †|°ëqS r   )r   r   )⁄.0⁄p©r   r   r   ⁄
<listcomp>§   Û    z1MultiPeriodStatNode.calculate.<locals>.<listcomp>È   r   )r   ⁄lenr   r   )r   r   ⁄valuesr   r!   r   r   Ö   s    zMultiPeriodStatNode.calculate)N)r   r   r   r   ⁄
statisticsZstdevr   r   r   r   r   r   r   r   r   r   r   S   s   +r   )r'   ⁄typingr   ⁄nodesr   r   r   r   r   r   r   ⁄<module>   s   N

===== fin_statement_model/__pycache__/nodes.cpython-39.pyc =====
a
    ©˚Xg>  „                   @   s‡   d dl mZmZ d dlmZmZ ddlmZ d dlZd dl	Z	G ddÑ deÉZ
G dd	Ñ d	e
ÉZG d
dÑ de
ÉZG ddÑ deÉZG ddÑ deÉZG ddÑ deÉZG ddÑ deÉZG ddÑ de
ÉZG ddÑ de
ÉZG ddÑ de
ÉZdS )È    )⁄ABC⁄abstractmethod)⁄Dict⁄ListÈ   )⁄METRIC_DEFINITIONSNc                   @   s2   e Zd ZU eed< eeedúddÑÉZddÑ ZdS )⁄Node⁄name©⁄period⁄returnc                 C   s   d S ©N© ©⁄selfr   r   r   ˙D/Users/joneickmeier/fin_statement_model/fin_statement_model/nodes.py⁄	calculate
   s    zNode.calculatec                 C   s   d S r   r   )r   r   r   r   ⁄clear_cache   s    zNode.clear_cacheN)	⁄__name__⁄
__module__⁄__qualname__⁄str⁄__annotations__r   ⁄floatr   r   r   r   r   r   r      s   
r   c                   @   s8   e Zd ZdZeeeef dúddÑZeedúddÑZdS )	⁄FinancialStatementItemNodea"  
    Represents a financial statement item with values for multiple periods.

    This node type stores raw financial statement data like revenue, expenses, assets, etc.
    Each node contains a mapping of time periods to their corresponding numerical values.

    Attributes:
        name (str): The identifier for this financial statement item (e.g. "revenue", "expenses")
        values (Dict[str, float]): Dictionary mapping time periods to values (e.g. {"2022": 1000.0})

    Example:
        # Create revenue node with historical values
        revenue = FinancialStatementItemNode("revenue", {
            "2022": 1000.0,
            "2021": 900.0,
            "2020": 800.0
        })

        # Calculate revenue for 2022
        revenue_2022 = revenue.calculate("2022")  # Returns 1000.0
    ©r	   ⁄valuesc                 C   s   || _ || _d S r   r   )r   r	   r   r   r   r   ⁄__init__(   s    z#FinancialStatementItemNode.__init__r
   c                 C   s   | j †|d°S )Ng        )r   ⁄getr   r   r   r   r   ,   s    z$FinancialStatementItemNode.calculateN)	r   r   r   ⁄__doc__r   r   r   r   r   r   r   r   r   r      s   r   c                   @   s8   e Zd ZdZeee dúddÑZeee	dúddÑÉZ
dS )	⁄CalculationNodea÷  
    Base class for calculation nodes that perform arithmetic operations on input nodes.

    This abstract class defines the interface and common functionality for nodes that
    perform calculations between other nodes in the financial statement graph.
    Specific calculation types (addition, subtraction, etc.) inherit from this class
    and implement their own calculation logic.

    Attributes:
        name (str): The identifier for this calculation node (e.g. "gross_profit")
        inputs (List[Node]): List of input nodes used in the calculation

    Example:
        # Create an addition calculation node
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        other_income = FinancialStatementItemNode("other_income", {"2022": 100.0})
        total_income = AdditionCalculationNode("total_income", [revenue, other_income])

        # Calculate total income for 2022
        total_2022 = total_income.calculate("2022")  # Returns 1100.0
    )r	   ⁄inputsc                 C   s   || _ || _g | _d S r   )r	   r!   ⁄input_names)r   r	   r!   r   r   r   r   E   s    zCalculationNode.__init__r
   c                 C   s   d S r   r   r   r   r   r   r   J   s    zCalculationNode.calculateN)r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r    /   s   r    c                   @   s    e Zd ZdZeedúddÑZdS )⁄AdditionCalculationNodeaˆ  
    A calculation node that adds together values from multiple input nodes.

    This node performs addition of values from all input nodes for a given time period.
    It inherits from CalculationNode and implements the calculate() method to sum values.

    Example:
        # Create nodes with historical values
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        other_income = FinancialStatementItemNode("other_income", {"2022": 100.0})
        
        # Create addition node to sum revenue and other income
        total_income = AdditionCalculationNode("total_income", [revenue, other_income])
        
        # Calculate total income for 2022
        total_2022 = total_income.calculate("2022")  # Returns 1100.0
    r
   c                    s   t á fddÑ| jD ÉÉS )Nc                 3   s   | ]}|† à °V  qd S r   )r   )⁄.0⁄i©r   r   r   ⁄	<genexpr>a   Û    z4AdditionCalculationNode.calculate.<locals>.<genexpr>)⁄sumr!   r   r   r&   r   r   `   s    z!AdditionCalculationNode.calculateN©r   r   r   r   r   r   r   r   r   r   r   r#   N   s   r#   c                   @   s    e Zd ZdZeedúddÑZdS )⁄SubtractionCalculationNodea0  
    A calculation node that subtracts subsequent input values from the first input.

    This node performs subtraction between input nodes for a given time period.
    It takes the first input node's value and subtracts all subsequent input node values from it.
    It inherits from CalculationNode and implements the calculate() method for subtraction.

    Example:
        # Create nodes with historical values
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        expenses = FinancialStatementItemNode("expenses", {"2022": 600.0})
        
        # Create subtraction node to calculate profit
        profit = SubtractionCalculationNode("profit", [revenue, expenses])
        
        # Calculate profit for 2022
        profit_2022 = profit.calculate("2022")  # Returns 400.0
    r
   c                 C   s6   | j d †|°}| j dd Ö D ]}||†|°8 }q|S )Nr   r   ©r!   r   ©r   r   ⁄result⁄inpr   r   r   r   v   s    z$SubtractionCalculationNode.calculateNr*   r   r   r   r   r+   c   s   r+   c                   @   s    e Zd ZdZeedúddÑZdS )⁄MultiplicationCalculationNodea“  
    A calculation node that multiplies values from multiple input nodes.

    This node performs multiplication of values from all input nodes for a given time period.
    It inherits from CalculationNode and implements the calculate() method to multiply values.

    Example:
        # Create nodes with historical values
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        margin = FinancialStatementItemNode("margin", {"2022": 0.4})
        
        # Create multiplication node to calculate profit
        profit = MultiplicationCalculationNode("profit", [revenue, margin])
        
        # Calculate profit for 2022
        profit_2022 = profit.calculate("2022")  # Returns 400.0
    r
   c                 C   s"   d}| j D ]}||†|°9 }q
|S )Nr   r,   r-   r   r   r   r   é   s    
z'MultiplicationCalculationNode.calculateNr*   r   r   r   r   r0   |   s   r0   c                   @   s    e Zd ZdZeedúddÑZdS )⁄DivisionCalculationNodea˙  
    A calculation node that divides values from input nodes sequentially.

    This node performs division between input nodes for a given time period.
    It takes the first input node's value and divides it by each subsequent input node value in sequence.
    It inherits from CalculationNode and implements the calculate() method for division.
    
    The node will raise a ZeroDivisionError if any divisor (input after the first) equals zero.

    Example:
        # Create nodes with historical values
        net_income = FinancialStatementItemNode("net_income", {"2022": 400.0})
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        
        # Create division node to calculate profit margin
        margin = DivisionCalculationNode("profit_margin", [net_income, revenue])
        
        # Calculate margin for 2022
        margin_2022 = margin.calculate("2022")  # Returns 0.4 (40%)

    Raises:
        ZeroDivisionError: If any divisor (input after the first) equals zero
    r
   c                 C   sJ   | j d †|°}| j dd Ö D ]&}|†|°}|dkr<tdÉÇ|| }q|S )Nr   r   z"Division by zero in division node.)r!   r   ⁄ZeroDivisionError)r   r   r.   r/   ⁄divisorr   r   r   r   ¨   s    

z!DivisionCalculationNode.calculateNr*   r   r   r   r   r1   î   s   r1   c                   @   s0   e Zd ZdZeedúddÑZeedúddÑZdS )	⁄MetricCalculationNodeaV  
    A node that calculates a metric defined in METRIC_DEFINITIONS.

    This node represents a financial metric calculation that is defined in the METRIC_DEFINITIONS dictionary.
    It creates an appropriate calculation node (Addition, Subtraction, Multiplication, or Division) based on
    the metric definition and handles retrieving the required input nodes from the graph.

    The node acts as a wrapper around the underlying calculation node, delegating the actual calculation
    while handling the metric-specific setup and validation.

    Args:
        name (str): The name/identifier for this metric node
        metric_name (str): The name of the metric as defined in METRIC_DEFINITIONS
        graph: The financial statement graph containing the input nodes

    Attributes:
        name (str): The node's name/identifier
        metric_name (str): The name of the metric being calculated
        graph: Reference to the containing graph
        definition (dict): The metric's definition from METRIC_DEFINITIONS
        calc_node (CalculationNode): The underlying calculation node that performs the actual computation

    Raises:
        ValueError: If the metric_name is not found in METRIC_DEFINITIONS
        ValueError: If any required input nodes are not found in the graph
        ValueError: If the calculation type in the metric definition is invalid

    Example:
        # Create metric node for net profit margin
        npm_node = MetricCalculationNode("npm", "net_profit_margin", graph)
        
        # Calculate net profit margin for 2022
        npm_2022 = npm_node.calculate("2022")
    )r	   ⁄metric_namec                 C   s~   || _ || _|| _t| | _i }| jd D ]6}| j†|°}|d u rXtd|õ d|õ dùÉÇ|||< q*t|d || jd É| _d S )Nr!   zInput node 'z' for metric 'z' not found.Z_calc⁄formula)	r	   r5   ⁄graphr   ⁄
definition⁄get_node⁄
ValueError⁄FormulaCalculationNode⁄	calc_node)r   r	   r5   r7   Zinput_nodesr/   ⁄noder   r   r   r   ÿ   s    

˝zMetricCalculationNode.__init__r
   c                 C   s   | j †|°S r   )r<   r   r   r   r   r   r   Ï   s    zMetricCalculationNode.calculateN)r   r   r   r   r   r   r   r   r   r   r   r   r4   µ   s   "r4   c                   @   s0   e Zd ZdZeedúddÑZeedúddÑZdS )	⁄TwoPeriodAverageNodeaæ  
    A node that calculates the average of a given metric's values over the current and previous period.

    This node takes an input node and calculates the average value between the current period and
    the immediately preceding period based on the graph's defined period ordering. The node requires
    that the graph has an ordered list of periods to determine the previous period.

    Args:
        name (str): The name/identifier for this average calculation node
        input_node (Node): The node whose values will be averaged
        graph: The financial statement graph containing the period definitions

    Attributes:
        name (str): The node's name/identifier
        input_node (Node): Reference to the input node being averaged
        graph: Reference to the containing graph

    Raises:
        ValueError: If the graph does not have defined periods
        ValueError: If the requested period is not found in the graph's periods
        ValueError: If there is no previous period available (e.g. first period)

    Example:
        # Create average total assets node
        total_assets = FinancialStatementItemNode("total_assets", {
            "2021": 1000.0,
            "2022": 1200.0
        })
        graph.periods = ["2021", "2022"]
        avg_assets = TwoPeriodAverageNode("avg_total_assets", total_assets, graph)
        
        # Calculate average for 2022
        avg_2022 = avg_assets.calculate("2022")  # Returns 1100.0
    )r	   ⁄
input_nodec                 C   s   || _ || _|| _d S r   )r	   r?   r7   )r   r	   r?   r7   r   r   r   r     s    zTwoPeriodAverageNode.__init__r
   c                 C   sé   t | jdÉr| jjstdÉÇ| jj}||vr<td|õ dùÉÇ|†|°}|dkr^td|õ dùÉÇ||d  }| j†|°}| j†|°}|| d	 S )
aå  
        Calculate the average value between the current period and previous period.

        This method retrieves values from the input node for both the specified period and
        the immediately preceding period based on the graph's period ordering. It then
        calculates the arithmetic mean of these two values.

        Args:
            period (str): The current period for which to calculate the average (e.g. "2022")

        Returns:
            float: The arithmetic mean of the current and previous period values

        Raises:
            ValueError: If the graph does not have defined periods
            ValueError: If the requested period is not found in the graph's periods
            ValueError: If there is no previous period available (e.g. first period)

        Example:
            # Create average total assets node
            total_assets = FinancialStatementItemNode("total_assets", {
                "2021": 1000.0,
                "2022": 1200.0
            })
            graph.periods = ["2021", "2022"]
            avg_assets = TwoPeriodAverageNode("avg_total_assets", total_assets, graph)
            
            # Calculate average for 2022
            avg_2022 = avg_assets.calculate("2022")  # Returns 1100.0
            
            # Will raise ValueError since 2021 has no previous period
            avg_2021 = avg_assets.calculate("2021")  # Raises ValueError
        ⁄periodsz.Graph does not have a defined list of periods.zPeriod 'z' not found in graph.periods.r   z%No previous period available before 'z' to calculate average.r   g       @)⁄hasattrr7   r@   r:   ⁄indexr?   r   )r   r   Zperiods_list⁄idxZprevious_period⁄current_valueZprevious_valuer   r   r   r     s    #
zTwoPeriodAverageNode.calculateN)	r   r   r   r   r   r   r   r   r   r   r   r   r   r>   Ô   s   "r>   c                
   @   sv   e Zd ZdZejejejej	ej
ejejejejejiZeeeef edúddÑZeedúddÑZeedúdd	ÑZd
S )r;   aä  
    A node that calculates values based on a mathematical formula string.
    
    Attributes:
        name (str): The identifier for this calculation node
        inputs (Dict[str, Node]): Dictionary mapping input names to their nodes
        formula (str): The formula string to evaluate (e.g. "revenue - cost_of_goods_sold")
        _ast: The parsed abstract syntax tree of the formula
    )r	   r!   r6   c                 C   s(   || _ || _|| _tj|ddçj| _d S )N⁄eval)⁄mode)r	   r!   r6   ⁄ast⁄parse⁄body⁄_ast)r   r	   r!   r6   r   r   r   r   b  s    zFormulaCalculationNode.__init__r
   c                 C   s   | † | j|°S r   )⁄	_evaluaterJ   r   r   r   r   r   h  s    z FormulaCalculationNode.calculatec                 C   s  t |tjÉrt|jÉS t |tjÉrR|j| jvr@td|jõ dùÉÇ| j|j †	|°S t |tj
ÉrÆ| †|j|°}| †|j|°}t|jÉ}|| jvrûtd|jõ ùÉÇ| j| ||ÉS t |tjÉr˙| †|j|°}t|jÉ}|| jvrÏtd|jõ ùÉÇ| j| |ÉS tdt†|°õ ùÉÇdS )z-Recursively evaluates the AST of the formula.zUnknown variable 'z' in formulazUnsupported operator zUnsupported unary operator zUnsupported syntax in formula: N)⁄
isinstancerG   ⁄Numr   ⁄n⁄Name⁄idr!   r:   r   ⁄BinOprK   ⁄left⁄right⁄type⁄op⁄	OPERATORSr   ⁄UnaryOp⁄operand⁄dump)r   r=   r   rR   rS   rU   rX   r   r   r   rK   k  s(    




z FormulaCalculationNode._evaluateN)r   r   r   r   rG   ⁄Add⁄operator⁄add⁄Sub⁄sub⁄Mult⁄mul⁄Div⁄truediv⁄USub⁄negrV   r   r   r   r   r   r   rK   r   r   r   r   r;   N  s   ˚r;   )⁄abcr   r   ⁄typingr   r   ⁄metricsr   rG   r[   r   r   r    r#   r+   r0   r1   r4   r>   r;   r   r   r   r   ⁄<module>   s   !:_

===== fin_statement_model/__pycache__/financial_statement.cpython-39.pyc =====
a
    ®1ûgék  „                   @   s≤   d dl mZ d dlmZmZmZmZ d dlZddl	m
Z
 ddlmZ ddlmZ ddlmZmZmZmZmZmZmZmZ dd	lmZmZmZmZmZ dd
lmZ G ddÑ dÉZ dS )È    )⁄Path)⁄Dict⁄List⁄Union⁄OptionalNÈ   )⁄Graph)⁄ExcelImporter)⁄MappingService)⁄FinancialStatementItemNode⁄Node⁄AdditionCalculationNode⁄SubtractionCalculationNode⁄MultiplicationCalculationNode⁄DivisionCalculationNode⁄CalculationNode⁄MetricCalculationNode)⁄ForecastNode⁄FixedGrowthForecastNode⁄CurveGrowthForecastNode⁄StatisticalGrowForecastNode⁄CustomGrowForecastNode)⁄METRIC_DEFINITIONSc                   @   s  e Zd ZdZd&edúddÑZeeeef dúddÑZ	ee
e ed	úd
dÑZeeedúddÑZd'ddÑZd(eejdúddÑZeeee
e eee
e f ddúddÑZedúddÑZd d dúddÑZd)eeef ee
e  eee edd úd!d"ÑZd*eed#úd$d%ÑZdS )+⁄FinancialStatementGrapha∆  
    A graph specialized for financial statements.
    A graph-based representation of financial statements and calculations.

    This class provides functionality to:
    - Add raw financial statement items (like revenue, expenses, etc.) with their values
    - Define calculations between financial items (addition, subtraction, multiplication, division)
    - Calculate derived metrics for specific time periods
    
    The graph structure ensures proper dependency management and calculation order.
    Each node in the graph represents either a raw financial statement item or a calculation.

    Example:
        fsg = FinancialStatementGraph()
        fsg.add_financial_statement_item("revenue", {"2022": 1000.0})
        fsg.add_financial_statement_item("expenses", {"2022": 600.0})
        fsg.add_calculation("profit", ["revenue", "expenses"], "subtraction")
        profit_2022 = fsg.calculate_financial_statement("profit", "2022")  # Returns 400.0
    N)⁄periodsc                 C   s    t É | _|d u rg }|| j_d S ©N)r   ⁄graphr   )⁄selfr   © r   ˙R/Users/joneickmeier/fin_statement_model/fin_statement_model/financial_statement.py⁄__init__"   s    z FinancialStatementGraph.__init__)⁄name⁄valuesc                 C   s   t ||É}| j†|° dS )a˚  
        Add a financial statement item node to the graph with historical values.

        Args:
            name: The name/identifier of the financial statement item (e.g. "revenue", "expenses")
            values: Dictionary mapping time periods to numerical values (e.g. {"2022": 1000.0})

        Raises:
            ValueError: If a node with the given name already exists in the graph

        Example:
            fsg.add_financial_statement_item("revenue", {"2022": 1000.0, "2023": 1200.0})
        N)r   r   ⁄add_node)r   r!   r"   ⁄noder   r   r   ⁄add_financial_statement_item(   s    
z4FinancialStatementGraph.add_financial_statement_item)r!   ⁄inputs⁄calculation_typec                    sò   á fddÑ|D É}d|v r"t dÉÇ|dkr6t||É}nL|dkrJt||É}n8|dkr^t||É}n$|dkrrt||É}nt d	|õ d
ùÉÇ||_à j†|° dS )aÆ  
        Add a calculation node to the graph that performs arithmetic operations between input nodes.

        Args:
            name: The name/identifier for the calculation node (e.g. "gross_profit", "operating_margin")
            inputs: List of input node names that will be used in the calculation. Must be existing nodes.
            calculation_type: Type of arithmetic operation to perform. Valid values are:
                - 'addition': Adds all input values together
                - 'subtraction': Subtracts subsequent values from the first input
                - 'multiplication': Multiplies all input values together  
                - 'division': Divides first input by second input

        Raises:
            ValueError: If any input nodes don't exist in the graph
            ValueError: If an invalid calculation_type is provided

        Example:
            # Calculate gross profit as revenue - cost_of_goods_sold
            fsg.add_calculation("gross_profit", ["revenue", "cost_of_goods_sold"], "subtraction")

            # Calculate profit margin as net_income / revenue
            fsg.add_calculation("profit_margin", ["net_income", "revenue"], "division")
        c                    s   g | ]}à j †|°ëqS r   )r   ⁄get_node)⁄.0⁄inp©r   r   r   ⁄
<listcomp>Q   Û    z;FinancialStatementGraph.add_calculation.<locals>.<listcomp>Nz2One of the input nodes for calculation is missing.⁄additionZsubtractionZmultiplication⁄divisionzInvalid calculation type '˙'.)⁄
ValueErrorr   r   r   r   ⁄input_namesr   r#   )r   r!   r&   r'   ⁄input_nodesr$   r   r+   r   ⁄add_calculation9   s    z'FinancialStatementGraph.add_calculation)⁄	node_name⁄period⁄returnc                 C   s   | j †||°S )aê  
        Calculate the value of a node for a specific time period.

        Args:
            node_name: The name/identifier of the node to calculate (e.g. "revenue", "gross_profit")
            period: The time period to calculate the value for (e.g. "FY2022")

        Returns:
            float: The calculated value for the specified node and period

        Raises:
            ValueError: If the node does not exist in the graph
            ValueError: If the period is not found in the node's data
            ValueError: If there is an error performing the calculation (e.g. division by zero)

        Example:
            # Calculate gross profit for FY2022
            gross_profit = fsg.calculate_financial_statement("gross_profit", "FY2022")
            
            # Calculate net profit margin for FY2021 
            npm = fsg.calculate_financial_statement("net_profit_margin", "FY2021")
        )r   ⁄	calculate)r   r5   r6   r   r   r   ⁄calculate_financial_statementa   s    z5FinancialStatementGraph.calculate_financial_statementTc              
      s   | j †°  |r∆| j j†° D ]™\â }t|tÉrtá fddÑ| j j†° D ÉÉrLqd}d}t|j†	° ÉD ]}|| j j
v rb|j| }|}qb|dur|dur| j j
†|°d }| j j
|dÖ D ]}||j|< q¥q| j †° }| j j
D ]B}|D ]8â | j †à °}z|†|° W q‡ têy   Y q‡Y q‡0 q‡qÿdS )a˘  
        Recalculate all nodes in the graph for all periods.

        This method clears all node caches and recalculates values for every node in the graph
        in topologically sorted order to ensure dependencies are handled correctly.

        Args:
            copy_forward (bool): If True, copy forward the last historical value for any
                               FinancialStatementItemNode that doesn't have forecast periods
                               defined. Defaults to False.
        c                 3   s"   | ]}|j à krt|tÉV  qd S r   )r!   ⁄
isinstancer   )r)   r$   ©r5   r   r   ⁄	<genexpr>é   s   
ˇz:FinancialStatementGraph.recalculate_all.<locals>.<genexpr>Nr   )r   ⁄clear_all_caches⁄nodes⁄itemsr:   r   ⁄anyr"   ⁄sorted⁄keysr   ⁄index⁄topological_sortr(   r8   r1   )r   Zcopy_forwardr$   ⁄
last_valueZlast_periodr6   Z	start_idx⁄orderr   r;   r   ⁄recalculate_allz   s0    



z'FinancialStatementGraph.recalculate_all)⁄recalculater7   c           	      C   sí   |r| † °  t| jjÉ}i }| jjD ]V}g }|D ]@}z| †||°}|†|° W q0 ttfyn   |†d° Y q00 q0|||< q$t	†
|°j}||_|S )a÷  
        Convert the financial statement graph into a pandas DataFrame.
        
        The DataFrame will have financial statement items as indices and periods as columns.
        Both raw financial statement items and calculated values will be included.

        Returns:
            pd.DataFrame: A DataFrame containing all financial statement values
                        with items as indices and periods as columns.

        Example:
            fsg = FinancialStatementGraph()
            fsg.add_financial_statement_item("revenue", {"2022": 1000.0, "2023": 1200.0})
            fsg.add_financial_statement_item("expenses", {"2022": 600.0, "2023": 700.0})
            fsg.add_calculation("profit", ["revenue", "expenses"], "subtraction")
            
            df = fsg.to_dataframe()
            # Results in:
            #           2022    2023
            # revenue  1000.0  1200.0
            # expenses  600.0   700.0
            # profit    400.0   500.0
        N)rG   rA   r   r   r>   r9   ⁄appendr1   ⁄KeyError⁄pd⁄	DataFrame⁄T⁄columns)	r   rH   r   ⁄datar5   r"   r6   ⁄value⁄dfr   r   r   ⁄to_dataframe≠   s     
z$FinancialStatementGraph.to_dataframe)r5   ⁄forecast_type⁄base_period⁄forecast_periods⁄growth_paramsr7   c                 C   s˛   | j †|°}|du r$td|õ dùÉÇ|dkrRt|ttfÉsBtdÉÇt||||É}nö|dkråt|tÉrtt|Ét|Ékr|tdÉÇt	||||É}n`|dkr¥t
|És§td	ÉÇt||||É}n8|d
kr‹t
|ÉsÃtdÉÇt||||É}ntd|õ dùÉÇ| j †||° dS )aT  
        Create a forecast node and replace the existing node in the graph.

        Args:
            node_name (str): Name of the node to forecast (must exist in graph)
            forecast_type (str): Type of forecast ('fixed', 'curve', 'statistical', or 'custom')
            base_period (str): Last historical period to use as basis for forecasting
            forecast_periods (List[str]): List of future periods to generate forecasts for
            growth_params: Growth parameters for the forecast:
                - For 'fixed': float representing constant growth rate
                - For 'curve': List[float] representing growth rates for each period
                - For 'statistical': Callable that returns random growth rates
                - For 'custom': Callable that takes (period, prev_period, prev_value)

        Raises:
            ValueError: If node_name doesn't exist in graph
            ValueError: If invalid forecast_type is provided
            ValueError: If growth_params don't match forecast_type requirements

        Example:
            # Create fixed 5% growth forecast
            fsg.create_forecast("revenue", "fixed", "FY2022", ["FY2023", "FY2024"], 0.05)
            
            # Create curved growth forecast
            fsg.create_forecast("revenue", "curve", "FY2022", ["FY2023", "FY2024"], [0.05, 0.06])
        NzNode 'z' not found in graph.⁄fixedz4Fixed growth forecast requires a single growth rate.⁄curvezNCurve growth forecast requires list of growth rates matching forecast periods.⁄statisticalzFStatistical growth forecast requires a callable distribution function.⁄customz;Custom growth forecast requires a callable growth function.zInvalid forecast type 'r0   )r   r(   r1   r:   ⁄int⁄floatr   ⁄list⁄lenr   ⁄callabler   r   ⁄replace_node)r   r5   rS   rT   rU   rV   ⁄
input_nodeZforecast_noder   r   r   ⁄create_forecast·   s:    ˇˇˇˇz'FinancialStatementGraph.create_forecast)r7   c              	   C   s  t | jj†° É}g }g }g }g }|D ]f}| jj| }t|tÉrJ|†|° q$t|tÉr`|†|° q$t|tÉrv|†|° q$t|t	Ér$|†|° q$dg}|†d° |†dd†
| jj°õ ù° |†d° |†d° t t| j†° ÉÉ}	|	D ]>}
|
|| v r‡|
|v êr|†d|
õ dù° q‡|†d|
õ ù° q‡|†d	° |†d° t|ÉD ]B}| jj| }t|d
Éêr<|j}|†d|õ dd†
|°õ dù° êq<|†d° |†d° t|ÉD ]}|†d|õ ù° êqú|†d° |†d° t|ÉD ê]0}| jj| }t|t	Éêr–|jj†dd°}d|õ d|õ dù}t|tÉêr6|†|õ d|jdõù° n t|tÉêràddÑ |jD É}|j}ddÑ t||ÉD É}|†|õ dd†
|°õ ù° nxt|tÉêr–ddl}|†|j°}|†d°d †° }|†|õ d|õ ù° n0t|t Éêrˆ|†|õ d|j!jõ ù° n
|†|° êq–d†
|°S )a⁄  
        Returns a string representation of the financial statement graph structure.

        The string includes:
        - All time periods in the graph
        - Financial statement items (raw data nodes)
        - Calculations between items, showing their input dependencies
        - Financial metrics that have been defined
        - Forecasted items with their forecast types

        Returns:
            str: A formatted string containing the graph summary
        z!Financial Statement Graph Summaryz(========================================z

Periods: z, z
Financial Statement Items:z-------------------------u   ‚Ä¢ z (w Forecasts)z
Calculations:r2   z = f(˙)z	
Metrics:z
Forecasted Items:r   ⁄ z (type: z, growth rate: ˙.1%c                 S   s   g | ]}|d õëqS )re   r   )r)   ⁄rater   r   r   r,   o  r-   z3FinancialStatementGraph.__str__.<locals>.<listcomp>c                 S   s   g | ]\}}|õ d |õ ùëqS )˙: r   )r)   ⁄p⁄rr   r   r   r,   q  r-   z
  Growth curve: r   Nzlambda:r   z
  Distribution: z
  Custom growth function: ⁄
)"r]   r   r>   rB   r:   r   rI   r   r   r   ⁄joinr   ⁄reversedrD   rA   ⁄hasattrr2   ⁄	__class__⁄__name__⁄replacer   ⁄growth_rater   ⁄growth_ratesrU   ⁄zipr   ⁄inspect⁄	getsource⁄distribution_callable⁄split⁄stripr   ⁄growth_function)r   r>   Zfinancial_itemsZcalculations⁄metrics⁄	forecastsr5   r$   ⁄output⁄
topo_order⁄item⁄calcr&   ZmetricZforecastrS   Z	base_inforr   r   Z
curve_infort   Zlambda_source⁄	func_callr   r   r   ⁄__str__!  sx    









"



zFinancialStatementGraph.__str__)⁄otherr7   c                    s(  t | jjÉt |jjÉB }ttt|ÉÉÉâ ttdúá fddÑ}| jj†	° D ].}|j
à jjv rjtd|j
õ ùÉÇ||| jÉ qH|jj†	° D ]ñ}|j
à jjv êrà j†|j
°}t|tÉrÑ|j	†° D ]P\}}||j	v r∫t|j	| | Édkr∫td|j
õ d|õ d|j	| õ d	|õ ùÉÇq∫qÑ|||jÉ qÑà †°  à S )
ab  
        Add (merge) two FinancialStatementGraphs into a single graph.
        
        Args:
            other: The FinancialStatementGraph to merge with this graph
            
        Returns:
            FinancialStatementGraph: A new graph containing all nodes from both graphs
            
        Raises:
            ValueError: If there are conflicting node names between graphs
            ValueError: If there are conflicting values for the same node and period
            
        Example:
            # Create separate graphs for income statement and balance sheet
            income_graph = FinancialStatementGraph()
            balance_graph = FinancialStatementGraph()
            
            # Add nodes to each graph...
            
            # Merge the graphs using + operator
            combined_graph = income_graph + balance_graph
        )r$   ⁄source_graphc                    s¸   t | tÉrà †| j| j° n‹t | tÉrJà †| j| j| jj	†
dd°†° ° nÆt | tÉr¯|†| jj°}t | tÉràà †|jd| j| j| j° npt | tÉrÆà †|jd| j| j| j° nJt | tÉr‘à †|jd| j| j| j° n$t | tÉr¯à †|jd| j| j| j° d S )Nr   rd   rW   rX   rY   rZ   )r:   r   r%   r!   r"   r   r4   r2   rn   ro   rp   ⁄lowerr   r(   ra   r   rb   rT   rU   rq   r   rr   r   rv   r   ry   )r$   rÉ   ⁄	base_node©⁄mergedr   r   ⁄	copy_node°  s8    

ˇ


˛

˛

˛

˛z2FinancialStatementGraph.__add__.<locals>.copy_nodezDuplicate node name found: gªΩ◊Ÿﬂ|€=zConflicting values for node z in period rg   z != )⁄setr   r   r   r]   rA   r   r   r>   r"   r!   r1   r(   r:   r   r?   ⁄absrG   )r   rÇ   Zall_periodsrà   r$   Zexisting_noder6   rP   r   rÜ   r   ⁄__add__Ñ  s2    

ˇˇˇzFinancialStatementGraph.__add__˙%Y-%m-%dÁ333333Î?)⁄	file_path⁄sheet_names⁄date_format⁄metric_definitions⁄similarity_thresholdr7   c              
   C   s‹   t |||É}t|pt|É}zÑ|†° \}}	ttt| jjÉt|	ÉB ÉÉ| j_|†	t|†
° É°}
|
†° D ]0\}\}}|tv rÇ| †|° qb| †||| ° qb| †°  W n8 ty÷ } z tdt|Éõ ùÉ|ÇW Y d}~n
d}~0 0 dS )a&  
        Import financial data from an Excel file into the graph.

        This method uses ExcelImporter to parse the Excel file and MappingService to normalize
        metric names, then integrates the data into the graph structure.

        Args:
            file_path: Path to the Excel file containing financial data
            sheet_names: Optional list of specific sheets to process. If None, processes all sheets.
            date_format: Format string for parsing date columns (default: "%Y-%m-%d")
            metric_definitions: Optional custom metric definitions. If None, uses METRIC_DEFINITIONS.
            similarity_threshold: Threshold for metric name matching (default: 0.85)

        Raises:
            FileNotFoundError: If the Excel file doesn't exist
            ValueError: If the file format is invalid or if there are mapping errors
            MappingError: If metric mapping fails for any items

        Example:
            # Import from Excel with default settings
            fsg.import_from_excel("financial_data.xlsx")

            # Import specific sheets with custom date format
            fsg.import_from_excel(
                "financial_data.xlsx",
                sheet_names=["Income Statement", "Balance Sheet"],
                date_format="%m/%d/%Y"
            )
        zError importing Excel data: N)r	   r
   r   Zget_financial_datarA   r]   râ   r   r   Zmap_metric_namesrB   r?   ⁄
add_metricr%   rG   ⁄	Exceptionr1   ⁄str)r   ré   rè   rê   rë   rí   Zexcel_importerZmapping_serviceZfinancial_datar   ⁄mappings⁄original_nameZmapped_nameZ
confidence⁄er   r   r   ⁄import_from_excel÷  s"    !˛ 
z)FinancialStatementGraph.import_from_excel)⁄metric_namer5   c           
   	   C   s
  |t vrtd|õ dùÉÇ|du r&tÉ }||v r>td|õ dùÉÇ|†|° t | }|d }|D ]^}| j†|°}|du r\|t v ré| j|||dç q\| j†|°du r\td|õ d	|õ d
|õ dùÉÇq\|p¬|}| j†|°dur‚|†|° dS t||| jÉ}	| j†	|	° |†|° dS )aƒ  
        Add a metric calculation node to the graph based on predefined metric definitions.

        This method adds a new metric node to the financial statement graph, handling all dependencies
        and ensuring proper calculation order. It will recursively add any required metric nodes that
        don't yet exist in the graph.

        Args:
            metric_name: The name of the metric to add (must exist in METRIC_DEFINITIONS)
            node_name: Optional custom name for the node (defaults to metric_name)
            _processing: Internal set to detect cyclic dependencies (do not set manually)

        Raises:
            ValueError: If the metric is not found in METRIC_DEFINITIONS
            ValueError: If a required input node is missing from the graph
            ValueError: If a cyclic dependency is detected between metrics

        Example:
            # Add gross profit metric
            fsg.add_metric("gross_profit")

            # Add net profit margin (will automatically add gross_profit if needed)
            fsg.add_metric("net_profit_margin")

            # Add metric with custom node name
            fsg.add_metric("gross_profit", node_name="adjusted_gross_profit")
        zMetric 'z"' not found in METRIC_DEFINITIONS.Nz'Cyclic dependency detected for metric 'r0   r&   )⁄_processingzRequired input 'z' for metric 'z' not found. Please ensure 'z.' is added as a financial statement item node.)
r   r1   râ   ⁄addr   r(   rì   ⁄remover   r#   )
r   rö   r5   rõ   ⁄
definitionZrequired_inputsr*   r$   Zmetric_node_nameZmetric_noder   r   r   rì     s6    
ˇˇ
z"FinancialStatementGraph.add_metric)N)T)T)Nrå   Nrç   )NN)ro   ⁄
__module__⁄__qualname__⁄__doc__r]   r    rï   r   r\   r%   r   r4   r9   rG   ⁄boolrK   rL   rR   r   rb   rÅ   rã   r   r   rô   rì   r   r   r   r   r      s(   (
34ˇ@cR   ˛˛Ar   )!⁄pathlibr   ⁄typingr   r   r   r   ⁄pandasrK   r   r   Zimporters.excel_importerr	   Zimporters.mapping_servicer
   r>   r   r   r   r   r   r   r   r   r{   r   r   r   r   r   rz   r   r   r   r   r   r   ⁄<module>   s   (

===== fin_statement_model/__pycache__/builder.cpython-39.pyc =====
a
    ®dTg÷
  „                   @   s.   d dl mZ d dlmZ deedúddÑZdS )È   )⁄METRIC_DEFINITIONS)⁄MetricCalculationNodeN)⁄metric_name⁄	node_namec           
   	   C   s   |t vrtd|õ dùÉÇ|du r&tÉ }||v r>td|õ dùÉÇ|†|° t | }|d }|D ]Z}| †|°}|du r\|t v råt| |||dç q\| †|°du r\td|õ d	|õ d
|õ dùÉÇq\|pæ|}| †|°dur‹|†|° dS t||| É}	| †|	° |†|° dS )a¡  
    Add a metric calculation node to the graph based on predefined metric definitions.

    This function adds a new metric node to the financial statement graph, handling all dependencies
    and ensuring proper calculation order. It will recursively add any required metric nodes that
    don't yet exist in the graph.

    Args:
        graph: The financial statement graph to add the metric to
        metric_name: The name of the metric to add (must exist in METRIC_DEFINITIONS)
        node_name: Optional custom name for the node (defaults to metric_name)
        _processing: Internal set to detect cyclic dependencies (do not set manually)

    Raises:
        ValueError: If the metric is not found in METRIC_DEFINITIONS
        ValueError: If a required input node is missing from the graph
        ValueError: If a cyclic dependency is detected between metrics

    Example:
        # Add gross profit metric
        add_metric(graph, "gross_profit")

        # Add net profit margin (will automatically add gross_profit if needed)
        add_metric(graph, "net_profit_margin")

        # Add metric with custom node name
        add_metric(graph, "gross_profit", node_name="adjusted_gross_profit")
    zMetric 'z"' not found in METRIC_DEFINITIONS.Nz'Cyclic dependency detected for metric 'z'.⁄inputs)⁄_processingzRequired input 'z' for metric 'z' not found. Please ensure 'z.' is added as a financial statement item node.)	r   ⁄
ValueError⁄set⁄add⁄get_node⁄
add_metric⁄remover   ⁄add_node)
⁄graphr   r   r   ⁄
definitionZrequired_inputs⁄inp⁄nodeZmetric_node_nameZmetric_node© r   ˙F/Users/joneickmeier/fin_statement_model/fin_statement_model/builder.pyr      s6    

ˇˇ

r   )NN)⁄metricsr   ⁄nodesr   ⁄strr   r   r   r   r   ⁄<module>   s   

===== fin_statement_model/__pycache__/forecasts.cpython-39.pyc =====
a
    ÂsTgß,  „                   @   sp   d dl mZmZ ddlmZ G ddÑ deÉZG ddÑ deÉZG dd	Ñ d	eÉZG d
dÑ deÉZG ddÑ deÉZ	dS )È    )⁄List⁄CallableÈ   )⁄Nodec                   @   sr   e Zd ZdZeeee dúddÑZeedúddÑZ	dd	Ñ Z
eedúd
dÑZeedúddÑZeeeedúddÑZdS )⁄ForecastNodeaM  
    Base class for forecast nodes that project future values based on historical data.

    A forecast node takes an input node (typically a financial statement item) and projects its
    future values using various growth methods. The node caches calculated values to avoid
    redundant computations.

    Attributes:
        name (str): Identifier for the forecast node
        input_node (Node): Source node containing historical values to forecast from
        base_period (str): Last historical period to use as basis for forecasting
        forecast_periods (List[str]): List of future periods to generate forecasts for
        _cache (dict): Internal cache of calculated values

    Methods:
        calculate(period): Get value for a specific period (historical or forecast)
        _calculate_value(period): Core calculation logic for a period
        _get_previous_period(period): Helper to get chronologically previous period
        _get_growth_factor_for_period(): Abstract method for growth rate calculation

    Example:
        # Create 5% fixed growth forecast for revenue
        base = "FY2022"
        forecasts = ["FY2023", "FY2024", "FY2025"]
        node = FixedGrowthForecastNode("revenue_forecast", revenue_node, base, forecasts, 0.05)
        
        # Get forecasted value
        fy2024_revenue = node.calculate("FY2024")
    )⁄
input_node⁄base_period⁄forecast_periodsc                 C   s$   |j | _ || _|| _|| _i | _d S ©N)⁄namer   r   r	   ⁄_cache)⁄selfr   r   r	   © r   ˙H/Users/joneickmeier/fin_statement_model/fin_statement_model/forecasts.py⁄__init__"   s
    zForecastNode.__init__)⁄period⁄returnc                 C   s$   || j vr| †|°| j |< | j | S )aG  
        Calculate the value for a specific period, using cached results if available.

        This method returns historical values for periods up to the base period, and
        calculates forecasted values for future periods. Results are cached to avoid
        redundant calculations.

        Args:
            period (str): The period to calculate the value for (e.g. "FY2023")

        Returns:
            float: The calculated value for the specified period

        Raises:
            ValueError: If the requested period is not in base_period or forecast_periods

        Example:
            # Get historical value
            base_value = node.calculate("FY2022")  # Returns actual historical value

            # Get forecasted value 
            forecast_value = node.calculate("FY2024")  # Returns projected value
        )r   ⁄_calculate_value)r   r   r   r   r   ⁄	calculate)   s    
zForecastNode.calculatec                 C   s   | j †°  dS )aW  
        Clear the calculation cache.

        This method clears any cached calculation results, forcing future calls to
        calculate() to recompute values rather than using cached results.

        Example:
            # Clear cached calculations
            node.clear_cache()  # Future calculate() calls will recompute values
        N)r   ⁄clear)r   r   r   r   ⁄clear_cacheE   s    zForecastNode.clear_cachec                 C   sd   || j kr| j†|°S || jvr6td|õ d| jõ ùÉÇ| †|°}| †|°}| †|||°}|d|  S )NzPeriod 'z' not in forecast periods for r   )r   r   r   r	   ⁄
ValueErrorr   ⁄_get_previous_period⁄_get_growth_factor_for_period)r   r   ⁄prev_period⁄
prev_valueZgrowth_factorr   r   r   r   R   s    



zForecastNode._calculate_value)⁄current_periodr   c                 C   s(   t | jg| j É}|†|°}||d  S )Nr   )⁄sortedr   r	   ⁄index)r   r   Zall_periods⁄idxr   r   r   r   \   s    
z!ForecastNode._get_previous_period©r   r   r   r   c                 C   s   t dÉÇd S )NzImplement in subclass.)⁄NotImplementedError©r   r   r   r   r   r   r   r   a   s    z*ForecastNode._get_growth_factor_for_periodN)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   ⁄strr   r   ⁄floatr   r   r   r   r   r   r   r   r   r      s   
r   c                       sD   e Zd ZdZeeee edúá fddÑZeeeedúddÑZ	á  Z
S )⁄FixedGrowthForecastNodea  
    A forecast node that applies a fixed growth rate to project future values.

    This node takes a constant growth rate and applies it to each forecast period,
    compounding from the base period value. It's useful for simple forecasting scenarios
    where steady growth is expected.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022") 
        forecast_periods (List[str]): List of future periods to forecast
        growth_rate (float): The fixed growth rate to apply (e.g. 0.05 for 5% growth)

    Example:
        # Create node forecasting 5% annual revenue growth
        forecast = FixedGrowthForecastNode(
            "revenue_forecast",
            revenue_node,
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            0.05
        )

        # Get forecasted value
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1.05)^2
    )r   r   r	   ⁄growth_ratec                    s   t É †|||° || _d S r
   )⁄superr   r*   )r   r   r   r	   r*   ©⁄	__class__r   r   r   Å   s    z FixedGrowthForecastNode.__init__r    c                 C   s   | j S r
   )r*   r"   r   r   r   r   Ö   s    z5FixedGrowthForecastNode._get_growth_factor_for_period©r#   r$   r%   r&   r   r'   r   r(   r   r   ⁄__classcell__r   r   r,   r   r)   d   s   r)   c                       sH   e Zd ZdZeeee ee dúá fddÑZeeeedúddÑZ	á  Z
S )⁄CurveGrowthForecastNodea   
    A forecast node that applies different growth rates for each forecast period.

    This node takes a list of growth rates corresponding to each forecast period,
    allowing for varying growth assumptions over time. This is useful when you expect
    growth patterns to change, such as high initial growth followed by moderation.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022")
        forecast_periods (List[str]): List of future periods to forecast
        growth_rates (List[float]): List of growth rates for each period (e.g. [0.08, 0.06, 0.04])
                                   Must match length of forecast_periods.

    Raises:
        ValueError: If length of growth_rates doesn't match forecast_periods

    Example:
        # Create node with declining growth rates
        forecast = CurveGrowthForecastNode(
            "revenue_forecast", 
            revenue_node,
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            [0.08, 0.06, 0.04]  # 8% then 6% then 4% growth
        )

        # Get forecasted value
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1.08) * (1.06)
    )r   r   r	   ⁄growth_ratesc                    s2   t É †|||° t|Ét|Ékr(tdÉÇ|| _d S )Nz3Number of growth rates must match forecast periods.)r+   r   ⁄lenr   r1   )r   r   r   r	   r1   r,   r   r   r   ©   s    z CurveGrowthForecastNode.__init__r    c                 C   s   | j †|°}| j| S r
   )r	   r   r1   )r   r   r   r   r   r   r   r   r   Ø   s    z5CurveGrowthForecastNode._get_growth_factor_for_periodr.   r   r   r,   r   r0   à   s     r0   c                       sL   e Zd ZdZeeee eg ef dúá fddÑZ	eeeedúddÑZ
á  ZS )⁄StatisticalGrowForecastNodea7  
    A forecast node that generates growth rates from a statistical distribution.

    This node uses a provided statistical distribution function to randomly generate
    growth rates for each forecast period. This is useful for modeling uncertainty
    and running Monte Carlo simulations of different growth scenarios.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022")
        forecast_periods (List[str]): List of future periods to forecast
        distribution_callable (Callable[[], float]): Function that returns random growth rates
                                                   from a statistical distribution

    Example:
        # Create node with normally distributed growth rates
        from numpy.random import normal
        forecast = StatisticalGrowForecastNode(
            "revenue_forecast",
            revenue_node, 
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            lambda: normal(0.05, 0.02)  # Mean 5% growth, 2% std dev
        )

        # Get forecasted value (will vary due to randomness)
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1 + r1) * (1 + r2) where r1,r2 are random
    )r   r   r	   ⁄distribution_callablec                    s   t É †|||° || _d S r
   )r+   r   r4   )r   r   r   r	   r4   r,   r   r   r   “   s    z$StatisticalGrowForecastNode.__init__r    c                 C   s   | † ° S r
   )r4   r"   r   r   r   r   ÷   s    z9StatisticalGrowForecastNode._get_growth_factor_for_period©r#   r$   r%   r&   r   r'   r   r   r(   r   r   r/   r   r   r,   r   r3   ≥   s   $r3   c                       sR   e Zd ZdZeeee eeeegef dúá fddÑZ	eeeedúddÑZ
á  ZS )⁄CustomGrowForecastNodeav  
    A forecast node that uses a custom function to determine growth rates.

    This node allows complete flexibility in how growth rates are calculated by accepting
    a custom function that can incorporate any logic or external data to determine the
    growth rate for each period.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022")
        forecast_periods (List[str]): List of future periods to forecast
        growth_function (Callable[[str, str, float], float]): Function that returns growth rate
            given current period, previous period, and previous value

    The growth_function should accept three parameters:
        - current_period (str): The period being forecasted
        - prev_period (str): The previous period
        - prev_value (float): The value from the previous period
    And return a float representing the growth rate for that period.

    Example:
        def custom_growth(period, prev_period, prev_value):
            # Growth rate increases by 1% each year, starting at 5%
            year_diff = int(period[-4:]) - int(prev_period[-4:])
            return 0.05 + (0.01 * year_diff)

        forecast = CustomGrowForecastNode(
            "revenue_forecast",
            revenue_node,
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            custom_growth
        )

        # Get forecasted value using custom growth logic
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1 + 0.05) * (1 + 0.06)
    )r   r   r	   ⁄growth_functionc                    s   t É †|||° || _d S r
   )r+   r   r7   )r   r   r   r	   r7   r,   r   r   r     s    zCustomGrowForecastNode.__init__r    c                 C   s   | † |||°S r
   )r7   r"   r   r   r   r     s    z4CustomGrowForecastNode._get_growth_factor_for_periodr5   r   r   r,   r   r6   Ÿ   s   '*r6   N)
⁄typingr   r   ⁄nodesr   r   r)   r0   r3   r6   r   r   r   r   ⁄<module>   s   `$+&

===== fin_statement_model/__pycache__/metrics.cpython-39.pyc =====
a
    ÕÎTgyY  „                S   @   s˙  d dgddddúddgddd	dúg d
¢ddddúddgddddúddgddddúg d¢ddddúddgddddúddgddddúdd gdd d!dúdd gd"d d#dúdd gd$d d%dúdd gd&d d'dúd(d gd)d d*dúd+d gd,d d-dúd.d/gd0d1d2dúd3d4gd5d1d6dúdd7gd8d9d:dúdd;gd<d9d=dúd>d3gd?d9d@dúg dA¢dBd9dCdúd+dDgdEd9dFdúd.dGgdHd9dIdúddJgdKd9dLdúdMdGgdNdOdPdúdMdQgdRdOdSdúdTdGgdUdOdVdúdWdGgdXdOdYdúd>dZgd[d\d]dúd>d.gd^d\d_dúdd`gdad\dbdúd7d;gdcd\dddúd.d3gded\dfdúg dg¢dhdidjdúdkdigdldidmdúddngdodidpdúg dq¢drdidsdúd d7gdtdudvdúddwgdxdudydúd dzgd{dud|dúdd}gd~duddúdzd gdÄdÅdÇdúdzd gdÄdÅdÉdúdwdgdÑdÅdÖdúdwdgdÑdÅdÜdúd}dgdádÅdàdúd}dgdádÅdâdúdädãgdådÅdçdúdédègdêdÅdëdúd dígdìdîdïdúd dñgdódîdòdúddôgdödõdúdúdùdûgdüdõd†dúd°d gd¢dõd£dúd§d(gd•dõd¶dúd§dgdßdõd®dúd©dôgd™d´d¨dúd≠dùgdÆd´dØdúd∞dgd±d´d≤dúd≥d¥gdµd∂d∑dúd°d∏gdπd∂d∫dúd§d gdªd∂dºdúdΩdægdød¿d¡dúd dægd¬d¿d√dúdƒd≈gd∆d¿d«dúdûd≈gd»d¿d…dúd dÀgdÃd¿dÕdúdŒdœgd–d¿d—dúddœgd“d¿d”dúd‘d’gd÷d¿d◊dúdÿd’gdŸd¿d⁄dúdd gd&d€d‹dúd›dﬁgdﬂd€d‡dúd·dﬁgd‚d€d„dúd≥d7gd‰d€dÂdúd≥d¥gdµd€dÊdúdÁdËgdÈd€dÍdúd∏dôgdÎd€dÏdúdÌdùgdÓd€dÔdúg d¢dÒd€dÚdúdÛúOZ dÙS )ıZrevenueZcost_of_goods_soldzrevenue - cost_of_goods_soldZprofitabilityzzThe profit a company makes after deducting the costs directly associated with making and selling its products or services.)⁄inputs⁄formulaZmetric_typeZmetric_description⁄gross_profitZoperating_expensesz!gross_profit - operating_expenseszMProfit generated from core business operations, excluding interest and taxes.)Zother_interest_expensesZinterest_income⁄interest_expensez:interest_income - interest_expense-other_interest_expenseszFIncome generated from interest-bearing assets minus interest expenses.⁄operating_income⁄total_interest_expensez)operating_income + total_interest_expensezProfit before taxes.⁄pre_tax_income⁄tax_expensezpre_tax_income - tax_expensezbThe company's total earnings or profit after all expenses, interest, and taxes have been deducted.)⁄
net_incomer   r   z1net_income - total_interest_expense + tax_expensezÖEarnings Before Interest and Taxes; measures company's operating performance without considering financial and tax-related decisions.⁄ebitZdepreciation_and_amortizationz$ebit + depreciation_and_amortizationzEarnings Before Interest, Taxes, Depreciation, and Amortization; indicates operational performance excluding non-cash expenses.r	   z#net_income - total_interest_expensezoNet Operating Profit After Taxes; shows operating performance after tax adjustments but before financing costs.zgross_profit / revenue⁄marginzyPercentage of revenue remaining after deducting cost of goods sold; indicates pricing strategy and production efficiency.zoperating_income / revenuezZPercentage of revenue remaining after operating expenses; measures operational efficiency.znet_income / revenuez^Percentage of revenue that becomes profit after all expenses; indicates overall profitability.zebit / revenuezMOperating profitability as a percentage of revenue before interest and taxes.⁄ebitdazebitda / revenuez[Operating performance as a percentage of revenue before financial, tax, and non-cash items.⁄nopatznopat / revenuez6After-tax operating profit as a percentage of revenue.Ztotal_assetsZtotal_assets_previousz*(total_assets + total_assets_previous) / 2ZassetzOMean value of assets between two periods; used for various return calculations.⁄total_equityZtotal_equity_previousz*(total_equity + total_equity_previous) / 2zUMean value of shareholders' equity between two periods; used for return calculations.⁄average_total_assetsz!net_income / average_total_assets⁄returnzGMeasures how efficiently a company uses its assets to generate profits.⁄average_shareholders_equityz(net_income / average_shareholders_equityzVMeasures how efficiently a company uses shareholders' investments to generate profits.⁄
total_debtztotal_debt + total_equityz7Temporary calculation for invested capital computation.)r   r   ⁄cashz total_debt + total_equity - cashzRTotal investment in the business excluding excess cash; used for ROIC calculation.Zaverage_invested_capitalz nopat / average_invested_capitalzdReturn on Invested Capital; measures how efficiently a company uses all capital to generate profits.Zcurrent_liabilitiesz"total_assets - current_liabilitieszFLong-term capital invested in the business; used for ROCE calculation.Zaverage_capital_employedzebit / average_capital_employedzSReturn on Capital Employed; measures profitability relative to long-term financing.Zcurrent_assetsz$current_assets / current_liabilitiesZ	liquidityzPMeasures company's ability to pay short-term obligations with short-term assets.Z	inventoryzcurrent_assets - inventoryz4Most liquid assets; used in quick ratio calculation.⁄quick_assetsz"quick_assets / current_liabilitieszSMore conservative measure of liquidity that excludes inventory from current assets.r   zcash / current_liabilitiesz[Most conservative liquidity measure; shows ability to cover short-term debt with cash only.Ztotal_shareholders_equityz&total_debt / total_shareholders_equityZleveragez?Measures extent of debt financing relative to equity financing.ztotal_debt / total_assetsz5Indicates percentage of assets financed through debt.r   zebit / interest_expensezDIndicates ability to meet interest payments from operating earnings.z2average_total_assets / average_shareholders_equityzQMeasures total assets relative to shareholders' equity; indicates leverage level.ztotal_assets / total_equityzXAlternative measure of financial leverage; shows assets funded by each dollar of equity.)⁄operating_cash_flowr   Ztaxesz.operating_cash_flow + interest_expense + taxesZdebt_servicez<Cash available to service debt obligations after operations.⁄cash_available_for_debt_servicez.cash_available_for_debt_service / debt_servicezFMeasures ability to service debt obligations from operating cash flow.⁄fixed_charges_before_taxzebit + fixed_charges_before_taxzKOperating earnings plus fixed charges; used in fixed charge coverage ratio.)r
   r   Zfixed_chargesz1(ebit + fixed_charges_before_tax) / fixed_chargeszAMeasures ability to meet fixed payment obligations from earnings.zrevenue / average_total_assetsZ
efficiencyz=Measures how efficiently assets are used to generate revenue.Zaverage_inventoryz&cost_of_goods_sold / average_inventoryzFIndicates how many times inventory is sold and replaced over a period.Zaverage_accounts_receivablez%revenue / average_accounts_receivablez/Measures how quickly customers pay their bills.Zaverage_accounts_payablez-cost_of_goods_sold / average_accounts_payablez4Measures how quickly the company pays its suppliers.z-(average_accounts_receivable / revenue) * 365Zworking_capitalz>Proportion of receivables to revenue; used in DSO calculation.zBDays Sales Outstanding; average number of days to collect payment.z.(average_inventory / cost_of_goods_sold) * 365z9Proportion of inventory to COGS; used in DIO calculation.z;Days Inventory Outstanding; average days to sell inventory.z5(average_accounts_payable / cost_of_goods_sold) * 365z8Proportion of payables to COGS; used in DPO calculation.z9Days Payables Outstanding; average days to pay suppliers.⁄dso⁄dioz	dso + dioz0Temporary calculation for cash conversion cycle.⁄temp_dso_dio⁄dpoztemp_dso_dio - dpoz:Number of days to convert resource inputs into cash flows.Zaverage_working_capitalz!revenue / average_working_capitalZasset_utilizationzCMeasures how efficiently working capital is used to generate sales.Zaverage_net_fixed_assetsz"revenue / average_net_fixed_assetszAMeasures how efficiently fixed assets are used to generate sales.Zshares_outstandingznet_income / shares_outstandingZmarketz?Earnings Per Share; profit allocated to each outstanding share.Zshare_price⁄epszshare_price / epszEPrice-to-Earnings ratio; indicates market value relative to earnings.Zmarket_capitalizationzmarket_capitalization / revenuezAPrice-to-Sales ratio; indicates market value relative to revenue.Zenterprise_valuezenterprise_value / ebitdazVEnterprise Value to EBITDA; indicates company value relative to operating performance.zenterprise_value / ebitzQEnterprise Value to EBIT; indicates company value relative to operating earnings.Zannual_dividendsz%annual_dividends / shares_outstandingZdividendz=Total dividends paid divided by number of shares outstanding.⁄dividends_per_sharez!dividends_per_share / share_pricez(Dividend return relative to share price.Z	dividendszdividends / net_incomez-Proportion of earnings paid out as dividends.r   Zcapexzoperating_cash_flow - capexZ	cash_flowz@Cash available after operating expenses and capital investments.⁄free_cash_flowz&market_capitalization / free_cash_flowzLPrice to Free Cash Flow; indicates market value relative to cash generation.zenterprise_value / revenuezMEnterprise Value to Sales ratio; indicates company value relative to revenue.Zrevenue_currentZrevenue_previousz"revenue_current - revenue_previousZgrowthz+Absolute change in revenue between periods.z/(revenue - revenue_previous) / revenue_previousz-Percentage change in revenue between periods.Zeps_currentZeps_previouszeps_current - eps_previousz'Absolute change in EPS between periods.z#(eps - eps_previous) / eps_previousz)Percentage change in EPS between periods.⁄	p_e_ratio⁄
eps_growthzp_e_ratio / eps_growthzJP/E ratio relative to EPS growth rate; indicates value considering growth.Znet_income_currentZnet_income_previousz(net_income_current - net_income_previousz.Absolute change in net income between periods.z8(net_income - net_income_previous) / net_income_previousz0Percentage change in net income between periods.Zdividends_currentZdividends_previousz&dividends_current - dividends_previousz-Absolute change in dividends between periods.⁄dividend_changez$dividend_change / dividends_previousz/Percentage change in dividends between periods.ZperformancezLOperating profit as a percentage of sales; indicates operational efficiency.Zgross_profit_currentZgross_profit_previousz,gross_profit_current - gross_profit_previousz0Absolute change in gross profit between periods.⁄gross_profit_changez+gross_profit_change / gross_profit_previousz2Percentage change in gross profit between periods.z*operating_cash_flow / average_total_assetszKCash-based return on assets; indicates asset efficiency in generating cash.zHOperating cash flow less capital expenditures; used in FCFE calculation.⁄ocf_minus_capexZnet_borrowingsz ocf_minus_capex + net_borrowingsz;Free Cash Flow to Equity; cash available to equity holders.z#free_cash_flow / shares_outstandingz3Free cash flow allocated to each outstanding share.⁄free_cash_flow_per_sharez&free_cash_flow_per_share / share_pricez.Free cash flow return relative to share price.)⁄net_profit_margin⁄asset_turnover⁄equity_multiplierz6net_profit_margin * asset_turnover * equity_multiplierzZDetailed breakdown of ROE into operational efficiency, asset use efficiency, and leverage.)Or   r   r   r   r	   r
   r   r   Zgross_profit_marginZoperating_marginr%   Zebit_marginZebitda_marginZnopat_marginr   r   Zreturn_on_assetsZreturn_on_equityZtemp_debt_equityZinvested_capitalZroicZcapital_employedZroceZcurrent_ratior   ⁄quick_ratioZ
cash_ratioZdebt_to_equityZdebt_to_assetsZinterest_coverageZfinancial_leverager'   r   Zdebt_service_coverage_ratioZebit_plus_fixed_chargesZfixed_charge_coverage_ratior&   Zinventory_turnoverZreceivables_turnoverZpayables_turnoverZar_over_revenuer   Zinv_over_cogsr   Zap_over_cogsr   r   Zcash_conversion_cycleZworking_capital_turnoverZfixed_asset_turnoverr   r   Z	p_s_ratioZ	ev_ebitdaZev_ebitr   Zdividend_yieldZdividend_payout_ratior   Zp_fcfZev_salesZrevenue_changeZrevenue_growthZ
eps_changer    Z	peg_ratioZnet_income_changeZnet_income_growthr!   Zdividend_growthZreturn_on_salesr"   Zgross_profit_growthZcash_return_on_assetsr#   Zfcfer$   Z	fcf_yieldZ
dupont_roeN)⁄METRIC_DEFINITIONS© r*   r*   ˙F/Users/joneickmeier/fin_statement_model/fin_statement_model/metrics.py⁄<module>   s  ¸¸¸¸¸¸¸¸¸¸¸¸¸¸	¸¸	¸¸¸¸¸¸¸	¸¸¸¸	¸¸¸¸¸	¸¸¸¸	¸¸¸¸	¸¸¸¸¸¸¸¸	¸¸	¸¸¸¸¸	¸¸¸	¸¸¸	¸¸¸¸¸¸¸¸¸	¸¸¸¸¸¸¸¸¸Ä Ä Ä Ä ˛

===== fin_statement_model/forecasts.py =====
from typing import List, Callable
from .nodes import Node

class ForecastNode(Node):
    """
    Base class for forecast nodes that project future values based on historical data.

    A forecast node takes an input node (typically a financial statement item) and projects its
    future values using various growth methods. The node caches calculated values to avoid
    redundant computations.

    Attributes:
        name (str): Identifier for the forecast node
        input_node (Node): Source node containing historical values to forecast from
        base_period (str): Last historical period to use as basis for forecasting
        forecast_periods (List[str]): List of future periods to generate forecasts for
        _cache (dict): Internal cache of calculated values

    Methods:
        calculate(period): Get value for a specific period (historical or forecast)
        _calculate_value(period): Core calculation logic for a period
        _get_previous_period(period): Helper to get chronologically previous period
        _get_growth_factor_for_period(): Abstract method for growth rate calculation

    Example:
        # Create 5% fixed growth forecast for revenue
        base = "FY2022"
        forecasts = ["FY2023", "FY2024", "FY2025"]
        node = FixedGrowthForecastNode("revenue_forecast", revenue_node, base, forecasts, 0.05)
        
        # Get forecasted value
        fy2024_revenue = node.calculate("FY2024")
    """
    def __init__(self, input_node: Node, base_period: str, forecast_periods: List[str]):
        self.name = input_node.name
        self.input_node = input_node
        self.base_period = base_period
        self.forecast_periods = forecast_periods
        self._cache = {}

    def calculate(self, period: str) -> float:
        """
        Calculate the value for a specific period, using cached results if available.

        This method returns historical values for periods up to the base period, and
        calculates forecasted values for future periods. Results are cached to avoid
        redundant calculations.

        Args:
            period (str): The period to calculate the value for (e.g. "FY2023")

        Returns:
            float: The calculated value for the specified period

        Raises:
            ValueError: If the requested period is not in base_period or forecast_periods

        Example:
            # Get historical value
            base_value = node.calculate("FY2022")  # Returns actual historical value

            # Get forecasted value 
            forecast_value = node.calculate("FY2024")  # Returns projected value
        """
        if period not in self._cache:
            self._cache[period] = self._calculate_value(period)
        return self._cache[period]

    def clear_cache(self):
        """
        Clear the calculation cache.

        This method clears any cached calculation results, forcing future calls to
        calculate() to recompute values rather than using cached results.

        Example:
            # Clear cached calculations
            node.clear_cache()  # Future calculate() calls will recompute values
        """
        self._cache.clear()

    def _calculate_value(self, period: str) -> float:
        if period <= self.base_period:
            return self.input_node.calculate(period)
        if period not in self.forecast_periods:
            raise ValueError(f"Period '{period}' not in forecast periods for {self.name}")
        prev_period = self._get_previous_period(period)
        prev_value = self.calculate(prev_period)
        growth_factor = self._get_growth_factor_for_period(period, prev_period, prev_value)
        return prev_value * (1 + growth_factor)

    def _get_previous_period(self, current_period: str) -> str:
        all_periods = sorted([self.base_period] + self.forecast_periods)
        idx = all_periods.index(current_period)
        return all_periods[idx - 1]

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -> float:
        raise NotImplementedError("Implement in subclass.")

class FixedGrowthForecastNode(ForecastNode):
    """
    A forecast node that applies a fixed growth rate to project future values.

    This node takes a constant growth rate and applies it to each forecast period,
    compounding from the base period value. It's useful for simple forecasting scenarios
    where steady growth is expected.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022") 
        forecast_periods (List[str]): List of future periods to forecast
        growth_rate (float): The fixed growth rate to apply (e.g. 0.05 for 5% growth)

    Example:
        # Create node forecasting 5% annual revenue growth
        forecast = FixedGrowthForecastNode(
            "revenue_forecast",
            revenue_node,
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            0.05
        )

        # Get forecasted value
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1.05)^2
    """
    def __init__(self, input_node: Node, base_period: str, forecast_periods: List[str], growth_rate: float):
        super().__init__(input_node, base_period, forecast_periods)
        self.growth_rate = growth_rate

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -> float:
        return self.growth_rate

class CurveGrowthForecastNode(ForecastNode):
    """
    A forecast node that applies different growth rates for each forecast period.

    This node takes a list of growth rates corresponding to each forecast period,
    allowing for varying growth assumptions over time. This is useful when you expect
    growth patterns to change, such as high initial growth followed by moderation.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022")
        forecast_periods (List[str]): List of future periods to forecast
        growth_rates (List[float]): List of growth rates for each period (e.g. [0.08, 0.06, 0.04])
                                   Must match length of forecast_periods.

    Raises:
        ValueError: If length of growth_rates doesn't match forecast_periods

    Example:
        # Create node with declining growth rates
        forecast = CurveGrowthForecastNode(
            "revenue_forecast", 
            revenue_node,
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            [0.08, 0.06, 0.04]  # 8% then 6% then 4% growth
        )

        # Get forecasted value
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1.08) * (1.06)
    """
    def __init__(self, input_node: Node, base_period: str, forecast_periods: List[str], growth_rates: List[float]):
        super().__init__( input_node, base_period, forecast_periods)
        if len(growth_rates) != len(forecast_periods):
            raise ValueError("Number of growth rates must match forecast periods.")
        self.growth_rates = growth_rates

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -> float:
        idx = self.forecast_periods.index(period)
        return self.growth_rates[idx]

class StatisticalGrowForecastNode(ForecastNode):
    """
    A forecast node that generates growth rates from a statistical distribution.

    This node uses a provided statistical distribution function to randomly generate
    growth rates for each forecast period. This is useful for modeling uncertainty
    and running Monte Carlo simulations of different growth scenarios.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022")
        forecast_periods (List[str]): List of future periods to forecast
        distribution_callable (Callable[[], float]): Function that returns random growth rates
                                                   from a statistical distribution

    Example:
        # Create node with normally distributed growth rates
        from numpy.random import normal
        forecast = StatisticalGrowForecastNode(
            "revenue_forecast",
            revenue_node, 
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            lambda: normal(0.05, 0.02)  # Mean 5% growth, 2% std dev
        )

        # Get forecasted value (will vary due to randomness)
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1 + r1) * (1 + r2) where r1,r2 are random
    """
    def __init__(self, input_node: Node, base_period: str, forecast_periods: List[str], distribution_callable: Callable[[], float]):
        super().__init__(input_node, base_period, forecast_periods)
        self.distribution_callable = distribution_callable

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -> float:
        return self.distribution_callable()

class CustomGrowForecastNode(ForecastNode):
    """
    A forecast node that uses a custom function to determine growth rates.

    This node allows complete flexibility in how growth rates are calculated by accepting
    a custom function that can incorporate any logic or external data to determine the
    growth rate for each period.

    Args:
        name (str): Name identifier for the node
        input_node (Node): The node containing historical/base values
        base_period (str): The last historical period (e.g. "FY2022")
        forecast_periods (List[str]): List of future periods to forecast
        growth_function (Callable[[str, str, float], float]): Function that returns growth rate
            given current period, previous period, and previous value

    The growth_function should accept three parameters:
        - current_period (str): The period being forecasted
        - prev_period (str): The previous period
        - prev_value (float): The value from the previous period
    And return a float representing the growth rate for that period.

    Example:
        def custom_growth(period, prev_period, prev_value):
            # Growth rate increases by 1% each year, starting at 5%
            year_diff = int(period[-4:]) - int(prev_period[-4:])
            return 0.05 + (0.01 * year_diff)

        forecast = CustomGrowForecastNode(
            "revenue_forecast",
            revenue_node,
            "FY2022",
            ["FY2023", "FY2024", "FY2025"],
            custom_growth
        )

        # Get forecasted value using custom growth logic
        fy2024_revenue = forecast.calculate("FY2024")
        # Returns: base_value * (1 + 0.05) * (1 + 0.06)
    """
    def __init__(self, input_node: Node, base_period: str, forecast_periods: List[str], growth_function: Callable[[str, str, float], float]):
        super().__init__(input_node, base_period, forecast_periods)
        self.growth_function = growth_function

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -> float:
        return self.growth_function(period, prev_period, prev_value)


===== fin_statement_model/financial_statement.py =====
from pathlib import Path
from typing import Dict, List, Union, Optional
import pandas as pd

from .graph import Graph
from .importers.excel_importer import ExcelImporter
from .importers.mapping_service import MappingService
from .nodes import FinancialStatementItemNode, Node, AdditionCalculationNode, \
    SubtractionCalculationNode, MultiplicationCalculationNode, DivisionCalculationNode, CalculationNode, \
    MetricCalculationNode
from .forecasts import ForecastNode, FixedGrowthForecastNode, CurveGrowthForecastNode, StatisticalGrowForecastNode, CustomGrowForecastNode
from .metrics import METRIC_DEFINITIONS

class FinancialStatementGraph:
    """
    A graph specialized for financial statements.
    A graph-based representation of financial statements and calculations.

    This class provides functionality to:
    - Add raw financial statement items (like revenue, expenses, etc.) with their values
    - Define calculations between financial items (addition, subtraction, multiplication, division)
    - Calculate derived metrics for specific time periods
    
    The graph structure ensures proper dependency management and calculation order.
    Each node in the graph represents either a raw financial statement item or a calculation.

    Example:
        fsg = FinancialStatementGraph()
        fsg.add_financial_statement_item("revenue", {"2022": 1000.0})
        fsg.add_financial_statement_item("expenses", {"2022": 600.0})
        fsg.add_calculation("profit", ["revenue", "expenses"], "subtraction")
        profit_2022 = fsg.calculate_financial_statement("profit", "2022")  # Returns 400.0
    """
    def __init__(self, periods: list = None):
        self.graph = Graph()
        if periods is None:
            periods = []
        self.graph.periods = periods

    def add_financial_statement_item(self, name: str, values: Dict[str, float]):
        """
        Add a financial statement item node to the graph with historical values.

        Args:
            name: The name/identifier of the financial statement item (e.g. "revenue", "expenses")
            values: Dictionary mapping time periods to numerical values (e.g. {"2022": 1000.0})

        Raises:
            ValueError: If a node with the given name already exists in the graph

        Example:
            fsg.add_financial_statement_item("revenue", {"2022": 1000.0, "2023": 1200.0})
        """
        node = FinancialStatementItemNode(name, values)
        self.graph.add_node(node)

    def add_calculation(self, name: str, inputs: List[str], calculation_type: str):
        """
        Add a calculation node to the graph that performs arithmetic operations between input nodes.

        Args:
            name: The name/identifier for the calculation node (e.g. "gross_profit", "operating_margin")
            inputs: List of input node names that will be used in the calculation. Must be existing nodes.
            calculation_type: Type of arithmetic operation to perform. Valid values are:
                - 'addition': Adds all input values together
                - 'subtraction': Subtracts subsequent values from the first input
                - 'multiplication': Multiplies all input values together  
                - 'division': Divides first input by second input

        Raises:
            ValueError: If any input nodes don't exist in the graph
            ValueError: If an invalid calculation_type is provided

        Example:
            # Calculate gross profit as revenue - cost_of_goods_sold
            fsg.add_calculation("gross_profit", ["revenue", "cost_of_goods_sold"], "subtraction")

            # Calculate profit margin as net_income / revenue
            fsg.add_calculation("profit_margin", ["net_income", "revenue"], "division")
        """
        input_nodes = [self.graph.get_node(inp) for inp in inputs]
        if None in input_nodes:
            raise ValueError("One of the input nodes for calculation is missing.")
        if calculation_type == 'addition':
            node = AdditionCalculationNode(name, input_nodes)
        elif calculation_type == 'subtraction':
            node = SubtractionCalculationNode(name, input_nodes)
        elif calculation_type == 'multiplication':
            node = MultiplicationCalculationNode(name, input_nodes)
        elif calculation_type == 'division':
            node = DivisionCalculationNode(name, input_nodes)
        else:
            raise ValueError(f"Invalid calculation type '{calculation_type}'.")
        node.input_names = inputs
        self.graph.add_node(node)

    def calculate_financial_statement(self, node_name: str, period: str) -> float:
        """
        Calculate the value of a node for a specific time period.

        Args:
            node_name: The name/identifier of the node to calculate (e.g. "revenue", "gross_profit")
            period: The time period to calculate the value for (e.g. "FY2022")

        Returns:
            float: The calculated value for the specified node and period

        Raises:
            ValueError: If the node does not exist in the graph
            ValueError: If the period is not found in the node's data
            ValueError: If there is an error performing the calculation (e.g. division by zero)

        Example:
            # Calculate gross profit for FY2022
            gross_profit = fsg.calculate_financial_statement("gross_profit", "FY2022")
            
            # Calculate net profit margin for FY2021 
            npm = fsg.calculate_financial_statement("net_profit_margin", "FY2021")
        """
        return self.graph.calculate(node_name, period)
    
    def recalculate_all(self, copy_forward=True):
        """
        Recalculate all nodes in the graph for all periods.

        This method clears all node caches and recalculates values for every node in the graph
        in topologically sorted order to ensure dependencies are handled correctly.

        Args:
            copy_forward (bool): If True, copy forward the last historical value for any
                               FinancialStatementItemNode that doesn't have forecast periods
                               defined. Defaults to False.
        """
        # Clear all caches first
        self.graph.clear_all_caches()
        
        if copy_forward:
            # First, handle copying forward values for FinancialStatementItemNodes
            for node_name, node in self.graph.nodes.items():
                if isinstance(node, FinancialStatementItemNode):
                    # Skip nodes that already have forecasts
                    if any(isinstance(node, ForecastNode) for node in self.graph.nodes.values() 
                          if node.name == node_name):
                        continue
                    
                    # Find the last historical value
                    last_value = None
                    last_period = None
                    for period in sorted(node.values.keys()):
                        if period in self.graph.periods:
                            last_value = node.values[period]
                            last_period = period
                    
                    # Copy forward the last value to all subsequent periods
                    if last_value is not None and last_period is not None:
                        start_idx = self.graph.periods.index(last_period) + 1
                        for period in self.graph.periods[start_idx:]:
                            node.values[period] = last_value
        
        # Get topologically sorted order to ensure proper calculation order
        order = self.graph.topological_sort()
        
        # Recalculate each node for all periods
        for period in self.graph.periods:
            for node_name in order:
                node = self.graph.get_node(node_name)
                try:
                    node.calculate(period)
                except ValueError:
                    # Skip if period not valid for this node
                    continue

    def to_dataframe(self, recalculate: bool = True) -> pd.DataFrame:
        """
        Convert the financial statement graph into a pandas DataFrame.
        
        The DataFrame will have financial statement items as indices and periods as columns.
        Both raw financial statement items and calculated values will be included.

        Returns:
            pd.DataFrame: A DataFrame containing all financial statement values
                        with items as indices and periods as columns.

        Example:
            fsg = FinancialStatementGraph()
            fsg.add_financial_statement_item("revenue", {"2022": 1000.0, "2023": 1200.0})
            fsg.add_financial_statement_item("expenses", {"2022": 600.0, "2023": 700.0})
            fsg.add_calculation("profit", ["revenue", "expenses"], "subtraction")
            
            df = fsg.to_dataframe()
            # Results in:
            #           2022    2023
            # revenue  1000.0  1200.0
            # expenses  600.0   700.0
            # profit    400.0   500.0
        """

        if recalculate:
            # Recalculate all nodes to ensure all values are up to date
            self.recalculate_all()

        # Get all periods from the graph
        periods = sorted(self.graph.periods)
        
        # Initialize data dictionary
        data = {}
        
        # Iterate through all nodes in the graph
        for node_name in self.graph.nodes:
            values = []
            for period in periods:
                try:
                    value = self.calculate_financial_statement(node_name, period)
                    values.append(value)
                except (ValueError, KeyError):
                    values.append(None)
            data[node_name] = values
            
        # Create DataFrame
        df = pd.DataFrame(data).T
        df.columns = periods
        
        return df

    def create_forecast(self, node_name: str, forecast_type: str, base_period: str, 
                       forecast_periods: List[str], growth_params: Union[float, List[float]]) -> None:
        """
        Create a forecast node and replace the existing node in the graph.

        Args:
            node_name (str): Name of the node to forecast (must exist in graph)
            forecast_type (str): Type of forecast ('fixed', 'curve', 'statistical', or 'custom')
            base_period (str): Last historical period to use as basis for forecasting
            forecast_periods (List[str]): List of future periods to generate forecasts for
            growth_params: Growth parameters for the forecast:
                - For 'fixed': float representing constant growth rate
                - For 'curve': List[float] representing growth rates for each period
                - For 'statistical': Callable that returns random growth rates
                - For 'custom': Callable that takes (period, prev_period, prev_value)

        Raises:
            ValueError: If node_name doesn't exist in graph
            ValueError: If invalid forecast_type is provided
            ValueError: If growth_params don't match forecast_type requirements

        Example:
            # Create fixed 5% growth forecast
            fsg.create_forecast("revenue", "fixed", "FY2022", ["FY2023", "FY2024"], 0.05)
            
            # Create curved growth forecast
            fsg.create_forecast("revenue", "curve", "FY2022", ["FY2023", "FY2024"], [0.05, 0.06])
        """
        # Validate node exists
        input_node = self.graph.get_node(node_name)
        if input_node is None:
            raise ValueError(f"Node '{node_name}' not found in graph.")

        # Create appropriate forecast node based on type
        if forecast_type == 'fixed':
            if not isinstance(growth_params, (int, float)):
                raise ValueError("Fixed growth forecast requires a single growth rate.")
            forecast_node = FixedGrowthForecastNode(
                input_node, base_period, forecast_periods, growth_params
            )
        elif forecast_type == 'curve':
            if not isinstance(growth_params, list) or len(growth_params) != len(forecast_periods):
                raise ValueError("Curve growth forecast requires list of growth rates matching forecast periods.")
            forecast_node = CurveGrowthForecastNode(
                input_node, base_period, forecast_periods, growth_params
            )
        elif forecast_type == 'statistical':
            if not callable(growth_params):
                raise ValueError("Statistical growth forecast requires a callable distribution function.")
            forecast_node = StatisticalGrowForecastNode(
                input_node, base_period, forecast_periods, growth_params
            )
        elif forecast_type == 'custom':
            if not callable(growth_params):
                raise ValueError("Custom growth forecast requires a callable growth function.")
            forecast_node = CustomGrowForecastNode(
                input_node, base_period, forecast_periods, growth_params
            )
        else:
            raise ValueError(f"Invalid forecast type '{forecast_type}'.")

        # Replace existing node with forecast node
        self.graph.replace_node(node_name, forecast_node)

    def __str__(self) -> str:
        """
        Returns a string representation of the financial statement graph structure.

        The string includes:
        - All time periods in the graph
        - Financial statement items (raw data nodes)
        - Calculations between items, showing their input dependencies
        - Financial metrics that have been defined
        - Forecasted items with their forecast types

        Returns:
            str: A formatted string containing the graph summary
        """
        # Get all nodes from the graph
        nodes = list(self.graph.nodes.keys())
        
        # Categorize nodes
        financial_items = []
        calculations = []
        metrics = []
        forecasts = []
        
        for node_name in nodes:
            node = self.graph.nodes[node_name]
            if isinstance(node, FinancialStatementItemNode):
                financial_items.append(node_name)
            elif isinstance(node, CalculationNode):
                calculations.append(node_name)
            elif isinstance(node, MetricCalculationNode):
                metrics.append(node_name)
            elif isinstance(node, ForecastNode):
                forecasts.append(node_name)
        
        output = ["Financial Statement Graph Summary"]
        output.append("=" * 40)
        
        output.append(f"\nPeriods: {', '.join(self.graph.periods)}")
        
        output.append("\nFinancial Statement Items:")
        output.append("-" * 25)
        # Get items in topological order
        topo_order = list(reversed(self.graph.topological_sort()))
        
        # Filter and display items in topological order
        for item in topo_order:
            if item in financial_items + forecasts:
                if item in forecasts:
                    output.append(f"‚Ä¢ {item} (w Forecasts)")
                else:
                    output.append(f"‚Ä¢ {item}")
        
        output.append("\nCalculations:")
        output.append("-" * 25)
        for calc in sorted(calculations):
            node = self.graph.nodes[calc]
            if hasattr(node, 'input_names'):
                inputs = node.input_names
                output.append(f"‚Ä¢ {calc} = f({', '.join(inputs)})")
        
        output.append("\nMetrics:")
        output.append("-" * 25)
        for metric in sorted(metrics):
            output.append(f"‚Ä¢ {metric}")
        
        output.append("\nForecasted Items:")
        output.append("-" * 25)
        for forecast in sorted(forecasts):
            node = self.graph.nodes[forecast]
            if isinstance(node, ForecastNode):
                forecast_type = node.__class__.__name__.replace('ForecastNode', '')
                base_info = f"‚Ä¢ {forecast} (type: {forecast_type})"
                
                # Add specific forecast parameters based on type
                if isinstance(node, FixedGrowthForecastNode):
                    output.append(f"{base_info}, growth rate: {node.growth_rate:.1%}")
                
                elif isinstance(node, CurveGrowthForecastNode):
                    growth_rates = [f"{rate:.1%}" for rate in node.growth_rates]
                    periods = node.forecast_periods
                    curve_info = [f"{p}: {r}" for p, r in zip(periods, growth_rates)]
                    output.append(f"{base_info}\n  Growth curve: {', '.join(curve_info)}")
                
                elif isinstance(node, StatisticalGrowForecastNode):
                    # Get the source code of the lambda function
                    import inspect
                    lambda_source = inspect.getsource(node.distribution_callable)
                    # Extract just the function call part (after the lambda:)
                    func_call = lambda_source.split('lambda:')[1].strip()
                    output.append(f"{base_info}\n  Distribution: {func_call}")
                
                elif isinstance(node, CustomGrowForecastNode):
                    output.append(f"{base_info}\n  Custom growth function: {node.growth_function.__name__}")
                
                else:
                    output.append(base_info)
        
        return "\n".join(output)

    def __add__(self, other: 'FinancialStatementGraph') -> 'FinancialStatementGraph':
        """
        Add (merge) two FinancialStatementGraphs into a single graph.
        
        Args:
            other: The FinancialStatementGraph to merge with this graph
            
        Returns:
            FinancialStatementGraph: A new graph containing all nodes from both graphs
            
        Raises:
            ValueError: If there are conflicting node names between graphs
            ValueError: If there are conflicting values for the same node and period
            
        Example:
            # Create separate graphs for income statement and balance sheet
            income_graph = FinancialStatementGraph()
            balance_graph = FinancialStatementGraph()
            
            # Add nodes to each graph...
            
            # Merge the graphs using + operator
            combined_graph = income_graph + balance_graph
        """
        # Create a new graph with combined periods
        all_periods = set(self.graph.periods) | set(other.graph.periods)
        merged = FinancialStatementGraph(list(sorted(all_periods)))
        
        # Helper function to copy a node to the merged graph
        def copy_node(node: Node, source_graph: Graph):
            if isinstance(node, FinancialStatementItemNode):
                merged.add_financial_statement_item(node.name, node.values)
            elif isinstance(node, CalculationNode):
                merged.add_calculation(node.name, node.input_names, 
                                    node.__class__.__name__.replace('CalculationNode', '').lower())
            elif isinstance(node, ForecastNode):
                # Copy forecast configuration
                base_node = source_graph.get_node(node.input_node.name)
                if isinstance(node, FixedGrowthForecastNode):
                    merged.create_forecast(base_node.name, 'fixed', 
                                        node.base_period, node.forecast_periods, 
                                        node.growth_rate)
                elif isinstance(node, CurveGrowthForecastNode):
                    merged.create_forecast(base_node.name, 'curve',
                                        node.base_period, node.forecast_periods,
                                        node.growth_rates)
                elif isinstance(node, StatisticalGrowForecastNode):
                    merged.create_forecast(base_node.name, 'statistical',
                                        node.base_period, node.forecast_periods,
                                        node.distribution_callable)
                elif isinstance(node, CustomGrowForecastNode):
                    merged.create_forecast(base_node.name, 'custom',
                                        node.base_period, node.forecast_periods,
                                        node.growth_function)
        
        # First, copy all nodes from the current graph
        for node in self.graph.nodes.values():
            if node.name in merged.graph.nodes:
                raise ValueError(f"Duplicate node name found: {node.name}")
            copy_node(node, self.graph)
        
        # Then copy nodes from the other graph
        for node in other.graph.nodes.values():
            if node.name in merged.graph.nodes:
                # Check if values match for overlapping periods
                existing_node = merged.graph.get_node(node.name)
                if isinstance(node, FinancialStatementItemNode):
                    for period, value in node.values.items():
                        if period in existing_node.values:
                            if abs(existing_node.values[period] - value) > 1e-10:
                                raise ValueError(
                                    f"Conflicting values for node {node.name} in period {period}: "
                                    f"{existing_node.values[period]} != {value}"
                                )
                continue
            copy_node(node, other.graph)
        
        # Recalculate all values in the merged graph
        merged.recalculate_all()
        
        return merged

    def import_from_excel(self, file_path: Union[str, Path], sheet_names: Optional[List[str]] = None,
                         date_format: str = "%Y-%m-%d", metric_definitions: Optional[Dict] = None,
                         similarity_threshold: float = 0.85) -> None:
        """
        Import financial data from an Excel file into the graph.

        This method uses ExcelImporter to parse the Excel file and MappingService to normalize
        metric names, then integrates the data into the graph structure.

        Args:
            file_path: Path to the Excel file containing financial data
            sheet_names: Optional list of specific sheets to process. If None, processes all sheets.
            date_format: Format string for parsing date columns (default: "%Y-%m-%d")
            metric_definitions: Optional custom metric definitions. If None, uses METRIC_DEFINITIONS.
            similarity_threshold: Threshold for metric name matching (default: 0.85)

        Raises:
            FileNotFoundError: If the Excel file doesn't exist
            ValueError: If the file format is invalid or if there are mapping errors
            MappingError: If metric mapping fails for any items

        Example:
            # Import from Excel with default settings
            fsg.import_from_excel("financial_data.xlsx")

            # Import specific sheets with custom date format
            fsg.import_from_excel(
                "financial_data.xlsx",
                sheet_names=["Income Statement", "Balance Sheet"],
                date_format="%m/%d/%Y"
            )
        """
        # Initialize importers
        excel_importer = ExcelImporter(file_path, sheet_names, date_format)
        mapping_service = MappingService(
            metric_definitions or METRIC_DEFINITIONS,
            similarity_threshold
        )

        try:
            # Read and process Excel data
            financial_data, periods = excel_importer.get_financial_data()

            # Update graph periods
            self.graph.periods = sorted(list(set(self.graph.periods) | set(periods)))

            # Map metric names and add to graph
            mappings = mapping_service.map_metric_names(list(financial_data.keys()))

            for original_name, (mapped_name, confidence) in mappings.items():
                if mapped_name in METRIC_DEFINITIONS:
                    # If it's a defined metric, add it through the metric system
                    self.add_metric(mapped_name)
                    continue

                # Add as financial statement item
                self.add_financial_statement_item(mapped_name, financial_data[original_name])

            # Recalculate all values to ensure consistency
            self.recalculate_all()

        except Exception as e:
            # Wrap any underlying errors with context
            raise ValueError(f"Error importing Excel data: {str(e)}") from e

    def add_metric(self, metric_name: str, node_name: str = None, _processing=None):
        """
        Add a metric calculation node to the graph based on predefined metric definitions.

        This method adds a new metric node to the financial statement graph, handling all dependencies
        and ensuring proper calculation order. It will recursively add any required metric nodes that
        don't yet exist in the graph.

        Args:
            metric_name: The name of the metric to add (must exist in METRIC_DEFINITIONS)
            node_name: Optional custom name for the node (defaults to metric_name)
            _processing: Internal set to detect cyclic dependencies (do not set manually)

        Raises:
            ValueError: If the metric is not found in METRIC_DEFINITIONS
            ValueError: If a required input node is missing from the graph
            ValueError: If a cyclic dependency is detected between metrics

        Example:
            # Add gross profit metric
            fsg.add_metric("gross_profit")

            # Add net profit margin (will automatically add gross_profit if needed)
            fsg.add_metric("net_profit_margin")

            # Add metric with custom node name
            fsg.add_metric("gross_profit", node_name="adjusted_gross_profit")
        """
        if metric_name not in METRIC_DEFINITIONS:
            raise ValueError(f"Metric '{metric_name}' not found in METRIC_DEFINITIONS.")

        if _processing is None:
            _processing = set()

        if metric_name in _processing:
            raise ValueError(f"Cyclic dependency detected for metric '{metric_name}'.")
        _processing.add(metric_name)

        definition = METRIC_DEFINITIONS[metric_name]
        required_inputs = definition['inputs']

        for inp in required_inputs:
            node = self.graph.get_node(inp)
            if node is None:
                if inp in METRIC_DEFINITIONS:
                    # It's another metric, add it first
                    self.add_metric(inp, inp, _processing=_processing)
                else:
                    # It's a raw data node - must be present before adding metric
                    if self.graph.get_node(inp) is None:
                        raise ValueError(
                            f"Required input '{inp}' for metric '{metric_name}' not found. "
                            f"Please ensure '{inp}' is added as a financial statement item node."
                        )

        metric_node_name = node_name or metric_name
        if self.graph.get_node(metric_node_name) is not None:
            _processing.remove(metric_name)
            return

        metric_node = MetricCalculationNode(metric_node_name, metric_name, self.graph)
        self.graph.add_node(metric_node)

        _processing.remove(metric_name)


===== fin_statement_model/stats.py =====
import statistics
from typing import List
from .nodes import Node

class YoYGrowthNode(Node):
    """
    A node that calculates year-over-year growth between two periods.

    This node takes an input node and calculates the percentage growth between a prior period
    and current period. The growth is calculated as: (current_value - prior_value) / prior_value.

    If the prior period value is zero, returns NaN to avoid division by zero.

    Args:
        name (str): The name/identifier for this growth calculation node
        input_node (Node): The node whose values will be used to calculate growth
        prior_period (str): The earlier time period (e.g. "2021")
        current_period (str): The later time period (e.g. "2022")

    Attributes:
        name (str): The node's name/identifier
        input_node (Node): Reference to the input node
        prior_period (str): The earlier period for growth calculation
        current_period (str): The later period for growth calculation

    Example:
        # Create growth node to calculate revenue growth
        revenue = FinancialStatementItemNode("revenue", {
            "2021": 1000.0,
            "2022": 1200.0
        })
        revenue_growth = YoYGrowthNode("revenue_growth", revenue, "2021", "2022")
        
        # Calculate growth
        growth = revenue_growth.calculate()  # Returns 0.2 (20% growth)

    Returns:
        float: The calculated growth rate as a decimal (e.g. 0.2 for 20% growth)
        float('nan'): If prior period value is zero
    """
    def __init__(self, name: str, input_node: Node, prior_period: str, current_period: str):
        self.name = name
        self.input_node = input_node
        self.prior_period = prior_period
        self.current_period = current_period

    def calculate(self, period: str = None) -> float:
        """
        Calculate the year-over-year growth rate.

        This method calculates the growth rate between the prior period and current period,
        ignoring the period parameter passed in since the periods are fixed at initialization.
        The growth rate is calculated as: (current_value - prior_value) / prior_value.

        Args:
            period (str, optional): Ignored parameter to match Node interface. The periods
                used for calculation are set during initialization.

        Returns:
            float: The calculated growth rate as a decimal (e.g. 0.2 for 20% growth)
            float('nan'): If the prior period value is zero to avoid division by zero

        Example:
            # Create growth node
            revenue = FinancialStatementItemNode("revenue", {
                "2021": 1000.0,
                "2022": 1200.0
            })
            growth = YoYGrowthNode("revenue_growth", revenue, "2021", "2022")
            
            # Calculate growth rate
            rate = growth.calculate()  # Returns 0.2 (20% growth)
            
            # Period parameter is ignored
            rate = growth.calculate("2022")  # Still returns 0.2
        """
        prior_value = self.input_node.calculate(self.prior_period)
        current_value = self.input_node.calculate(self.current_period)
        if prior_value == 0:
            return float('nan')
        return (current_value - prior_value) / prior_value

class MultiPeriodStatNode(Node):
    """
    A node that calculates statistical measures across multiple time periods.

    This node takes an input node and calculates statistical measures (like standard deviation,
    mean, etc.) across a list of time periods. The specific statistical function is configurable
    via the stat_func parameter, defaulting to standard deviation.

    The node is useful for analyzing the variability or central tendency of financial metrics
    across multiple periods, such as revenue volatility or average profit margins.

    Args:
        name (str): The name/identifier for this statistical node
        input_node (Node): The node whose values will be analyzed across periods
        periods (List[str]): List of time periods to include in the statistical calculation
        stat_func (callable, optional): Statistical function to apply. Defaults to statistics.stdev.
            Must accept a list of numbers and return a single number.

    Attributes:
        name (str): The node's name/identifier
        input_node (Node): The source node for values
        periods (List[str]): The time periods to analyze
        stat_func (callable): The statistical function to apply

    Returns:
        float: The calculated statistical measure
        float('nan'): If fewer than 2 periods are provided

    Example:
        # Create node to calculate revenue volatility
        revenue = FinancialStatementItemNode("revenue", {
            "2020": 1000.0,
            "2021": 1200.0,
            "2022": 1100.0
        })
        volatility = MultiPeriodStatNode(
            "revenue_volatility",
            revenue,
            ["2020", "2021", "2022"]
        )
        
        # Calculate standard deviation
        std_dev = volatility.calculate()  # Returns standard deviation of revenue
    """
    def __init__(self, name: str, input_node: Node, periods: List[str], stat_func=statistics.stdev):
        self.name = name
        self.input_node = input_node
        self.periods = periods
        self.stat_func = stat_func

    def calculate(self, period: str = None) -> float:
        """
        Calculate the statistical measure across the configured time periods.

        This method retrieves values from the input node for each configured period and applies
        the statistical function to analyze those values. The period parameter is ignored since
        this node operates across multiple periods rather than a single period.

        Args:
            period (str, optional): Ignored. This node operates across the periods configured at initialization.

        Returns:
            float: The calculated statistical measure (e.g. standard deviation) across periods
            float('nan'): If fewer than 2 periods are provided (insufficient for statistical calculation)

        Example:
            # Create revenue volatility node
            revenue = FinancialStatementItemNode("revenue", {
                "2020": 1000.0,
                "2021": 1200.0,
                "2022": 1100.0
            })
            volatility = MultiPeriodStatNode(
                "revenue_volatility", 
                revenue,
                ["2020", "2021", "2022"]
            )

            # Calculate standard deviation
            std_dev = volatility.calculate()  # Returns ~100.0
        """
        values = [self.input_node.calculate(p) for p in self.periods]
        if len(values) < 2:
            return float('nan')
        return self.stat_func(values)


===== fin_statement_model/nodes.py =====
from abc import ABC, abstractmethod
from typing import Dict, List
from .metrics import METRIC_DEFINITIONS
import ast
import operator

class Node(ABC):
    name: str

    @abstractmethod
    def calculate(self, period: str) -> float:
        pass

    def clear_cache(self):
        # Default: no cache
        pass

class FinancialStatementItemNode(Node):
    """
    Represents a financial statement item with values for multiple periods.

    This node type stores raw financial statement data like revenue, expenses, assets, etc.
    Each node contains a mapping of time periods to their corresponding numerical values.

    Attributes:
        name (str): The identifier for this financial statement item (e.g. "revenue", "expenses")
        values (Dict[str, float]): Dictionary mapping time periods to values (e.g. {"2022": 1000.0})

    Example:
        # Create revenue node with historical values
        revenue = FinancialStatementItemNode("revenue", {
            "2022": 1000.0,
            "2021": 900.0,
            "2020": 800.0
        })

        # Calculate revenue for 2022
        revenue_2022 = revenue.calculate("2022")  # Returns 1000.0
    """
    def __init__(self, name: str, values: Dict[str, float]):
        self.name = name
        self.values = values

    def calculate(self, period: str) -> float:
        return self.values.get(period, 0.0)

class CalculationNode(Node):
    """
    Base class for calculation nodes that perform arithmetic operations on input nodes.

    This abstract class defines the interface and common functionality for nodes that
    perform calculations between other nodes in the financial statement graph.
    Specific calculation types (addition, subtraction, etc.) inherit from this class
    and implement their own calculation logic.

    Attributes:
        name (str): The identifier for this calculation node (e.g. "gross_profit")
        inputs (List[Node]): List of input nodes used in the calculation

    Example:
        # Create an addition calculation node
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        other_income = FinancialStatementItemNode("other_income", {"2022": 100.0})
        total_income = AdditionCalculationNode("total_income", [revenue, other_income])

        # Calculate total income for 2022
        total_2022 = total_income.calculate("2022")  # Returns 1100.0
    """
    def __init__(self, name: str, inputs: List[Node]):
        self.name = name
        self.inputs = inputs
        self.input_names = []  # Will be set by FinancialStatementGraph.add_calculation

    @abstractmethod
    def calculate(self, period: str) -> float:
        pass

class AdditionCalculationNode(CalculationNode):
    """
    A calculation node that adds together values from multiple input nodes.

    This node performs addition of values from all input nodes for a given time period.
    It inherits from CalculationNode and implements the calculate() method to sum values.

    Example:
        # Create nodes with historical values
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        other_income = FinancialStatementItemNode("other_income", {"2022": 100.0})
        
        # Create addition node to sum revenue and other income
        total_income = AdditionCalculationNode("total_income", [revenue, other_income])
        
        # Calculate total income for 2022
        total_2022 = total_income.calculate("2022")  # Returns 1100.0
    """
    def calculate(self, period: str) -> float:
        return sum(i.calculate(period) for i in self.inputs)

class SubtractionCalculationNode(CalculationNode):
    """
    A calculation node that subtracts subsequent input values from the first input.

    This node performs subtraction between input nodes for a given time period.
    It takes the first input node's value and subtracts all subsequent input node values from it.
    It inherits from CalculationNode and implements the calculate() method for subtraction.

    Example:
        # Create nodes with historical values
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        expenses = FinancialStatementItemNode("expenses", {"2022": 600.0})
        
        # Create subtraction node to calculate profit
        profit = SubtractionCalculationNode("profit", [revenue, expenses])
        
        # Calculate profit for 2022
        profit_2022 = profit.calculate("2022")  # Returns 400.0
    """
    def calculate(self, period: str) -> float:
        result = self.inputs[0].calculate(period)
        for inp in self.inputs[1:]:
            result -= inp.calculate(period)
        return result

class MultiplicationCalculationNode(CalculationNode):
    """
    A calculation node that multiplies values from multiple input nodes.

    This node performs multiplication of values from all input nodes for a given time period.
    It inherits from CalculationNode and implements the calculate() method to multiply values.

    Example:
        # Create nodes with historical values
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        margin = FinancialStatementItemNode("margin", {"2022": 0.4})
        
        # Create multiplication node to calculate profit
        profit = MultiplicationCalculationNode("profit", [revenue, margin])
        
        # Calculate profit for 2022
        profit_2022 = profit.calculate("2022")  # Returns 400.0
    """
    def calculate(self, period: str) -> float:
        result = 1
        for inp in self.inputs:
            result *= inp.calculate(period)
        return result

class DivisionCalculationNode(CalculationNode):
    """
    A calculation node that divides values from input nodes sequentially.

    This node performs division between input nodes for a given time period.
    It takes the first input node's value and divides it by each subsequent input node value in sequence.
    It inherits from CalculationNode and implements the calculate() method for division.
    
    The node will raise a ZeroDivisionError if any divisor (input after the first) equals zero.

    Example:
        # Create nodes with historical values
        net_income = FinancialStatementItemNode("net_income", {"2022": 400.0})
        revenue = FinancialStatementItemNode("revenue", {"2022": 1000.0})
        
        # Create division node to calculate profit margin
        margin = DivisionCalculationNode("profit_margin", [net_income, revenue])
        
        # Calculate margin for 2022
        margin_2022 = margin.calculate("2022")  # Returns 0.4 (40%)

    Raises:
        ZeroDivisionError: If any divisor (input after the first) equals zero
    """
    def calculate(self, period: str) -> float:
        result = self.inputs[0].calculate(period)
        for inp in self.inputs[1:]:
            divisor = inp.calculate(period)
            if divisor == 0:
                raise ZeroDivisionError("Division by zero in division node.")
            result /= divisor
        return result

class MetricCalculationNode(Node):
    """
    A node that calculates a metric defined in METRIC_DEFINITIONS.

    This node represents a financial metric calculation that is defined in the METRIC_DEFINITIONS dictionary.
    It creates an appropriate calculation node (Addition, Subtraction, Multiplication, or Division) based on
    the metric definition and handles retrieving the required input nodes from the graph.

    The node acts as a wrapper around the underlying calculation node, delegating the actual calculation
    while handling the metric-specific setup and validation.

    Args:
        name (str): The name/identifier for this metric node
        metric_name (str): The name of the metric as defined in METRIC_DEFINITIONS
        graph: The financial statement graph containing the input nodes

    Attributes:
        name (str): The node's name/identifier
        metric_name (str): The name of the metric being calculated
        graph: Reference to the containing graph
        definition (dict): The metric's definition from METRIC_DEFINITIONS
        calc_node (CalculationNode): The underlying calculation node that performs the actual computation

    Raises:
        ValueError: If the metric_name is not found in METRIC_DEFINITIONS
        ValueError: If any required input nodes are not found in the graph
        ValueError: If the calculation type in the metric definition is invalid

    Example:
        # Create metric node for net profit margin
        npm_node = MetricCalculationNode("npm", "net_profit_margin", graph)
        
        # Calculate net profit margin for 2022
        npm_2022 = npm_node.calculate("2022")
    """
    def __init__(self, name: str, metric_name: str, graph):
        self.name = name
        self.metric_name = metric_name
        self.graph = graph
        self.definition = METRIC_DEFINITIONS[metric_name]

        # Create dictionary of input nodes
        input_nodes = {}
        for inp in self.definition["inputs"]:
            node = self.graph.get_node(inp)
            if node is None:
                raise ValueError(f"Input node '{inp}' for metric '{metric_name}' not found.")
            input_nodes[inp] = node

        self.calc_node = FormulaCalculationNode(
            name + "_calc",
            input_nodes,
            self.definition["formula"]
        )

    def calculate(self, period: str) -> float:
        return self.calc_node.calculate(period)

class TwoPeriodAverageNode(Node):
    """
    A node that calculates the average of a given metric's values over the current and previous period.

    This node takes an input node and calculates the average value between the current period and
    the immediately preceding period based on the graph's defined period ordering. The node requires
    that the graph has an ordered list of periods to determine the previous period.

    Args:
        name (str): The name/identifier for this average calculation node
        input_node (Node): The node whose values will be averaged
        graph: The financial statement graph containing the period definitions

    Attributes:
        name (str): The node's name/identifier
        input_node (Node): Reference to the input node being averaged
        graph: Reference to the containing graph

    Raises:
        ValueError: If the graph does not have defined periods
        ValueError: If the requested period is not found in the graph's periods
        ValueError: If there is no previous period available (e.g. first period)

    Example:
        # Create average total assets node
        total_assets = FinancialStatementItemNode("total_assets", {
            "2021": 1000.0,
            "2022": 1200.0
        })
        graph.periods = ["2021", "2022"]
        avg_assets = TwoPeriodAverageNode("avg_total_assets", total_assets, graph)
        
        # Calculate average for 2022
        avg_2022 = avg_assets.calculate("2022")  # Returns 1100.0
    """
    def __init__(self, name: str, input_node: Node, graph):
        self.name = name
        self.input_node = input_node
        self.graph = graph

    def calculate(self, period: str) -> float:
        """
        Calculate the average value between the current period and previous period.

        This method retrieves values from the input node for both the specified period and
        the immediately preceding period based on the graph's period ordering. It then
        calculates the arithmetic mean of these two values.

        Args:
            period (str): The current period for which to calculate the average (e.g. "2022")

        Returns:
            float: The arithmetic mean of the current and previous period values

        Raises:
            ValueError: If the graph does not have defined periods
            ValueError: If the requested period is not found in the graph's periods
            ValueError: If there is no previous period available (e.g. first period)

        Example:
            # Create average total assets node
            total_assets = FinancialStatementItemNode("total_assets", {
                "2021": 1000.0,
                "2022": 1200.0
            })
            graph.periods = ["2021", "2022"]
            avg_assets = TwoPeriodAverageNode("avg_total_assets", total_assets, graph)
            
            # Calculate average for 2022
            avg_2022 = avg_assets.calculate("2022")  # Returns 1100.0
            
            # Will raise ValueError since 2021 has no previous period
            avg_2021 = avg_assets.calculate("2021")  # Raises ValueError
        """
        # Ensure graph.periods is available and sorted
        if not hasattr(self.graph, 'periods') or not self.graph.periods:
            raise ValueError("Graph does not have a defined list of periods.")

        periods_list = self.graph.periods
        if period not in periods_list:
            raise ValueError(f"Period '{period}' not found in graph.periods.")

        idx = periods_list.index(period)
        if idx == 0:
            # If there's no previous period, we can't calculate an average
            # Decide how to handle this. Perhaps return just current value or raise an error.
            raise ValueError(f"No previous period available before '{period}' to calculate average.")

        previous_period = periods_list[idx - 1]

        current_value = self.input_node.calculate(period)
        previous_value = self.input_node.calculate(previous_period)

        return (current_value + previous_value) / 2.0

class FormulaCalculationNode(Node):
    """
    A node that calculates values based on a mathematical formula string.
    
    Attributes:
        name (str): The identifier for this calculation node
        inputs (Dict[str, Node]): Dictionary mapping input names to their nodes
        formula (str): The formula string to evaluate (e.g. "revenue - cost_of_goods_sold")
        _ast: The parsed abstract syntax tree of the formula
    """
    
    # Supported operators
    OPERATORS = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        ast.USub: operator.neg,
    }
    
    def __init__(self, name: str, inputs: Dict[str, Node], formula: str):
        self.name = name
        self.inputs = inputs
        self.formula = formula
        self._ast = ast.parse(formula, mode='eval').body
        
    def calculate(self, period: str) -> float:
        return self._evaluate(self._ast, period)
    
    def _evaluate(self, node, period: str) -> float:
        """Recursively evaluates the AST of the formula."""
        
        # Handle numbers
        if isinstance(node, ast.Num):
            return float(node.n)
            
        # Handle variables (input nodes)
        if isinstance(node, ast.Name):
            if node.id not in self.inputs:
                raise ValueError(f"Unknown variable '{node.id}' in formula")
            return self.inputs[node.id].calculate(period)
            
        # Handle binary operations
        if isinstance(node, ast.BinOp):
            left = self._evaluate(node.left, period)
            right = self._evaluate(node.right, period)
            op = type(node.op)
            if op not in self.OPERATORS:
                raise ValueError(f"Unsupported operator {op.__name__}")
            return self.OPERATORS[op](left, right)
            
        # Handle unary operations (like negative numbers)
        if isinstance(node, ast.UnaryOp):
            operand = self._evaluate(node.operand, period)
            op = type(node.op)
            if op not in self.OPERATORS:
                raise ValueError(f"Unsupported unary operator {op.__name__}")
            return self.OPERATORS[op](operand)
            
        raise ValueError(f"Unsupported syntax in formula: {ast.dump(node)}")

