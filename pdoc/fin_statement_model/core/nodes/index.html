<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.core.nodes API documentation</title>
<meta name="description" content="Provide core node implementations for the financial statement model …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.core.nodes</code></h1>
</header>
<section id="section-intro">
<p>Provide core node implementations for the financial statement model.</p>
<p>This package exports the <code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code> base class and specialized node types for building
and evaluating financial statement graphs:</p>
<p>Data Nodes:
- FinancialStatementItemNode: Store raw financial data for specific periods.</p>
<p>Calculation Nodes:
- CalculationNode: Delegate value computation to a calculation object.
- FormulaCalculationNode: Evaluate expression-based formulas.
- CustomCalculationNode: Compute values using custom Python functions.</p>
<p>Statistical Nodes:
- YoYGrowthNode: Compute year-over-year percentage growth.
- MultiPeriodStatNode: Compute statistical measures (mean, stdev) over multiple periods.
- TwoPeriodAverageNode: Compute the average between two periods.</p>
<p>Forecast Nodes:
- ForecastNode: Base class for forecasting future values.
- FixedGrowthForecastNode: Apply a constant growth rate.
- CurveGrowthForecastNode: Apply period-specific growth rates.
- StatisticalGrowthForecastNode: Draw growth from a distribution.
- CustomGrowthForecastNode: Compute growth via a custom function.
- AverageValueForecastNode: Project the historical average forward.
- AverageHistoricalGrowthForecastNode: Apply average historical growth rate.</p>
<p>Also provides <code>standard_node_registry</code> and <code><a title="fin_statement_model.core.nodes.is_calculation_node" href="#fin_statement_model.core.nodes.is_calculation_node">is_calculation_node()</a></code> helper.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import (
...     FinancialStatementItemNode,
...     FormulaCalculationNode,
...     is_calculation_node,
... )
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 1000, &quot;2023&quot;: 1200})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2022&quot;: 400, &quot;2023&quot;: 500})
&gt;&gt;&gt; gp = FormulaCalculationNode(&quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;)
&gt;&gt;&gt; gp.calculate(&quot;2023&quot;)
700
&gt;&gt;&gt; is_calculation_node(gp)
True
&gt;&gt;&gt; is_calculation_node(revenue)
False
</code></pre>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.core.nodes.base" href="base.html">fin_statement_model.core.nodes.base</a></code></dt>
<dd>
<div class="desc"><p>Define the abstract base class for all nodes in the graph …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes.calculation_nodes" href="calculation_nodes.html">fin_statement_model.core.nodes.calculation_nodes</a></code></dt>
<dd>
<div class="desc"><p>Provide node implementations for performing calculations in the financial statement model …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes.forecast_nodes" href="forecast_nodes.html">fin_statement_model.core.nodes.forecast_nodes</a></code></dt>
<dd>
<div class="desc"><p>Provide forecast nodes to project future values from historical data …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes.item_node" href="item_node.html">fin_statement_model.core.nodes.item_node</a></code></dt>
<dd>
<div class="desc"><p>Define a node representing a basic financial statement item …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes.standard_nodes_defn" href="standard_nodes_defn/index.html">fin_statement_model.core.nodes.standard_nodes_defn</a></code></dt>
<dd>
<div class="desc"><p>Standard Node Definitions Package …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes.standard_registry" href="standard_registry.html">fin_statement_model.core.nodes.standard_registry</a></code></dt>
<dd>
<div class="desc"><p>Registry for standard node names and metadata …</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.core.nodes.stats_nodes" href="stats_nodes.html">fin_statement_model.core.nodes.stats_nodes</a></code></dt>
<dd>
<div class="desc"><p>Provide statistical node implementations for time-series analyses …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.core.nodes.is_calculation_node"><code class="name flex">
<span>def <span class="ident">is_calculation_node</span></span>(<span>node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_calculation_node(node: Node) -&gt; bool:
    &#34;&#34;&#34;Determine if a node performs a calculated value.

    A node is considered a calculation node if it computes values rather than
    storing raw data. Calculation node types include:
    - CalculationNode
    - FormulaCalculationNode
    - CustomCalculationNode
    - ForecastNode and its subclasses
    - YoYGrowthNode
    - MultiPeriodStatNode
    - TwoPeriodAverageNode

    Args:
        node (Node): Node instance to check.

    Returns:
        bool: True if `node` performs a calculation; False otherwise.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import is_calculation_node, FinancialStatementItemNode, CalculationNode
        &gt;&gt;&gt; data_node = FinancialStatementItemNode(&#34;rev&#34;, {&#34;2023&#34;: 100})
        &gt;&gt;&gt; is_calculation_node(data_node)
        False
        &gt;&gt;&gt; class DummyCalc:
        ...     def calculate(self, inputs, period):
        ...         return 1.0
        &gt;&gt;&gt; calc_node = CalculationNode(&#34;sum&#34;, inputs=[data_node], calculation=DummyCalc())
        &gt;&gt;&gt; is_calculation_node(calc_node)
        True
    &#34;&#34;&#34;
    return isinstance(
        node,
        CalculationNode
        | ForecastNode
        | CustomCalculationNode
        | YoYGrowthNode
        | MultiPeriodStatNode
        | TwoPeriodAverageNode,
    )</code></pre>
</details>
<div class="desc"><p>Determine if a node performs a calculated value.</p>
<p>A node is considered a calculation node if it computes values rather than
storing raw data. Calculation node types include:
- CalculationNode
- FormulaCalculationNode
- CustomCalculationNode
- ForecastNode and its subclasses
- YoYGrowthNode
- MultiPeriodStatNode
- TwoPeriodAverageNode</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node instance to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>node</code> performs a calculation; False otherwise.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import is_calculation_node, FinancialStatementItemNode, CalculationNode
&gt;&gt;&gt; data_node = FinancialStatementItemNode(&quot;rev&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; is_calculation_node(data_node)
False
&gt;&gt;&gt; class DummyCalc:
...     def calculate(self, inputs, period):
...         return 1.0
&gt;&gt;&gt; calc_node = CalculationNode(&quot;sum&quot;, inputs=[data_node], calculation=DummyCalc())
&gt;&gt;&gt; is_calculation_node(calc_node)
True
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">AverageHistoricalGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;average_growth&#34;)
class AverageHistoricalGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that applies the average historical growth rate to all future periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; AverageHistoricalGrowthForecastNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve the base node.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, AverageHistoricalGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100, &#34;2023&#34;: 110})
        &gt;&gt;&gt; forecast = AverageHistoricalGrowthForecastNode(revenue, &#34;2023&#34;, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = AverageHistoricalGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2025&#34;), 2)
        121.0
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
    ):
        &#34;&#34;&#34;Create an AverageHistoricalGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.avg_growth_rate = self._calculate_average_growth_rate()
        logger.debug(&#34;Created AverageHistoricalGrowthForecastNode with growth rate: %s&#34;, self.avg_growth_rate)

    def _calculate_average_growth_rate(self) -&gt; float:
        &#34;&#34;&#34;Calculate the average growth rate from historical values.

        Returns:
            float: The average growth rate or 0.0 if insufficient data.
        &#34;&#34;&#34;
        # Get historical periods up to base_period, sorted
        historical_periods = sorted([p for p in self.values if p &lt;= self.base_period])

        if len(historical_periods) &lt; MIN_HISTORICAL_PERIODS:
            logger.warning(&#34;Insufficient historical data for %s, using 0.0 as growth rate&#34;, self.name)
            return 0.0

        # Calculate growth rates between consecutive periods
        growth_rates = []
        for i in range(1, len(historical_periods)):
            prev_period = historical_periods[i - 1]
            curr_period = historical_periods[i]
            prev_value = self.values.get(prev_period, 0.0)
            curr_value = self.values.get(curr_period, 0.0)

            if prev_value != 0:
                growth_rate = (curr_value - prev_value) / prev_value
                growth_rates.append(growth_rate)

        if not growth_rates:
            logger.warning(&#34;No valid growth rates calculated for %s, using 0.0&#34;, self.name)
            return 0.0

        # Compute average growth rate and ensure float type
        return float(sum(growth_rates)) / len(growth_rates)

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        return self.avg_growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;historical_growth&#34;,
            &#34;avg_growth_rate&#34;: self.avg_growth_rate,
        })
        return base_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;AverageHistoricalGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create an AverageHistoricalGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new AverageHistoricalGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize AverageHistoricalGrowthForecastNode&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in AverageHistoricalGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(&#34;Missing &#39;base_node_name&#39; field in AverageHistoricalGrowthForecastNode data&#34;)

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])

        if not base_period:
            raise ValueError(&#34;Missing &#39;base_period&#39; field in AverageHistoricalGrowthForecastNode data&#34;)

        node = cls(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node that applies the average historical growth rate to all future periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; AverageHistoricalGrowthForecastNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, AverageHistoricalGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100, &quot;2023&quot;: 110})
&gt;&gt;&gt; forecast = AverageHistoricalGrowthForecastNode(revenue, &quot;2023&quot;, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = AverageHistoricalGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2025&quot;), 2)
121.0
</code></pre>
<p>Create an AverageHistoricalGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode">AverageHistoricalGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an AverageHistoricalGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new AverageHistoricalGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;historical_growth&#34;,
        &#34;avg_growth_rate&#34;: self.avg_growth_rate,
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.AverageValueForecastNode"><code class="flex name class">
<span>class <span class="ident">AverageValueForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;average&#34;)
class AverageValueForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that projects the historical average forward.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; AverageValueForecastNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve the base node.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, AverageValueForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100, &#34;2023&#34;: 110})
        &gt;&gt;&gt; forecast = AverageValueForecastNode(revenue, &#34;2023&#34;, [&#34;2024&#34;, &#34;2025&#34;])
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = AverageValueForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; forecast2.calculate(&#34;2024&#34;)
        105.0
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
    ):
        &#34;&#34;&#34;Create an AverageValueForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.average_value = self._calculate_average_value()
        logger.debug(&#34;Created AverageValueForecastNode with average value: %s&#34;, self.average_value)

    def _calculate_average_value(self) -&gt; float:
        &#34;&#34;&#34;Calculate the average historical value up to the base period.

        Returns:
            float: The average of historical values or 0.0 if none.
        &#34;&#34;&#34;
        values = [value for period, value in self.values.items() if period &lt;= self.base_period]
        if not values:
            logger.warning(&#34;No historical values found for %s, using 0.0 as average&#34;, self.name)
            return 0.0
        # Compute average and ensure float type
        return float(sum(values)) / len(values)

    def _calculate_value(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the value for a specific period using the computed average value.&#34;&#34;&#34;
        # For historical periods, return the actual value
        if period &lt;= self.base_period:
            # Return historical value, ensuring float type
            return float(self.values.get(period, 0.0))

        # For forecast periods, return the constant average value
        if period not in self.forecast_periods:
            raise ValueError(f&#34;Period &#39;{period}&#39; not in forecast periods for {self.name}&#34;)

        return self.average_value

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        &#34;&#34;&#34;Not used for average value forecasts.&#34;&#34;&#34;
        _ = (period, prev_period, prev_value)  # Parameters intentionally unused
        return 0.0

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;average&#34;,
            &#34;average_value&#34;: self.average_value,
        })
        return base_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;AverageValueForecastNode&#34;:
        &#34;&#34;&#34;Create an AverageValueForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new AverageValueForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize AverageValueForecastNode&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in AverageValueForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(&#34;Missing &#39;base_node_name&#39; field in AverageValueForecastNode data&#34;)

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])

        if not base_period:
            raise ValueError(&#34;Missing &#39;base_period&#39; field in AverageValueForecastNode data&#34;)

        node = cls(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node that projects the historical average forward.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; AverageValueForecastNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, AverageValueForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100, &quot;2023&quot;: 110})
&gt;&gt;&gt; forecast = AverageValueForecastNode(revenue, &quot;2023&quot;, [&quot;2024&quot;, &quot;2025&quot;])
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = AverageValueForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; forecast2.calculate(&quot;2024&quot;)
105.0
</code></pre>
<p>Create an AverageValueForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.AverageValueForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode">AverageValueForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an AverageValueForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new AverageValueForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.AverageValueForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;average&#34;,
        &#34;average_value&#34;: self.average_value,
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.CalculationNode"><code class="flex name class">
<span>class <span class="ident">CalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="../calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>,<br>**kwargs: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;calculation&#34;)
class CalculationNode(Node):
    &#34;&#34;&#34;Delegate calculation logic to a calculation object.

    Use a calculation object to encapsulate the algorithm for computing node values.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        name (str): Identifier for this node.
        inputs (List[Node]): A list of input nodes required by the calculation.
        calculation (Any): An object possessing a `calculate(inputs: List[Node], period: str) -&gt; float` method.
        _values (Dict[str, float]): Internal cache for calculated results.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; d = sum_node.to_dict()
        &gt;&gt;&gt; sum_node2 = CalculationNode.from_dict(d, {&#34;a&#34;: node_a, &#34;b&#34;: node_b})
        &gt;&gt;&gt; sum_node2.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;

    def __init__(self, name: str, inputs: list[Node], calculation: Calculation, **kwargs: Any):
        &#34;&#34;&#34;Initialize the CalculationNode.

        Args:
            name (str): The unique identifier for this node.
            inputs (List[Node]): List of input nodes needed by the calculation.
            calculation (Any): The calculation object implementing the calculation.
                Must have a `calculate` method.
            **kwargs: Additional attributes to store on the node (e.g., metric_name, metric_description).

        Raises:
            TypeError: If `inputs` is not a list of Nodes, or if `calculation`
                does not have a callable `calculate` method.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(inputs, list) or not all(isinstance(n, Node) for n in inputs):
            raise TypeError(&#34;CalculationNode inputs must be a list of Node instances.&#34;)
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
            raise TypeError(&#34;Calculation object must have a callable &#39;calculate&#39; method.&#34;)

        self.inputs = inputs
        self.calculation = calculation
        self._values: dict[str, float] = {}  # Cache for calculated values

        # Store any additional attributes passed via kwargs
        for key, value in kwargs.items():
            setattr(self, key, value)

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Raises:
            CalculationError: If calculation fails or returns a non-numeric value.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
            30.0
        &#34;&#34;&#34;
        if period in self._values:
            return self._values[period]

        try:
            # Delegate to the calculation object&#39;s calculate method
            result = self.calculation.calculate(self.inputs, period)
            if not isinstance(result, int | float):
                raise TypeError(
                    f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
                )
            # Cache and return the result
            self._values[period] = float(result)
            return self._values[period]
        except Exception as e:
            # Wrap potential errors from the calculation
            raise CalculationError(
                message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=period,
                details={
                    &#34;calculation&#34;: type(self.calculation).__name__,
                    &#34;error&#34;: str(e),
                },
            ) from e

    def set_calculation(self, calculation: Calculation) -&gt; None:
        &#34;&#34;&#34;Change the calculation object for the node.

        Args:
            calculation (Any): The new calculation object. Must have a callable
                `calculate` method.

        Raises:
            TypeError: If the new calculation is invalid.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
        &#34;&#34;&#34;
        if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
            raise TypeError(&#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;)
        self.calculation = calculation
        self.clear_cache()  # Clear cache as logic has changed

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the internal cache of calculated values.

        Returns:
            None

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.clear_cache()
        &#34;&#34;&#34;
        self._values.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Return the names of input nodes used by the calculation.

        Returns:
            A list of input node names.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; class SumCalculation:
            ...     def calculate(self, inputs, period):
            ...         return sum(node.calculate(period) for node in inputs)
            &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
            &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
            &gt;&gt;&gt; sum_node.get_dependencies()
            [&#39;a&#39;, &#39;b&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s type, name, inputs, and calculation info.

        Note:
            This method requires access to NodeFactory&#39;s calculation registry
            to properly serialize the calculation type. Some calculation types
            with non-serializable parameters may include warnings.

        Example:
            &gt;&gt;&gt; # See CalculationNode usage in main module docstring
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        node_dict: dict[str, Any] = {
            &#34;type&#34;: &#34;calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
        }

        # Add calculation type information
        calc_class_name = type(self.calculation).__name__
        node_dict[&#34;calculation_type_class&#34;] = calc_class_name

        # Find the calculation type key from NodeFactory registry
        inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
        type_key = inv_map.get(calc_class_name)
        if type_key:
            node_dict[&#34;calculation_type&#34;] = type_key

            # Extract calculation-specific arguments
            calculation_args = {}

            # Handle specific calculation types
            if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
                calculation_args[&#34;weights&#34;] = self.calculation.weights
            elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
                calculation_args[&#34;formula&#34;] = self.calculation.formula
                if hasattr(self.calculation, &#34;input_variable_names&#34;):
                    node_dict[&#34;formula_variable_names&#34;] = self.calculation.input_variable_names
            elif type_key == &#34;custom_formula&#34;:
                node_dict[&#34;serialization_warning&#34;] = (
                    &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                    &#34;Manual reconstruction required.&#34;
                )

            if calculation_args:
                node_dict[&#34;calculation_args&#34;] = calculation_args

        # Add any additional attributes (like metric info)
        if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
            node_dict[&#34;metric_name&#34;] = self.metric_name
        if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
            node_dict[&#34;metric_description&#34;] = self.metric_description

        return node_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CalculationNode&#34;:
        &#34;&#34;&#34;Create a CalculationNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CalculationNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.

        Example:
            &gt;&gt;&gt; # See CalculationNode usage in main module docstring
        &#34;&#34;&#34;
        # Import here to avoid circular imports
        from fin_statement_model.core.node_factory import NodeFactory

        if data.get(&#34;type&#34;) != &#34;calculation&#34;:
            raise ValueError(f&#34;Invalid type for CalculationNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CalculationNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize CalculationNode&#34;)

        input_names = data.get(&#34;inputs&#34;, [])
        if not isinstance(input_names, list):
            raise TypeError(&#34;&#39;inputs&#39; field must be a list&#34;)

        # Resolve input nodes from context
        input_nodes = []
        for input_name in input_names:
            if input_name not in context:
                raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
            input_nodes.append(context[input_name])

        calculation_type = data.get(&#34;calculation_type&#34;)
        if not calculation_type:
            raise ValueError(&#34;Missing &#39;calculation_type&#39; field in CalculationNode data&#34;)

        # Get calculation arguments
        calculation_args = data.get(&#34;calculation_args&#34;, {})

        # Handle formula variable names for formula calculations
        formula_variable_names = data.get(&#34;formula_variable_names&#34;)

        # Extract metric information
        metric_name = data.get(&#34;metric_name&#34;)
        metric_description = data.get(&#34;metric_description&#34;)

        # Create the node using NodeFactory
        return cast(
            &#34;CalculationNode&#34;,
            NodeFactory.create_calculation_node(
                name=name,
                inputs=input_nodes,
                calculation_type=calculation_type,
                formula_variable_names=formula_variable_names,
                metric_name=metric_name,
                metric_description=metric_description,
                **calculation_args,
            ),
        )</code></pre>
</details>
<div class="desc"><p>Delegate calculation logic to a calculation object.</p>
<p>Use a calculation object to encapsulate the algorithm for computing node values.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CalculationNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>]</code></dt>
<dd>A list of input nodes required by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>An object possessing a <code>calculate(inputs: List[Node], period: str) -&gt; float</code> method.</dd>
<dt><strong><code>_values</code></strong> :&ensp;<code>Dict[str, float]</code></dt>
<dd>Internal cache for calculated results.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; d = sum_node.to_dict()
&gt;&gt;&gt; sum_node2 = CalculationNode.from_dict(d, {&quot;a&quot;: node_a, &quot;b&quot;: node_b})
&gt;&gt;&gt; sum_node2.calculate(&quot;2023&quot;)
30.0
</code></pre>
<p>Initialize the CalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique identifier for this node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>]</code></dt>
<dd>List of input nodes needed by the calculation.</dd>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The calculation object implementing the calculation.
Must have a <code>calculate</code> method.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional attributes to store on the node (e.g., metric_name, metric_description).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>inputs</code> is not a list of Nodes, or if <code>calculation</code>
does not have a callable <code>calculate</code> method.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode">FormulaCalculationNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a CalculationNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CalculationNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CalculationNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Check the cache; on a miss, delegate to `calculation.calculate` and cache the result.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Raises:
        CalculationError: If calculation fails or returns a non-numeric value.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.calculate(&#34;2023&#34;)
        30.0
    &#34;&#34;&#34;
    if period in self._values:
        return self._values[period]

    try:
        # Delegate to the calculation object&#39;s calculate method
        result = self.calculation.calculate(self.inputs, period)
        if not isinstance(result, int | float):
            raise TypeError(
                f&#34;Calculation for node &#39;{self.name}&#39; did not return a numeric value (got {type(self.calculation).__name__}).&#34;
            )
        # Cache and return the result
        self._values[period] = float(result)
        return self._values[period]
    except Exception as e:
        # Wrap potential errors from the calculation
        raise CalculationError(
            message=f&#34;Error during calculation for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=period,
            details={
                &#34;calculation&#34;: type(self.calculation).__name__,
                &#34;error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Check the cache; on a miss, delegate to <code>calculation.calculate</code> and cache the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If calculation fails or returns a non-numeric value.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.calculate(&quot;2023&quot;)
30.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CalculationNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the internal cache of calculated values.

    Returns:
        None

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.clear_cache()
    &#34;&#34;&#34;
    self._values.clear()</code></pre>
</details>
<div class="desc"><p>Clear the internal cache of calculated values.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.clear_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Return the names of input nodes used by the calculation.

    Returns:
        A list of input node names.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.get_dependencies()
        [&#39;a&#39;, &#39;b&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs]</code></pre>
</details>
<div class="desc"><p>Return the names of input nodes used by the calculation.</p>
<h2 id="returns">Returns</h2>
<p>A list of input node names.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.get_dependencies()
['a', 'b']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CalculationNode.set_calculation"><code class="name flex">
<span>def <span class="ident">set_calculation</span></span>(<span>self,<br>calculation: <a title="fin_statement_model.core.calculations.calculation.Calculation" href="../calculations/calculation.html#fin_statement_model.core.calculations.calculation.Calculation">Calculation</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calculation(self, calculation: Calculation) -&gt; None:
    &#34;&#34;&#34;Change the calculation object for the node.

    Args:
        calculation (Any): The new calculation object. Must have a callable
            `calculate` method.

    Raises:
        TypeError: If the new calculation is invalid.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; class SumCalculation:
        ...     def calculate(self, inputs, period):
        ...         return sum(node.calculate(period) for node in inputs)
        &gt;&gt;&gt; node_a = FinancialStatementItemNode(&#34;a&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; node_b = FinancialStatementItemNode(&#34;b&#34;, {&#34;2023&#34;: 20})
        &gt;&gt;&gt; sum_node = CalculationNode(&#34;sum_ab&#34;, inputs=[node_a, node_b], calculation=SumCalculation())
        &gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
    &#34;&#34;&#34;
    if not hasattr(calculation, &#34;calculate&#34;) or not callable(calculation.calculate):
        raise TypeError(&#34;New calculation object must have a callable &#39;calculate&#39; method.&#34;)
    self.calculation = calculation
    self.clear_cache()  # Clear cache as logic has changed</code></pre>
</details>
<div class="desc"><p>Change the calculation object for the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calculation</code></strong> :&ensp;<code>Any</code></dt>
<dd>The new calculation object. Must have a callable
<code>calculate</code> method.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the new calculation is invalid.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; class SumCalculation:
...     def calculate(self, inputs, period):
...         return sum(node.calculate(period) for node in inputs)
&gt;&gt;&gt; node_a = FinancialStatementItemNode(&quot;a&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; node_b = FinancialStatementItemNode(&quot;b&quot;, {&quot;2023&quot;: 20})
&gt;&gt;&gt; sum_node = CalculationNode(&quot;sum_ab&quot;, inputs=[node_a, node_b], calculation=SumCalculation())
&gt;&gt;&gt; sum_node.set_calculation(SumCalculation())
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s type, name, inputs, and calculation info.

    Note:
        This method requires access to NodeFactory&#39;s calculation registry
        to properly serialize the calculation type. Some calculation types
        with non-serializable parameters may include warnings.

    Example:
        &gt;&gt;&gt; # See CalculationNode usage in main module docstring
    &#34;&#34;&#34;
    # Import here to avoid circular imports
    from fin_statement_model.core.node_factory import NodeFactory

    node_dict: dict[str, Any] = {
        &#34;type&#34;: &#34;calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
    }

    # Add calculation type information
    calc_class_name = type(self.calculation).__name__
    node_dict[&#34;calculation_type_class&#34;] = calc_class_name

    # Find the calculation type key from NodeFactory registry
    inv_map = {v: k for k, v in NodeFactory._calculation_methods.items()}
    type_key = inv_map.get(calc_class_name)
    if type_key:
        node_dict[&#34;calculation_type&#34;] = type_key

        # Extract calculation-specific arguments
        calculation_args = {}

        # Handle specific calculation types
        if type_key == &#34;weighted_average&#34; and hasattr(self.calculation, &#34;weights&#34;):
            calculation_args[&#34;weights&#34;] = self.calculation.weights
        elif type_key == &#34;formula&#34; and hasattr(self.calculation, &#34;formula&#34;):
            calculation_args[&#34;formula&#34;] = self.calculation.formula
            if hasattr(self.calculation, &#34;input_variable_names&#34;):
                node_dict[&#34;formula_variable_names&#34;] = self.calculation.input_variable_names
        elif type_key == &#34;custom_formula&#34;:
            node_dict[&#34;serialization_warning&#34;] = (
                &#34;CustomFormulaCalculation uses a Python function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            )

        if calculation_args:
            node_dict[&#34;calculation_args&#34;] = calculation_args

    # Add any additional attributes (like metric info)
    if hasattr(self, &#34;metric_name&#34;) and self.metric_name:
        node_dict[&#34;metric_name&#34;] = self.metric_name
    if hasattr(self, &#34;metric_description&#34;) and self.metric_description:
        node_dict[&#34;metric_description&#34;] = self.metric_description

    return node_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's type, name, inputs, and calculation info.</p>
<h2 id="note">Note</h2>
<p>This method requires access to NodeFactory's calculation registry
to properly serialize the calculation type. Some calculation types
with non-serializable parameters may include warnings.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.CurveGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">CurveGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_rates: list[float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;curve&#34;)
class CurveGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node with period-specific growth rates.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CurveGrowthForecastNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve the base node.

    Attributes:
        growth_rates (list[float]): Growth rate for each corresponding forecast period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CurveGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; rates = [0.10, 0.08]
        &gt;&gt;&gt; forecast = CurveGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;, &#34;2024&#34;], rates)
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = CurveGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2024&#34;), 2)
        118.8
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_rates: list[float],
    ):
        &#34;&#34;&#34;Create a CurveGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_rates (list[float]): Growth rate for each forecast period; length must equal *forecast_periods*.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        if len(growth_rates) != len(forecast_periods):
            raise ValueError(&#34;Number of growth rates must match forecast periods.&#34;)
        self.growth_rates = [float(rate) for rate in growth_rates]  # Ensure all are floats
        logger.debug(&#34;Created CurveGrowthForecastNode with growth rates: %s&#34;, self.growth_rates)
        logger.debug(&#34;  Base period: %s&#34;, base_period)
        logger.debug(&#34;  Forecast periods: %s&#34;, forecast_periods)
        logger.debug(&#34;  Base value: %s&#34;, input_node.calculate(base_period))

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        &#34;&#34;&#34;Get the growth factor for a specific period.&#34;&#34;&#34;
        idx = self.forecast_periods.index(period)
        growth_rate = self.growth_rates[idx]
        logger.debug(
            &#34;CurveGrowthForecastNode: Using growth rate %s for period %s&#34;,
            growth_rate,
            period,
        )
        logger.debug(&#34;  Previous period: %s&#34;, prev_period)
        logger.debug(&#34;  Previous value: %s&#34;, prev_value)
        return growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;curve&#34;,
            &#34;growth_params&#34;: self.growth_rates.copy(),
        })
        return base_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CurveGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a CurveGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new CurveGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize CurveGrowthForecastNode&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in CurveGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(&#34;Missing &#39;base_node_name&#39; field in CurveGrowthForecastNode data&#34;)

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])
        growth_params = data.get(&#34;growth_params&#34;, [])

        if not base_period:
            raise ValueError(&#34;Missing &#39;base_period&#39; field in CurveGrowthForecastNode data&#34;)

        if not isinstance(growth_params, list):
            raise TypeError(&#34;&#39;growth_params&#39; must be a list for CurveGrowthForecastNode&#34;)

        node = cls(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            growth_rates=growth_params,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node with period-specific growth rates.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CurveGrowthForecastNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_rates</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Growth rate for each corresponding forecast period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CurveGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; rates = [0.10, 0.08]
&gt;&gt;&gt; forecast = CurveGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;, &quot;2024&quot;], rates)
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = CurveGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2024&quot;), 2)
118.8
</code></pre>
<p>Create a CurveGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_rates</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>Growth rate for each forecast period; length must equal <em>forecast_periods</em>.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CurveGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a CurveGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new CurveGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CurveGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;curve&#34;,
        &#34;growth_params&#34;: self.growth_rates.copy(),
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.CustomCalculationNode"><code class="flex name class">
<span>class <span class="ident">CustomCalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: list[<a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>formula_func: Callable[..., float],<br>description: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;custom_calculation&#34;)
class CustomCalculationNode(Node):
    &#34;&#34;&#34;Calculate values using a custom Python function.

    Use a provided callable to compute node values from input nodes.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomCalculationNode`:
            Not supported; always raises NotImplementedError because the function cannot be serialized.

    Attributes:
        inputs (list[Node]): Nodes supplying inputs to the function.
        formula_func (Callable[..., float]): Function to compute values.
        description (Optional[str]): Description of the calculation.
        _values (dict[str, float]): Cache of computed results.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        15.0
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        inputs: list[Node],
        formula_func: Callable[..., float],
        description: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Create a CustomCalculationNode.

        Args:
            name (str): Unique identifier for the node.
            inputs (list[Node]): Nodes providing input values.
            formula_func (Callable[..., float]): Function to compute values.
            description (str, optional): Description of the calculation.

        Raises:
            TypeError: If `inputs` is not a list of Node or `formula_func` is not callable.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            15.0
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(inputs, list) or not all(isinstance(n, Node) for n in inputs):
            raise TypeError(&#34;CustomCalculationNode inputs must be a list of Node instances&#34;)
        if not callable(formula_func):
            raise TypeError(&#34;CustomCalculationNode formula_func must be a callable function&#34;)

        self.inputs = inputs
        self.formula_func = formula_func
        self.description = description
        self._values: dict[str, float] = {}  # Cache for calculated results

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Compute the node&#39;s value for a given period.

        Evaluate `formula_func` with inputs from `inputs` and cache the result.

        Args:
            period (str): The time period for which to perform the calculation.

        Returns:
            float: Computed value for the period.

        Raises:
            CalculationError: On errors retrieving inputs or computing the function.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            15.0
        &#34;&#34;&#34;
        if period in self._values:
            return self._values[period]

        try:
            # Get input values
            input_values = []
            for node in self.inputs:
                value = node.calculate(period)
                if not isinstance(value, int | float):
                    raise TypeError(
                        f&#34;Input node &#39;{node.name}&#39; did not return a numeric value for period &#39;{period}&#39;. Got {type(value).__name__}.&#34;
                    )
                input_values.append(value)

            # Calculate the value using the provided function
            result = self.formula_func(*input_values)
            if not isinstance(result, int | float):
                raise TypeError(f&#34;Formula did not return a numeric value. Got {type(result).__name__}.&#34;)

            # Cache and return the result
            self._values[period] = float(result)
            return self._values[period]
        except Exception as e:
            # Wrap potential errors from the function
            raise CalculationError(
                message=f&#34;Error during custom calculation for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=period,
                details={&#34;function&#34;: self.formula_func.__name__, &#34;error&#34;: str(e)},
            ) from e

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached calculation results for this node.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.clear_cache()
        &#34;&#34;&#34;
        self._values.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes used by the function.

        Returns:
            list[str]: Names of input nodes.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; def add(a, b):
            ...     return a + b
            &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
            &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
            &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
            &gt;&gt;&gt; node.get_dependencies()
            [&#39;A&#39;, &#39;B&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized node data with non-serializable function warning.

        Example:
            &gt;&gt;&gt; # See CustomCalculationNode usage in main module docstring
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;custom_calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
            &#34;description&#34;: self.description,
            &#34;serialization_warning&#34;: (
                &#34;CustomCalculationNode uses a Python function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        }

    # ------------------------------------------------------------------
    # Serialization helpers (unsupported)
    # ------------------------------------------------------------------

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CustomCalculationNode&#34;:  # pragma: no cover
        &#34;&#34;&#34;Deserialization is not supported for CustomCalculationNode.

        The underlying Python callable cannot be serialized/restored automatically.
        Callers must supply their own factory logic instead.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;CustomCalculationNode deserialization is not supported. &#34;
            &#34;The underlying Python callable cannot be reconstructed automatically.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Calculate values using a custom Python function.</p>
<p>Use a provided callable to compute node values from input nodes.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomCalculationNode</code>:
Not supported; always raises NotImplementedError because the function cannot be serialized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>inputs</code></strong> :&ensp;<code>list[<a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>]</code></dt>
<dd>Nodes supplying inputs to the function.</dd>
<dt><strong><code>formula_func</code></strong> :&ensp;<code>Callable[&hellip;, float]</code></dt>
<dd>Function to compute values.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Description of the calculation.</dd>
<dt><strong><code>_values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Cache of computed results.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
15.0
</code></pre>
<p>Create a CustomCalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>list[<a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>]</code></dt>
<dd>Nodes providing input values.</dd>
<dt><strong><code>formula_func</code></strong> :&ensp;<code>Callable[&hellip;, float]</code></dt>
<dd>Function to compute values.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Description of the calculation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>inputs</code> is not a list of Node or <code>formula_func</code> is not callable.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
15.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CustomCalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode">CustomCalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization is not supported for CustomCalculationNode.</p>
<p>The underlying Python callable cannot be serialized/restored automatically.
Callers must supply their own factory logic instead.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CustomCalculationNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Compute the node&#39;s value for a given period.

    Evaluate `formula_func` with inputs from `inputs` and cache the result.

    Args:
        period (str): The time period for which to perform the calculation.

    Returns:
        float: Computed value for the period.

    Raises:
        CalculationError: On errors retrieving inputs or computing the function.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        15.0
    &#34;&#34;&#34;
    if period in self._values:
        return self._values[period]

    try:
        # Get input values
        input_values = []
        for node in self.inputs:
            value = node.calculate(period)
            if not isinstance(value, int | float):
                raise TypeError(
                    f&#34;Input node &#39;{node.name}&#39; did not return a numeric value for period &#39;{period}&#39;. Got {type(value).__name__}.&#34;
                )
            input_values.append(value)

        # Calculate the value using the provided function
        result = self.formula_func(*input_values)
        if not isinstance(result, int | float):
            raise TypeError(f&#34;Formula did not return a numeric value. Got {type(result).__name__}.&#34;)

        # Cache and return the result
        self._values[period] = float(result)
        return self._values[period]
    except Exception as e:
        # Wrap potential errors from the function
        raise CalculationError(
            message=f&#34;Error during custom calculation for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=period,
            details={&#34;function&#34;: self.formula_func.__name__, &#34;error&#34;: str(e)},
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the node's value for a given period.</p>
<p>Evaluate <code>formula_func</code> with inputs from <code>inputs</code> and cache the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>The time period for which to perform the calculation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Computed value for the period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>On errors retrieving inputs or computing the function.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
15.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CustomCalculationNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached calculation results for this node.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.clear_cache()
    &#34;&#34;&#34;
    self._values.clear()</code></pre>
</details>
<div class="desc"><p>Clear cached calculation results for this node.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.clear_cache()
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CustomCalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes used by the function.

    Returns:
        list[str]: Names of input nodes.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; def add(a, b):
        ...     return a + b
        &gt;&gt;&gt; a = FinancialStatementItemNode(&#34;A&#34;, {&#34;2023&#34;: 10})
        &gt;&gt;&gt; b = FinancialStatementItemNode(&#34;B&#34;, {&#34;2023&#34;: 5})
        &gt;&gt;&gt; node = CustomCalculationNode(&#34;add_node&#34;, inputs=[a, b], formula_func=add)
        &gt;&gt;&gt; node.get_dependencies()
        [&#39;A&#39;, &#39;B&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs]</code></pre>
</details>
<div class="desc"><p>Get names of nodes used by the function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Names of input nodes.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; def add(a, b):
...     return a + b
&gt;&gt;&gt; a = FinancialStatementItemNode(&quot;A&quot;, {&quot;2023&quot;: 10})
&gt;&gt;&gt; b = FinancialStatementItemNode(&quot;B&quot;, {&quot;2023&quot;: 5})
&gt;&gt;&gt; node = CustomCalculationNode(&quot;add_node&quot;, inputs=[a, b], formula_func=add)
&gt;&gt;&gt; node.get_dependencies()
['A', 'B']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.CustomCalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized node data with non-serializable function warning.

    Example:
        &gt;&gt;&gt; # See CustomCalculationNode usage in main module docstring
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;custom_calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
        &#34;description&#34;: self.description,
        &#34;serialization_warning&#34;: (
            &#34;CustomCalculationNode uses a Python function which cannot be serialized. &#34;
            &#34;Manual reconstruction required.&#34;
        ),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized node data with non-serializable function warning.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See CustomCalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.CustomGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">CustomGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_function: Callable[[str, str, float], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;custom&#34;)
class CustomGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that computes growth via a user-supplied function.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomGrowthForecastNode`:
            Not supported; always raises NotImplementedError because the function cannot be serialized.

    Attributes:
        growth_function (Callable[[str, str, float], float]): Function returning growth factor.

    Example:
        &gt;&gt;&gt; # Not supported:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CustomGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; node = CustomGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;], lambda p, pp, v: 0.05)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; CustomGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})  # doctest: +SKIP
        Traceback (most recent call last):
        ...
        NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized because the growth_function cannot be serialized. Manual reconstruction required.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_function: Callable[[str, str, float], float],
    ):
        &#34;&#34;&#34;Create a CustomGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_function (Callable[[str, str, float], float]): Function returning growth factor.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.growth_function = growth_function

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        return self.growth_function(period, prev_period, prev_value)

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.

        Note:
            The growth_function cannot be serialized, so a warning is included.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;custom&#34;,
            &#34;serialization_warning&#34;: (
                &#34;CustomGrowthForecastNode uses a growth function which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        })
        return base_dict

    # Deserialization intentionally unsupported - growth_function is not serializable.

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;CustomGrowthForecastNode&#34;:  # pragma: no cover
        &#34;&#34;&#34;Deserialization is not supported for CustomGrowthForecastNode.&#34;&#34;&#34;
        raise NotImplementedError(
            &#34;CustomGrowthForecastNode cannot be deserialized; growth_function is not serializable.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Forecast node that computes growth via a user-supplied function.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; CustomGrowthForecastNode</code>:
Not supported; always raises NotImplementedError because the function cannot be serialized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_function</code></strong> :&ensp;<code>Callable[[str, str, float], float]</code></dt>
<dd>Function returning growth factor.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Not supported:
&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, CustomGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; node = CustomGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;], lambda p, pp, v: 0.05)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; CustomGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})  # doctest: +SKIP
Traceback (most recent call last):
...
NotImplementedError: CustomGrowthForecastNode cannot be fully deserialized because the growth_function cannot be serialized. Manual reconstruction required.
</code></pre>
<p>Create a CustomGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_function</code></strong> :&ensp;<code>Callable[[str, str, float], float]</code></dt>
<dd>Function returning growth factor.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CustomGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization is not supported for CustomGrowthForecastNode.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.CustomGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.

    Note:
        The growth_function cannot be serialized, so a warning is included.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;custom&#34;,
        &#34;serialization_warning&#34;: (
            &#34;CustomGrowthForecastNode uses a growth function which cannot be serialized. &#34;
            &#34;Manual reconstruction required.&#34;
        ),
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p>
<h2 id="note">Note</h2>
<p>The growth_function cannot be serialized, so a warning is included.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.FinancialStatementItemNode"><code class="flex name class">
<span>class <span class="ident">FinancialStatementItemNode</span></span>
<span>(</span><span>name: str, values: dict[str, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;financial_statement_item&#34;)
class FinancialStatementItemNode(Node):
    &#34;&#34;&#34;Store raw financial statement values for specific periods.

    Represents a leaf node containing actual reported financial data
    (e.g., revenue, COGS) across time periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode`:
            Classmethod to deserialize a node from a dictionary. `context` is ignored for data nodes.

    Attributes:
        name (str): Unique identifier for the financial item.
        values (dict[str, float]): Mapping from period identifiers to their values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 1000.0, &#34;2023&#34;: 1200.0}
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; node2 = FinancialStatementItemNode.from_dict(d)
        &gt;&gt;&gt; node2.calculate(&#34;2023&#34;)
        1200.0
    &#34;&#34;&#34;

    values: dict[str, float]

    def __init__(self, name: str, values: dict[str, float]):
        &#34;&#34;&#34;Create a FinancialStatementItemNode.

        Args:
            name (str): Unique identifier for the financial item.
            values (dict[str, float]): Initial mapping of periods to values.

        Raises:
            ValueError: If `name` is empty, contains invalid characters, or has leading/trailing whitespace.

        Example:
            &gt;&gt;&gt; FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            FinancialStatementItemNode object
        &#34;&#34;&#34;
        super().__init__(name)
        self.values = values

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Get the value for a specific period.

        Args:
            period (str): Period identifier to retrieve.

        Returns:
            float: Stored value for `period`, or 0.0 if not present.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            1000.0
            &gt;&gt;&gt; node.calculate(&#34;2022&#34;)
            0.0
        &#34;&#34;&#34;
        return self.values.get(period, 0.0)

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set the value for a specific period.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
            &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
            1500.0
        &#34;&#34;&#34;
        self.values[period] = value

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

        Example:
            &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
            &gt;&gt;&gt; data = node.to_dict()
            &gt;&gt;&gt; data[&#34;type&#34;]
            &#39;financial_statement_item&#39;
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;financial_statement_item&#34;,
            &#34;name&#34;: self.name,
            &#34;values&#34;: self.values.copy(),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, &#34;Node&#34;] | None = None,
    ) -&gt; &#34;FinancialStatementItemNode&#34;:
        &#34;&#34;&#34;Deserialize a FinancialStatementItemNode from a dictionary.

        Args:
            data (dict[str, Any]): Serialized node data; must contain keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.
            context (dict[str, Node] | None): Optional context for deserialization (ignored).

        Returns:
            FinancialStatementItemNode: Reconstructed node.

        Raises:
            ValueError: If &#39;type&#39; is not &#39;financial_statement_item&#39; or &#39;name&#39; is missing.
            TypeError: If &#39;values&#39; is not a dict.

        Example:
            &gt;&gt;&gt; d = {&#34;type&#34;: &#34;financial_statement_item&#34;, &#34;name&#34;: &#34;Revenue&#34;, &#34;values&#34;: {&#34;2023&#34;: 1000.0}}
            &gt;&gt;&gt; node = FinancialStatementItemNode.from_dict(d)
            &gt;&gt;&gt; node.name
            &#39;Revenue&#39;
            &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
            1000.0
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;financial_statement_item&#34;:
            raise ValueError(f&#34;Invalid type for FinancialStatementItemNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FinancialStatementItemNode data&#34;)

        values = data.get(&#34;values&#34;, {})
        if not isinstance(values, dict):
            raise TypeError(&#34;&#39;values&#39; field must be a dict[str, float]&#34;)

        # Context is intentionally ignored for simple data nodes but referenced to avoid
        # unused-argument linter violations and to aid future debugging.
        if context is not None:
            logger.debug(
                &#34;FinancialStatementItemNode.from_dict received a non-null &#39;context&#39; argument, which is currently ignored. Node: %s&#34;,
                name,
            )

        return cls(name, values)</code></pre>
</details>
<div class="desc"><p>Store raw financial statement values for specific periods.</p>
<p>Represents a leaf node containing actual reported financial data
(e.g., revenue, COGS) across time periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FinancialStatementItemNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is ignored for data nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Mapping from period identifiers to their values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 1000.0, &quot;2023&quot;: 1200.0}
&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; node2 = FinancialStatementItemNode.from_dict(d)
&gt;&gt;&gt; node2.calculate(&quot;2023&quot;)
1200.0
</code></pre>
<p>Create a FinancialStatementItemNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the financial item.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Initial mapping of periods to values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, contains invalid characters, or has leading/trailing whitespace.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
FinancialStatementItemNode object
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FinancialStatementItemNode.values"><code class="name">var <span class="ident">values</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FinancialStatementItemNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, '<a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>'] | None = None) ‑> <a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize a FinancialStatementItemNode from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data; must contain keys 'type', 'name', and 'values'.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Optional context for deserialization (ignored).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode" href="#fin_statement_model.core.nodes.FinancialStatementItemNode">FinancialStatementItemNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If 'type' is not 'financial_statement_item' or 'name' is missing.</dd>
<dt><code>TypeError</code></dt>
<dd>If 'values' is not a dict.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {&quot;type&quot;: &quot;financial_statement_item&quot;, &quot;name&quot;: &quot;Revenue&quot;, &quot;values&quot;: {&quot;2023&quot;: 1000.0}}
&gt;&gt;&gt; node = FinancialStatementItemNode.from_dict(d)
&gt;&gt;&gt; node.name
'Revenue'
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1000.0
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FinancialStatementItemNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Get the value for a specific period.

    Args:
        period (str): Period identifier to retrieve.

    Returns:
        float: Stored value for `period`, or 0.0 if not present.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; node.calculate(&#34;2023&#34;)
        1000.0
        &gt;&gt;&gt; node.calculate(&#34;2022&#34;)
        0.0
    &#34;&#34;&#34;
    return self.values.get(period, 0.0)</code></pre>
</details>
<div class="desc"><p>Get the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Stored value for <code>period</code>, or 0.0 if not present.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; node.calculate(&quot;2023&quot;)
1000.0
&gt;&gt;&gt; node.calculate(&quot;2022&quot;)
0.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.FinancialStatementItemNode.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set the value for a specific period.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; node.set_value(&#34;2024&#34;, 1500.0)
        &gt;&gt;&gt; node.calculate(&#34;2024&#34;)
        1500.0
    &#34;&#34;&#34;
    self.values[period] = value</code></pre>
</details>
<div class="desc"><p>Set the value for a specific period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; node.set_value(&quot;2024&quot;, 1500.0)
&gt;&gt;&gt; node.calculate(&quot;2024&quot;)
1500.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.FinancialStatementItemNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Dictionary with keys &#39;type&#39;, &#39;name&#39;, and &#39;values&#39;.

    Example:
        &gt;&gt;&gt; node = FinancialStatementItemNode(&#34;Revenue&#34;, {&#34;2023&#34;: 1000.0})
        &gt;&gt;&gt; data = node.to_dict()
        &gt;&gt;&gt; data[&#34;type&#34;]
        &#39;financial_statement_item&#39;
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;financial_statement_item&#34;,
        &#34;name&#34;: self.name,
        &#34;values&#34;: self.values.copy(),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary with keys 'type', 'name', and 'values'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; node = FinancialStatementItemNode(&quot;Revenue&quot;, {&quot;2023&quot;: 1000.0})
&gt;&gt;&gt; data = node.to_dict()
&gt;&gt;&gt; data[&quot;type&quot;]
'financial_statement_item'
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_dependencies" href="base.html#fin_statement_model.core.nodes.base.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.FixedGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">FixedGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>growth_rate: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;simple&#34;)
class FixedGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node that applies a single growth rate to every future period.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FixedGrowthForecastNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve the base node.

    Attributes:
        growth_rate (float): Constant growth factor expressed as a decimal (``0.05`` → 5 %).

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, FixedGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;, &#34;2024&#34;], 0.05)
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2024&#34;), 2)
        110.25
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        growth_rate: float | None = None,
    ):
        &#34;&#34;&#34;Create a FixedGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            growth_rate (float | None): Constant growth rate (``0.05`` → 5 %).
                If ``None``, the default configured in ``cfg(&#39;forecasting.default_growth_rate&#39;)`` is used.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)

        # Use config default if not provided (import inside to avoid circular import)
        if growth_rate is None:
            from fin_statement_model.config.access import cfg

            growth_rate = cfg(&#34;forecasting.default_growth_rate&#34;)

        self.growth_rate = float(growth_rate)  # Ensure it&#39;s a float
        logger.debug(&#34;Created FixedGrowthForecastNode with growth rate: %s&#34;, self.growth_rate)

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (prev_period, prev_value)  # Mark unused parameters to satisfy linters
        logger.debug(
            &#34;FixedGrowthForecastNode: Using growth rate %s for period %s&#34;,
            self.growth_rate,
            period,
        )
        return self.growth_rate

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;simple&#34;,
            &#34;growth_params&#34;: self.growth_rate,
        })
        return base_dict

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;FixedGrowthForecastNode&#34;:
        &#34;&#34;&#34;Create a FixedGrowthForecastNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new FixedGrowthForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
        &#34;&#34;&#34;
        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize FixedGrowthForecastNode&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FixedGrowthForecastNode data&#34;)

        base_node_name = data.get(&#34;base_node_name&#34;)
        if not base_node_name:
            raise ValueError(&#34;Missing &#39;base_node_name&#39; field in FixedGrowthForecastNode data&#34;)

        if base_node_name not in context:
            raise ValueError(f&#34;Base node &#39;{base_node_name}&#39; not found in context&#34;)

        base_node = context[base_node_name]
        base_period = data.get(&#34;base_period&#34;)
        forecast_periods = data.get(&#34;forecast_periods&#34;, [])
        growth_params = data.get(&#34;growth_params&#34;)

        if not base_period:
            raise ValueError(&#34;Missing &#39;base_period&#39; field in FixedGrowthForecastNode data&#34;)

        node = cls(
            input_node=base_node,
            base_period=base_period,
            forecast_periods=forecast_periods,
            growth_rate=growth_params,
        )

        # Set the correct name from the serialized data
        node.name = name
        return node</code></pre>
</details>
<div class="desc"><p>Forecast node that applies a single growth rate to every future period.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FixedGrowthForecastNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve the base node.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>growth_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Constant growth factor expressed as a decimal (<code>0.05</code> → 5 %).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, FixedGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;, &quot;2024&quot;], 0.05)
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2024&quot;), 2)
110.25
</code></pre>
<p>Create a FixedGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>growth_rate</code></strong> :&ensp;<code>float | None</code></dt>
<dd>Constant growth rate (<code>0.05</code> → 5 %).
If <code>None</code>, the default configured in <code>cfg('forecasting.default_growth_rate')</code> is used.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FixedGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a FixedGrowthForecastNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new FixedGrowthForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FixedGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;simple&#34;,
        &#34;growth_params&#34;: self.growth_rate,
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.ForecastNode"><code class="flex name class">
<span>class <span class="ident">ForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForecastNode(Node):
    &#34;&#34;&#34;Base class for projecting future values from historical data.

    ForecastNode uses a source node&#39;s historical data to generate projected values
    for specified future periods, caching results to avoid redundant computations.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; ForecastNode`:
            Classmethod to deserialize a node from a dictionary. Subclasses must override this method.

    Attributes:
        input_node (Node): Node providing historical data.
        base_period (str): Last historical period used as forecast base.
        forecast_periods (list[str]): Future periods to project.
        values (dict[str, float]): Historical and forecasted values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; from fin_statement_model.core.nodes.forecast_nodes import FixedGrowthForecastNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100, &#34;2023&#34;: 110})
        &gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &#34;2023&#34;, [&#34;2024&#34;, &#34;2025&#34;], 0.05)
        &gt;&gt;&gt; d = forecast.to_dict()
        &gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})
        &gt;&gt;&gt; round(forecast2.calculate(&#34;2025&#34;), 2)
        121.28
    &#34;&#34;&#34;

    _cache: dict[str, float]

    def __init__(self, input_node: Node, base_period: str, forecast_periods: list[str]):
        &#34;&#34;&#34;Initialize a ForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period as forecast base.
            forecast_periods (list[str]): Future periods to generate forecasts for.
        &#34;&#34;&#34;
        # Initialize with a default name based on input node, but allow it to be overridden
        super().__init__(input_node.name)
        self.input_node = input_node
        self.base_period = base_period
        self.forecast_periods = forecast_periods
        self._cache = {}

        # Copy historical values from input node
        if hasattr(input_node, &#34;values&#34;):
            self.values = input_node.values.copy()
        else:
            self.values = {}

    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Returns historical values for periods up to `base_period`; computes forecast for later periods.

        Args:
            period (str): Period identifier, historical or forecast.

        Returns:
            float: Value for the specified period.

        Raises:
            ValueError: If `period` is not a historical or forecast period.
        &#34;&#34;&#34;
        if period not in self._cache:
            self._cache[period] = self._calculate_value(period)
        return self._cache[period]

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached forecast values.

        Use to force recomputation of all periods when input data changes.
        &#34;&#34;&#34;
        self._cache.clear()

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes that this forecast depends on.

        Returns:
            list[str]: Single-element list of the input node&#39;s name.
        &#34;&#34;&#34;
        # For *self-forecast* nodes (the forecast overwrites its own base item and
        # therefore shares the same name), we must not expose a self-dependency.
        # This avoids artificial cycles in graph traversals.
        if self.input_node.name == self.name:
            return []
        return [self.input_node.name]

    def _calculate_value(self, period: str) -&gt; float:
        &#34;&#34;&#34;Compute the value for a given period without caching.

        Args:
            period (str): Period identifier to compute.

        Returns:
            float: Historical or forecasted value.

        Raises:
            ValueError: If `period` is not valid for this node.
        &#34;&#34;&#34;
        # For historical periods, return the actual value
        if period &lt;= self.base_period:
            # Return historical value, ensuring float type
            return float(self.values.get(period, 0.0))

        # For forecast periods, calculate using growth rate
        if period not in self.forecast_periods:
            raise ValueError(f&#34;Period &#39;{period}&#39; not in forecast periods for {self.name}&#34;)

        # Get the previous period&#39;s value
        prev_period = self._get_previous_period(period)
        prev_value = self.calculate(prev_period)

        # Get the growth rate for this period
        growth_factor = self._get_growth_factor_for_period(period, prev_period, prev_value)

        # Calculate the new value
        return prev_value * (1 + growth_factor)

    def _get_previous_period(self, current_period: str) -&gt; str:
        all_periods = sorted([self.base_period, *self.forecast_periods])
        idx = all_periods.index(current_period)
        return all_periods[idx - 1]

    @abstractmethod
    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        &#34;&#34;&#34;Return the growth factor for *period*.

        Subclasses must implement this to provide their specific growth logic.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Subclasses must implement _get_growth_factor_for_period.&#34;)

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation including base forecast parameters.

        Note:
            Subclasses should override to include specific forecast details.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;forecast&#34;,
            &#34;name&#34;: self.name,
            &#34;base_node_name&#34;: self.input_node.name,
            &#34;base_period&#34;: self.base_period,
            &#34;forecast_periods&#34;: self.forecast_periods.copy(),
            &#34;forecast_type&#34;: &#34;base&#34;,  # Override in subclasses
        }

    @classmethod
    @abstractmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;ForecastNode&#34;:
        &#34;&#34;&#34;Recreate a ForecastNode from serialized data.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new ForecastNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.
            NotImplementedError: This base method should be overridden by subclasses.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Subclasses must implement from_dict.&#34;)</code></pre>
</details>
<div class="desc"><p>Base class for projecting future values from historical data.</p>
<p>ForecastNode uses a source node's historical data to generate projected values
for specified future periods, caching results to avoid redundant computations.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; ForecastNode</code>:
Classmethod to deserialize a node from a dictionary. Subclasses must override this method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node providing historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period used as forecast base.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, float]</code></dt>
<dd>Historical and forecasted values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; from fin_statement_model.core.nodes.forecast_nodes import FixedGrowthForecastNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100, &quot;2023&quot;: 110})
&gt;&gt;&gt; forecast = FixedGrowthForecastNode(revenue, &quot;2023&quot;, [&quot;2024&quot;, &quot;2025&quot;], 0.05)
&gt;&gt;&gt; d = forecast.to_dict()
&gt;&gt;&gt; forecast2 = FixedGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})
&gt;&gt;&gt; round(forecast2.calculate(&quot;2025&quot;), 2)
121.28
</code></pre>
<p>Initialize a ForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period as forecast base.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to generate forecasts for.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageHistoricalGrowthForecastNode">AverageHistoricalGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.AverageValueForecastNode">AverageValueForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.ForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a ForecastNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new ForecastNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>This base method should be overridden by subclasses.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.ForecastNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Returns historical values for periods up to `base_period`; computes forecast for later periods.

    Args:
        period (str): Period identifier, historical or forecast.

    Returns:
        float: Value for the specified period.

    Raises:
        ValueError: If `period` is not a historical or forecast period.
    &#34;&#34;&#34;
    if period not in self._cache:
        self._cache[period] = self._calculate_value(period)
    return self._cache[period]</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Returns historical values for periods up to <code>base_period</code>; computes forecast for later periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier, historical or forecast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Value for the specified period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>period</code> is not a historical or forecast period.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.nodes.ForecastNode.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached forecast values.

    Use to force recomputation of all periods when input data changes.
    &#34;&#34;&#34;
    self._cache.clear()</code></pre>
</details>
<div class="desc"><p>Clear cached forecast values.</p>
<p>Use to force recomputation of all periods when input data changes.</p></div>
</dd>
<dt id="fin_statement_model.core.nodes.ForecastNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes that this forecast depends on.

    Returns:
        list[str]: Single-element list of the input node&#39;s name.
    &#34;&#34;&#34;
    # For *self-forecast* nodes (the forecast overwrites its own base item and
    # therefore shares the same name), we must not expose a self-dependency.
    # This avoids artificial cycles in graph traversals.
    if self.input_node.name == self.name:
        return []
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes that this forecast depends on.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Single-element list of the input node's name.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.nodes.ForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation including base forecast parameters.

    Note:
        Subclasses should override to include specific forecast details.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;forecast&#34;,
        &#34;name&#34;: self.name,
        &#34;base_node_name&#34;: self.input_node.name,
        &#34;base_period&#34;: self.base_period,
        &#34;forecast_periods&#34;: self.forecast_periods.copy(),
        &#34;forecast_type&#34;: &#34;base&#34;,  # Override in subclasses
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation including base forecast parameters.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Subclasses should override to include specific forecast details.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.FormulaCalculationNode"><code class="flex name class">
<span>class <span class="ident">FormulaCalculationNode</span></span>
<span>(</span><span>name: str,<br>inputs: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>],<br>formula: str,<br>metric_name: str | None = None,<br>metric_description: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;formula_calculation&#34;)
class FormulaCalculationNode(CalculationNode):
    &#34;&#34;&#34;Calculate values based on a formula string.

    Use a formula expression and mapped input nodes to evaluate a calculation.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FormulaCalculationNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        inputs_dict (dict[str, Node]): Mapping of variable names to input nodes.
        formula (str): Mathematical expression to evaluate.
        metric_name (Optional[str]): Metric identifier from the registry, if any.
        metric_description (Optional[str]): Description from the metric definition, if any.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
        &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
        &gt;&gt;&gt; formula_node = FormulaCalculationNode(
        ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
        ... )
        &gt;&gt;&gt; d = formula_node.to_dict()
        &gt;&gt;&gt; formula_node2 = FormulaCalculationNode.from_dict(d, {&#34;revenue&#34;: revenue, &#34;cogs&#34;: cogs})
        &gt;&gt;&gt; formula_node2.calculate(&#34;2023&#34;)
        40.0
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        inputs: dict[str, Node],
        formula: str,
        metric_name: str | None = None,
        metric_description: str | None = None,
    ):
        &#34;&#34;&#34;Create a FormulaCalculationNode.

        Args:
            name (str): Unique identifier for the node.
            inputs (dict[str, Node]): Mapping of variable names to input nodes.
            formula (str): Mathematical formula string to evaluate.
            metric_name (Optional[str]): Original metric key from registry.
            metric_description (Optional[str]): Description from the metric definition.

        Raises:
            ValueError: If `formula` syntax is invalid.
            TypeError: If any entry in `inputs` is not a Node.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
            &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
            &gt;&gt;&gt; formula_node = FormulaCalculationNode(
            ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
            ... )
            &gt;&gt;&gt; formula_node.calculate(&#34;2023&#34;)
            40.0
        &#34;&#34;&#34;
        if not isinstance(inputs, dict) or not all(isinstance(n, Node) for n in inputs.values()):
            raise TypeError(&#34;FormulaCalculationNode inputs must be a dict of Node instances.&#34;)

        # Store the formula and metric attributes
        self.formula = formula
        self.metric_name = metric_name
        self.metric_description = metric_description

        # Extract variable names and input nodes in consistent order
        input_variable_names = list(inputs.keys())
        input_nodes = list(inputs.values())

        # Create FormulaCalculation strategy
        formula_calculation = FormulaCalculation(formula, input_variable_names)

        # Initialize parent CalculationNode with the strategy
        super().__init__(name, input_nodes, formula_calculation)

        # Store the inputs dict for compatibility (separate from parent&#39;s inputs list)
        self.inputs_dict = inputs

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes used in the formula.

        Returns:
            list[str]: Names of input nodes.

        Example:
            &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
            &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
            &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
            &gt;&gt;&gt; formula_node = FormulaCalculationNode(
            ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
            ... )
            &gt;&gt;&gt; formula_node.get_dependencies()
            [&#39;revenue&#39;, &#39;cogs&#39;]
        &#34;&#34;&#34;
        return [node.name for node in self.inputs_dict.values()]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized node data.

        Example:
            &gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;formula_calculation&#34;,
            &#34;name&#34;: self.name,
            &#34;inputs&#34;: self.get_dependencies(),
            &#34;formula_variable_names&#34;: list(self.inputs_dict.keys()),
            &#34;formula&#34;: self.formula,
            &#34;calculation_type&#34;: &#34;formula&#34;,
            &#34;metric_name&#34;: self.metric_name,
            &#34;metric_description&#34;: self.metric_description,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;FormulaCalculationNode&#34;:
        &#34;&#34;&#34;Create a FormulaCalculationNode from a dictionary with node context.

        Args:
            data: Dictionary containing the node&#39;s serialized data.
            context: Dictionary of existing nodes to resolve dependencies.

        Returns:
            A new FormulaCalculationNode instance.

        Raises:
            ValueError: If the data is invalid or missing required fields.

        Example:
            &gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;formula_calculation&#34;:
            raise ValueError(f&#34;Invalid type for FormulaCalculationNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in FormulaCalculationNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize FormulaCalculationNode&#34;)

        formula = data.get(&#34;formula&#34;)
        if not formula:
            raise ValueError(&#34;Missing &#39;formula&#39; field in FormulaCalculationNode data&#34;)

        input_names = data.get(&#34;inputs&#34;, [])
        formula_variable_names = data.get(&#34;formula_variable_names&#34;, [])

        if len(input_names) != len(formula_variable_names):
            raise ValueError(&#34;Mismatch between inputs and formula_variable_names in FormulaCalculationNode data&#34;)

        # Resolve input nodes from context and create inputs dict
        inputs_dict = {}
        for var_name, input_name in zip(formula_variable_names, input_names, strict=False):
            if input_name not in context:
                raise ValueError(f&#34;Input node &#39;{input_name}&#39; not found in context&#34;)
            inputs_dict[var_name] = context[input_name]

        # Extract metric information
        metric_name = data.get(&#34;metric_name&#34;)
        metric_description = data.get(&#34;metric_description&#34;)

        return cls(
            name=name,
            inputs=inputs_dict,
            formula=formula,
            metric_name=metric_name,
            metric_description=metric_description,
        )</code></pre>
</details>
<div class="desc"><p>Calculate values based on a formula string.</p>
<p>Use a formula expression and mapped input nodes to evaluate a calculation.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; FormulaCalculationNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>inputs_dict</code></strong> :&ensp;<code>dict[str, <a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>]</code></dt>
<dd>Mapping of variable names to input nodes.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Mathematical expression to evaluate.</dd>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Metric identifier from the registry, if any.</dd>
<dt><strong><code>metric_description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Description from the metric definition, if any.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2023&quot;: 60})
&gt;&gt;&gt; formula_node = FormulaCalculationNode(
...     &quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;
... )
&gt;&gt;&gt; d = formula_node.to_dict()
&gt;&gt;&gt; formula_node2 = FormulaCalculationNode.from_dict(d, {&quot;revenue&quot;: revenue, &quot;cogs&quot;: cogs})
&gt;&gt;&gt; formula_node2.calculate(&quot;2023&quot;)
40.0
</code></pre>
<p>Create a FormulaCalculationNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node.</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>dict[str, <a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>]</code></dt>
<dd>Mapping of variable names to input nodes.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Mathematical formula string to evaluate.</dd>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Original metric key from registry.</dd>
<dt><strong><code>metric_description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Description from the metric definition.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>formula</code> syntax is invalid.</dd>
<dt><code>TypeError</code></dt>
<dd>If any entry in <code>inputs</code> is not a Node.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2023&quot;: 60})
&gt;&gt;&gt; formula_node = FormulaCalculationNode(
...     &quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;
... )
&gt;&gt;&gt; formula_node.calculate(&quot;2023&quot;)
40.0
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FormulaCalculationNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.FormulaCalculationNode">FormulaCalculationNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a FormulaCalculationNode from a dictionary with node context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary containing the node's serialized data.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Dictionary of existing nodes to resolve dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new FormulaCalculationNode instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the data is invalid or missing required fields.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.FormulaCalculationNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes used in the formula.

    Returns:
        list[str]: Names of input nodes.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2023&#34;: 100})
        &gt;&gt;&gt; cogs = FinancialStatementItemNode(&#34;cogs&#34;, {&#34;2023&#34;: 60})
        &gt;&gt;&gt; formula_node = FormulaCalculationNode(
        ...     &#34;gross_profit&#34;, inputs={&#34;rev&#34;: revenue, &#34;cost&#34;: cogs}, formula=&#34;rev - cost&#34;
        ... )
        &gt;&gt;&gt; formula_node.get_dependencies()
        [&#39;revenue&#39;, &#39;cogs&#39;]
    &#34;&#34;&#34;
    return [node.name for node in self.inputs_dict.values()]</code></pre>
</details>
<div class="desc"><p>Get names of nodes used in the formula.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Names of input nodes.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes.item_node import FinancialStatementItemNode
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2023&quot;: 100})
&gt;&gt;&gt; cogs = FinancialStatementItemNode(&quot;cogs&quot;, {&quot;2023&quot;: 60})
&gt;&gt;&gt; formula_node = FormulaCalculationNode(
...     &quot;gross_profit&quot;, inputs={&quot;rev&quot;: revenue, &quot;cost&quot;: cogs}, formula=&quot;rev - cost&quot;
... )
&gt;&gt;&gt; formula_node.get_dependencies()
['revenue', 'cogs']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.FormulaCalculationNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized node data.

    Example:
        &gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;formula_calculation&#34;,
        &#34;name&#34;: self.name,
        &#34;inputs&#34;: self.get_dependencies(),
        &#34;formula_variable_names&#34;: list(self.inputs_dict.keys()),
        &#34;formula&#34;: self.formula,
        &#34;calculation_type&#34;: &#34;formula&#34;,
        &#34;metric_name&#34;: self.metric_name,
        &#34;metric_description&#34;: self.metric_description,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # See FormulaCalculationNode usage in main module docstring
</code></pre></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.calculate" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.clear_cache" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.set_calculation" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode.set_calculation">set_calculation</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.MultiPeriodStatNode"><code class="flex name class">
<span>class <span class="ident">MultiPeriodStatNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>periods: list[str],<br>stat_func: Callable[..., typing.Any] = &lt;function stdev&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;multi_period_stat&#34;)
class MultiPeriodStatNode(Node):
    &#34;&#34;&#34;Compute a statistical measure over multiple periods.

    Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning if stat_func is custom).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes. Custom stat functions may require manual reconstruction.

    Attributes:
        input_node (Node): Node providing source values.
        periods (list[str]): Period identifiers to include.
        stat_func (StatFunc): Function to apply to collected values.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
        &gt;&gt;&gt; data = {&#34;Q1&#34;: 10, &#34;Q2&#34;: 12, &#34;Q3&#34;: 11, &#34;Q4&#34;: 13}
        &gt;&gt;&gt; sales = FinancialStatementItemNode(&#34;sales&#34;, data)
        &gt;&gt;&gt; import statistics
        &gt;&gt;&gt; avg = MultiPeriodStatNode(
        ...     &#34;avg_sales&#34;, input_node=sales, periods=[&#34;Q1&#34;, &#34;Q2&#34;, &#34;Q3&#34;, &#34;Q4&#34;], stat_func=statistics.mean
        ... )
        &gt;&gt;&gt; d = avg.to_dict()
        &gt;&gt;&gt; avg2 = MultiPeriodStatNode.from_dict(d, {&#34;sales&#34;: sales})
        &gt;&gt;&gt; avg2.calculate()
        11.5
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        input_node: Node,
        periods: list[str],
        stat_func: StatFunc = statistics.stdev,  # Default to standard deviation
    ):
        &#34;&#34;&#34;Create a MultiPeriodStatNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values.
            periods (list[str]): Period identifiers to analyze.
            stat_func (StatFunc): Function applied to collected values. Defaults to statistics.stdev.

        Raises:
            ValueError: If `periods` is empty or not a list.
            TypeError: If `input_node` is not a Node or `stat_func` is not callable.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;MultiPeriodStatNode input_node must be a Node instance.&#34;)
        if not isinstance(periods, list) or not periods:
            raise ValueError(&#34;MultiPeriodStatNode periods must be a non-empty list.&#34;)
        if not all(isinstance(p, str) for p in periods):
            raise TypeError(&#34;MultiPeriodStatNode periods must contain only strings.&#34;)
        if not callable(stat_func):
            raise TypeError(&#34;MultiPeriodStatNode stat_func must be a callable function.&#34;)

        self.input_node = input_node
        self.periods = periods
        self.stat_func = stat_func

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the statistical measure across specified periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

        Raises:
            CalculationError: If input retrieval fails or unexpected errors occur.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        values: list[Numeric] = []
        retrieval_errors = []
        try:
            for p in self.periods:
                try:
                    value = self.input_node.calculate(p)
                    if isinstance(value, int | float) and math.isfinite(value):
                        values.append(float(value))
                    else:
                        # Log non-numeric/non-finite values but continue if possible
                        logger.warning(
                            &#34;MultiPeriodStatNode &#39;%s&#39;: Input &#39;%s&#39; gave non-numeric/non-finite value (%s) for period &#39;%s&#39;. Skipping.&#34;,
                            self.name,
                            self.input_node.name,
                            value,
                            p,
                        )
                except Exception:
                    # Log error fetching data for a specific period but continue
                    logger.exception(
                        &#34;MultiPeriodStatNode &#39;%s&#39;: Error getting value for period &#39;%s&#39; from &#39;%s&#39;&#34;,
                        self.name,
                        p,
                        self.input_node.name,
                    )
                    retrieval_errors.append(p)

            # If no valid numeric values were collected
            if not values:
                logger.warning(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: No valid numeric data points found across periods %s. Returning NaN.&#34;,
                    self.name,
                    self.periods,
                )
                return float(&#34;nan&#34;)

            # Attempt the statistical calculation
            try:
                result = self.stat_func(values)
                # Ensure result is float, handle potential NaN from stat_func
                return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
            except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
                # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
                logger.warning(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: Stat function &#39;%s&#39; failed (%s). Values: %s. Returning NaN.&#34;,
                    self.name,
                    self.stat_func.__name__,
                    stat_err,
                    values,
                )
                return float(&#34;nan&#34;)

        except Exception as e:
            # Catch any other unexpected errors during the process
            raise CalculationError(
                message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=&#34;multi-period&#34;,  # Indicate calculation context
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;periods&#34;: self.periods,
                    &#34;stat_func&#34;: self.stat_func.__name__,
                    &#34;collected_values_count&#34;: len(values),
                    &#34;retrieval_errors_periods&#34;: retrieval_errors,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized data with function name and periods.

        Note:
            `stat_func` may not be fully serializable; manual reconstruction may be required.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;multi_period_stat&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;periods&#34;: self.periods.copy(),
            &#34;stat_func_name&#34;: self.stat_func.__name__,
            &#34;serialization_warning&#34;: (
                &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
                &#34;Manual reconstruction may be required for custom functions.&#34;
            ),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;MultiPeriodStatNode&#34;:
        &#34;&#34;&#34;Recreate a MultiPeriodStatNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            MultiPeriodStatNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;multi_period_stat&#34;:
            raise ValueError(f&#34;Invalid type for MultiPeriodStatNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in MultiPeriodStatNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in MultiPeriodStatNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize MultiPeriodStatNode&#34;)
        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        periods = data.get(&#34;periods&#34;, [])
        stat_func_name = data.get(&#34;stat_func_name&#34;, &#34;stdev&#34;)

        if not periods:
            raise ValueError(&#34;Missing or empty &#39;periods&#39; field in MultiPeriodStatNode data&#34;)

        # Map common statistical function names to their implementations
        stat_func_map: dict[str, StatFunc] = {
            &#34;mean&#34;: statistics.mean,
            &#34;stdev&#34;: statistics.stdev,
            &#34;median&#34;: statistics.median,
            &#34;variance&#34;: statistics.variance,
            &#34;pstdev&#34;: statistics.pstdev,
            &#34;pvariance&#34;: statistics.pvariance,
        }

        stat_func = stat_func_map.get(stat_func_name, statistics.stdev)
        if stat_func_name not in stat_func_map:
            logger.warning(
                &#34;Unknown stat_func_name &#39;%s&#39; for MultiPeriodStatNode &#39;%s&#39;. Using default statistics.stdev.&#34;,
                stat_func_name,
                name,
            )

        return cls(
            name=name,
            input_node=input_node,
            periods=periods,
            stat_func=stat_func,
        )</code></pre>
</details>
<div class="desc"><p>Compute a statistical measure over multiple periods.</p>
<p>Apply a statistical function (e.g., mean, stdev) to values from an input node across specified periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning if stat_func is custom).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; MultiPeriodStatNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes. Custom stat functions may require manual reconstruction.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to include.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function to apply to collected values.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, MultiPeriodStatNode
&gt;&gt;&gt; data = {&quot;Q1&quot;: 10, &quot;Q2&quot;: 12, &quot;Q3&quot;: 11, &quot;Q4&quot;: 13}
&gt;&gt;&gt; sales = FinancialStatementItemNode(&quot;sales&quot;, data)
&gt;&gt;&gt; import statistics
&gt;&gt;&gt; avg = MultiPeriodStatNode(
...     &quot;avg_sales&quot;, input_node=sales, periods=[&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot;], stat_func=statistics.mean
... )
&gt;&gt;&gt; d = avg.to_dict()
&gt;&gt;&gt; avg2 = MultiPeriodStatNode.from_dict(d, {&quot;sales&quot;: sales})
&gt;&gt;&gt; avg2.calculate()
11.5
</code></pre>
<p>Create a MultiPeriodStatNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Period identifiers to analyze.</dd>
<dt><strong><code>stat_func</code></strong> :&ensp;<code>StatFunc</code></dt>
<dd>Function applied to collected values. Defaults to statistics.stdev.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>periods</code> is empty or not a list.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or <code>stat_func</code> is not callable.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.MultiPeriodStatNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a MultiPeriodStatNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.nodes.MultiPeriodStatNode" href="#fin_statement_model.core.nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.MultiPeriodStatNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the statistical measure across specified periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: Result of `stat_func` on collected values, or NaN if insufficient valid data.

    Raises:
        CalculationError: If input retrieval fails or unexpected errors occur.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    values: list[Numeric] = []
    retrieval_errors = []
    try:
        for p in self.periods:
            try:
                value = self.input_node.calculate(p)
                if isinstance(value, int | float) and math.isfinite(value):
                    values.append(float(value))
                else:
                    # Log non-numeric/non-finite values but continue if possible
                    logger.warning(
                        &#34;MultiPeriodStatNode &#39;%s&#39;: Input &#39;%s&#39; gave non-numeric/non-finite value (%s) for period &#39;%s&#39;. Skipping.&#34;,
                        self.name,
                        self.input_node.name,
                        value,
                        p,
                    )
            except Exception:
                # Log error fetching data for a specific period but continue
                logger.exception(
                    &#34;MultiPeriodStatNode &#39;%s&#39;: Error getting value for period &#39;%s&#39; from &#39;%s&#39;&#34;,
                    self.name,
                    p,
                    self.input_node.name,
                )
                retrieval_errors.append(p)

        # If no valid numeric values were collected
        if not values:
            logger.warning(
                &#34;MultiPeriodStatNode &#39;%s&#39;: No valid numeric data points found across periods %s. Returning NaN.&#34;,
                self.name,
                self.periods,
            )
            return float(&#34;nan&#34;)

        # Attempt the statistical calculation
        try:
            result = self.stat_func(values)
            # Ensure result is float, handle potential NaN from stat_func
            return float(result) if math.isfinite(result) else float(&#34;nan&#34;)
        except (statistics.StatisticsError, ValueError, TypeError) as stat_err:
            # Handle errors specific to statistical functions (e.g., stdev needs &gt;= 2 points)
            logger.warning(
                &#34;MultiPeriodStatNode &#39;%s&#39;: Stat function &#39;%s&#39; failed (%s). Values: %s. Returning NaN.&#34;,
                self.name,
                self.stat_func.__name__,
                stat_err,
                values,
            )
            return float(&#34;nan&#34;)

    except Exception as e:
        # Catch any other unexpected errors during the process
        raise CalculationError(
            message=f&#34;Failed to calculate multi-period stat for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=&#34;multi-period&#34;,  # Indicate calculation context
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;periods&#34;: self.periods,
                &#34;stat_func&#34;: self.stat_func.__name__,
                &#34;collected_values_count&#34;: len(values),
                &#34;retrieval_errors_periods&#34;: retrieval_errors,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the statistical measure across specified periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Result of <code>stat_func</code> on collected values, or NaN if insufficient valid data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>If input retrieval fails or unexpected errors occur.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.nodes.MultiPeriodStatNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this statistical node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this statistical node depends on.</p></div>
</dd>
<dt id="fin_statement_model.core.nodes.MultiPeriodStatNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized data with function name and periods.

    Note:
        `stat_func` may not be fully serializable; manual reconstruction may be required.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;multi_period_stat&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;periods&#34;: self.periods.copy(),
        &#34;stat_func_name&#34;: self.stat_func.__name__,
        &#34;serialization_warning&#34;: (
            &#34;MultiPeriodStatNode uses a statistical function which may not be fully serializable. &#34;
            &#34;Manual reconstruction may be required for custom functions.&#34;
        ),
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized data with function name and periods.</dd>
</dl>
<h2 id="note">Note</h2>
<p><code>stat_func</code> may not be fully serializable; manual reconstruction may be required.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(ABC):
    &#34;&#34;&#34;Abstract base class for all nodes in the financial statement model.

    This class defines the required interface for all node types, including calculation,
    serialization, and dependency inspection. Subclasses must implement `calculate`, `to_dict`,
    and (for deserializable nodes) `from_dict` as a classmethod.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node`:
            Classmethod to deserialize a node from a dictionary. Nodes with dependencies
            (e.g., calculation, forecast, stat nodes) must use the `context` argument to resolve them.
            Data nodes may ignore `context`.

    Attributes:
        name (str): Unique identifier for the node instance.
        values (dict[str, Any]): Optional mapping of period to value (for data nodes).

    Example:
        &gt;&gt;&gt; class DummyNode(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     @classmethod
        ...     def from_dict(cls, data, context=None):
        ...         return cls(data[&#34;name&#34;])
        &gt;&gt;&gt; node = DummyNode(&#34;Revenue&#34;)
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; DummyNode.from_dict(d).name
        &#39;Revenue&#39;
    &#34;&#34;&#34;

    name: str
    values: dict[str, Any]

    def __init__(self, name: str):
        &#34;&#34;&#34;Initialize the Node instance with a unique name.

        Args:
            name (str): Unique identifier for the node. Must be a non-empty string.

        Raises:
            ValueError: If `name` is empty, not a string, or contains invalid characters.

        Example:
            &gt;&gt;&gt; Node(&#34;Revenue&#34;)  # doctest: +ELLIPSIS
            Traceback (most recent call last):
            ...
            TypeError: Can&#39;t instantiate abstract class Node...
        &#34;&#34;&#34;
        # Check if name is a non-empty string
        if not isinstance(name, str) or not name:
            raise ValueError(&#34;Node name must be a non-empty string.&#34;)
        # Check for invalid characters (including newline, tab)
        if &#34;\n&#34; in name or &#34;\t&#34; in name:
            raise ValueError(f&#34;Invalid node name: &#39;{name}&#39;. Contains invalid characters.&#34;)
        # Check for leading/trailing whitespace
        if name != name.strip():
            raise ValueError(f&#34;Invalid node name: &#39;{name}&#39;. Cannot have leading/trailing whitespace.&#34;)
        self.name = name

    @abstractmethod
    def calculate(self, period: str) -&gt; float:
        &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

        Subclasses must override this method to implement specific calculation logic.

        Args:
            period (str): Identifier for the time period.

        Returns:
            float: Calculated value for the period.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 2.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; Dummy(&#34;Test&#34;).calculate(&#34;2023&#34;)
            2.0
        &#34;&#34;&#34;

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear cached calculation results for this node.

        Subclasses with caching should override this method to clear their internal cache.

        Returns:
            None

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def clear_cache(self):
            ...         print(&#34;Cache cleared!&#34;)
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.clear_cache()
            Cache cleared!
        &#34;&#34;&#34;
        # Default: no cache to clear
        return None

    def has_attribute(self, attr_name: str) -&gt; bool:
        &#34;&#34;&#34;Check if the node has a specific attribute.

        Args:
            attr_name (str): The name of the attribute to check.

        Returns:
            bool: True if the attribute exists, otherwise False.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
            True
        &#34;&#34;&#34;
        return hasattr(self, attr_name)

    def get_attribute(self, attribute_name: str) -&gt; object:
        &#34;&#34;&#34;Get a named attribute from the node.

        Args:
            attribute_name (str): The name of the attribute to retrieve.

        Returns:
            object: The value of the specified attribute.

        Raises:
            AttributeError: If the attribute does not exist.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
            &#39;Test&#39;
        &#34;&#34;&#34;
        try:
            return getattr(self, attribute_name)
        except AttributeError as err:
            raise AttributeError(f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;) from err

    def set_value(self, period: str, value: float) -&gt; None:
        &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

        Override in subclasses to support mutating stored data.

        Args:
            period (str): Period identifier.
            value (float): Numerical value to store.

        Raises:
            NotImplementedError: Always in base class.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def set_value(self, period, value):
            ...         print(f&#34;Set {period} to {value}&#34;)
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.set_value(&#34;2023&#34;, 100)
            Set 2023 to 100
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)

    @abstractmethod
    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        This method should return a dictionary containing all information
        necessary to reconstruct the node, including:
        - node type
        - name
        - any configuration parameters
        - values (for data nodes)
        - input references (for calculation nodes)

        Returns:
            dict[str, Any]: Dictionary representation of the node.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.to_dict()[&#34;type&#34;]
            &#39;dummy&#39;
        &#34;&#34;&#34;

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the names of nodes this node depends on.

        Default implementation returns empty list. Override in nodes that have dependencies.

        Returns:
            list[str]: List of node names this node depends on.

        Example:
            &gt;&gt;&gt; class Dummy(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     def get_dependencies(self):
            ...         return [&#34;dep1&#34;, &#34;dep2&#34;]
            &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
            &gt;&gt;&gt; node.get_dependencies()
            [&#39;dep1&#39;, &#39;dep2&#39;]
        &#34;&#34;&#34;
        return []

    @classmethod
    @abstractmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, &#34;Node&#34;] | None = None,
    ) -&gt; &#34;Node&#34;:
        &#34;&#34;&#34;Deserialize a node from its dictionary representation.

        Subclasses that support deserialization must override this method.
        Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the
        `context` argument to resolve them. Data nodes may ignore `context`.

        Args:
            data: The serialized node dictionary (usually produced by :py:meth:`to_dict`).
            context: Optional mapping of node names to node objects that have already been deserialized.

        Returns:
            Node: A fully instantiated node object.

        Raises:
            NotImplementedError: If not overridden in a subclass.

        Example:
            &gt;&gt;&gt; class DummyNode(Node):
            ...     def calculate(self, period):
            ...         return 1.0
            ...
            ...     def to_dict(self):
            ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
            ...
            ...     @classmethod
            ...     def from_dict(cls, data, context=None):
            ...         return cls(data[&#34;name&#34;])
            &gt;&gt;&gt; node = DummyNode(&#34;Revenue&#34;)
            &gt;&gt;&gt; d = node.to_dict()
            &gt;&gt;&gt; DummyNode.from_dict(d).name
            &#39;Revenue&#39;
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{cls.__name__}.from_dict() is not implemented. Subclasses requiring deserialization must override this method.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Abstract base class for all nodes in the financial statement model.</p>
<p>This class defines the required interface for all node types, including calculation,
serialization, and dependency inspection. Subclasses must implement <code>calculate</code>, <code>to_dict</code>,
and (for deserializable nodes) <code>from_dict</code> as a classmethod.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; Node</code>:
Classmethod to deserialize a node from a dictionary. Nodes with dependencies
(e.g., calculation, forecast, stat nodes) must use the <code>context</code> argument to resolve them.
Data nodes may ignore <code>context</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node instance.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Optional mapping of period to value (for data nodes).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     @classmethod
...     def from_dict(cls, data, context=None):
...         return cls(data[&quot;name&quot;])
&gt;&gt;&gt; node = DummyNode(&quot;Revenue&quot;)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; DummyNode.from_dict(d).name
'Revenue'
</code></pre>
<p>Initialize the Node instance with a unique name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node. Must be a non-empty string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>name</code> is empty, not a string, or contains invalid characters.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Node(&quot;Revenue&quot;)  # doctest: +ELLIPSIS
Traceback (most recent call last):
...
TypeError: Can't instantiate abstract class Node...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CalculationNode">CalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode" href="calculation_nodes.html#fin_statement_model.core.nodes.calculation_nodes.CustomCalculationNode">CustomCalculationNode</a></li>
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.item_node.FinancialStatementItemNode" href="item_node.html#fin_statement_model.core.nodes.item_node.FinancialStatementItemNode">FinancialStatementItemNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode" href="stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode" href="stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></li>
<li><a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></li>
<li>fin_statement_model.io.graph.definition_io.GraphDefinitionReader._TempNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.core.nodes.Node.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.values"><code class="name">var <span class="ident">values</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.Node.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, '<a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a>'] | None = None) ‑> <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize a node from its dictionary representation.</p>
<p>Subclasses that support deserialization must override this method.
Nodes with dependencies (e.g., calculation, forecast, stat nodes) must use the
<code>context</code> argument to resolve them. Data nodes may ignore <code>context</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The serialized node dictionary (usually produced by :py:meth:<code>to_dict</code>).</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional mapping of node names to node objects that have already been deserialized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>A fully instantiated node object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If not overridden in a subclass.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class DummyNode(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     @classmethod
...     def from_dict(cls, data, context=None):
...         return cls(data[&quot;name&quot;])
&gt;&gt;&gt; node = DummyNode(&quot;Revenue&quot;)
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; DummyNode.from_dict(d).name
'Revenue'
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.Node.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate(self, period: str) -&gt; float:
    &#34;&#34;&#34;Calculate the node&#39;s value for a given period.

    Subclasses must override this method to implement specific calculation logic.

    Args:
        period (str): Identifier for the time period.

    Returns:
        float: Calculated value for the period.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 2.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; Dummy(&#34;Test&#34;).calculate(&#34;2023&#34;)
        2.0
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Calculate the node's value for a given period.</p>
<p>Subclasses must override this method to implement specific calculation logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the time period.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Calculated value for the period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 2.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; Dummy(&quot;Test&quot;).calculate(&quot;2023&quot;)
2.0
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear cached calculation results for this node.

    Subclasses with caching should override this method to clear their internal cache.

    Returns:
        None

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def clear_cache(self):
        ...         print(&#34;Cache cleared!&#34;)
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.clear_cache()
        Cache cleared!
    &#34;&#34;&#34;
    # Default: no cache to clear
    return None</code></pre>
</details>
<div class="desc"><p>Clear cached calculation results for this node.</p>
<p>Subclasses with caching should override this method to clear their internal cache.</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def clear_cache(self):
...         print(&quot;Cache cleared!&quot;)
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.clear_cache()
Cache cleared!
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.get_attribute"><code class="name flex">
<span>def <span class="ident">get_attribute</span></span>(<span>self, attribute_name: str) ‑> object</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute(self, attribute_name: str) -&gt; object:
    &#34;&#34;&#34;Get a named attribute from the node.

    Args:
        attribute_name (str): The name of the attribute to retrieve.

    Returns:
        object: The value of the specified attribute.

    Raises:
        AttributeError: If the attribute does not exist.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.get_attribute(&#34;name&#34;)
        &#39;Test&#39;
    &#34;&#34;&#34;
    try:
        return getattr(self, attribute_name)
    except AttributeError as err:
        raise AttributeError(f&#34;Node &#39;{self.name}&#39; has no attribute &#39;{attribute_name}&#39;&#34;) from err</code></pre>
</details>
<div class="desc"><p>Get a named attribute from the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the attribute to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The value of the specified attribute.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If the attribute does not exist.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.get_attribute(&quot;name&quot;)
'Test'
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the names of nodes this node depends on.

    Default implementation returns empty list. Override in nodes that have dependencies.

    Returns:
        list[str]: List of node names this node depends on.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def get_dependencies(self):
        ...         return [&#34;dep1&#34;, &#34;dep2&#34;]
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.get_dependencies()
        [&#39;dep1&#39;, &#39;dep2&#39;]
    &#34;&#34;&#34;
    return []</code></pre>
</details>
<div class="desc"><p>Get the names of nodes this node depends on.</p>
<p>Default implementation returns empty list. Override in nodes that have dependencies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of node names this node depends on.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def get_dependencies(self):
...         return [&quot;dep1&quot;, &quot;dep2&quot;]
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.get_dependencies()
['dep1', 'dep2']
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.has_attribute"><code class="name flex">
<span>def <span class="ident">has_attribute</span></span>(<span>self, attr_name: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_attribute(self, attr_name: str) -&gt; bool:
    &#34;&#34;&#34;Check if the node has a specific attribute.

    Args:
        attr_name (str): The name of the attribute to check.

    Returns:
        bool: True if the attribute exists, otherwise False.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.has_attribute(&#34;name&#34;)
        True
    &#34;&#34;&#34;
    return hasattr(self, attr_name)</code></pre>
</details>
<div class="desc"><p>Check if the node has a specific attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attr_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the attribute to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the attribute exists, otherwise False.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.has_attribute(&quot;name&quot;)
True
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, period: str, value: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, period: str, value: float) -&gt; None:
    &#34;&#34;&#34;Set a value for a specific period on data-bearing nodes.

    Override in subclasses to support mutating stored data.

    Args:
        period (str): Period identifier.
        value (float): Numerical value to store.

    Raises:
        NotImplementedError: Always in base class.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        ...
        ...     def set_value(self, period, value):
        ...         print(f&#34;Set {period} to {value}&#34;)
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.set_value(&#34;2023&#34;, 100)
        Set 2023 to 100
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Node &#39;{self.name}&#39; does not support set_value&#34;)</code></pre>
</details>
<div class="desc"><p>Set a value for a specific period on data-bearing nodes.</p>
<p>Override in subclasses to support mutating stored data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code></dt>
<dd>Period identifier.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Numerical value to store.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Always in base class.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
...
...     def set_value(self, period, value):
...         print(f&quot;Set {period} to {value}&quot;)
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.set_value(&quot;2023&quot;, 100)
Set 2023 to 100
</code></pre></div>
</dd>
<dt id="fin_statement_model.core.nodes.Node.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    This method should return a dictionary containing all information
    necessary to reconstruct the node, including:
    - node type
    - name
    - any configuration parameters
    - values (for data nodes)
    - input references (for calculation nodes)

    Returns:
        dict[str, Any]: Dictionary representation of the node.

    Example:
        &gt;&gt;&gt; class Dummy(Node):
        ...     def calculate(self, period):
        ...         return 1.0
        ...
        ...     def to_dict(self):
        ...         return {&#34;type&#34;: &#34;dummy&#34;, &#34;name&#34;: self.name}
        &gt;&gt;&gt; node = Dummy(&#34;Test&#34;)
        &gt;&gt;&gt; node.to_dict()[&#34;type&#34;]
        &#39;dummy&#39;
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<p>This method should return a dictionary containing all information
necessary to reconstruct the node, including:
- node type
- name
- any configuration parameters
- values (for data nodes)
- input references (for calculation nodes)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Dictionary representation of the node.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Dummy(Node):
...     def calculate(self, period):
...         return 1.0
...
...     def to_dict(self):
...         return {&quot;type&quot;: &quot;dummy&quot;, &quot;name&quot;: self.name}
&gt;&gt;&gt; node = Dummy(&quot;Test&quot;)
&gt;&gt;&gt; node.to_dict()[&quot;type&quot;]
'dummy'
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.core.nodes.StatisticalGrowthForecastNode"><code class="flex name class">
<span>class <span class="ident">StatisticalGrowthForecastNode</span></span>
<span>(</span><span>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>base_period: str,<br>forecast_periods: list[str],<br>distribution_callable: Callable[[], float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@forecast_type(&#34;statistical&#34;)
class StatisticalGrowthForecastNode(ForecastNode):
    &#34;&#34;&#34;Forecast node whose growth rates are drawn from a random distribution.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary (includes a warning).
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; StatisticalGrowthForecastNode`:
            Not supported; always raises NotImplementedError because the callable cannot be serialized.

    Attributes:
        distribution_callable (Callable[[], float]): Function returning a pseudo-random growth rate.

    Example:
        &gt;&gt;&gt; # Not supported:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, StatisticalGrowthForecastNode
        &gt;&gt;&gt; import random
        &gt;&gt;&gt; revenue = FinancialStatementItemNode(&#34;revenue&#34;, {&#34;2022&#34;: 100})
        &gt;&gt;&gt; node = StatisticalGrowthForecastNode(revenue, &#34;2022&#34;, [&#34;2023&#34;], lambda: random.gauss(0.05, 0.01))
        &gt;&gt;&gt; d = node.to_dict()
        &gt;&gt;&gt; StatisticalGrowthForecastNode.from_dict(d, {&#34;revenue&#34;: revenue})  # doctest: +SKIP
        Traceback (most recent call last):
        ...
        NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized because the distribution_callable cannot be serialized. Manual reconstruction required.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_node: Node,
        base_period: str,
        forecast_periods: list[str],
        distribution_callable: Callable[[], float],
    ):
        &#34;&#34;&#34;Create a StatisticalGrowthForecastNode.

        Args:
            input_node (Node): Source of historical data.
            base_period (str): Last historical period.
            forecast_periods (list[str]): Future periods to project.
            distribution_callable (Callable[[], float]): Zero-argument function returning random growth rates.
        &#34;&#34;&#34;
        super().__init__(input_node, base_period, forecast_periods)
        self.distribution_callable = distribution_callable

    def _get_growth_factor_for_period(self, period: str, prev_period: str, prev_value: float) -&gt; float:
        _ = (period, prev_period, prev_value)  # Parameters are intentionally unused
        return self.distribution_callable()

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize the node to a dictionary representation.

        Returns:
            Dictionary containing the node&#39;s forecast configuration.

        Note:
            The distribution_callable cannot be serialized, so a warning is included.
        &#34;&#34;&#34;
        base_dict = super().to_dict()
        base_dict.update({
            &#34;forecast_type&#34;: &#34;statistical&#34;,
            &#34;serialization_warning&#34;: (
                &#34;StatisticalGrowthForecastNode uses a distribution callable which cannot be serialized. &#34;
                &#34;Manual reconstruction required.&#34;
            ),
        })
        return base_dict

    # Deserialization intentionally unsupported - distribution_callable is not serializable.

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;StatisticalGrowthForecastNode&#34;:  # pragma: no cover
        &#34;&#34;&#34;Deserialization is not supported for StatisticalGrowthForecastNode.&#34;&#34;&#34;
        raise NotImplementedError(
            &#34;StatisticalGrowthForecastNode cannot be deserialized; distribution_callable is not serializable.&#34;
        )</code></pre>
</details>
<div class="desc"><p>Forecast node whose growth rates are drawn from a random distribution.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary (includes a warning).
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; StatisticalGrowthForecastNode</code>:
Not supported; always raises NotImplementedError because the callable cannot be serialized.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>distribution_callable</code></strong> :&ensp;<code>Callable[[], float]</code></dt>
<dd>Function returning a pseudo-random growth rate.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Not supported:
&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, StatisticalGrowthForecastNode
&gt;&gt;&gt; import random
&gt;&gt;&gt; revenue = FinancialStatementItemNode(&quot;revenue&quot;, {&quot;2022&quot;: 100})
&gt;&gt;&gt; node = StatisticalGrowthForecastNode(revenue, &quot;2022&quot;, [&quot;2023&quot;], lambda: random.gauss(0.05, 0.01))
&gt;&gt;&gt; d = node.to_dict()
&gt;&gt;&gt; StatisticalGrowthForecastNode.from_dict(d, {&quot;revenue&quot;: revenue})  # doctest: +SKIP
Traceback (most recent call last):
...
NotImplementedError: StatisticalGrowthForecastNode cannot be fully deserialized because the distribution_callable cannot be serialized. Manual reconstruction required.
</code></pre>
<p>Create a StatisticalGrowthForecastNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Source of historical data.</dd>
<dt><strong><code>base_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Last historical period.</dd>
<dt><strong><code>forecast_periods</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Future periods to project.</dd>
<dt><strong><code>distribution_callable</code></strong> :&ensp;<code>Callable[[], float]</code></dt>
<dd>Zero-argument function returning random growth rates.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></li>
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.StatisticalGrowthForecastNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialization is not supported for StatisticalGrowthForecastNode.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.StatisticalGrowthForecastNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize the node to a dictionary representation.

    Returns:
        Dictionary containing the node&#39;s forecast configuration.

    Note:
        The distribution_callable cannot be serialized, so a warning is included.
    &#34;&#34;&#34;
    base_dict = super().to_dict()
    base_dict.update({
        &#34;forecast_type&#34;: &#34;statistical&#34;,
        &#34;serialization_warning&#34;: (
            &#34;StatisticalGrowthForecastNode uses a distribution callable which cannot be serialized. &#34;
            &#34;Manual reconstruction required.&#34;
        ),
    })
    return base_dict</code></pre>
</details>
<div class="desc"><p>Serialize the node to a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing the node's forecast configuration.</p>
<h2 id="note">Note</h2>
<p>The distribution_callable cannot be serialized, so a warning is included.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode">ForecastNode</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies" href="forecast_nodes.html#fin_statement_model.core.nodes.forecast_nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes.ForecastNode.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.TwoPeriodAverageNode"><code class="flex name class">
<span>class <span class="ident">TwoPeriodAverageNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>period1: str,<br>period2: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;two_period_average&#34;)
class TwoPeriodAverageNode(Node):
    &#34;&#34;&#34;Compute the average of an input node&#39;s values over two periods.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; TwoPeriodAverageNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        input_node (Node): Node supplying values.
        period1 (str): Identifier for the first period.
        period2 (str): Identifier for the second period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, TwoPeriodAverageNode
        &gt;&gt;&gt; data = {&#34;Jan&#34;: 10.0, &#34;Feb&#34;: 11.0}
        &gt;&gt;&gt; price = FinancialStatementItemNode(&#34;price&#34;, data)
        &gt;&gt;&gt; avg = TwoPeriodAverageNode(&#34;avg_price&#34;, input_node=price, period1=&#34;Jan&#34;, period2=&#34;Feb&#34;)
        &gt;&gt;&gt; d = avg.to_dict()
        &gt;&gt;&gt; avg2 = TwoPeriodAverageNode.from_dict(d, {&#34;price&#34;: price})
        &gt;&gt;&gt; avg2.calculate()
        10.5
    &#34;&#34;&#34;

    def __init__(self, name: str, input_node: Node, period1: str, period2: str):
        &#34;&#34;&#34;Create a TwoPeriodAverageNode.

        Args:
            name (str): Unique identifier for the node.
            input_node (Node): Node supplying values.
            period1 (str): Identifier for the first period.
            period2 (str): Identifier for the second period.

        Raises:
            TypeError: If `input_node` is not a Node or periods are not strings.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(f&#34;TwoPeriodAverageNode input_node must be a Node instance, got {type(input_node).__name__}&#34;)
        if not isinstance(period1, str) or not isinstance(period2, str):
            raise TypeError(&#34;TwoPeriodAverageNode period1 and period2 must be strings.&#34;)

        self.input_node = input_node
        self.period1 = period1
        self.period2 = period2

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the average value for the two configured periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: (value1 + value2) / 2, or NaN if either value is non-numeric.

        Raises:
            CalculationError: On errors retrieving input node values.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        try:
            val1 = self.input_node.calculate(self.period1)
            val2 = self.input_node.calculate(self.period2)

            # Ensure values are numeric and finite
            if not isinstance(val1, int | float) or not math.isfinite(val1):
                logger.warning(
                    &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.period1,
                    val1,
                )
                return float(&#34;nan&#34;)
            if not isinstance(val2, int | float) or not math.isfinite(val2):
                logger.warning(
                    &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.period2,
                    val2,
                )
                return float(&#34;nan&#34;)

            # Calculate the average
            return (float(val1) + float(val2)) / 2.0

        except Exception as e:
            # Wrap potential errors during input node calculation
            raise CalculationError(
                message=f&#34;Failed to calculate two-period average for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=f&#34;{self.period1}_and_{self.period2}&#34;,  # Indicate context
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;period1&#34;: self.period1,
                    &#34;period2&#34;: self.period2,
                    &#34;original_error&#34;: str(e),
                },
            ) from e

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this average node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation with type, name, and periods.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;two_period_average&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;period1&#34;: self.period1,
            &#34;period2&#34;: self.period2,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;TwoPeriodAverageNode&#34;:
        &#34;&#34;&#34;Recreate a TwoPeriodAverageNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            TwoPeriodAverageNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;two_period_average&#34;:
            raise ValueError(f&#34;Invalid type for TwoPeriodAverageNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in TwoPeriodAverageNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in TwoPeriodAverageNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize TwoPeriodAverageNode&#34;)
        if input_node_name not in context:
            raise ValueError(f&#34;Input node &#39;{input_node_name}&#39; not found in context&#34;)

        input_node = context[input_node_name]
        period1 = data.get(&#34;period1&#34;)
        period2 = data.get(&#34;period2&#34;)

        if not period1:
            raise ValueError(&#34;Missing &#39;period1&#39; field in TwoPeriodAverageNode data&#34;)
        if not period2:
            raise ValueError(&#34;Missing &#39;period2&#39; field in TwoPeriodAverageNode data&#34;)

        return cls(
            name=name,
            input_node=input_node,
            period1=period1,
            period2=period2,
        )</code></pre>
</details>
<div class="desc"><p>Compute the average of an input node's values over two periods.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; TwoPeriodAverageNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>period1</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the first period.</dd>
<dt><strong><code>period2</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the second period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, TwoPeriodAverageNode
&gt;&gt;&gt; data = {&quot;Jan&quot;: 10.0, &quot;Feb&quot;: 11.0}
&gt;&gt;&gt; price = FinancialStatementItemNode(&quot;price&quot;, data)
&gt;&gt;&gt; avg = TwoPeriodAverageNode(&quot;avg_price&quot;, input_node=price, period1=&quot;Jan&quot;, period2=&quot;Feb&quot;)
&gt;&gt;&gt; d = avg.to_dict()
&gt;&gt;&gt; avg2 = TwoPeriodAverageNode.from_dict(d, {&quot;price&quot;: price})
&gt;&gt;&gt; avg2.calculate()
10.5
</code></pre>
<p>Create a TwoPeriodAverageNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for the node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node supplying values.</dd>
<dt><strong><code>period1</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the first period.</dd>
<dt><strong><code>period2</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the second period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or periods are not strings.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.TwoPeriodAverageNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode" href="stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a TwoPeriodAverageNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.nodes.TwoPeriodAverageNode" href="#fin_statement_model.core.nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.TwoPeriodAverageNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the average value for the two configured periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: (value1 + value2) / 2, or NaN if either value is non-numeric.

    Raises:
        CalculationError: On errors retrieving input node values.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    try:
        val1 = self.input_node.calculate(self.period1)
        val2 = self.input_node.calculate(self.period2)

        # Ensure values are numeric and finite
        if not isinstance(val1, int | float) or not math.isfinite(val1):
            logger.warning(
                &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.period1,
                val1,
            )
            return float(&#34;nan&#34;)
        if not isinstance(val2, int | float) or not math.isfinite(val2):
            logger.warning(
                &#34;TwoPeriodAverageNode &#39;%s&#39;: Value for period &#39;%s&#39; is non-numeric/non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.period2,
                val2,
            )
            return float(&#34;nan&#34;)

        # Calculate the average
        return (float(val1) + float(val2)) / 2.0

    except Exception as e:
        # Wrap potential errors during input node calculation
        raise CalculationError(
            message=f&#34;Failed to calculate two-period average for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=f&#34;{self.period1}_and_{self.period2}&#34;,  # Indicate context
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;period1&#34;: self.period1,
                &#34;period2&#34;: self.period2,
                &#34;original_error&#34;: str(e),
            },
        ) from e</code></pre>
</details>
<div class="desc"><p>Compute the average value for the two configured periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>(value1 + value2) / 2, or NaN if either value is non-numeric.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>On errors retrieving input node values.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.nodes.TwoPeriodAverageNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this average node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this average node depends on.</p></div>
</dd>
<dt id="fin_statement_model.core.nodes.TwoPeriodAverageNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation with type, name, and periods.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;two_period_average&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;period1&#34;: self.period1,
        &#34;period2&#34;: self.period2,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation with type, name, and periods.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.core.nodes.YoYGrowthNode"><code class="flex name class">
<span>class <span class="ident">YoYGrowthNode</span></span>
<span>(</span><span>name: str,<br>input_node: <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>,<br>prior_period: str,<br>current_period: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@node_type(&#34;yoy_growth&#34;)
class YoYGrowthNode(Node):
    &#34;&#34;&#34;Compute year-over-year percentage growth.

    Compare values of an input node for two periods and compute
    (current_value - prior_value) / prior_value.

    Serialization contract:
        - `to_dict(self) -&gt; dict`: Serialize the node to a dictionary.
        - `from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode`:
            Classmethod to deserialize a node from a dictionary. `context` is required to resolve input nodes.

    Attributes:
        input_node (Node): Node providing source values.
        prior_period (str): Identifier for the earlier period.
        current_period (str): Identifier for the later period.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
        &gt;&gt;&gt; data = {&#34;2022&#34;: 100.0, &#34;2023&#34;: 120.0}
        &gt;&gt;&gt; base = FinancialStatementItemNode(&#34;revenue&#34;, data)
        &gt;&gt;&gt; yoy = YoYGrowthNode(&#34;rev_yoy&#34;, input_node=base, prior_period=&#34;2022&#34;, current_period=&#34;2023&#34;)
        &gt;&gt;&gt; d = yoy.to_dict()
        &gt;&gt;&gt; yoy2 = YoYGrowthNode.from_dict(d, {&#34;revenue&#34;: base})
        &gt;&gt;&gt; round(yoy2.calculate(), 2)
        0.2
    &#34;&#34;&#34;

    def __init__(self, name: str, input_node: Node, prior_period: str, current_period: str):
        &#34;&#34;&#34;Create a YoYGrowthNode.

        Args:
            name (str): Unique identifier for this node.
            input_node (Node): Node supplying values for comparison.
            prior_period (str): Identifier for the earlier period.
            current_period (str): Identifier for the later period.

        Raises:
            TypeError: If `input_node` is not a Node or periods are not strings.
        &#34;&#34;&#34;
        super().__init__(name)
        if not isinstance(input_node, Node):
            raise TypeError(&#34;YoYGrowthNode input_node must be a Node instance.&#34;)
        if not isinstance(prior_period, str) or not isinstance(current_period, str):
            raise TypeError(&#34;YoYGrowthNode prior_period and current_period must be strings.&#34;)

        self.input_node = input_node
        self.prior_period = prior_period
        self.current_period = current_period

    def calculate(self, period: str | None = None) -&gt; float:
        &#34;&#34;&#34;Compute the YoY growth rate.

        Ignore the `period` parameter; use configured periods.

        Args:
            period (str | None): Ignored.

        Returns:
            float: (current - prior) / prior, or NaN if prior is zero or non-finite.

        Raises:
            CalculationError: On errors retrieving or validating input values.
        &#34;&#34;&#34;
        _ = period  # Parameter intentionally unused
        try:
            prior_value = self.input_node.calculate(self.prior_period)
            current_value = self.input_node.calculate(self.current_period)

            # Validate input types
            if not isinstance(prior_value, int | float):
                raise TypeError(f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;)
            if not isinstance(current_value, int | float):
                raise TypeError(f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;)

            # Handle division by zero or non-finite prior value
            if prior_value == 0 or not math.isfinite(prior_value):
                logger.warning(
                    &#34;YoYGrowthNode &#39;%s&#39;: Prior period &#39;%s&#39; value is zero or non-finite (%s). Returning NaN.&#34;,
                    self.name,
                    self.prior_period,
                    prior_value,
                )
                return float(&#34;nan&#34;)

            # Calculate growth
            growth = (float(current_value) - float(prior_value)) / float(prior_value)
        except Exception as e:
            # Wrap any exception during calculation
            raise CalculationError(
                message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
                node_id=self.name,
                period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
                details={
                    &#34;input_node&#34;: self.input_node.name,
                    &#34;prior_period&#34;: self.prior_period,
                    &#34;current_period&#34;: self.current_period,
                    &#34;original_error&#34;: str(e),
                },
            ) from e
        else:
            return growth

    def get_dependencies(self) -&gt; list[str]:
        &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
        return [self.input_node.name]

    def to_dict(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Serialize this node to a dictionary.

        Returns:
            dict[str, Any]: Serialized representation with type, name, and periods.
        &#34;&#34;&#34;
        return {
            &#34;type&#34;: &#34;yoy_growth&#34;,
            &#34;name&#34;: self.name,
            &#34;input_node_name&#34;: self.input_node.name,
            &#34;prior_period&#34;: self.prior_period,
            &#34;current_period&#34;: self.current_period,
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
        context: dict[str, Node] | None = None,
    ) -&gt; &#34;YoYGrowthNode&#34;:
        &#34;&#34;&#34;Recreate a YoYGrowthNode from serialized data.

        Args:
            data (dict[str, Any]): Serialized node data.
            context (dict[str, Node] | None): Existing nodes for dependencies.

        Returns:
            YoYGrowthNode: Reconstructed node.

        Raises:
            ValueError: If required fields are missing or invalid.
        &#34;&#34;&#34;
        if data.get(&#34;type&#34;) != &#34;yoy_growth&#34;:
            raise ValueError(f&#34;Invalid type for YoYGrowthNode: {data.get(&#39;type&#39;)}&#34;)

        name = data.get(&#34;name&#34;)
        if not name:
            raise ValueError(&#34;Missing &#39;name&#39; field in YoYGrowthNode data&#34;)

        input_node_name = data.get(&#34;input_node_name&#34;)
        if not input_node_name:
            raise ValueError(&#34;Missing &#39;input_node_name&#39; field in YoYGrowthNode data&#34;)

        if context is None:
            raise ValueError(&#34;&#39;context&#39; must be provided to deserialize YoYGrowthNode&#34;)
        input_node = context[input_node_name]

        prior_period = data.get(&#34;prior_period&#34;)
        current_period = data.get(&#34;current_period&#34;)

        if not prior_period:
            raise ValueError(&#34;Missing &#39;prior_period&#39; field in YoYGrowthNode data&#34;)
        if not current_period:
            raise ValueError(&#34;Missing &#39;current_period&#39; field in YoYGrowthNode data&#34;)

        return cls(
            name=name,
            input_node=input_node,
            prior_period=prior_period,
            current_period=current_period,
        )</code></pre>
</details>
<div class="desc"><p>Compute year-over-year percentage growth.</p>
<p>Compare values of an input node for two periods and compute
(current_value - prior_value) / prior_value.</p>
<p>Serialization contract:
- <code>to_dict(self) -&gt; dict</code>: Serialize the node to a dictionary.
- <code>from_dict(cls, data: dict, context: dict[str, Node] | None = None) -&gt; YoYGrowthNode</code>:
Classmethod to deserialize a node from a dictionary. <code>context</code> is required to resolve input nodes.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node providing source values.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.nodes import FinancialStatementItemNode, YoYGrowthNode
&gt;&gt;&gt; data = {&quot;2022&quot;: 100.0, &quot;2023&quot;: 120.0}
&gt;&gt;&gt; base = FinancialStatementItemNode(&quot;revenue&quot;, data)
&gt;&gt;&gt; yoy = YoYGrowthNode(&quot;rev_yoy&quot;, input_node=base, prior_period=&quot;2022&quot;, current_period=&quot;2023&quot;)
&gt;&gt;&gt; d = yoy.to_dict()
&gt;&gt;&gt; yoy2 = YoYGrowthNode.from_dict(d, {&quot;revenue&quot;: base})
&gt;&gt;&gt; round(yoy2.calculate(), 2)
0.2
</code></pre>
<p>Create a YoYGrowthNode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique identifier for this node.</dd>
<dt><strong><code>input_node</code></strong> :&ensp;<code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></dt>
<dd>Node supplying values for comparison.</dd>
<dt><strong><code>prior_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the earlier period.</dd>
<dt><strong><code>current_period</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the later period.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>input_node</code> is not a Node or periods are not strings.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.YoYGrowthNode.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict[str, typing.Any],<br>context: dict[str, <a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a>] | None = None) ‑> <a title="fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode" href="stats_nodes.html#fin_statement_model.core.nodes.stats_nodes.YoYGrowthNode">YoYGrowthNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recreate a YoYGrowthNode from serialized data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Serialized node data.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>dict[str, Node] | None</code></dt>
<dd>Existing nodes for dependencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fin_statement_model.core.nodes.YoYGrowthNode" href="#fin_statement_model.core.nodes.YoYGrowthNode">YoYGrowthNode</a></code></dt>
<dd>Reconstructed node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required fields are missing or invalid.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.core.nodes.YoYGrowthNode.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, period: str | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, period: str | None = None) -&gt; float:
    &#34;&#34;&#34;Compute the YoY growth rate.

    Ignore the `period` parameter; use configured periods.

    Args:
        period (str | None): Ignored.

    Returns:
        float: (current - prior) / prior, or NaN if prior is zero or non-finite.

    Raises:
        CalculationError: On errors retrieving or validating input values.
    &#34;&#34;&#34;
    _ = period  # Parameter intentionally unused
    try:
        prior_value = self.input_node.calculate(self.prior_period)
        current_value = self.input_node.calculate(self.current_period)

        # Validate input types
        if not isinstance(prior_value, int | float):
            raise TypeError(f&#34;Prior period (&#39;{self.prior_period}&#39;) value is non-numeric.&#34;)
        if not isinstance(current_value, int | float):
            raise TypeError(f&#34;Current period (&#39;{self.current_period}&#39;) value is non-numeric.&#34;)

        # Handle division by zero or non-finite prior value
        if prior_value == 0 or not math.isfinite(prior_value):
            logger.warning(
                &#34;YoYGrowthNode &#39;%s&#39;: Prior period &#39;%s&#39; value is zero or non-finite (%s). Returning NaN.&#34;,
                self.name,
                self.prior_period,
                prior_value,
            )
            return float(&#34;nan&#34;)

        # Calculate growth
        growth = (float(current_value) - float(prior_value)) / float(prior_value)
    except Exception as e:
        # Wrap any exception during calculation
        raise CalculationError(
            message=f&#34;Failed to calculate YoY growth for node &#39;{self.name}&#39;&#34;,
            node_id=self.name,
            period=f&#34;{self.prior_period}_to_{self.current_period}&#34;,  # Indicate period span
            details={
                &#34;input_node&#34;: self.input_node.name,
                &#34;prior_period&#34;: self.prior_period,
                &#34;current_period&#34;: self.current_period,
                &#34;original_error&#34;: str(e),
            },
        ) from e
    else:
        return growth</code></pre>
</details>
<div class="desc"><p>Compute the YoY growth rate.</p>
<p>Ignore the <code>period</code> parameter; use configured periods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>str | None</code></dt>
<dd>Ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>(current - prior) / prior, or NaN if prior is zero or non-finite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CalculationError</code></dt>
<dd>On errors retrieving or validating input values.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.core.nodes.YoYGrowthNode.get_dependencies"><code class="name flex">
<span>def <span class="ident">get_dependencies</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dependencies(self) -&gt; list[str]:
    &#34;&#34;&#34;Get names of nodes this node depends on.&#34;&#34;&#34;
    return [self.input_node.name]</code></pre>
</details>
<div class="desc"><p>Get names of nodes this node depends on.</p></div>
</dd>
<dt id="fin_statement_model.core.nodes.YoYGrowthNode.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Serialize this node to a dictionary.

    Returns:
        dict[str, Any]: Serialized representation with type, name, and periods.
    &#34;&#34;&#34;
    return {
        &#34;type&#34;: &#34;yoy_growth&#34;,
        &#34;name&#34;: self.name,
        &#34;input_node_name&#34;: self.input_node.name,
        &#34;prior_period&#34;: self.prior_period,
        &#34;current_period&#34;: self.current_period,
    }</code></pre>
</details>
<div class="desc"><p>Serialize this node to a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Serialized representation with type, name, and periods.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.core.nodes.base.Node" href="base.html#fin_statement_model.core.nodes.base.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.core.nodes.base.Node.clear_cache" href="base.html#fin_statement_model.core.nodes.base.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.get_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.has_attribute" href="base.html#fin_statement_model.core.nodes.base.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.base.Node.set_value" href="base.html#fin_statement_model.core.nodes.base.Node.set_value">set_value</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.core" href="../index.html">fin_statement_model.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.core.nodes.base" href="base.html">fin_statement_model.core.nodes.base</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.calculation_nodes" href="calculation_nodes.html">fin_statement_model.core.nodes.calculation_nodes</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.forecast_nodes" href="forecast_nodes.html">fin_statement_model.core.nodes.forecast_nodes</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.item_node" href="item_node.html">fin_statement_model.core.nodes.item_node</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.standard_nodes_defn" href="standard_nodes_defn/index.html">fin_statement_model.core.nodes.standard_nodes_defn</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.standard_registry" href="standard_registry.html">fin_statement_model.core.nodes.standard_registry</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.stats_nodes" href="stats_nodes.html">fin_statement_model.core.nodes.stats_nodes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.is_calculation_node" href="#fin_statement_model.core.nodes.is_calculation_node">is_calculation_node</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode" href="#fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode">AverageHistoricalGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode.from_dict" href="#fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode.to_dict" href="#fin_statement_model.core.nodes.AverageHistoricalGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.AverageValueForecastNode" href="#fin_statement_model.core.nodes.AverageValueForecastNode">AverageValueForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.AverageValueForecastNode.from_dict" href="#fin_statement_model.core.nodes.AverageValueForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.AverageValueForecastNode.to_dict" href="#fin_statement_model.core.nodes.AverageValueForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.CalculationNode" href="#fin_statement_model.core.nodes.CalculationNode">CalculationNode</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.core.nodes.CalculationNode.calculate" href="#fin_statement_model.core.nodes.CalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CalculationNode.clear_cache" href="#fin_statement_model.core.nodes.CalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CalculationNode.from_dict" href="#fin_statement_model.core.nodes.CalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CalculationNode.get_dependencies" href="#fin_statement_model.core.nodes.CalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CalculationNode.set_calculation" href="#fin_statement_model.core.nodes.CalculationNode.set_calculation">set_calculation</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CalculationNode.to_dict" href="#fin_statement_model.core.nodes.CalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.CurveGrowthForecastNode" href="#fin_statement_model.core.nodes.CurveGrowthForecastNode">CurveGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.CurveGrowthForecastNode.from_dict" href="#fin_statement_model.core.nodes.CurveGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CurveGrowthForecastNode.to_dict" href="#fin_statement_model.core.nodes.CurveGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.CustomCalculationNode" href="#fin_statement_model.core.nodes.CustomCalculationNode">CustomCalculationNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.CustomCalculationNode.calculate" href="#fin_statement_model.core.nodes.CustomCalculationNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CustomCalculationNode.clear_cache" href="#fin_statement_model.core.nodes.CustomCalculationNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CustomCalculationNode.from_dict" href="#fin_statement_model.core.nodes.CustomCalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CustomCalculationNode.get_dependencies" href="#fin_statement_model.core.nodes.CustomCalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CustomCalculationNode.to_dict" href="#fin_statement_model.core.nodes.CustomCalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.CustomGrowthForecastNode" href="#fin_statement_model.core.nodes.CustomGrowthForecastNode">CustomGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.CustomGrowthForecastNode.from_dict" href="#fin_statement_model.core.nodes.CustomGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.CustomGrowthForecastNode.to_dict" href="#fin_statement_model.core.nodes.CustomGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode" href="#fin_statement_model.core.nodes.FinancialStatementItemNode">FinancialStatementItemNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode.calculate" href="#fin_statement_model.core.nodes.FinancialStatementItemNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode.from_dict" href="#fin_statement_model.core.nodes.FinancialStatementItemNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode.set_value" href="#fin_statement_model.core.nodes.FinancialStatementItemNode.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode.to_dict" href="#fin_statement_model.core.nodes.FinancialStatementItemNode.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FinancialStatementItemNode.values" href="#fin_statement_model.core.nodes.FinancialStatementItemNode.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.FixedGrowthForecastNode" href="#fin_statement_model.core.nodes.FixedGrowthForecastNode">FixedGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.FixedGrowthForecastNode.from_dict" href="#fin_statement_model.core.nodes.FixedGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FixedGrowthForecastNode.to_dict" href="#fin_statement_model.core.nodes.FixedGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.ForecastNode" href="#fin_statement_model.core.nodes.ForecastNode">ForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.ForecastNode.calculate" href="#fin_statement_model.core.nodes.ForecastNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.ForecastNode.clear_cache" href="#fin_statement_model.core.nodes.ForecastNode.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.ForecastNode.from_dict" href="#fin_statement_model.core.nodes.ForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.ForecastNode.get_dependencies" href="#fin_statement_model.core.nodes.ForecastNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.ForecastNode.to_dict" href="#fin_statement_model.core.nodes.ForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.FormulaCalculationNode" href="#fin_statement_model.core.nodes.FormulaCalculationNode">FormulaCalculationNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.FormulaCalculationNode.from_dict" href="#fin_statement_model.core.nodes.FormulaCalculationNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FormulaCalculationNode.get_dependencies" href="#fin_statement_model.core.nodes.FormulaCalculationNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.FormulaCalculationNode.to_dict" href="#fin_statement_model.core.nodes.FormulaCalculationNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.MultiPeriodStatNode" href="#fin_statement_model.core.nodes.MultiPeriodStatNode">MultiPeriodStatNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.MultiPeriodStatNode.calculate" href="#fin_statement_model.core.nodes.MultiPeriodStatNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.MultiPeriodStatNode.from_dict" href="#fin_statement_model.core.nodes.MultiPeriodStatNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.MultiPeriodStatNode.get_dependencies" href="#fin_statement_model.core.nodes.MultiPeriodStatNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.MultiPeriodStatNode.to_dict" href="#fin_statement_model.core.nodes.MultiPeriodStatNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.Node" href="#fin_statement_model.core.nodes.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.core.nodes.Node.calculate" href="#fin_statement_model.core.nodes.Node.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.clear_cache" href="#fin_statement_model.core.nodes.Node.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.from_dict" href="#fin_statement_model.core.nodes.Node.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.get_attribute" href="#fin_statement_model.core.nodes.Node.get_attribute">get_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.get_dependencies" href="#fin_statement_model.core.nodes.Node.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.has_attribute" href="#fin_statement_model.core.nodes.Node.has_attribute">has_attribute</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.name" href="#fin_statement_model.core.nodes.Node.name">name</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.set_value" href="#fin_statement_model.core.nodes.Node.set_value">set_value</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.to_dict" href="#fin_statement_model.core.nodes.Node.to_dict">to_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.Node.values" href="#fin_statement_model.core.nodes.Node.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.StatisticalGrowthForecastNode" href="#fin_statement_model.core.nodes.StatisticalGrowthForecastNode">StatisticalGrowthForecastNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.StatisticalGrowthForecastNode.from_dict" href="#fin_statement_model.core.nodes.StatisticalGrowthForecastNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.StatisticalGrowthForecastNode.to_dict" href="#fin_statement_model.core.nodes.StatisticalGrowthForecastNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.TwoPeriodAverageNode" href="#fin_statement_model.core.nodes.TwoPeriodAverageNode">TwoPeriodAverageNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.TwoPeriodAverageNode.calculate" href="#fin_statement_model.core.nodes.TwoPeriodAverageNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.TwoPeriodAverageNode.from_dict" href="#fin_statement_model.core.nodes.TwoPeriodAverageNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.TwoPeriodAverageNode.get_dependencies" href="#fin_statement_model.core.nodes.TwoPeriodAverageNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.TwoPeriodAverageNode.to_dict" href="#fin_statement_model.core.nodes.TwoPeriodAverageNode.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.core.nodes.YoYGrowthNode" href="#fin_statement_model.core.nodes.YoYGrowthNode">YoYGrowthNode</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.core.nodes.YoYGrowthNode.calculate" href="#fin_statement_model.core.nodes.YoYGrowthNode.calculate">calculate</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.YoYGrowthNode.from_dict" href="#fin_statement_model.core.nodes.YoYGrowthNode.from_dict">from_dict</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.YoYGrowthNode.get_dependencies" href="#fin_statement_model.core.nodes.YoYGrowthNode.get_dependencies">get_dependencies</a></code></li>
<li><code><a title="fin_statement_model.core.nodes.YoYGrowthNode.to_dict" href="#fin_statement_model.core.nodes.YoYGrowthNode.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
