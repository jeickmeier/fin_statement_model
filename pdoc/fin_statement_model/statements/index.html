<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.statements API documentation</title>
<meta name="description" content="Financial Statements Layer (`fin_statement_model.statements`) â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.statements</code></h1>
</header>
<section id="section-intro">
<p>Financial Statements Layer (<code><a title="fin_statement_model.statements" href="#fin_statement_model.statements">fin_statement_model.statements</a></code>).</p>
<p>This package provides domain-specific abstractions for defining, building,
managing, and presenting financial statements (like Income Statement,
Balance Sheet, Cash Flow Statement) based on underlying configurations.</p>
<p>It sits above the <code>core</code> layer and orchestrates the use of core components
(like <code>Graph</code>, <code>Node</code>) within the context of financial statement structures.
It utilizes configurations (often YAML files) to define the layout, items,
and calculations of a statement.</p>
<p>Key functionalities include:
- Defining statement structure (<code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code>, <code><a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a></code>, <code><a title="fin_statement_model.statements.LineItem" href="#fin_statement_model.statements.LineItem">LineItem</a></code> etc.)
- Loading and validating statement configurations (<code><a title="fin_statement_model.statements.StatementConfig" href="#fin_statement_model.statements.StatementConfig">StatementConfig</a></code>).
- Building <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> objects from configurations
(<code><a title="fin_statement_model.statements.StatementStructureBuilder" href="#fin_statement_model.statements.StatementStructureBuilder">StatementStructureBuilder</a></code>).
- Managing multiple loaded statements (<code><a title="fin_statement_model.statements.StatementRegistry" href="#fin_statement_model.statements.StatementRegistry">StatementRegistry</a></code>).
- Populating a <code>core.graph.Graph</code> with calculation nodes based on statement
definitions (<code><a title="fin_statement_model.statements.populate_graph_from_statement" href="#fin_statement_model.statements.populate_graph_from_statement">populate_graph_from_statement()</a></code>).
- Formatting statement data retrieved from a graph into user-friendly formats,
primarily pandas DataFrames (<code><a title="fin_statement_model.statements.StatementFormatter" href="#fin_statement_model.statements.StatementFormatter">StatementFormatter</a></code>).
- High-level functions to streamline common workflows like generating a
statement DataFrame or exporting statements to files (<code><a title="fin_statement_model.statements.create_statement_dataframe" href="#fin_statement_model.statements.create_statement_dataframe">create_statement_dataframe()</a></code>,
<code><a title="fin_statement_model.statements.export_statements_to_excel" href="#fin_statement_model.statements.export_statements_to_excel">export_statements_to_excel()</a></code>).
- Centralizing ID resolution logic between statement items and graph nodes
(<code><a title="fin_statement_model.statements.IDResolver" href="#fin_statement_model.statements.IDResolver">IDResolver</a></code>).</p>
<p>This package imports from <code>core</code> and <code>io</code> (indirectly via <code>factory</code>), but should
not be imported by <code>core</code>.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fin_statement_model.statements.configs" href="configs/index.html">fin_statement_model.statements.configs</a></code></dt>
<dd>
<div class="desc"><p>Configuration handling for financial statements â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.errors" href="errors.html">fin_statement_model.statements.errors</a></code></dt>
<dd>
<div class="desc"><p>Custom Exception classes for the <code><a title="fin_statement_model.statements" href="#fin_statement_model.statements">fin_statement_model.statements</a></code> package â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.formatting" href="formatting/index.html">fin_statement_model.statements.formatting</a></code></dt>
<dd>
<div class="desc"><p>Formatting and data fetching for financial statements â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.orchestration" href="orchestration/index.html">fin_statement_model.statements.orchestration</a></code></dt>
<dd>
<div class="desc"><p>High-level orchestration functions for statement processing â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.population" href="population/index.html">fin_statement_model.statements.population</a></code></dt>
<dd>
<div class="desc"><p>Graph population functionality for financial statements â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.registry" href="registry.html">fin_statement_model.statements.registry</a></code></dt>
<dd>
<div class="desc"><p>Registry for managing loaded and validated financial statement structures â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.structure" href="structure/index.html">fin_statement_model.statements.structure</a></code></dt>
<dd>
<div class="desc"><p>Statement structure package â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.utilities" href="utilities/index.html">fin_statement_model.statements.utilities</a></code></dt>
<dd>
<div class="desc"><p>Cross-cutting utilities for the statements package â€¦</p></div>
</dd>
<dt><code class="name"><a title="fin_statement_model.statements.validation" href="validation.html">fin_statement_model.statements.validation</a></code></dt>
<dd>
<div class="desc"><p>Unified node name validation and standardization utilities â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.statements.build_validated_statement_from_config"><code class="name flex">
<span>def <span class="ident">build_validated_statement_from_config</span></span>(<span>config_path_or_data:Â strÂ |Â dict[str,Â typing.Any],<br>strict_mode:Â boolÂ =Â False,<br>auto_standardize:Â boolÂ =Â True) â€‘>Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_validated_statement_from_config(
    config_path_or_data: str | dict[str, Any],
    strict_mode: bool = False,
    auto_standardize: bool = True,
) -&gt; StatementStructure:
    &#34;&#34;&#34;Build a complete validated StatementStructure from configuration.

    This is the highest-level convenience function that handles the entire
    process from config to built statement with comprehensive validation.

    Args:
        config_path_or_data: Path to config file or config data dict.
        strict_mode: If True, treats node validation failures as errors.
        auto_standardize: If True, auto-standardize alternate node names.

    Returns:
        StatementStructure instance.

    Raises:
        ConfigurationError: If validation fails in strict mode.
        ValueError: If config validation fails.

    Example:
        &gt;&gt;&gt; try:
        ...     statement = build_validated_statement_from_config(&#34;path/to/income_statement.yaml&#34;, strict_mode=True)
        ...     print(f&#34;Built statement: {statement.name}&#34;)
        ... except ConfigurationError as e:
        ...     print(f&#34;Validation failed: {e}&#34;)
    &#34;&#34;&#34;
    # Validate config
    config, errors = validate_statement_config_with_nodes(config_path_or_data, strict_mode, auto_standardize)

    if errors:
        raise ConfigurationError(
            message=&#34;Statement configuration validation failed&#34;,
            errors=errors,
        )

    # Create builder with validation
    builder = create_validated_statement_builder(
        enable_node_validation=True,
        strict_mode=strict_mode,
    )

    # Build statement
    return builder.build(config)</code></pre>
</details>
<div class="desc"><p>Build a complete validated StatementStructure from configuration.</p>
<p>This is the highest-level convenience function that handles the entire
process from config to built statement with comprehensive validation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_path_or_data</code></strong></dt>
<dd>Path to config file or config data dict.</dd>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, treats node validation failures as errors.</dd>
<dt><strong><code>auto_standardize</code></strong></dt>
<dd>If True, auto-standardize alternate node names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>StatementStructure instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.ConfigurationError" href="#fin_statement_model.statements.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If validation fails in strict mode.</dd>
<dt><code>ValueError</code></dt>
<dd>If config validation fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; try:
...     statement = build_validated_statement_from_config(&quot;path/to/income_statement.yaml&quot;, strict_mode=True)
...     print(f&quot;Built statement: {statement.name}&quot;)
... except ConfigurationError as e:
...     print(f&quot;Validation failed: {e}&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.combine_results"><code class="name flex">
<span>def <span class="ident">combine_results</span></span>(<span>*results:Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]) â€‘>Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[list[~T]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_results(*results: Result[T]) -&gt; Result[list[T]]:
    &#34;&#34;&#34;Combine multiple results into a single result.

    If all results are successful, returns Success with list of values.
    If any result is a failure, returns Failure with all errors combined.
    &#34;&#34;&#34;
    collector = ErrorCollector()
    values = []

    for result in results:
        if result.is_success():
            values.append(cast(&#34;T&#34;, result.get_value()))
        else:
            for error in result.get_errors():
                if error.severity == ErrorSeverity.WARNING:
                    collector.add_warning(error.code, error.message, error.context, error.source)
                else:
                    collector.add_error(error.code, error.message, error.context, error.source)

    if collector.has_errors():
        return Failure(errors=collector.get_all())
    return Success(value=values)</code></pre>
</details>
<div class="desc"><p>Combine multiple results into a single result.</p>
<p>If all results are successful, returns Success with list of values.
If any result is a failure, returns Failure with all errors combined.</p></div>
</dd>
<dt id="fin_statement_model.statements.create_statement_dataframe"><code class="name flex">
<span>def <span class="ident">create_statement_dataframe</span></span>(<span>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>raw_configs:Â dict[str,Â dict[str,Â typing.Any]],<br>format_kwargs:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None,<br>enable_node_validation:Â boolÂ |Â NoneÂ =Â None,<br>node_validation_strict:Â boolÂ |Â NoneÂ =Â None) â€‘>Â dict[str,Â pandas.core.frame.DataFrame]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_statement_dataframe(
    graph: Graph,
    raw_configs: dict[str, dict[str, Any]],
    format_kwargs: dict[str, Any] | None = None,
    enable_node_validation: bool | None = None,
    node_validation_strict: bool | None = None,
) -&gt; dict[str, pd.DataFrame]:
    &#34;&#34;&#34;Build statements from configurations, populate graph, and format DataFrames.

    Args:
        graph: Graph instance to populate.
        raw_configs: Mapping of statement IDs to configuration dicts.
        format_kwargs: Optional kwargs for formatter.
        enable_node_validation: If True, validate node IDs.
        node_validation_strict: If True, treat validation failures as errors.

    Returns:
        Mapping of statement IDs to pandas DataFrames.

    Raises:
        StatementError: If loading or formatting fails.
    &#34;&#34;&#34;
    registry = StatementRegistry()
    enable_node_validation = enable_node_validation if enable_node_validation is not None else False
    node_validation_strict = node_validation_strict if node_validation_strict is not None else False
    builder = StatementStructureBuilder(
        enable_node_validation=enable_node_validation,
        node_validation_strict=node_validation_strict,
    )
    format_kwargs = format_kwargs or {}

    # Step 1: Load, build, register
    loaded_ids = load_build_register_statements(
        raw_configs,
        registry,
        builder,
        enable_node_validation=enable_node_validation,
        node_validation_strict=node_validation_strict,
    )
    if not loaded_ids:
        raise StatementError(&#34;No valid statements could be loaded.&#34;)

    # Step 2: Populate graph
    populate_graph(registry, graph)

    # Step 3: Format results
    results: dict[str, pd.DataFrame] = {}
    for stmt_id in loaded_ids:
        statement = registry.get(stmt_id)
        if statement is None:
            logger.error(&#34;Statement &#39;%s&#39; not found in registry.&#34;, stmt_id)
            raise StatementError(f&#34;Statement &#39;{stmt_id}&#39; not found in registry.&#34;)
        formatter = StatementFormatter(statement)
        if format_kwargs:
            context = formatter._prepare_formatting_context(**format_kwargs)
        else:
            # Use default project configuration
            context = formatter._prepare_formatting_context()

        df = formatter.generate_dataframe(graph, context=context)
        results[stmt_id] = df

    return results</code></pre>
</details>
<div class="desc"><p>Build statements from configurations, populate graph, and format DataFrames.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>Graph instance to populate.</dd>
<dt><strong><code>raw_configs</code></strong></dt>
<dd>Mapping of statement IDs to configuration dicts.</dd>
<dt><strong><code>format_kwargs</code></strong></dt>
<dd>Optional kwargs for formatter.</dd>
<dt><strong><code>enable_node_validation</code></strong></dt>
<dd>If True, validate node IDs.</dd>
<dt><strong><code>node_validation_strict</code></strong></dt>
<dd>If True, treat validation failures as errors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Mapping of statement IDs to pandas DataFrames.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If loading or formatting fails.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.create_validated_statement_builder"><code class="name flex">
<span>def <span class="ident">create_validated_statement_builder</span></span>(<span>enable_node_validation:Â boolÂ =Â True,<br>strict_mode:Â boolÂ =Â False,<br>node_validator:Â <a title="fin_statement_model.statements.validation.UnifiedNodeValidator" href="validation.html#fin_statement_model.statements.validation.UnifiedNodeValidator">UnifiedNodeValidator</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.structure.builder.StatementStructureBuilder" href="structure/builder.html#fin_statement_model.statements.structure.builder.StatementStructureBuilder">StatementStructureBuilder</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_validated_statement_builder(
    enable_node_validation: bool = True,
    strict_mode: bool = False,
    node_validator: UnifiedNodeValidator | None = None,
) -&gt; StatementStructureBuilder:
    &#34;&#34;&#34;Create a StatementStructureBuilder with optional node validation enabled.

    Args:
        enable_node_validation: If True, validates node IDs during build.
        strict_mode: If True, treats node validation failures as errors.
        node_validator: Optional pre-configured UnifiedNodeValidator instance.

    Returns:
        StatementStructureBuilder instance with validation configured.

    Example:
        &gt;&gt;&gt; builder = create_validated_statement_builder(
        ...     enable_node_validation=True,
        ...     strict_mode=False,  # Warnings only
        ... )
        &gt;&gt;&gt; statement = builder.build(validated_config)
    &#34;&#34;&#34;
    return StatementStructureBuilder(
        enable_node_validation=enable_node_validation,
        node_validation_strict=strict_mode,
        node_validator=node_validator,
    )</code></pre>
</details>
<div class="desc"><p>Create a StatementStructureBuilder with optional node validation enabled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable_node_validation</code></strong></dt>
<dd>If True, validates node IDs during build.</dd>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, treats node validation failures as errors.</dd>
<dt><strong><code>node_validator</code></strong></dt>
<dd>Optional pre-configured UnifiedNodeValidator instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>StatementStructureBuilder instance with validation configured.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; builder = create_validated_statement_builder(
...     enable_node_validation=True,
...     strict_mode=False,  # Warnings only
... )
&gt;&gt;&gt; statement = builder.build(validated_config)
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.create_validated_statement_config"><code class="name flex">
<span>def <span class="ident">create_validated_statement_config</span></span>(<span>config_data:Â dict[str,Â typing.Any],<br>enable_node_validation:Â boolÂ =Â True,<br>strict_mode:Â boolÂ =Â False,<br>node_validator:Â <a title="fin_statement_model.statements.validation.UnifiedNodeValidator" href="validation.html#fin_statement_model.statements.validation.UnifiedNodeValidator">UnifiedNodeValidator</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.configs.validator.StatementConfig" href="configs/validator.html#fin_statement_model.statements.configs.validator.StatementConfig">StatementConfig</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_validated_statement_config(
    config_data: dict[str, Any],
    enable_node_validation: bool = True,
    strict_mode: bool = False,
    node_validator: UnifiedNodeValidator | None = None,
) -&gt; StatementConfig:
    &#34;&#34;&#34;Create a StatementConfig with optional node validation enabled.

    Args:
        config_data: Dictionary containing the raw configuration data.
        enable_node_validation: If True, validates node IDs using UnifiedNodeValidator.
        strict_mode: If True, treats node validation failures as errors.
        node_validator: Optional pre-configured UnifiedNodeValidator instance.

    Returns:
        StatementConfig instance with validation configured.

    Example:
        &gt;&gt;&gt; config_data = {...}  # Your YAML/JSON config as dict
        &gt;&gt;&gt; config = create_validated_statement_config(config_data, enable_node_validation=True, strict_mode=True)
        &gt;&gt;&gt; errors = config.validate_config()
        &gt;&gt;&gt; if errors:
        ...     print(&#34;Validation failed:&#34;, errors)
    &#34;&#34;&#34;
    return StatementConfig(
        config_data=config_data,
        enable_node_validation=enable_node_validation,
        node_validation_strict=strict_mode,
        node_validator=node_validator,
    )</code></pre>
</details>
<div class="desc"><p>Create a StatementConfig with optional node validation enabled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_data</code></strong></dt>
<dd>Dictionary containing the raw configuration data.</dd>
<dt><strong><code>enable_node_validation</code></strong></dt>
<dd>If True, validates node IDs using UnifiedNodeValidator.</dd>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, treats node validation failures as errors.</dd>
<dt><strong><code>node_validator</code></strong></dt>
<dd>Optional pre-configured UnifiedNodeValidator instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>StatementConfig instance with validation configured.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; config_data = {...}  # Your YAML/JSON config as dict
&gt;&gt;&gt; config = create_validated_statement_config(config_data, enable_node_validation=True, strict_mode=True)
&gt;&gt;&gt; errors = config.validate_config()
&gt;&gt;&gt; if errors:
...     print(&quot;Validation failed:&quot;, errors)
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.export_statements_to_excel"><code class="name flex">
<span>def <span class="ident">export_statements_to_excel</span></span>(<span>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>raw_configs:Â dict[str,Â dict[str,Â typing.Any]],<br>output_dir:Â str,<br>format_kwargs:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None,<br>writer_kwargs:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_statements_to_excel(
    graph: Graph,
    raw_configs: dict[str, dict[str, Any]],
    output_dir: str,
    format_kwargs: dict[str, Any] | None = None,
    writer_kwargs: dict[str, Any] | None = None,
) -&gt; None:
    &#34;&#34;&#34;Generate statement DataFrames and export them to individual Excel files.

    Loads configurations, builds statements, populates the graph (if necessary),
    generates DataFrames for each statement, and saves each DataFrame to a
    separate `.xlsx` file in the specified `output_dir`.

    Args:
        graph: The core.graph.Graph instance containing necessary data.
        raw_configs: Mapping of statement IDs to configuration dictionaries.
        output_dir: The directory where the resulting Excel files will be saved.
            File names will be derived from the statement IDs (e.g.,
            &#39;income_statement.xlsx&#39;).
        format_kwargs: Optional dictionary of arguments passed to
            `StatementFormatter.generate_dataframe` when creating the DataFrames.
        writer_kwargs: Optional dictionary of arguments passed to the underlying
            Excel writer (`write_statement_to_excel`), such as
            `sheet_name` or engine options.

    Raises:
        ConfigurationError: If loading or validating configurations fails.
        StatementError: If processing statements fails critically.
        TypeError: If `raw_configs` is not a valid mapping.
        WriteError: If writing any of the Excel files fails.
        FinancialModelError: Potentially other errors from graph operations.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.graph import Graph
        &gt;&gt;&gt; # Assume &#39;my_graph&#39; is a pre-populated Graph instance
        &gt;&gt;&gt; # Assume configs exist in &#39;./statement_configs/&#39;
        &gt;&gt;&gt; try:
        ...     export_statements_to_excel(
        ...         graph=my_graph,
        ...         raw_configs=my_configs,
        ...         output_dir=&#34;./output_excel/&#34;,
        ...         writer_kwargs={&#34;freeze_panes&#34;: (1, 1)},  # Freeze header row/col
        ...     )
        ...     # Use logger.info
        ...     logger.info(&#34;Statements exported to ./output_excel/&#34;)
        ... except (FileNotFoundError, ConfigurationError, StatementError, WriteError) as e:
        ...     # Use logger.error or logger.exception
        ...     logger.error(&#34;Export failed: %s&#34;, e)
    &#34;&#34;&#34;
    try:
        dfs = create_statement_dataframe(graph, raw_configs, format_kwargs or {})
    except FinancialModelError:
        logger.exception(&#34;Failed to generate statement DataFrames for Excel export:&#34;)
        raise

    export_statements(
        dfs=dfs,
        output_dir=output_dir,
        writer_func=write_statement_to_excel,
        writer_kwargs=writer_kwargs or {},
        file_suffix=&#34;.xlsx&#34;,
    )</code></pre>
</details>
<div class="desc"><p>Generate statement DataFrames and export them to individual Excel files.</p>
<p>Loads configurations, builds statements, populates the graph (if necessary),
generates DataFrames for each statement, and saves each DataFrame to a
separate <code>.xlsx</code> file in the specified <code>output_dir</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The core.graph.Graph instance containing necessary data.</dd>
<dt><strong><code>raw_configs</code></strong></dt>
<dd>Mapping of statement IDs to configuration dictionaries.</dd>
<dt><strong><code>output_dir</code></strong></dt>
<dd>The directory where the resulting Excel files will be saved.
File names will be derived from the statement IDs (e.g.,
'income_statement.xlsx').</dd>
<dt><strong><code>format_kwargs</code></strong></dt>
<dd>Optional dictionary of arguments passed to
<code><a title="fin_statement_model.statements.StatementFormatter.generate_dataframe" href="#fin_statement_model.statements.StatementFormatter.generate_dataframe">StatementFormatter.generate_dataframe()</a></code> when creating the DataFrames.</dd>
<dt><strong><code>writer_kwargs</code></strong></dt>
<dd>Optional dictionary of arguments passed to the underlying
Excel writer (<code>write_statement_to_excel</code>), such as
<code>sheet_name</code> or engine options.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.ConfigurationError" href="#fin_statement_model.statements.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If loading or validating configurations fails.</dd>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If processing statements fails critically.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>raw_configs</code> is not a valid mapping.</dd>
<dt><code>WriteError</code></dt>
<dd>If writing any of the Excel files fails.</dd>
<dt><code>FinancialModelError</code></dt>
<dd>Potentially other errors from graph operations.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.graph import Graph
&gt;&gt;&gt; # Assume 'my_graph' is a pre-populated Graph instance
&gt;&gt;&gt; # Assume configs exist in './statement_configs/'
&gt;&gt;&gt; try:
...     export_statements_to_excel(
...         graph=my_graph,
...         raw_configs=my_configs,
...         output_dir=&quot;./output_excel/&quot;,
...         writer_kwargs={&quot;freeze_panes&quot;: (1, 1)},  # Freeze header row/col
...     )
...     # Use logger.info
...     logger.info(&quot;Statements exported to ./output_excel/&quot;)
... except (FileNotFoundError, ConfigurationError, StatementError, WriteError) as e:
...     # Use logger.error or logger.exception
...     logger.error(&quot;Export failed: %s&quot;, e)
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.export_statements_to_json"><code class="name flex">
<span>def <span class="ident">export_statements_to_json</span></span>(<span>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>raw_configs:Â dict[str,Â dict[str,Â typing.Any]],<br>output_dir:Â str,<br>format_kwargs:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None,<br>writer_kwargs:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_statements_to_json(
    graph: Graph,
    raw_configs: dict[str, dict[str, Any]],
    output_dir: str,
    format_kwargs: dict[str, Any] | None = None,
    writer_kwargs: dict[str, Any] | None = None,
) -&gt; None:
    &#34;&#34;&#34;Generate statement DataFrames and export them to individual JSON files.

    Loads configurations, builds statements, populates the graph (if necessary),
    generates DataFrames for each statement, and saves each DataFrame to a
    separate `.json` file in the specified `output_dir`.

    Args:
        graph: The core.graph.Graph instance containing necessary data.
        raw_configs: Mapping of statement IDs to configuration dictionaries.
        output_dir: The directory where the resulting JSON files will be saved.
            File names will be derived from the statement IDs (e.g.,
            &#39;balance_sheet.json&#39;).
        format_kwargs: Optional dictionary of arguments passed to
            `StatementFormatter.generate_dataframe` when creating the DataFrames.
        writer_kwargs: Optional dictionary of arguments passed to the underlying
            JSON writer (`write_statement_to_json`). Common options
            include `orient` (e.g., &#39;records&#39;, &#39;columns&#39;, &#39;split&#39;) and `indent`.
            Defaults to &#39;records&#39; orient and indent=2 if not provided.

    Raises:
        ConfigurationError: If loading or validating configurations fails.
        StatementError: If processing statements fails critically.
        TypeError: If `raw_configs` is not a valid mapping.
        WriteError: If writing any of the JSON files fails.
        FinancialModelError: Potentially other errors from graph operations.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.graph import Graph
        &gt;&gt;&gt; # Assume &#39;my_graph&#39; is a pre-populated Graph instance
        &gt;&gt;&gt; # Assume configs exist in &#39;./statement_configs/&#39;
        &gt;&gt;&gt; try:
        ...     export_statements_to_json(
        ...         graph=my_graph,
        ...         raw_configs=my_configs,
        ...         output_dir=&#34;./output_json/&#34;,
        ...         writer_kwargs={&#34;orient&#34;: &#34;split&#34;, &#34;indent&#34;: 4},
        ...     )
        ...     # Use logger.info
        ...     logger.info(&#34;Statements exported to ./output_json/&#34;)
        ... except (FileNotFoundError, ConfigurationError, StatementError, WriteError) as e:
        ...     # Use logger.error or logger.exception
        ...     logger.error(&#34;Export failed: %s&#34;, e)
    &#34;&#34;&#34;
    final_writer_kwargs = writer_kwargs or {}
    # Set JSON specific defaults if not provided
    final_writer_kwargs.setdefault(&#34;orient&#34;, &#34;records&#34;)
    final_writer_kwargs.setdefault(&#34;indent&#34;, 2)

    try:
        dfs = create_statement_dataframe(graph, raw_configs, format_kwargs or {})
    except FinancialModelError:
        logger.exception(&#34;Failed to generate statement DataFrames for JSON export:&#34;)
        raise

    export_statements(
        dfs=dfs,
        output_dir=output_dir,
        writer_func=write_statement_to_json,
        writer_kwargs=final_writer_kwargs,
        file_suffix=&#34;.json&#34;,
    )</code></pre>
</details>
<div class="desc"><p>Generate statement DataFrames and export them to individual JSON files.</p>
<p>Loads configurations, builds statements, populates the graph (if necessary),
generates DataFrames for each statement, and saves each DataFrame to a
separate <code>.json</code> file in the specified <code>output_dir</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The core.graph.Graph instance containing necessary data.</dd>
<dt><strong><code>raw_configs</code></strong></dt>
<dd>Mapping of statement IDs to configuration dictionaries.</dd>
<dt><strong><code>output_dir</code></strong></dt>
<dd>The directory where the resulting JSON files will be saved.
File names will be derived from the statement IDs (e.g.,
'balance_sheet.json').</dd>
<dt><strong><code>format_kwargs</code></strong></dt>
<dd>Optional dictionary of arguments passed to
<code><a title="fin_statement_model.statements.StatementFormatter.generate_dataframe" href="#fin_statement_model.statements.StatementFormatter.generate_dataframe">StatementFormatter.generate_dataframe()</a></code> when creating the DataFrames.</dd>
<dt><strong><code>writer_kwargs</code></strong></dt>
<dd>Optional dictionary of arguments passed to the underlying
JSON writer (<code>write_statement_to_json</code>). Common options
include <code>orient</code> (e.g., 'records', 'columns', 'split') and <code>indent</code>.
Defaults to 'records' orient and indent=2 if not provided.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.ConfigurationError" href="#fin_statement_model.statements.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If loading or validating configurations fails.</dd>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If processing statements fails critically.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>raw_configs</code> is not a valid mapping.</dd>
<dt><code>WriteError</code></dt>
<dd>If writing any of the JSON files fails.</dd>
<dt><code>FinancialModelError</code></dt>
<dd>Potentially other errors from graph operations.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.graph import Graph
&gt;&gt;&gt; # Assume 'my_graph' is a pre-populated Graph instance
&gt;&gt;&gt; # Assume configs exist in './statement_configs/'
&gt;&gt;&gt; try:
...     export_statements_to_json(
...         graph=my_graph,
...         raw_configs=my_configs,
...         output_dir=&quot;./output_json/&quot;,
...         writer_kwargs={&quot;orient&quot;: &quot;split&quot;, &quot;indent&quot;: 4},
...     )
...     # Use logger.info
...     logger.info(&quot;Statements exported to ./output_json/&quot;)
... except (FileNotFoundError, ConfigurationError, StatementError, WriteError) as e:
...     # Use logger.error or logger.exception
...     logger.error(&quot;Export failed: %s&quot;, e)
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.list_available_builtin_configs"><code class="name flex">
<span>def <span class="ident">list_available_builtin_configs</span></span>(<span>) â€‘>Â list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_available_builtin_configs() -&gt; list[str]:
    &#34;&#34;&#34;Return the IDs of YAML configs bundled with ``fin_statement_model``.

    The library ships a small set of reference statement configurations in
    ``fin_statement_model/statements/configs``.  Each config is stored as a
    YAML file whose *stem* (filename without extension) serves as the public
    *statement_id* when loading the config.

    Returns:
        A list of available built-in statement IDs sorted alphabetically.
    &#34;&#34;&#34;
    cfg_dir = Path(__file__).parent / &#34;configs&#34;
    if not cfg_dir.exists():
        return []

    return sorted(p.stem for p in cfg_dir.glob(&#34;*.yaml&#34;))</code></pre>
</details>
<div class="desc"><p>Return the IDs of YAML configs bundled with <code><a title="fin_statement_model" href="../index.html">fin_statement_model</a></code>.</p>
<p>The library ships a small set of reference statement configurations in
<code>fin_statement_model/statements/configs</code>.
Each config is stored as a
YAML file whose <em>stem</em> (filename without extension) serves as the public
<em>statement_id</em> when loading the config.</p>
<h2 id="returns">Returns</h2>
<p>A list of available built-in statement IDs sorted alphabetically.</p></div>
</dd>
<dt id="fin_statement_model.statements.populate_graph_from_statement"><code class="name flex">
<span>def <span class="ident">populate_graph_from_statement</span></span>(<span>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>) â€‘>Â list[tuple[str,Â str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_graph_from_statement(statement: StatementStructure, graph: Graph) -&gt; list[tuple[str, str]]:
    &#34;&#34;&#34;Add calculation nodes defined in a StatementStructure to a Graph.

    This function bridges the gap between static statement definitions and the
    dynamic calculation graph. It processes three types of items:

    1. **CalculatedLineItem**: Creates calculation nodes with specified operations
    2. **SubtotalLineItem**: Creates addition nodes that sum multiple items
    3. **MetricLineItem**: Creates metric-based calculation nodes

    ID Resolution Logic:
    - Input IDs in statement configurations are resolved to graph node IDs using
      the `IDResolver` class
    - This handles the mapping between statement item IDs and actual graph nodes
    - Resolution accounts for LineItem.node_id vs other items using their ID directly

    Dependency Handling:
    - Items may depend on other items that haven&#39;t been created yet
    - The function uses a retry mechanism: failed items are retried after
      successful ones, allowing dependencies to be resolved
    - Circular dependencies are detected and reported as errors

    Idempotency:
    - If a node already exists in the graph, it will be skipped
    - This allows the function to be called multiple times safely

    Args:
        statement: The `StatementStructure` object containing the definitions
            of calculated items, subtotals, and metrics.
        graph: The `core.graph.Graph` instance that will be populated with
            the calculation nodes.

    Returns:
        A list of tuples, where each tuple contains `(item_id, error_message)`
        for any items that could not be successfully added to the graph. An
        empty list indicates that all applicable items were added (or already
        existed) without critical errors.

    Raises:
        TypeError: If `statement` is not a `StatementStructure` or `graph` is
            not a `Graph` instance.

    Example:
        &gt;&gt;&gt; from fin_statement_model.core.graph import Graph
        &gt;&gt;&gt; from fin_statement_model.statements.structure import StatementStructure
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Create graph with data nodes
        &gt;&gt;&gt; graph = Graph()
        &gt;&gt;&gt; graph.add_financial_statement_item(&#34;revenue_node&#34;, {&#34;2023&#34;: 1000})
        &gt;&gt;&gt; graph.add_financial_statement_item(&#34;cogs_node&#34;, {&#34;2023&#34;: 600})
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Create statement with calculations
        &gt;&gt;&gt; statement = StatementStructure(id=&#34;IS&#34;, name=&#34;Income Statement&#34;)
        &gt;&gt;&gt; # Add a LineItem that maps to &#39;revenue_node&#39;
        &gt;&gt;&gt; revenue_item = LineItem(id=&#34;revenue&#34;, name=&#34;Revenue&#34;, node_id=&#34;revenue_node&#34;)
        &gt;&gt;&gt; # Add a CalculatedLineItem that references the LineItem
        &gt;&gt;&gt; gross_profit = CalculatedLineItem(
        ...     id=&#34;gross_profit&#34;,
        ...     name=&#34;Gross Profit&#34;,
        ...     calculation_type=&#34;subtraction&#34;,
        ...     input_ids=[&#34;revenue&#34;, &#34;cogs&#34;],  # Uses LineItem IDs
        ... )
        &gt;&gt;&gt;
        &gt;&gt;&gt; errors = populate_graph_from_statement(statement, graph)
        &gt;&gt;&gt; # The function will:
        &gt;&gt;&gt; # 1. Resolve &#39;revenue&#39; to &#39;revenue_node&#39; via LineItem.node_id
        &gt;&gt;&gt; # 2. Resolve &#39;cogs&#39; to &#39;cogs_node&#39; (if it exists in statement or graph)
        &gt;&gt;&gt; # 3. Create a calculation node &#39;gross_profit&#39; with the resolved inputs
    &#34;&#34;&#34;
    # Validate inputs
    if not isinstance(statement, StatementStructure):
        raise TypeError(&#34;statement must be a StatementStructure instance&#34;)
    if not isinstance(graph, Graph):
        raise TypeError(&#34;graph must be a Graph instance&#34;)

    # Initialize components
    id_resolver = IDResolver(statement, standard_node_registry)
    processor_manager = ItemProcessorManager(id_resolver, graph, statement)

    # Get all items to process
    calculation_items = statement.get_calculation_items()
    metric_items = statement.get_metric_items()
    all_items_to_process = calculation_items + metric_items

    # Track results
    errors_encountered: list[tuple[str, str]] = []
    nodes_added_count = 0

    logger.info(
        &#34;Starting graph population for statement &#39;%s&#39;. Processing %s calculation/metric items.&#34;,
        statement.id,
        len(all_items_to_process),
    )

    # Process items with retry mechanism
    items_to_process = list(all_items_to_process)
    processed_in_pass = -1  # Initialize to enter loop

    while items_to_process and processed_in_pass != 0:
        items_failed_this_pass = []
        processed_in_pass = 0

        logger.debug(&#34;Population loop: Processing %s items...&#34;, len(items_to_process))

        for item in items_to_process:
            # Determine if this is a retry (not the first overall pass)
            is_retry = len(items_to_process) &lt; len(all_items_to_process)

            # Process the item
            result = processor_manager.process_item(item, is_retry)

            if result.success:
                processed_in_pass += 1
                if result.node_added:
                    nodes_added_count += 1
            else:
                items_failed_this_pass.append(item)
                # Only record errors on retry or for non-dependency errors
                if is_retry and result.error_message:
                    errors_encountered.append((item.id, result.error_message))

        # Prepare for next iteration
        items_to_process = items_failed_this_pass

        # Check for stalled progress
        if processed_in_pass == 0 and items_to_process:
            logger.warning(
                &#34;Population loop stalled. %s items could not be processed: %s&#34;,
                len(items_to_process),
                [item.id for item in items_to_process],
            )
            # Add errors for items that couldn&#39;t be processed
            for item in items_to_process:
                if not any(err[0] == item.id for err in errors_encountered):
                    errors_encountered.append((
                        item.id,
                        &#34;Failed to process due to unresolved dependencies or circular reference.&#34;,
                    ))
            break

    # Log results
    if errors_encountered:
        logger.warning(
            &#34;Graph population for statement &#39;%s&#39; completed with %s persistent errors.&#34;,
            statement.id,
            len(errors_encountered),
        )
    else:
        log_level = logging.INFO if nodes_added_count &gt; 0 else logging.DEBUG
        logger.log(
            log_level,
            &#34;Graph population for statement &#39;%s&#39; completed. Added %s new nodes.&#34;,
            statement.id,
            nodes_added_count,
        )

    return errors_encountered</code></pre>
</details>
<div class="desc"><p>Add calculation nodes defined in a StatementStructure to a Graph.</p>
<p>This function bridges the gap between static statement definitions and the
dynamic calculation graph. It processes three types of items:</p>
<ol>
<li><strong>CalculatedLineItem</strong>: Creates calculation nodes with specified operations</li>
<li><strong>SubtotalLineItem</strong>: Creates addition nodes that sum multiple items</li>
<li><strong>MetricLineItem</strong>: Creates metric-based calculation nodes</li>
</ol>
<p>ID Resolution Logic:
- Input IDs in statement configurations are resolved to graph node IDs using
the <code><a title="fin_statement_model.statements.IDResolver" href="#fin_statement_model.statements.IDResolver">IDResolver</a></code> class
- This handles the mapping between statement item IDs and actual graph nodes
- Resolution accounts for LineItem.node_id vs other items using their ID directly</p>
<p>Dependency Handling:
- Items may depend on other items that haven't been created yet
- The function uses a retry mechanism: failed items are retried after
successful ones, allowing dependencies to be resolved
- Circular dependencies are detected and reported as errors</p>
<p>Idempotency:
- If a node already exists in the graph, it will be skipped
- This allows the function to be called multiple times safely</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> object containing the definitions
of calculated items, subtotals, and metrics.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The <code>core.graph.Graph</code> instance that will be populated with
the calculation nodes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of tuples, where each tuple contains <code>(item_id, error_message)</code>
for any items that could not be successfully added to the graph. An
empty list indicates that all applicable items were added (or already
existed) without critical errors.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>statement</code> is not a <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> or <code>graph</code> is
not a <code>Graph</code> instance.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from fin_statement_model.core.graph import Graph
&gt;&gt;&gt; from fin_statement_model.statements.structure import StatementStructure
&gt;&gt;&gt;
&gt;&gt;&gt; # Create graph with data nodes
&gt;&gt;&gt; graph = Graph()
&gt;&gt;&gt; graph.add_financial_statement_item(&quot;revenue_node&quot;, {&quot;2023&quot;: 1000})
&gt;&gt;&gt; graph.add_financial_statement_item(&quot;cogs_node&quot;, {&quot;2023&quot;: 600})
&gt;&gt;&gt;
&gt;&gt;&gt; # Create statement with calculations
&gt;&gt;&gt; statement = StatementStructure(id=&quot;IS&quot;, name=&quot;Income Statement&quot;)
&gt;&gt;&gt; # Add a LineItem that maps to 'revenue_node'
&gt;&gt;&gt; revenue_item = LineItem(id=&quot;revenue&quot;, name=&quot;Revenue&quot;, node_id=&quot;revenue_node&quot;)
&gt;&gt;&gt; # Add a CalculatedLineItem that references the LineItem
&gt;&gt;&gt; gross_profit = CalculatedLineItem(
...     id=&quot;gross_profit&quot;,
...     name=&quot;Gross Profit&quot;,
...     calculation_type=&quot;subtraction&quot;,
...     input_ids=[&quot;revenue&quot;, &quot;cogs&quot;],  # Uses LineItem IDs
... )
&gt;&gt;&gt;
&gt;&gt;&gt; errors = populate_graph_from_statement(statement, graph)
&gt;&gt;&gt; # The function will:
&gt;&gt;&gt; # 1. Resolve 'revenue' to 'revenue_node' via LineItem.node_id
&gt;&gt;&gt; # 2. Resolve 'cogs' to 'cogs_node' (if it exists in statement or graph)
&gt;&gt;&gt; # 3. Create a calculation node 'gross_profit' with the resolved inputs
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.pretty_print_errors"><code class="name flex">
<span>def <span class="ident">pretty_print_errors</span></span>(<span>errors:Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_errors(errors: list[ErrorDetail]) -&gt; None:
    &#34;&#34;&#34;Pretty-print a list of ErrorDetail objects as a table to the console.

    Args:
        errors: List of ErrorDetail instances to display.
    &#34;&#34;&#34;
    if not errors:
        return

    # Prepare table headers
    headers = [&#34;SEVERITY&#34;, &#34;CODE&#34;, &#34;CONTEXT&#34;, &#34;SOURCE&#34;, &#34;MESSAGE&#34;]
    rows: list[list[str]] = [
        [
            err.severity.value.upper(),
            err.code,
            err.context or &#34;&#34;,
            err.source or &#34;&#34;,
            err.message,
        ]
        for err in errors
    ]

    # Calculate column widths
    col_widths = [max(len(str(val)) for val in col) for col in zip(headers, *rows, strict=False)]

    # Build header row and separator
    &#34; | &#34;.join(headers[i].ljust(col_widths[i]) for i in range(len(headers)))
    &#34;-+-&#34;.join(&#34;&#34;.ljust(col_widths[i], &#34;-&#34;) for i in range(len(headers)))

    # Print table
    for row in rows:
        &#34; | &#34;.join(str(row[i]).ljust(col_widths[i]) for i in range(len(headers)))</code></pre>
</details>
<div class="desc"><p>Pretty-print a list of ErrorDetail objects as a table to the console.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>errors</code></strong></dt>
<dd>List of ErrorDetail instances to display.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.retry_on_specific_errors"><code class="name flex">
<span>def <span class="ident">retry_on_specific_errors</span></span>(<span>operation:Â Callable[[],Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>retryable_errors:Â set[str],<br>max_attempts:Â intÂ |Â NoneÂ =Â None,<br>operation_name:Â strÂ |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_on_specific_errors(
    operation: Callable[[], Result[T]],
    retryable_errors: set[str],
    max_attempts: int | None = None,
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Retry an operation only for specific error codes.

    Args:
        operation: The operation to retry
        retryable_errors: Set of error codes that trigger retry
        max_attempts: Maximum number of attempts. If not provided, uses config default from api.api_retry_count
        operation_name: Optional name for logging

    Returns:
        RetryResult with the final outcome
    &#34;&#34;&#34;
    # Use config default if not provided
    max_attempts = cfg_or_param(&#34;api.api_retry_count&#34;, max_attempts)

    config = RetryConfig(
        max_attempts=max_attempts,
        strategy=RetryStrategy.CONDITIONAL,
        retryable_errors=retryable_errors,
        backoff=ExponentialBackoff(),
    )
    handler = RetryHandler(config)
    return handler.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Retry an operation only for specific error codes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>The operation to retry</dd>
<dt><strong><code>retryable_errors</code></strong></dt>
<dd>Set of error codes that trigger retry</dd>
<dt><strong><code>max_attempts</code></strong></dt>
<dd>Maximum number of attempts. If not provided, uses config default from api.api_retry_count</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult with the final outcome</p></div>
</dd>
<dt id="fin_statement_model.statements.retry_with_exponential_backoff"><code class="name flex">
<span>def <span class="ident">retry_with_exponential_backoff</span></span>(<span>operation:Â Callable[[],Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>max_attempts:Â intÂ |Â NoneÂ =Â None,<br>base_delay:Â floatÂ =Â 1.0,<br>operation_name:Â strÂ |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_with_exponential_backoff(
    operation: Callable[[], Result[T]],
    max_attempts: int | None = None,
    base_delay: float = 1.0,
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Retry an operation with exponential backoff.

    Args:
        operation: The operation to retry
        max_attempts: Maximum number of attempts. If not provided, uses config default from api.api_retry_count
        base_delay: Initial delay in seconds
        operation_name: Optional name for logging

    Returns:
        RetryResult with the final outcome
    &#34;&#34;&#34;
    # Use config default if not provided
    max_attempts = cfg_or_param(&#34;api.api_retry_count&#34;, max_attempts)

    config = RetryConfig(
        max_attempts=max_attempts,
        strategy=RetryStrategy.BACKOFF,
        backoff=ExponentialBackoff(base_delay=base_delay),
    )
    handler = RetryHandler(config)
    return handler.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Retry an operation with exponential backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>The operation to retry</dd>
<dt><strong><code>max_attempts</code></strong></dt>
<dd>Maximum number of attempts. If not provided, uses config default from api.api_retry_count</dd>
<dt><strong><code>base_delay</code></strong></dt>
<dd>Initial delay in seconds</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult with the final outcome</p></div>
</dd>
<dt id="fin_statement_model.statements.validate_statement_config_with_nodes"><code class="name flex">
<span>def <span class="ident">validate_statement_config_with_nodes</span></span>(<span>config_path_or_data:Â strÂ |Â dict[str,Â typing.Any],<br>strict_mode:Â boolÂ =Â False,<br>auto_standardize:Â boolÂ =Â True) â€‘>Â tuple[<a title="fin_statement_model.statements.configs.validator.StatementConfig" href="configs/validator.html#fin_statement_model.statements.configs.validator.StatementConfig">StatementConfig</a>,Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_statement_config_with_nodes(
    config_path_or_data: str | dict[str, Any],
    strict_mode: bool = False,
    auto_standardize: bool = True,
) -&gt; tuple[StatementConfig, list[ErrorDetail]]:
    &#34;&#34;&#34;Validate a statement configuration with comprehensive node validation.

    This is a high-level convenience function that handles the entire validation
    process including node ID validation.

    Args:
        config_path_or_data: Path to config file or config data dict.
        strict_mode: If True, treats node validation failures as errors.
        auto_standardize: If True, auto-standardize alternate node names.

    Returns:
        Tuple of (StatementConfig, validation_errors), where validation_errors is a list of ErrorDetail.
        If the list is empty, validation was successful.

    Example:
        &gt;&gt;&gt; config, errors = validate_statement_config_with_nodes(&#34;path/to/income_statement.yaml&#34;, strict_mode=True)
        &gt;&gt;&gt; if errors:
        ...     print(&#34;Validation failed:&#34;, errors)
        &gt;&gt;&gt; else:
        ...     print(&#34;Validation passed!&#34;)
    &#34;&#34;&#34;
    # File-based loading is no longer supported; only in-memory dicts
    if not isinstance(config_path_or_data, dict):
        raise ConfigurationError(
            message=&#34;File-based loading of statement configs is no longer supported; please pass a configuration dictionary.&#34;
        )
    config_data = config_path_or_data

    # Create validator
    node_validator = UnifiedNodeValidator(
        standard_node_registry,
        strict_mode=strict_mode,
        auto_standardize=auto_standardize,
        warn_on_non_standard=True,
        enable_patterns=True,
    )

    # Create and validate config
    config = StatementConfig(
        config_data=config_data,
        enable_node_validation=True,
        node_validation_strict=strict_mode,
        node_validator=node_validator,
    )

    errors = config.validate_config()
    return config, errors</code></pre>
</details>
<div class="desc"><p>Validate a statement configuration with comprehensive node validation.</p>
<p>This is a high-level convenience function that handles the entire validation
process including node ID validation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_path_or_data</code></strong></dt>
<dd>Path to config file or config data dict.</dd>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, treats node validation failures as errors.</dd>
<dt><strong><code>auto_standardize</code></strong></dt>
<dd>If True, auto-standardize alternate node names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (StatementConfig, validation_errors), where validation_errors is a list of ErrorDetail.
If the list is empty, validation was successful.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; config, errors = validate_statement_config_with_nodes(&quot;path/to/income_statement.yaml&quot;, strict_mode=True)
&gt;&gt;&gt; if errors:
...     print(&quot;Validation failed:&quot;, errors)
&gt;&gt;&gt; else:
...     print(&quot;Validation passed!&quot;)
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec"><code class="flex name class">
<span>class <span class="ident">AdjustmentFilterSpec</span></span>
<span>(</span><span>**data:Â Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdjustmentFilterSpec(BaseModel):
    &#34;&#34;&#34;Define an adjustment filter specification for configuration.

    This model represents the adjustment filter options that can be specified
    in configuration files. It maps to the core AdjustmentFilter model but
    uses serializable types suitable for YAML/JSON.

    Args:
        include_scenarios: Only include adjustments from these scenarios.
        exclude_scenarios: Exclude adjustments from these scenarios.
        include_tags: Include adjustments matching any of these tag prefixes.
        exclude_tags: Exclude adjustments matching any of these tag prefixes.
        require_all_tags: Include only adjustments having all these exact tags.
        include_types: Only include adjustments of these types.
        exclude_types: Exclude adjustments of these types.
        period: The specific period context for effective window checks.
    &#34;&#34;&#34;

    include_scenarios: list[str] | None = Field(None, description=&#34;Only include adjustments from these scenarios.&#34;)
    exclude_scenarios: list[str] | None = Field(None, description=&#34;Exclude adjustments from these scenarios.&#34;)
    include_tags: list[str] | None = Field(None, description=&#34;Include adjustments matching any of these tag prefixes.&#34;)
    exclude_tags: list[str] | None = Field(None, description=&#34;Exclude adjustments matching any of these tag prefixes.&#34;)
    require_all_tags: list[str] | None = Field(
        None, description=&#34;Include only adjustments having all these exact tags.&#34;
    )
    include_types: list[str] | None = Field(
        None,
        description=&#34;Only include adjustments of these types (additive, multiplicative, replacement).&#34;,
    )
    exclude_types: list[str] | None = Field(
        None,
        description=&#34;Exclude adjustments of these types (additive, multiplicative, replacement).&#34;,
    )
    period: str | None = Field(None, description=&#34;The specific period context for effective window checks.&#34;)

    @field_validator(&#34;include_types&#34;, &#34;exclude_types&#34;, mode=&#34;before&#34;)
    @classmethod
    def validate_adjustment_types(cls, value: list[str] | None) -&gt; list[str] | None:
        &#34;&#34;&#34;Validate adjustment types are valid.&#34;&#34;&#34;
        if value is not None:
            valid_types = {&#34;additive&#34;, &#34;multiplicative&#34;, &#34;replacement&#34;}
            for adj_type in value:
                if adj_type not in valid_types:
                    raise ValueError(f&#34;Invalid adjustment type &#39;{adj_type}&#39;. Must be one of: {valid_types}&#34;)
        return value

    model_config = ConfigDict(extra=&#34;forbid&#34;, frozen=True)</code></pre>
</details>
<div class="desc"><p>Define an adjustment filter specification for configuration.</p>
<p>This model represents the adjustment filter options that can be specified
in configuration files. It maps to the core AdjustmentFilter model but
uses serializable types suitable for YAML/JSON.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_scenarios</code></strong></dt>
<dd>Only include adjustments from these scenarios.</dd>
<dt><strong><code>exclude_scenarios</code></strong></dt>
<dd>Exclude adjustments from these scenarios.</dd>
<dt><strong><code>include_tags</code></strong></dt>
<dd>Include adjustments matching any of these tag prefixes.</dd>
<dt><strong><code>exclude_tags</code></strong></dt>
<dd>Exclude adjustments matching any of these tag prefixes.</dd>
<dt><strong><code>require_all_tags</code></strong></dt>
<dd>Include only adjustments having all these exact tags.</dd>
<dt><strong><code>include_types</code></strong></dt>
<dd>Only include adjustments of these types.</dd>
<dt><strong><code>exclude_types</code></strong></dt>
<dd>Exclude adjustments of these types.</dd>
<dt><strong><code>period</code></strong></dt>
<dd>The specific period context for effective window checks.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.exclude_scenarios"><code class="name">var <span class="ident">exclude_scenarios</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.exclude_tags"><code class="name">var <span class="ident">exclude_tags</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.exclude_types"><code class="name">var <span class="ident">exclude_types</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.include_scenarios"><code class="name">var <span class="ident">include_scenarios</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.include_tags"><code class="name">var <span class="ident">include_tags</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.include_types"><code class="name">var <span class="ident">include_types</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.period"><code class="name">var <span class="ident">period</span> :Â strÂ |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.require_all_tags"><code class="name">var <span class="ident">require_all_tags</span> :Â list[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.AdjustmentFilterSpec.validate_adjustment_types"><code class="name flex">
<span>def <span class="ident">validate_adjustment_types</span></span>(<span>value:Â list[str]Â |Â None) â€‘>Â list[str]Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Validate adjustment types are valid.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.BackoffStrategy"><code class="flex name class">
<span>class <span class="ident">BackoffStrategy</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackoffStrategy(ABC):
    &#34;&#34;&#34;Abstract base class for backoff strategies.&#34;&#34;&#34;

    @abstractmethod
    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Get delay in seconds for the given attempt number.

        Args:
            attempt: The attempt number (1-based)

        Returns:
            Delay in seconds before the next retry
        &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Abstract base class for backoff strategies.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.ConstantBackoff" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.ConstantBackoff">ConstantBackoff</a></li>
<li><a title="fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff">ExponentialBackoff</a></li>
<li><a title="fin_statement_model.statements.utilities.retry_handler.LinearBackoff" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.LinearBackoff">LinearBackoff</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.BackoffStrategy.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt:Â int) â€‘>Â float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Get delay in seconds for the given attempt number.

    Args:
        attempt: The attempt number (1-based)

    Returns:
        Delay in seconds before the next retry
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get delay in seconds for the given attempt number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attempt</code></strong></dt>
<dd>The attempt number (1-based)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Delay in seconds before the next retry</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.CalculatedItemProcessor"><code class="flex name class">
<span>class <span class="ident">CalculatedItemProcessor</span></span>
<span>(</span><span>id_resolver:Â <a title="fin_statement_model.statements.population.id_resolver.IDResolver" href="population/id_resolver.html#fin_statement_model.statements.population.id_resolver.IDResolver">IDResolver</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculatedItemProcessor(ItemProcessor):
    &#34;&#34;&#34;Processor for CalculatedLineItem objects.

    Handles the creation of calculation nodes with specific operations by:
    1. Resolving input IDs to graph nodes
    2. Getting sign conventions from input items
    3. Creating the calculation node with proper sign handling
    &#34;&#34;&#34;

    def can_process(self, item: StatementItem) -&gt; bool:
        &#34;&#34;&#34;Check if item is a CalculatedLineItem.&#34;&#34;&#34;
        return isinstance(item, CalculatedLineItem)

    def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
        &#34;&#34;&#34;Process a CalculatedLineItem and add it to the graph.&#34;&#34;&#34;
        if not isinstance(item, CalculatedLineItem):
            return ProcessorResult(success=False, error_message=&#34;Invalid item type&#34;)

        # Check if node already exists
        if self.graph.has_node(item.id):
            return ProcessorResult(success=True, node_added=False)

        # Command: create any needed signed nodes
        neg_base_ids: list[str] = []
        for input_id in item.input_ids:
            input_item = self.statement.find_item_by_id(input_id)
            if input_item and getattr(input_item, &#34;sign_convention&#34;, 1) == -1:
                node_id = self.id_resolver.resolve(input_id, self.graph)
                if node_id:
                    neg_base_ids.append(node_id)
        if neg_base_ids:
            self.graph.ensure_signed_nodes(neg_base_ids)

        # Query: resolve inputs without mutating graph
        resolved_inputs, missing = self._resolve_inputs(item)
        if missing:
            return self._handle_missing_inputs(item, missing, is_retry)

        # Add calculation node
        error_message = None
        try:
            self.graph.add_calculation(
                name=item.id,
                input_names=resolved_inputs,
                operation_type=item.calculation_type,
                **item.parameters,
            )
        except (
            NodeError,
            CircularDependencyError,
            CalculationError,
            ConfigurationError,
        ) as e:
            error_msg = f&#34;Failed to add calculation node &#39;{item.id}&#39;: {e}&#34;
            logger.exception(error_msg)
            error_message = str(e)
        except Exception as e:
            error_msg = f&#34;Unexpected error adding calculation node &#39;{item.id}&#39;: {e}&#34;
            logger.exception(error_msg)
            error_message = f&#34;Unexpected error: {e}&#34;

        if error_message:
            return ProcessorResult(success=False, error_message=error_message)
        return ProcessorResult(success=True, node_added=True)

    def _resolve_inputs(self, item: CalculatedLineItem) -&gt; tuple[list[str], list[tuple[str, str | None]]]:
        &#34;&#34;&#34;Resolve input IDs to graph node or signed-node IDs without side effects.

        Args:
            item: The CalculatedLineItem being processed.

        Returns:
            Tuple of (resolved_node_ids, missing_details).
        &#34;&#34;&#34;
        resolved: list[str] = []
        missing: list[tuple[str, str | None]] = []

        for input_id in item.input_ids:
            node_id = self.id_resolver.resolve(input_id, self.graph)
            # Missing base node
            if not node_id or not self.graph.has_node(node_id):
                missing.append((input_id, node_id))
                continue
            # Determine sign
            input_item = self.statement.find_item_by_id(input_id)
            sign = getattr(input_item, &#34;sign_convention&#34;, 1) if input_item else 1
            if sign == -1:
                signed_id = f&#34;{node_id}_signed&#34;
                # Represent signed node if exists, else missing
                if signed_id in self.graph.nodes:
                    resolved.append(signed_id)
                else:
                    missing.append((input_id, signed_id))
            else:
                resolved.append(node_id)
        return resolved, missing</code></pre>
</details>
<div class="desc"><p>Processor for CalculatedLineItem objects.</p>
<p>Handles the creation of calculation nodes with specific operations by:
1. Resolving input IDs to graph nodes
2. Getting sign conventions from input items
3. Creating the calculation node with proper sign handling</p>
<p>Initialize the processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_resolver</code></strong></dt>
<dd>ID resolver for mapping statement IDs to graph node IDs.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph to add nodes to.</dd>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure being processed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.population.item_processors.ItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor">ItemProcessor</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.CalculatedItemProcessor.can_process"><code class="name flex">
<span>def <span class="ident">can_process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_process(self, item: StatementItem) -&gt; bool:
    &#34;&#34;&#34;Check if item is a CalculatedLineItem.&#34;&#34;&#34;
    return isinstance(item, CalculatedLineItem)</code></pre>
</details>
<div class="desc"><p>Check if item is a CalculatedLineItem.</p></div>
</dd>
<dt id="fin_statement_model.statements.CalculatedItemProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>,<br>is_retry:Â boolÂ =Â False) â€‘>Â <a title="fin_statement_model.statements.population.item_processors.ProcessorResult" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ProcessorResult">ProcessorResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
    &#34;&#34;&#34;Process a CalculatedLineItem and add it to the graph.&#34;&#34;&#34;
    if not isinstance(item, CalculatedLineItem):
        return ProcessorResult(success=False, error_message=&#34;Invalid item type&#34;)

    # Check if node already exists
    if self.graph.has_node(item.id):
        return ProcessorResult(success=True, node_added=False)

    # Command: create any needed signed nodes
    neg_base_ids: list[str] = []
    for input_id in item.input_ids:
        input_item = self.statement.find_item_by_id(input_id)
        if input_item and getattr(input_item, &#34;sign_convention&#34;, 1) == -1:
            node_id = self.id_resolver.resolve(input_id, self.graph)
            if node_id:
                neg_base_ids.append(node_id)
    if neg_base_ids:
        self.graph.ensure_signed_nodes(neg_base_ids)

    # Query: resolve inputs without mutating graph
    resolved_inputs, missing = self._resolve_inputs(item)
    if missing:
        return self._handle_missing_inputs(item, missing, is_retry)

    # Add calculation node
    error_message = None
    try:
        self.graph.add_calculation(
            name=item.id,
            input_names=resolved_inputs,
            operation_type=item.calculation_type,
            **item.parameters,
        )
    except (
        NodeError,
        CircularDependencyError,
        CalculationError,
        ConfigurationError,
    ) as e:
        error_msg = f&#34;Failed to add calculation node &#39;{item.id}&#39;: {e}&#34;
        logger.exception(error_msg)
        error_message = str(e)
    except Exception as e:
        error_msg = f&#34;Unexpected error adding calculation node &#39;{item.id}&#39;: {e}&#34;
        logger.exception(error_msg)
        error_message = f&#34;Unexpected error: {e}&#34;

    if error_message:
        return ProcessorResult(success=False, error_message=error_message)
    return ProcessorResult(success=True, node_added=True)</code></pre>
</details>
<div class="desc"><p>Process a CalculatedLineItem and add it to the graph.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.population.item_processors.ItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor">ItemProcessor</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.population.item_processors.ItemProcessor.resolve_inputs" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor.resolve_inputs">resolve_inputs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.CalculatedLineItem"><code class="flex name class">
<span>class <span class="ident">CalculatedLineItem</span></span>
<span>(</span><span>id:Â str,<br>name:Â str,<br>calculation:Â dict[str,Â typing.Any],<br>description:Â strÂ =Â '',<br>sign_convention:Â intÂ =Â 1,<br>metadata:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None,<br>default_adjustment_filter:Â typing.AnyÂ |Â NoneÂ =Â None,<br>display_format:Â strÂ |Â NoneÂ =Â None,<br>hide_if_all_zero:Â boolÂ =Â False,<br>css_class:Â strÂ |Â NoneÂ =Â None,<br>notes_references:Â list[str]Â |Â NoneÂ =Â None,<br>units:Â strÂ |Â NoneÂ =Â None,<br>display_scale_factor:Â floatÂ |Â NoneÂ =Â None,<br>is_contra:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculatedLineItem(LineItem):
    &#34;&#34;&#34;Represents a calculated line item whose values come from graph calculations.

    Args:
      id: Unique ID (also used as node_id)
      name: Display name
      calculation: Dict with &#39;type&#39;, &#39;inputs&#39;, optional &#39;parameters&#39;
      description: Optional description
      sign_convention: 1 or -1
      metadata: Optional metadata
      default_adjustment_filter: Optional default adjustment filter for this item
      display_format: Optional specific number format string
      hide_if_all_zero: Whether to hide this item if all values are zero
      css_class: Optional CSS class name for HTML/web outputs
      notes_references: List of footnote/note IDs referenced by this item
      units: Optional unit description
      display_scale_factor: Factor to scale values for display
      is_contra: Whether this is a contra item for special display formatting

    Raises:
      StatementError: If calculation dictionary is invalid
    &#34;&#34;&#34;

    def __init__(
        self,
        id: str,
        name: str,
        calculation: dict[str, Any],
        description: str = &#34;&#34;,
        sign_convention: int = 1,
        metadata: dict[str, Any] | None = None,
        default_adjustment_filter: Any | None = None,
        display_format: str | None = None,
        hide_if_all_zero: bool = False,
        css_class: str | None = None,
        notes_references: list[str] | None = None,
        units: str | None = None,
        display_scale_factor: float | None = None,
        is_contra: bool = False,
    ):
        &#34;&#34;&#34;Initialize a CalculatedLineItem based on calculation specification.

        Args:
            id: Unique ID (also used as node_id).
            name: Display name.
            calculation: Calculation spec dict with &#39;type&#39;, &#39;inputs&#39;, optional &#39;parameters&#39;.
            description: Optional description.
            sign_convention: Sign convention (1 or -1).
            metadata: Optional metadata.
            default_adjustment_filter: Optional default adjustment filter for this item.
            display_format: Optional specific number format string.
            hide_if_all_zero: Whether to hide this item if all values are zero.
            css_class: Optional CSS class name for HTML/web outputs.
            notes_references: List of footnote/note IDs referenced by this item.
            units: Optional unit description.
            display_scale_factor: Factor to scale values for display.
                                If not provided, uses config default from display.scale_factor.
            is_contra: Whether this is a contra item for special display formatting.

        Raises:
            StatementError: If calculation dictionary is invalid.
        &#34;&#34;&#34;
        super().__init__(
            id=id,
            name=name,
            node_id=id,
            description=description,
            sign_convention=sign_convention,
            metadata=metadata,
            default_adjustment_filter=default_adjustment_filter,
            display_format=display_format,
            hide_if_all_zero=hide_if_all_zero,
            css_class=css_class,
            notes_references=notes_references,
            units=units,
            display_scale_factor=display_scale_factor,
            is_contra=is_contra,
        )
        if not isinstance(calculation, dict):
            raise StatementError(f&#34;Invalid calculation spec for item: {id}&#34;)
        if &#34;type&#34; not in calculation:
            raise StatementError(f&#34;Missing calculation type for item: {id}&#34;)
        inputs = calculation.get(&#34;inputs&#34;)
        if not isinstance(inputs, list) or not inputs:
            raise StatementError(f&#34;Calculation inputs must be a non-empty list for item: {id}&#34;)
        self._calculation = calculation

    @property
    def calculation_type(self) -&gt; str:
        &#34;&#34;&#34;Get the calculation operation type (e.g., &#39;addition&#39;).&#34;&#34;&#34;
        return cast(&#34;str&#34;, self._calculation[&#34;type&#34;])

    @property
    def input_ids(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the list of input item IDs for this calculation.&#34;&#34;&#34;
        return cast(&#34;list[str]&#34;, self._calculation[&#34;inputs&#34;])

    @property
    def parameters(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get optional parameters for the calculation.&#34;&#34;&#34;
        return cast(&#34;dict[str, Any]&#34;, self._calculation.get(&#34;parameters&#34;, {}))

    @property
    def item_type(self) -&gt; StatementItemType:
        &#34;&#34;&#34;Get the type of this item (CALCULATED).&#34;&#34;&#34;
        return StatementItemType.CALCULATED</code></pre>
</details>
<div class="desc"><p>Represents a calculated line item whose values come from graph calculations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique ID (also used as node_id)</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name</dd>
<dt><strong><code>calculation</code></strong></dt>
<dd>Dict with 'type', 'inputs', optional 'parameters'</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>1 or -1</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display</dd>
<dt><strong><code>is_contra</code></strong></dt>
<dd>Whether this is a contra item for special display formatting</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If calculation dictionary is invalid</dd>
</dl>
<p>Initialize a CalculatedLineItem based on calculation specification.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique ID (also used as node_id).</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name.</dd>
<dt><strong><code>calculation</code></strong></dt>
<dd>Calculation spec dict with 'type', 'inputs', optional 'parameters'.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description.</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>Sign convention (1 or -1).</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata.</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item.</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string.</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero.</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs.</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description.</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display.
If not provided, uses config default from display.scale_factor.</dd>
<dt><strong><code>is_contra</code></strong></dt>
<dd>Whether this is a contra item for special display formatting.</dd>
</dl>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If calculation dictionary is invalid.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.structure.items.LineItem" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem">LineItem</a></li>
<li><a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.structure.items.SubtotalLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.SubtotalLineItem">SubtotalLineItem</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.CalculatedLineItem.calculation_type"><code class="name">prop <span class="ident">calculation_type</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def calculation_type(self) -&gt; str:
    &#34;&#34;&#34;Get the calculation operation type (e.g., &#39;addition&#39;).&#34;&#34;&#34;
    return cast(&#34;str&#34;, self._calculation[&#34;type&#34;])</code></pre>
</details>
<div class="desc"><p>Get the calculation operation type (e.g., 'addition').</p></div>
</dd>
<dt id="fin_statement_model.statements.CalculatedLineItem.input_ids"><code class="name">prop <span class="ident">input_ids</span> :Â list[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_ids(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the list of input item IDs for this calculation.&#34;&#34;&#34;
    return cast(&#34;list[str]&#34;, self._calculation[&#34;inputs&#34;])</code></pre>
</details>
<div class="desc"><p>Get the list of input item IDs for this calculation.</p></div>
</dd>
<dt id="fin_statement_model.statements.CalculatedLineItem.item_type"><code class="name">prop <span class="ident">item_type</span> :Â <a title="fin_statement_model.statements.structure.items.StatementItemType" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItemType">StatementItemType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item_type(self) -&gt; StatementItemType:
    &#34;&#34;&#34;Get the type of this item (CALCULATED).&#34;&#34;&#34;
    return StatementItemType.CALCULATED</code></pre>
</details>
<div class="desc"><p>Get the type of this item (CALCULATED).</p></div>
</dd>
<dt id="fin_statement_model.statements.CalculatedLineItem.parameters"><code class="name">prop <span class="ident">parameters</span> :Â dict[str,Â typing.Any]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get optional parameters for the calculation.&#34;&#34;&#34;
    return cast(&#34;dict[str, Any]&#34;, self._calculation.get(&#34;parameters&#34;, {}))</code></pre>
</details>
<div class="desc"><p>Get optional parameters for the calculation.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.structure.items.LineItem" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem">LineItem</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.css_class" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.css_class">css_class</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.default_adjustment_filter" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.default_adjustment_filter">default_adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.description" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.display_format" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.display_format">display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.display_scale_factor" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.get_resolved_node_id" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.get_resolved_node_id">get_resolved_node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.hide_if_all_zero" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.hide_if_all_zero">hide_if_all_zero</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.id" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.is_contra" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.is_contra">is_contra</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.metadata" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.name" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.node_id" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.node_id">node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.notes_references" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.notes_references">notes_references</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.sign_convention" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.sign_convention">sign_convention</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.standard_node_ref" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.standard_node_ref">standard_node_ref</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.LineItem.units" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.units">units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.ConfigurationError"><code class="flex name class">
<span>class <span class="ident">ConfigurationError</span></span>
<span>(</span><span>message:Â str,<br>config_path:Â strÂ |Â NoneÂ =Â None,<br>errors:Â list[typing.Any]Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationError(FinancialModelError):
    &#34;&#34;&#34;Error raised for invalid configuration files or objects.

    This typically occurs when parsing or validating configuration data,
    such as YAML files defining metrics or statement structures.

    Examples:
        &gt;&gt;&gt; raise ConfigurationError(&#34;Invalid syntax&#34;, config_path=&#34;config.yaml&#34;)
        &gt;&gt;&gt; raise ConfigurationError(
        ...     &#34;Missing required fields&#34;, config_path=&#34;metrics.yaml&#34;, errors=[&#34;Missing &#39;formula&#39; for &#39;revenue&#39;&#34;]
        ... )
    &#34;&#34;&#34;

    def __init__(
        self,
        message: str,
        config_path: str | None = None,
        errors: list[Any] | None = None,
    ):
        &#34;&#34;&#34;Initialize the ConfigurationError.

        Args:
            message: The base error message.
            config_path: Optional path to the configuration file where the error occurred.
            errors: Optional list of specific validation errors found.
        &#34;&#34;&#34;
        self.config_path = config_path
        self.errors = errors or []

        if config_path and self.errors:
            full_message = f&#34;{message} in {config_path}: {&#39; ; &#39;.join(str(e) for e in self.errors)}&#34;
        elif config_path:
            full_message = f&#34;{message} in {config_path}&#34;
        elif self.errors:
            full_message = f&#34;{message}: {&#39; ; &#39;.join(str(e) for e in self.errors)}&#34;
        else:
            full_message = message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for invalid configuration files or objects.</p>
<p>This typically occurs when parsing or validating configuration data,
such as YAML files defining metrics or statement structures.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise ConfigurationError(&quot;Invalid syntax&quot;, config_path=&quot;config.yaml&quot;)
&gt;&gt;&gt; raise ConfigurationError(
...     &quot;Missing required fields&quot;, config_path=&quot;metrics.yaml&quot;, errors=[&quot;Missing 'formula' for 'revenue'&quot;]
... )
</code></pre>
<p>Initialize the ConfigurationError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>config_path</code></strong></dt>
<dd>Optional path to the configuration file where the error occurred.</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>Optional list of specific validation errors found.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.ConstantBackoff"><code class="flex name class">
<span>class <span class="ident">ConstantBackoff</span></span>
<span>(</span><span>delay:Â floatÂ =Â 1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstantBackoff(BackoffStrategy):
    &#34;&#34;&#34;Constant delay backoff strategy.&#34;&#34;&#34;

    def __init__(self, delay: float = 1.0):
        &#34;&#34;&#34;Initialize constant backoff.

        Args:
            delay: Constant delay in seconds
        &#34;&#34;&#34;
        self.delay = delay

    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Return constant delay.&#34;&#34;&#34;
        _ = attempt  # Parameter intentionally unused in constant backoff
        return self.delay</code></pre>
</details>
<div class="desc"><p>Constant delay backoff strategy.</p>
<p>Initialize constant backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delay</code></strong></dt>
<dd>Constant delay in seconds</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.ConstantBackoff.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt:Â int) â€‘>Â float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Return constant delay.&#34;&#34;&#34;
    _ = attempt  # Parameter intentionally unused in constant backoff
    return self.delay</code></pre>
</details>
<div class="desc"><p>Return constant delay.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.DataFetcher"><code class="flex name class">
<span>class <span class="ident">DataFetcher</span></span>
<span>(</span><span>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataFetcher:
    &#34;&#34;&#34;Fetches data from graph for statement formatting.

    This class encapsulates the logic for:
    - Resolving statement item IDs to graph node IDs
    - Fetching values from the graph with error handling
    - Applying adjustment filters if specified
    - Collecting errors and warnings during the process
    &#34;&#34;&#34;

    def __init__(self, statement: StatementStructure, graph: Graph):
        &#34;&#34;&#34;Initialize the data fetcher.

        Args:
            statement: The statement structure to fetch data for
            graph: The graph containing the data
        &#34;&#34;&#34;
        self.statement = statement
        self.graph = graph
        self.id_resolver = IDResolver(statement, standard_node_registry)

    def _resolve_adjustment_filter(
        self,
        item: StatementItem,
        global_filter: AdjustmentFilterInput | None = None,
    ) -&gt; AdjustmentFilterInput | None:
        &#34;&#34;&#34;Resolve which adjustment filter to use for an item.

        Precedence order:
        1. Global filter passed to fetch method (highest priority)
        2. Item&#39;s default adjustment filter
        3. Parent section&#39;s default adjustment filter
        4. None (no filter)

        Args:
            item: The statement item to get the filter for.
            global_filter: Optional global filter that overrides everything.

        Returns:
            The resolved adjustment filter to use, or None.
        &#34;&#34;&#34;
        # Global filter has highest priority
        if global_filter is not None:
            return global_filter

        # Check item&#39;s own default filter
        if hasattr(item, &#34;default_adjustment_filter&#34;) and item.default_adjustment_filter is not None:
            return cast(&#34;AdjustmentFilterInput&#34;, item.default_adjustment_filter)

        # Check parent section&#39;s default filter
        # We need to find which section contains this item
        parent_section = self._find_parent_section(item)
        if (
            parent_section
            and hasattr(parent_section, &#34;default_adjustment_filter&#34;)
            and parent_section.default_adjustment_filter is not None
        ):
            return cast(&#34;AdjustmentFilterInput&#34;, parent_section.default_adjustment_filter)

        # No filter
        return None

    def _find_parent_section(self, target_item: StatementItem) -&gt; Section | None:
        &#34;&#34;&#34;Find the parent section that contains the given item.

        Args:
            target_item: The item to find the parent section for.

        Returns:
            The parent Section object, or None if not found.
        &#34;&#34;&#34;

        def search_in_section(section: Section) -&gt; Section | None:
            # Check direct items
            for item in section.items:
                if item is target_item or (
                    hasattr(item, &#34;id&#34;) and hasattr(target_item, &#34;id&#34;) and item.id == target_item.id
                ):
                    return section
                # Check nested sections
                if isinstance(item, Section):
                    result = search_in_section(item)
                    if result:
                        return result

            # Check subtotal
            if hasattr(section, &#34;subtotal&#34;) and section.subtotal is target_item:
                return section

            return None

        # Search through all top-level sections
        for section in self.statement.sections:
            result = search_in_section(section)
            if result:
                return result

        return None

    def fetch_all_data(
        self,
        adjustment_filter: AdjustmentFilterInput | None = None,
        include_missing: bool = False,
    ) -&gt; FetchResult:
        &#34;&#34;&#34;Fetch data for all items in the statement.

        Args:
            adjustment_filter: Optional global filter for adjustments (overrides item defaults)
            include_missing: If True, include nodes that don&#39;t exist in graph
                           with NaN values

        Returns:
            FetchResult containing the fetched data and any errors
        &#34;&#34;&#34;
        error_collector = ErrorCollector()
        data: dict[str, dict[str, float]] = {}
        missing_nodes: list[str] = []

        # Check if graph has periods
        periods = self.graph.periods
        if not periods:
            error_collector.add_error(
                code=&#34;no_periods&#34;,
                message=f&#34;Graph has no periods defined for statement &#39;{self.statement.id}&#39;&#34;,
                source=self.statement.id,
            )
            return FetchResult(data={}, errors=error_collector, node_count=0, missing_nodes=[])

        logger.debug(&#34;Fetching data for statement &#39;%s&#39; across %s periods&#34;, self.statement.id, len(periods))

        # Get all items and resolve their node IDs
        all_items = self.statement.get_all_items()
        processed_node_ids = set()

        for item in all_items:
            # Resolve item ID to node ID
            node_id = self.id_resolver.resolve(item.id, self.graph)

            if not node_id:
                error_collector.add_warning(
                    code=&#34;unresolvable_item&#34;,
                    message=f&#34;Cannot resolve item &#39;{item.id}&#39; to a node ID&#34;,
                    source=item.id,
                    context=&#34;IDResolver.resolve&#34;,
                )
                continue

            if node_id in processed_node_ids:
                continue  # Skip already processed nodes

            processed_node_ids.add(node_id)

            # Resolve adjustment filter for this specific item
            item_filter = self._resolve_adjustment_filter(item, adjustment_filter)

            # Fetch data for this node
            node_result = self._fetch_node_data(node_id, periods, item_filter, item_id=item.id)

            if node_result.is_success():
                node_data = cast(&#34;NodeData&#34;, node_result.get_value())
                if node_data.has_data or include_missing:
                    data[node_id] = node_data.values

                # Add any warnings from node fetching
                for error in node_data.errors:
                    if error.severity == ErrorSeverity.WARNING:
                        error_collector.add_warning(
                            error.code,
                            error.message,
                            error.context,
                            error.source or item.id,
                        )
            else:
                # Node doesn&#39;t exist in graph
                missing_nodes.append(node_id)
                if include_missing:
                    # Fill with NaN values
                    data[node_id] = dict.fromkeys(periods, np.nan)

                error_collector.add_from_result(node_result, source=item.id)

        logger.info(
            &#34;Fetched data for %s nodes from statement &#39;%s&#39;. Missing: %s, Warnings: %s&#34;,
            len(data),
            self.statement.id,
            len(missing_nodes),
            len(error_collector.get_warnings()),
        )

        return FetchResult(
            data=data,
            errors=error_collector,
            node_count=len(data),
            missing_nodes=missing_nodes,
        )

    def _fetch_node_data(
        self,
        node_id: str,
        periods: list[str],
        adjustment_filter: AdjustmentFilterInput | None,
        item_id: str | None = None,
    ) -&gt; Result[NodeData]:
        &#34;&#34;&#34;Fetch data for a single node across all periods.

        Args:
            node_id: The graph node ID to fetch
            periods: List of periods to fetch
            adjustment_filter: Optional adjustment filter
            item_id: Optional statement item ID for error context

        Returns:
            Result containing NodeData or error details
        &#34;&#34;&#34;
        # Check if node exists
        if not self.graph.has_node(node_id):
            return Failure([
                ErrorDetail(
                    code=&#34;node_not_found&#34;,
                    message=f&#34;Node &#39;{node_id}&#39; not found in graph&#34;,
                    source=item_id or node_id,
                    severity=ErrorSeverity.WARNING,
                )
            ])

        values = {}
        is_adjusted = {}
        errors = []

        for period in periods:
            try:
                # Fetch value with optional adjustments
                raw_value = cast(
                    &#34;float&#34;,
                    self.graph.get_adjusted_value(
                        node_id,
                        period,
                        filter_input=adjustment_filter,
                        return_flag=False,  # Only need the value
                    ),
                )
                # Ensure value is float or NaN
                values[period] = float(raw_value) if pd.notna(raw_value) else np.nan
                is_adjusted[period] = bool(raw_value)

            except (NodeError, CalculationError) as e:
                # Expected errors - log as warning
                logger.warning(&#34;Error calculating node &#39;%s&#39; for period &#39;%s&#39;: %s&#34;, node_id, period, e)
                values[period] = np.nan
                is_adjusted[period] = False
                errors.append(
                    ErrorDetail(
                        code=&#34;calculation_error&#34;,
                        message=f&#34;Failed to calculate value: {e}&#34;,
                        context=f&#34;period={period}&#34;,
                        severity=ErrorSeverity.WARNING,
                        source=item_id or node_id,
                    )
                )

            except TypeError as e:
                # Filter/adjustment errors
                logger.warning(&#34;Type error for node &#39;%s&#39;, period &#39;%s&#39;: %s&#34;, node_id, period, e)
                values[period] = np.nan
                is_adjusted[period] = False
                errors.append(
                    ErrorDetail(
                        code=&#34;filter_error&#34;,
                        message=f&#34;Invalid adjustment filter: {e}&#34;,
                        context=f&#34;period={period}&#34;,
                        severity=ErrorSeverity.WARNING,
                        source=item_id or node_id,
                    )
                )

            except Exception as e:
                # Unexpected errors - log as error
                logger.exception(&#34;Unexpected error for node &#39;%s&#39;, period &#39;%s&#39;&#34;, node_id, period)
                values[period] = np.nan
                is_adjusted[period] = False
                errors.append(
                    ErrorDetail(
                        code=&#34;unexpected_error&#34;,
                        message=f&#34;Unexpected error: {e}&#34;,
                        context=f&#34;period={period}, error_type={type(e).__name__}&#34;,
                        severity=ErrorSeverity.ERROR,
                        source=item_id or node_id,
                    )
                )

        return Success(NodeData(node_id=node_id, values=values, is_adjusted=is_adjusted, errors=errors))

    def check_adjustments(
        self,
        node_ids: list[str],
        periods: list[str],
        adjustment_filter: AdjustmentFilterInput | None = None,
    ) -&gt; dict[str, dict[str, bool]]:
        &#34;&#34;&#34;Check which node/period combinations have adjustments.

        Args:
            node_ids: List of node IDs to check
            periods: List of periods to check
            adjustment_filter: Filter to check adjustments against

        Returns:
            Dict mapping node_id -&gt; period -&gt; was_adjusted boolean
        &#34;&#34;&#34;
        results = {}

        for node_id in node_ids:
            if not self.graph.has_node(node_id):
                results[node_id] = dict.fromkeys(periods, False)
                continue

            period_results = {}
            for period in periods:
                try:
                    was_adjusted = self.graph.was_adjusted(node_id, period, adjustment_filter)
                    period_results[period] = bool(was_adjusted)
                except (NodeError, CalculationError, ValueError) as exc:
                    logger.warning(&#34;Error checking adjustments for %s/%s: %s&#34;, node_id, period, exc)
                    period_results[period] = False

            results[node_id] = period_results

        return results</code></pre>
</details>
<div class="desc"><p>Fetches data from graph for statement formatting.</p>
<p>This class encapsulates the logic for:
- Resolving statement item IDs to graph node IDs
- Fetching values from the graph with error handling
- Applying adjustment filters if specified
- Collecting errors and warnings during the process</p>
<p>Initialize the data fetcher.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure to fetch data for</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph containing the data</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.DataFetcher.check_adjustments"><code class="name flex">
<span>def <span class="ident">check_adjustments</span></span>(<span>self,<br>node_ids:Â list[str],<br>periods:Â list[str],<br>adjustment_filter:Â <a title="fin_statement_model.core.adjustments.models.AdjustmentFilter" href="../core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentFilter">AdjustmentFilter</a>Â |Â set[str]Â |Â collections.abc.Callable[...,Â bool]Â |Â NoneÂ =Â None) â€‘>Â dict[str,Â dict[str,Â bool]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_adjustments(
    self,
    node_ids: list[str],
    periods: list[str],
    adjustment_filter: AdjustmentFilterInput | None = None,
) -&gt; dict[str, dict[str, bool]]:
    &#34;&#34;&#34;Check which node/period combinations have adjustments.

    Args:
        node_ids: List of node IDs to check
        periods: List of periods to check
        adjustment_filter: Filter to check adjustments against

    Returns:
        Dict mapping node_id -&gt; period -&gt; was_adjusted boolean
    &#34;&#34;&#34;
    results = {}

    for node_id in node_ids:
        if not self.graph.has_node(node_id):
            results[node_id] = dict.fromkeys(periods, False)
            continue

        period_results = {}
        for period in periods:
            try:
                was_adjusted = self.graph.was_adjusted(node_id, period, adjustment_filter)
                period_results[period] = bool(was_adjusted)
            except (NodeError, CalculationError, ValueError) as exc:
                logger.warning(&#34;Error checking adjustments for %s/%s: %s&#34;, node_id, period, exc)
                period_results[period] = False

        results[node_id] = period_results

    return results</code></pre>
</details>
<div class="desc"><p>Check which node/period combinations have adjustments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_ids</code></strong></dt>
<dd>List of node IDs to check</dd>
<dt><strong><code>periods</code></strong></dt>
<dd>List of periods to check</dd>
<dt><strong><code>adjustment_filter</code></strong></dt>
<dd>Filter to check adjustments against</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict mapping node_id -&gt; period -&gt; was_adjusted boolean</p></div>
</dd>
<dt id="fin_statement_model.statements.DataFetcher.fetch_all_data"><code class="name flex">
<span>def <span class="ident">fetch_all_data</span></span>(<span>self,<br>adjustment_filter:Â <a title="fin_statement_model.core.adjustments.models.AdjustmentFilter" href="../core/adjustments/models.html#fin_statement_model.core.adjustments.models.AdjustmentFilter">AdjustmentFilter</a>Â |Â set[str]Â |Â collections.abc.Callable[...,Â bool]Â |Â NoneÂ =Â None,<br>include_missing:Â boolÂ =Â False) â€‘>Â <a title="fin_statement_model.statements.formatting.data_fetcher.FetchResult" href="formatting/data_fetcher.html#fin_statement_model.statements.formatting.data_fetcher.FetchResult">FetchResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_all_data(
    self,
    adjustment_filter: AdjustmentFilterInput | None = None,
    include_missing: bool = False,
) -&gt; FetchResult:
    &#34;&#34;&#34;Fetch data for all items in the statement.

    Args:
        adjustment_filter: Optional global filter for adjustments (overrides item defaults)
        include_missing: If True, include nodes that don&#39;t exist in graph
                       with NaN values

    Returns:
        FetchResult containing the fetched data and any errors
    &#34;&#34;&#34;
    error_collector = ErrorCollector()
    data: dict[str, dict[str, float]] = {}
    missing_nodes: list[str] = []

    # Check if graph has periods
    periods = self.graph.periods
    if not periods:
        error_collector.add_error(
            code=&#34;no_periods&#34;,
            message=f&#34;Graph has no periods defined for statement &#39;{self.statement.id}&#39;&#34;,
            source=self.statement.id,
        )
        return FetchResult(data={}, errors=error_collector, node_count=0, missing_nodes=[])

    logger.debug(&#34;Fetching data for statement &#39;%s&#39; across %s periods&#34;, self.statement.id, len(periods))

    # Get all items and resolve their node IDs
    all_items = self.statement.get_all_items()
    processed_node_ids = set()

    for item in all_items:
        # Resolve item ID to node ID
        node_id = self.id_resolver.resolve(item.id, self.graph)

        if not node_id:
            error_collector.add_warning(
                code=&#34;unresolvable_item&#34;,
                message=f&#34;Cannot resolve item &#39;{item.id}&#39; to a node ID&#34;,
                source=item.id,
                context=&#34;IDResolver.resolve&#34;,
            )
            continue

        if node_id in processed_node_ids:
            continue  # Skip already processed nodes

        processed_node_ids.add(node_id)

        # Resolve adjustment filter for this specific item
        item_filter = self._resolve_adjustment_filter(item, adjustment_filter)

        # Fetch data for this node
        node_result = self._fetch_node_data(node_id, periods, item_filter, item_id=item.id)

        if node_result.is_success():
            node_data = cast(&#34;NodeData&#34;, node_result.get_value())
            if node_data.has_data or include_missing:
                data[node_id] = node_data.values

            # Add any warnings from node fetching
            for error in node_data.errors:
                if error.severity == ErrorSeverity.WARNING:
                    error_collector.add_warning(
                        error.code,
                        error.message,
                        error.context,
                        error.source or item.id,
                    )
        else:
            # Node doesn&#39;t exist in graph
            missing_nodes.append(node_id)
            if include_missing:
                # Fill with NaN values
                data[node_id] = dict.fromkeys(periods, np.nan)

            error_collector.add_from_result(node_result, source=item.id)

    logger.info(
        &#34;Fetched data for %s nodes from statement &#39;%s&#39;. Missing: %s, Warnings: %s&#34;,
        len(data),
        self.statement.id,
        len(missing_nodes),
        len(error_collector.get_warnings()),
    )

    return FetchResult(
        data=data,
        errors=error_collector,
        node_count=len(data),
        missing_nodes=missing_nodes,
    )</code></pre>
</details>
<div class="desc"><p>Fetch data for all items in the statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>adjustment_filter</code></strong></dt>
<dd>Optional global filter for adjustments (overrides item defaults)</dd>
<dt><strong><code>include_missing</code></strong></dt>
<dd>If True, include nodes that don't exist in graph
with NaN values</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>FetchResult containing the fetched data and any errors</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector"><code class="flex name class">
<span>class <span class="ident">ErrorCollector</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErrorCollector:
    &#34;&#34;&#34;Collects errors during multi-step operations.

    Useful for operations that should continue collecting errors
    rather than failing fast on the first error.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize an empty error collector.&#34;&#34;&#34;
        self._errors: list[ErrorDetail] = []
        self._warnings: list[ErrorDetail] = []

    def add_error(
        self,
        code: str,
        message: str,
        context: str | None = None,
        source: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add an error to the collector.&#34;&#34;&#34;
        self._errors.append(
            ErrorDetail(
                code=code,
                message=message,
                context=context,
                severity=ErrorSeverity.ERROR,
                source=source,
            )
        )

    def add_warning(
        self,
        code: str,
        message: str,
        context: str | None = None,
        source: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add a warning to the collector.&#34;&#34;&#34;
        self._warnings.append(
            ErrorDetail(
                code=code,
                message=message,
                context=context,
                severity=ErrorSeverity.WARNING,
                source=source,
            )
        )

    def add_from_result(self, result: Result[Any], source: str | None = None) -&gt; None:
        &#34;&#34;&#34;Add errors from a Result object.&#34;&#34;&#34;
        if result.is_failure():
            for error in result.get_errors():
                # Override source if provided
                if source:
                    new_error = ErrorDetail(
                        code=error.code,
                        message=error.message,
                        context=error.context,
                        severity=error.severity,
                        source=source,
                    )
                    if new_error.severity == ErrorSeverity.WARNING:
                        self._warnings.append(new_error)
                    else:
                        self._errors.append(new_error)
                elif error.severity == ErrorSeverity.WARNING:
                    self._warnings.append(error)
                else:
                    self._errors.append(error)

    def has_errors(self) -&gt; bool:
        &#34;&#34;&#34;Check if any errors have been collected.&#34;&#34;&#34;
        return len(self._errors) &gt; 0

    def has_warnings(self) -&gt; bool:
        &#34;&#34;&#34;Check if any warnings have been collected.&#34;&#34;&#34;
        return len(self._warnings) &gt; 0

    def get_errors(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Get all collected errors (not warnings).&#34;&#34;&#34;
        return list(self._errors)

    def get_warnings(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Get all collected warnings.&#34;&#34;&#34;
        return list(self._warnings)

    def get_all(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Get all collected errors and warnings.&#34;&#34;&#34;
        return self._errors + self._warnings

    def to_result(self, value: T | None = None) -&gt; Result[T]:
        &#34;&#34;&#34;Convert collector state to a Result.

        If there are errors, returns Failure.
        Otherwise returns Success with the provided value.
        &#34;&#34;&#34;
        if self.has_errors():
            return Failure(errors=self._errors)
        # Cast value to T for Success
        return Success(value=cast(&#34;T&#34;, value))

    def log_all(self, prefix: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Log all collected errors and warnings.&#34;&#34;&#34;
        for warning in self._warnings:
            logger.warning(&#34;%s%s&#34;, prefix, warning)
        for error in self._errors:
            logger.error(&#34;%s%s&#34;, prefix, error)</code></pre>
</details>
<div class="desc"><p>Collects errors during multi-step operations.</p>
<p>Useful for operations that should continue collecting errors
rather than failing fast on the first error.</p>
<p>Initialize an empty error collector.</p></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.ErrorCollector.add_error"><code class="name flex">
<span>def <span class="ident">add_error</span></span>(<span>self,<br>code:Â str,<br>message:Â str,<br>context:Â strÂ |Â NoneÂ =Â None,<br>source:Â strÂ |Â NoneÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_error(
    self,
    code: str,
    message: str,
    context: str | None = None,
    source: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Add an error to the collector.&#34;&#34;&#34;
    self._errors.append(
        ErrorDetail(
            code=code,
            message=message,
            context=context,
            severity=ErrorSeverity.ERROR,
            source=source,
        )
    )</code></pre>
</details>
<div class="desc"><p>Add an error to the collector.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.add_from_result"><code class="name flex">
<span>def <span class="ident">add_from_result</span></span>(<span>self,<br>result:Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[typing.Any],<br>source:Â strÂ |Â NoneÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_from_result(self, result: Result[Any], source: str | None = None) -&gt; None:
    &#34;&#34;&#34;Add errors from a Result object.&#34;&#34;&#34;
    if result.is_failure():
        for error in result.get_errors():
            # Override source if provided
            if source:
                new_error = ErrorDetail(
                    code=error.code,
                    message=error.message,
                    context=error.context,
                    severity=error.severity,
                    source=source,
                )
                if new_error.severity == ErrorSeverity.WARNING:
                    self._warnings.append(new_error)
                else:
                    self._errors.append(new_error)
            elif error.severity == ErrorSeverity.WARNING:
                self._warnings.append(error)
            else:
                self._errors.append(error)</code></pre>
</details>
<div class="desc"><p>Add errors from a Result object.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.add_warning"><code class="name flex">
<span>def <span class="ident">add_warning</span></span>(<span>self,<br>code:Â str,<br>message:Â str,<br>context:Â strÂ |Â NoneÂ =Â None,<br>source:Â strÂ |Â NoneÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_warning(
    self,
    code: str,
    message: str,
    context: str | None = None,
    source: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Add a warning to the collector.&#34;&#34;&#34;
    self._warnings.append(
        ErrorDetail(
            code=code,
            message=message,
            context=context,
            severity=ErrorSeverity.WARNING,
            source=source,
        )
    )</code></pre>
</details>
<div class="desc"><p>Add a warning to the collector.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Get all collected errors and warnings.&#34;&#34;&#34;
    return self._errors + self._warnings</code></pre>
</details>
<div class="desc"><p>Get all collected errors and warnings.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.get_errors"><code class="name flex">
<span>def <span class="ident">get_errors</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_errors(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Get all collected errors (not warnings).&#34;&#34;&#34;
    return list(self._errors)</code></pre>
</details>
<div class="desc"><p>Get all collected errors (not warnings).</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.get_warnings"><code class="name flex">
<span>def <span class="ident">get_warnings</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_warnings(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Get all collected warnings.&#34;&#34;&#34;
    return list(self._warnings)</code></pre>
</details>
<div class="desc"><p>Get all collected warnings.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.has_errors"><code class="name flex">
<span>def <span class="ident">has_errors</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_errors(self) -&gt; bool:
    &#34;&#34;&#34;Check if any errors have been collected.&#34;&#34;&#34;
    return len(self._errors) &gt; 0</code></pre>
</details>
<div class="desc"><p>Check if any errors have been collected.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.has_warnings"><code class="name flex">
<span>def <span class="ident">has_warnings</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_warnings(self) -&gt; bool:
    &#34;&#34;&#34;Check if any warnings have been collected.&#34;&#34;&#34;
    return len(self._warnings) &gt; 0</code></pre>
</details>
<div class="desc"><p>Check if any warnings have been collected.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.log_all"><code class="name flex">
<span>def <span class="ident">log_all</span></span>(<span>self, prefix:Â strÂ =Â '') â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_all(self, prefix: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;Log all collected errors and warnings.&#34;&#34;&#34;
    for warning in self._warnings:
        logger.warning(&#34;%s%s&#34;, prefix, warning)
    for error in self._errors:
        logger.error(&#34;%s%s&#34;, prefix, error)</code></pre>
</details>
<div class="desc"><p>Log all collected errors and warnings.</p></div>
</dd>
<dt id="fin_statement_model.statements.ErrorCollector.to_result"><code class="name flex">
<span>def <span class="ident">to_result</span></span>(<span>self, value:Â ~TÂ |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_result(self, value: T | None = None) -&gt; Result[T]:
    &#34;&#34;&#34;Convert collector state to a Result.

    If there are errors, returns Failure.
    Otherwise returns Success with the provided value.
    &#34;&#34;&#34;
    if self.has_errors():
        return Failure(errors=self._errors)
    # Cast value to T for Success
    return Success(value=cast(&#34;T&#34;, value))</code></pre>
</details>
<div class="desc"><p>Convert collector state to a Result.</p>
<p>If there are errors, returns Failure.
Otherwise returns Success with the provided value.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ErrorDetail"><code class="flex name class">
<span>class <span class="ident">ErrorDetail</span></span>
<span>(</span><span>code:Â str,<br>message:Â str,<br>context:Â strÂ |Â NoneÂ =Â None,<br>severity:Â <a title="fin_statement_model.statements.utilities.result_types.ErrorSeverity" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorSeverity">ErrorSeverity</a>Â =Â ErrorSeverity.ERROR,<br>source:Â strÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class ErrorDetail:
    &#34;&#34;&#34;Detailed information about an error.

    Attributes:
        code: Error code for programmatic handling
        message: Human-readable error message
        context: Optional context about where/what caused the error
        severity: Severity level of the error
        source: Optional source identifier (e.g., item ID, file path)
    &#34;&#34;&#34;

    code: str
    message: str
    context: str | None = None
    severity: ErrorSeverity = ErrorSeverity.ERROR
    source: str | None = None

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Format error as string.&#34;&#34;&#34;
        parts = [f&#34;[{self.severity.value.upper()}]&#34;]
        if self.source:
            parts.append(f&#34;{self.source}:&#34;)
        parts.append(self.message)
        if self.context:
            parts.append(f&#34;({self.context})&#34;)
        return &#34; &#34;.join(parts)</code></pre>
</details>
<div class="desc"><p>Detailed information about an error.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>code</code></strong></dt>
<dd>Error code for programmatic handling</dd>
<dt><strong><code>message</code></strong></dt>
<dd>Human-readable error message</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional context about where/what caused the error</dd>
<dt><strong><code>severity</code></strong></dt>
<dd>Severity level of the error</dd>
<dt><strong><code>source</code></strong></dt>
<dd>Optional source identifier (e.g., item ID, file path)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.ErrorDetail.code"><code class="name">var <span class="ident">code</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ErrorDetail.context"><code class="name">var <span class="ident">context</span> :Â strÂ |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ErrorDetail.message"><code class="name">var <span class="ident">message</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ErrorDetail.severity"><code class="name">var <span class="ident">severity</span> :Â <a title="fin_statement_model.statements.utilities.result_types.ErrorSeverity" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorSeverity">ErrorSeverity</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ErrorDetail.source"><code class="name">var <span class="ident">source</span> :Â strÂ |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ErrorSeverity"><code class="flex name class">
<span>class <span class="ident">ErrorSeverity</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErrorSeverity(Enum):
    &#34;&#34;&#34;Severity levels for errors.&#34;&#34;&#34;

    WARNING = &#34;warning&#34;
    ERROR = &#34;error&#34;
    CRITICAL = &#34;critical&#34;</code></pre>
</details>
<div class="desc"><p>Severity levels for errors.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.ErrorSeverity.CRITICAL"><code class="name">var <span class="ident">CRITICAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ErrorSeverity.ERROR"><code class="name">var <span class="ident">ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ErrorSeverity.WARNING"><code class="name">var <span class="ident">WARNING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ExponentialBackoff"><code class="flex name class">
<span>class <span class="ident">ExponentialBackoff</span></span>
<span>(</span><span>base_delay:Â floatÂ =Â 1.0,<br>max_delay:Â floatÂ =Â 60.0,<br>multiplier:Â floatÂ =Â 2.0,<br>jitter:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExponentialBackoff(BackoffStrategy):
    &#34;&#34;&#34;Exponential backoff strategy with optional jitter.&#34;&#34;&#34;

    def __init__(
        self,
        base_delay: float = 1.0,
        max_delay: float = 60.0,
        multiplier: float = 2.0,
        jitter: bool = True,
    ):
        &#34;&#34;&#34;Initialize exponential backoff.

        Args:
            base_delay: Initial delay in seconds
            max_delay: Maximum delay in seconds
            multiplier: Multiplier for each retry
            jitter: Whether to add random jitter
        &#34;&#34;&#34;
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.multiplier = multiplier
        self.jitter = jitter

    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Calculate exponential backoff delay.&#34;&#34;&#34;
        delay = min(self.base_delay * (self.multiplier ** (attempt - 1)), self.max_delay)

        if self.jitter:
            # Add up to 20% jitter (non-crypto randomness acceptable)
            jitter_factor = secrets.randbelow(10000) / 10000  # 0.0-0.9999
            jitter_amount = delay * 0.2 * jitter_factor
            delay += jitter_amount

        return delay</code></pre>
</details>
<div class="desc"><p>Exponential backoff strategy with optional jitter.</p>
<p>Initialize exponential backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_delay</code></strong></dt>
<dd>Initial delay in seconds</dd>
<dt><strong><code>max_delay</code></strong></dt>
<dd>Maximum delay in seconds</dd>
<dt><strong><code>multiplier</code></strong></dt>
<dd>Multiplier for each retry</dd>
<dt><strong><code>jitter</code></strong></dt>
<dd>Whether to add random jitter</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.ExponentialBackoff.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt:Â int) â€‘>Â float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Calculate exponential backoff delay.&#34;&#34;&#34;
    delay = min(self.base_delay * (self.multiplier ** (attempt - 1)), self.max_delay)

    if self.jitter:
        # Add up to 20% jitter (non-crypto randomness acceptable)
        jitter_factor = secrets.randbelow(10000) / 10000  # 0.0-0.9999
        jitter_amount = delay * 0.2 * jitter_factor
        delay += jitter_amount

    return delay</code></pre>
</details>
<div class="desc"><p>Calculate exponential backoff delay.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.Failure"><code class="flex name class">
<span>class <span class="ident">Failure</span></span>
<span>(</span><span>errors:Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]Â =Â &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Failure(Result[T]):
    &#34;&#34;&#34;Represents a failed operation result.&#34;&#34;&#34;

    errors: list[ErrorDetail] = field(default_factory=list)

    def __post_init__(self) -&gt; None:
        &#34;&#34;&#34;Ensure at least one error is present.&#34;&#34;&#34;
        if not self.errors:
            # Add a default error if none provided
            object.__setattr__(
                self,
                &#34;errors&#34;,
                [
                    ErrorDetail(
                        code=&#34;unknown&#34;,
                        message=&#34;Operation failed with no specific error&#34;,
                    )
                ],
            )

    def is_success(self) -&gt; bool:
        &#34;&#34;&#34;Always returns False for Failure.&#34;&#34;&#34;
        return False

    def is_failure(self) -&gt; bool:
        &#34;&#34;&#34;Always returns True for Failure.&#34;&#34;&#34;
        return True

    def get_value(self) -&gt; T | None:
        &#34;&#34;&#34;Always returns None for Failure.&#34;&#34;&#34;
        return None

    def get_errors(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Return the error details.&#34;&#34;&#34;
        return self.errors

    @classmethod
    def from_exception(cls, exc: Exception, code: str = &#34;exception&#34;) -&gt; &#34;Failure[T]&#34;:
        &#34;&#34;&#34;Create a Failure from an exception.&#34;&#34;&#34;
        return cls(
            errors=[
                ErrorDetail(
                    code=code,
                    message=str(exc),
                    context=type(exc).__name__,
                    severity=ErrorSeverity.ERROR,
                )
            ]
        )</code></pre>
</details>
<div class="desc"><p>Represents a failed operation result.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fin_statement_model.statements.Failure.from_exception"><code class="name flex">
<span>def <span class="ident">from_exception</span></span>(<span>exc:Â Exception, code:Â strÂ =Â 'exception') â€‘>Â <a title="fin_statement_model.statements.utilities.result_types.Failure" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Failure">Failure</a>[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Failure from an exception.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.Failure.errors"><code class="name">var <span class="ident">errors</span> :Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.Failure.get_errors"><code class="name flex">
<span>def <span class="ident">get_errors</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_errors(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Return the error details.&#34;&#34;&#34;
    return self.errors</code></pre>
</details>
<div class="desc"><p>Return the error details.</p></div>
</dd>
<dt id="fin_statement_model.statements.Failure.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self) â€‘>Â ~TÂ |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self) -&gt; T | None:
    &#34;&#34;&#34;Always returns None for Failure.&#34;&#34;&#34;
    return None</code></pre>
</details>
<div class="desc"><p>Always returns None for Failure.</p></div>
</dd>
<dt id="fin_statement_model.statements.Failure.is_failure"><code class="name flex">
<span>def <span class="ident">is_failure</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_failure(self) -&gt; bool:
    &#34;&#34;&#34;Always returns True for Failure.&#34;&#34;&#34;
    return True</code></pre>
</details>
<div class="desc"><p>Always returns True for Failure.</p></div>
</dd>
<dt id="fin_statement_model.statements.Failure.is_success"><code class="name flex">
<span>def <span class="ident">is_success</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_success(self) -&gt; bool:
    &#34;&#34;&#34;Always returns False for Failure.&#34;&#34;&#34;
    return False</code></pre>
</details>
<div class="desc"><p>Always returns False for Failure.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.utilities.result_types.Result.unwrap" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result.unwrap">unwrap</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.result_types.Result.unwrap_or" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result.unwrap_or">unwrap_or</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.FetchResult"><code class="flex name class">
<span>class <span class="ident">FetchResult</span></span>
<span>(</span><span>data:Â dict[str,Â dict[str,Â float]],<br>errors:Â <a title="fin_statement_model.statements.utilities.result_types.ErrorCollector" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorCollector">ErrorCollector</a>,<br>node_count:Â int,<br>missing_nodes:Â list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FetchResult:
    &#34;&#34;&#34;Result of fetching data for a statement.

    Attributes:
        data: Dict mapping node_id to period values
        errors: ErrorCollector with any errors/warnings
        node_count: Number of nodes successfully fetched
        missing_nodes: List of node IDs that couldn&#39;t be found
    &#34;&#34;&#34;

    data: dict[str, dict[str, float]]
    errors: ErrorCollector
    node_count: int
    missing_nodes: list[str]

    def to_result(self) -&gt; Result[dict[str, dict[str, float]]]:
        &#34;&#34;&#34;Convert to Result type.&#34;&#34;&#34;
        if self.errors.has_errors():
            return Failure(errors=self.errors.get_errors())
        return Success(value=self.data)</code></pre>
</details>
<div class="desc"><p>Result of fetching data for a statement.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dict mapping node_id to period values</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>ErrorCollector with any errors/warnings</dd>
<dt><strong><code>node_count</code></strong></dt>
<dd>Number of nodes successfully fetched</dd>
<dt><strong><code>missing_nodes</code></strong></dt>
<dd>List of node IDs that couldn't be found</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.FetchResult.data"><code class="name">var <span class="ident">data</span> :Â dict[str,Â dict[str,Â float]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.FetchResult.errors"><code class="name">var <span class="ident">errors</span> :Â <a title="fin_statement_model.statements.utilities.result_types.ErrorCollector" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorCollector">ErrorCollector</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.FetchResult.missing_nodes"><code class="name">var <span class="ident">missing_nodes</span> :Â list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.FetchResult.node_count"><code class="name">var <span class="ident">node_count</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.FetchResult.to_result"><code class="name flex">
<span>def <span class="ident">to_result</span></span>(<span>self) â€‘>Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[dict[str,Â dict[str,Â float]]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_result(self) -&gt; Result[dict[str, dict[str, float]]]:
    &#34;&#34;&#34;Convert to Result type.&#34;&#34;&#34;
    if self.errors.has_errors():
        return Failure(errors=self.errors.get_errors())
    return Success(value=self.data)</code></pre>
</details>
<div class="desc"><p>Convert to Result type.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.IDResolver"><code class="flex name class">
<span>class <span class="ident">IDResolver</span></span>
<span>(</span><span>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>,<br>registry:Â <a title="fin_statement_model.core.nodes.standard_registry.StandardNodeRegistry" href="../core/nodes/standard_registry.html#fin_statement_model.core.nodes.standard_registry.StandardNodeRegistry">StandardNodeRegistry</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IDResolver:
    &#34;&#34;&#34;Centralizes ID resolution from statement items to graph nodes.

    This class handles the complexity of mapping statement item IDs to graph
    node IDs, accounting for the fact that:
    - LineItems can have either a direct node_id property OR a standard_node_ref
      that gets resolved through the provided registry
    - Other items (CalculatedLineItem, SubtotalLineItem, MetricLineItem) use
      their ID directly as the node ID
    - Some nodes may exist directly in the graph without being statement items

    The resolver caches mappings for performance and provides both single and
    batch resolution methods. Standard node references are resolved at cache
    build time for optimal performance.
    &#34;&#34;&#34;

    def __init__(self, statement: StatementStructure, registry: StandardNodeRegistry):
        &#34;&#34;&#34;Initialize the resolver with a statement structure and a registry.

        Args:
            statement: The statement structure containing items to resolve.
            registry: The standard node registry for resolving references.
        &#34;&#34;&#34;
        self.statement = statement
        self._registry = registry
        self._item_to_node_cache: dict[str, str] = {}
        self._node_to_items_cache: dict[str, list[str]] = {}
        self._build_cache()

    def _build_cache(self) -&gt; None:
        &#34;&#34;&#34;Pre-build ID mappings for all items in the statement.&#34;&#34;&#34;
        logger.debug(&#34;Building ID cache for statement &#39;%s&#39;&#34;, self.statement.id)

        for item in self.statement.get_all_items():
            if isinstance(item, LineItem):
                # Get the resolved node ID (handles both direct node_id and standard_node_ref)
                resolved_node_id = item.get_resolved_node_id(self._registry)
                if resolved_node_id:
                    # LineItems map their ID to their resolved node_id
                    self._item_to_node_cache[item.id] = resolved_node_id
                    self._node_to_items_cache.setdefault(resolved_node_id, []).append(item.id)

                    # Log if using standard node reference for debugging
                    if item.standard_node_ref:
                        logger.debug(
                            &#34;Resolved standard node reference &#39;%s&#39; to &#39;%s&#39; for item &#39;%s&#39;&#34;,
                            item.standard_node_ref,
                            resolved_node_id,
                            item.id,
                        )
                else:
                    logger.warning(
                        &#34;Could not resolve node reference for LineItem &#39;%s&#39;. node_id: %s, standard_node_ref: %s&#34;,
                        item.id,
                        item.node_id,
                        item.standard_node_ref,
                    )
            else:
                # Other items use their ID directly as the node ID
                self._item_to_node_cache[item.id] = item.id
                self._node_to_items_cache.setdefault(item.id, []).append(item.id)

        logger.debug(
            &#34;ID cache built: %s item-&gt;node mappings, %s unique nodes&#34;,
            len(self._item_to_node_cache),
            len(self._node_to_items_cache),
        )

    def resolve(self, item_id: str, graph: Graph | None = None) -&gt; str | None:
        &#34;&#34;&#34;Resolve a statement item ID to its graph node ID.

        Resolution process:
        1. Check the pre-built cache for the item ID
        2. If not found and a graph is provided, check if the ID exists
           directly as a node in the graph
        3. Return None if not found anywhere

        Args:
            item_id: The statement item ID to resolve.
            graph: Optional graph to check for direct node existence.

        Returns:
            The resolved graph node ID if found, None otherwise.
        &#34;&#34;&#34;
        # Rebuild cache if it&#39;s empty (e.g., after invalidation)
        if not self._item_to_node_cache:
            self._build_cache()

        # Check cache first
        if item_id in self._item_to_node_cache:
            return self._item_to_node_cache[item_id]

        # Check if it exists directly in graph
        if graph and graph.has_node(item_id):
            # Cache this discovery for future lookups
            self._item_to_node_cache[item_id] = item_id
            self._node_to_items_cache.setdefault(item_id, []).append(item_id)
            return item_id

        return None

    def resolve_multiple(self, item_ids: list[str], graph: Graph | None = None) -&gt; dict[str, str | None]:
        &#34;&#34;&#34;Resolve multiple item IDs at once.

        Args:
            item_ids: List of statement item IDs to resolve.
            graph: Optional graph to check for direct node existence.

        Returns:
            Dictionary mapping each item ID to its resolved node ID (or None).
        &#34;&#34;&#34;
        return {item_id: self.resolve(item_id, graph) for item_id in item_ids}

    def get_items_for_node(self, node_id: str) -&gt; list[str]:
        &#34;&#34;&#34;Get all statement item IDs that map to a given node ID.

        This reverse lookup can be useful for debugging and understanding
        which statement items contribute to a particular graph node.

        Args:
            node_id: The graph node ID to look up.

        Returns:
            List of statement item IDs that map to this node (may be empty).
        &#34;&#34;&#34;
        # Rebuild cache if it&#39;s empty
        if not self._node_to_items_cache:
            self._build_cache()
        return self._node_to_items_cache.get(node_id, [])

    def get_all_mappings(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Get all item ID to node ID mappings.

        Returns:
            Dictionary of all cached mappings.
        &#34;&#34;&#34;
        # Rebuild cache if it&#39;s empty
        if not self._item_to_node_cache:
            self._build_cache()
        return self._item_to_node_cache.copy()

    def invalidate_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the cache, forcing a rebuild on next resolution.

        This should be called if the statement structure changes after
        the resolver was created.
        &#34;&#34;&#34;
        self._item_to_node_cache.clear()
        self._node_to_items_cache.clear()
        logger.debug(&#34;ID cache invalidated for statement &#39;%s&#39;&#34;, self.statement.id)

    def refresh_cache(self) -&gt; None:
        &#34;&#34;&#34;Rebuild the cache from the current statement structure.&#34;&#34;&#34;
        self.invalidate_cache()
        self._build_cache()</code></pre>
</details>
<div class="desc"><p>Centralizes ID resolution from statement items to graph nodes.</p>
<p>This class handles the complexity of mapping statement item IDs to graph
node IDs, accounting for the fact that:
- LineItems can have either a direct node_id property OR a standard_node_ref
that gets resolved through the provided registry
- Other items (CalculatedLineItem, SubtotalLineItem, MetricLineItem) use
their ID directly as the node ID
- Some nodes may exist directly in the graph without being statement items</p>
<p>The resolver caches mappings for performance and provides both single and
batch resolution methods. Standard node references are resolved at cache
build time for optimal performance.</p>
<p>Initialize the resolver with a statement structure and a registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure containing items to resolve.</dd>
<dt><strong><code>registry</code></strong></dt>
<dd>The standard node registry for resolving references.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.IDResolver.get_all_mappings"><code class="name flex">
<span>def <span class="ident">get_all_mappings</span></span>(<span>self) â€‘>Â dict[str,Â str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_mappings(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Get all item ID to node ID mappings.

    Returns:
        Dictionary of all cached mappings.
    &#34;&#34;&#34;
    # Rebuild cache if it&#39;s empty
    if not self._item_to_node_cache:
        self._build_cache()
    return self._item_to_node_cache.copy()</code></pre>
</details>
<div class="desc"><p>Get all item ID to node ID mappings.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary of all cached mappings.</p></div>
</dd>
<dt id="fin_statement_model.statements.IDResolver.get_items_for_node"><code class="name flex">
<span>def <span class="ident">get_items_for_node</span></span>(<span>self, node_id:Â str) â€‘>Â list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_items_for_node(self, node_id: str) -&gt; list[str]:
    &#34;&#34;&#34;Get all statement item IDs that map to a given node ID.

    This reverse lookup can be useful for debugging and understanding
    which statement items contribute to a particular graph node.

    Args:
        node_id: The graph node ID to look up.

    Returns:
        List of statement item IDs that map to this node (may be empty).
    &#34;&#34;&#34;
    # Rebuild cache if it&#39;s empty
    if not self._node_to_items_cache:
        self._build_cache()
    return self._node_to_items_cache.get(node_id, [])</code></pre>
</details>
<div class="desc"><p>Get all statement item IDs that map to a given node ID.</p>
<p>This reverse lookup can be useful for debugging and understanding
which statement items contribute to a particular graph node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The graph node ID to look up.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of statement item IDs that map to this node (may be empty).</p></div>
</dd>
<dt id="fin_statement_model.statements.IDResolver.invalidate_cache"><code class="name flex">
<span>def <span class="ident">invalidate_cache</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the cache, forcing a rebuild on next resolution.

    This should be called if the statement structure changes after
    the resolver was created.
    &#34;&#34;&#34;
    self._item_to_node_cache.clear()
    self._node_to_items_cache.clear()
    logger.debug(&#34;ID cache invalidated for statement &#39;%s&#39;&#34;, self.statement.id)</code></pre>
</details>
<div class="desc"><p>Clear the cache, forcing a rebuild on next resolution.</p>
<p>This should be called if the statement structure changes after
the resolver was created.</p></div>
</dd>
<dt id="fin_statement_model.statements.IDResolver.refresh_cache"><code class="name flex">
<span>def <span class="ident">refresh_cache</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_cache(self) -&gt; None:
    &#34;&#34;&#34;Rebuild the cache from the current statement structure.&#34;&#34;&#34;
    self.invalidate_cache()
    self._build_cache()</code></pre>
</details>
<div class="desc"><p>Rebuild the cache from the current statement structure.</p></div>
</dd>
<dt id="fin_statement_model.statements.IDResolver.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self,<br>item_id:Â str,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>Â |Â NoneÂ =Â None) â€‘>Â strÂ |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve(self, item_id: str, graph: Graph | None = None) -&gt; str | None:
    &#34;&#34;&#34;Resolve a statement item ID to its graph node ID.

    Resolution process:
    1. Check the pre-built cache for the item ID
    2. If not found and a graph is provided, check if the ID exists
       directly as a node in the graph
    3. Return None if not found anywhere

    Args:
        item_id: The statement item ID to resolve.
        graph: Optional graph to check for direct node existence.

    Returns:
        The resolved graph node ID if found, None otherwise.
    &#34;&#34;&#34;
    # Rebuild cache if it&#39;s empty (e.g., after invalidation)
    if not self._item_to_node_cache:
        self._build_cache()

    # Check cache first
    if item_id in self._item_to_node_cache:
        return self._item_to_node_cache[item_id]

    # Check if it exists directly in graph
    if graph and graph.has_node(item_id):
        # Cache this discovery for future lookups
        self._item_to_node_cache[item_id] = item_id
        self._node_to_items_cache.setdefault(item_id, []).append(item_id)
        return item_id

    return None</code></pre>
</details>
<div class="desc"><p>Resolve a statement item ID to its graph node ID.</p>
<p>Resolution process:
1. Check the pre-built cache for the item ID
2. If not found and a graph is provided, check if the ID exists
directly as a node in the graph
3. Return None if not found anywhere</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The statement item ID to resolve.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>Optional graph to check for direct node existence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resolved graph node ID if found, None otherwise.</p></div>
</dd>
<dt id="fin_statement_model.statements.IDResolver.resolve_multiple"><code class="name flex">
<span>def <span class="ident">resolve_multiple</span></span>(<span>self,<br>item_ids:Â list[str],<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>Â |Â NoneÂ =Â None) â€‘>Â dict[str,Â strÂ |Â None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_multiple(self, item_ids: list[str], graph: Graph | None = None) -&gt; dict[str, str | None]:
    &#34;&#34;&#34;Resolve multiple item IDs at once.

    Args:
        item_ids: List of statement item IDs to resolve.
        graph: Optional graph to check for direct node existence.

    Returns:
        Dictionary mapping each item ID to its resolved node ID (or None).
    &#34;&#34;&#34;
    return {item_id: self.resolve(item_id, graph) for item_id in item_ids}</code></pre>
</details>
<div class="desc"><p>Resolve multiple item IDs at once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_ids</code></strong></dt>
<dd>List of statement item IDs to resolve.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>Optional graph to check for direct node existence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping each item ID to its resolved node ID (or None).</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ItemProcessor"><code class="flex name class">
<span>class <span class="ident">ItemProcessor</span></span>
<span>(</span><span>id_resolver:Â <a title="fin_statement_model.statements.population.id_resolver.IDResolver" href="population/id_resolver.html#fin_statement_model.statements.population.id_resolver.IDResolver">IDResolver</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemProcessor(ABC):
    &#34;&#34;&#34;Abstract base class for processing statement items into graph nodes.

    This base class provides common functionality for resolving input IDs
    and handling missing inputs across different item types.
    &#34;&#34;&#34;

    def __init__(self, id_resolver: IDResolver, graph: Graph, statement: StatementStructure):
        &#34;&#34;&#34;Initialize the processor.

        Args:
            id_resolver: ID resolver for mapping statement IDs to graph node IDs.
            graph: The graph to add nodes to.
            statement: The statement structure being processed.
        &#34;&#34;&#34;
        self.id_resolver = id_resolver
        self.graph = graph
        self.statement = statement

    @abstractmethod
    def can_process(self, item: StatementItem) -&gt; bool:
        &#34;&#34;&#34;Check if this processor can handle the given item type.

        Args:
            item: The statement item to check.

        Returns:
            True if this processor can handle the item type.
        &#34;&#34;&#34;

    @abstractmethod
    def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
        &#34;&#34;&#34;Process the item and add it to the graph if needed.

        Args:
            item: The statement item to process.
            is_retry: Whether this is a retry attempt (affects error logging).

        Returns:
            ProcessorResult indicating success/failure and details.
        &#34;&#34;&#34;

    def resolve_inputs(self, input_ids: list[str]) -&gt; tuple[list[str], list[tuple[str, str | None]]]:
        &#34;&#34;&#34;Resolve input IDs to graph node IDs.

        Args:
            input_ids: List of statement item IDs to resolve.

        Returns:
            Tuple of (resolved_node_ids, missing_details).
            missing_details contains tuples of (item_id, resolved_node_id_or_none).
        &#34;&#34;&#34;
        resolved = []
        missing = []

        for input_id in input_ids:
            node_id = self.id_resolver.resolve(input_id, self.graph)
            if node_id and self.graph.has_node(node_id):
                resolved.append(node_id)
            else:
                missing.append((input_id, node_id))

        return resolved, missing

    def _handle_missing_inputs(
        self,
        item: StatementItem,
        missing: list[tuple[str, str | None]],
        is_retry: bool,
    ) -&gt; ProcessorResult:
        &#34;&#34;&#34;Handle missing input nodes consistently across processors.

        Args:
            item: The item being processed.
            missing: List of missing input details.
            is_retry: Whether this is a retry attempt.

        Returns:
            ProcessorResult with appropriate error details.
        &#34;&#34;&#34;
        missing_summary = [
            (f&#34;item &#39;{i_id}&#39; needs node &#39;{n_id}&#39;&#34; if n_id else f&#34;item &#39;{i_id}&#39; not found/mappable&#34;)
            for i_id, n_id in missing
        ]

        if is_retry:
            logger.error(
                &#34;Retry failed for %s &#39;%s&#39; in statement &#39;%s&#39;: missing required inputs: %s&#34;,
                type(item).__name__,
                item.id,
                self.statement.id,
                &#34;; &#34;.join(missing_summary),
            )
            return ProcessorResult(
                success=False,
                error_message=f&#34;Missing inputs on retry: {missing_summary}&#34;,
                missing_inputs=missing,
            )
        else:
            # Don&#39;t log on first attempt - allows dependency resolution
            return ProcessorResult(success=False, missing_inputs=missing)</code></pre>
</details>
<div class="desc"><p>Abstract base class for processing statement items into graph nodes.</p>
<p>This base class provides common functionality for resolving input IDs
and handling missing inputs across different item types.</p>
<p>Initialize the processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_resolver</code></strong></dt>
<dd>ID resolver for mapping statement IDs to graph node IDs.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph to add nodes to.</dd>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure being processed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.population.item_processors.CalculatedItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.CalculatedItemProcessor">CalculatedItemProcessor</a></li>
<li><a title="fin_statement_model.statements.population.item_processors.MetricItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.MetricItemProcessor">MetricItemProcessor</a></li>
<li><a title="fin_statement_model.statements.population.item_processors.SubtotalItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.SubtotalItemProcessor">SubtotalItemProcessor</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.ItemProcessor.can_process"><code class="name flex">
<span>def <span class="ident">can_process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def can_process(self, item: StatementItem) -&gt; bool:
    &#34;&#34;&#34;Check if this processor can handle the given item type.

    Args:
        item: The statement item to check.

    Returns:
        True if this processor can handle the item type.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Check if this processor can handle the given item type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>The statement item to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if this processor can handle the item type.</p></div>
</dd>
<dt id="fin_statement_model.statements.ItemProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>,<br>is_retry:Â boolÂ =Â False) â€‘>Â <a title="fin_statement_model.statements.population.item_processors.ProcessorResult" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ProcessorResult">ProcessorResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
    &#34;&#34;&#34;Process the item and add it to the graph if needed.

    Args:
        item: The statement item to process.
        is_retry: Whether this is a retry attempt (affects error logging).

    Returns:
        ProcessorResult indicating success/failure and details.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Process the item and add it to the graph if needed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>The statement item to process.</dd>
<dt><strong><code>is_retry</code></strong></dt>
<dd>Whether this is a retry attempt (affects error logging).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ProcessorResult indicating success/failure and details.</p></div>
</dd>
<dt id="fin_statement_model.statements.ItemProcessor.resolve_inputs"><code class="name flex">
<span>def <span class="ident">resolve_inputs</span></span>(<span>self, input_ids:Â list[str]) â€‘>Â tuple[list[str],Â list[tuple[str,Â strÂ |Â None]]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_inputs(self, input_ids: list[str]) -&gt; tuple[list[str], list[tuple[str, str | None]]]:
    &#34;&#34;&#34;Resolve input IDs to graph node IDs.

    Args:
        input_ids: List of statement item IDs to resolve.

    Returns:
        Tuple of (resolved_node_ids, missing_details).
        missing_details contains tuples of (item_id, resolved_node_id_or_none).
    &#34;&#34;&#34;
    resolved = []
    missing = []

    for input_id in input_ids:
        node_id = self.id_resolver.resolve(input_id, self.graph)
        if node_id and self.graph.has_node(node_id):
            resolved.append(node_id)
        else:
            missing.append((input_id, node_id))

    return resolved, missing</code></pre>
</details>
<div class="desc"><p>Resolve input IDs to graph node IDs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_ids</code></strong></dt>
<dd>List of statement item IDs to resolve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (resolved_node_ids, missing_details).
missing_details contains tuples of (item_id, resolved_node_id_or_none).</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ItemProcessorManager"><code class="flex name class">
<span>class <span class="ident">ItemProcessorManager</span></span>
<span>(</span><span>id_resolver:Â <a title="fin_statement_model.statements.population.id_resolver.IDResolver" href="population/id_resolver.html#fin_statement_model.statements.population.id_resolver.IDResolver">IDResolver</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemProcessorManager:
    &#34;&#34;&#34;Manages the collection of item processors.

    This class coordinates the processing of different statement item types
    by delegating to the appropriate processor based on the item type.
    &#34;&#34;&#34;

    def __init__(self, id_resolver: IDResolver, graph: Graph, statement: StatementStructure):
        &#34;&#34;&#34;Initialize the processor manager with all available processors.

        Args:
            id_resolver: ID resolver for mapping statement IDs to graph node IDs.
            graph: The graph to add nodes to.
            statement: The statement structure being processed.
        &#34;&#34;&#34;
        self.processors = [
            MetricItemProcessor(id_resolver, graph, statement),
            CalculatedItemProcessor(id_resolver, graph, statement),
            SubtotalItemProcessor(id_resolver, graph, statement),
        ]

    def process_item(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
        &#34;&#34;&#34;Process a statement item using the appropriate processor.

        Args:
            item: The statement item to process.
            is_retry: Whether this is a retry attempt.

        Returns:
            ProcessorResult from the appropriate processor, or a success result
            if no processor handles the item type (e.g., for LineItem).
        &#34;&#34;&#34;
        for processor in self.processors:
            if processor.can_process(item):
                return processor.process(item, is_retry)

        # No processor found - this is OK for non-calculation items like LineItem
        logger.debug(
            &#34;No processor for item type %s with ID &#39;%s&#39;. This is expected for non-calculation items.&#34;,
            type(item).__name__,
            item.id,
        )
        return ProcessorResult(success=True, node_added=False)</code></pre>
</details>
<div class="desc"><p>Manages the collection of item processors.</p>
<p>This class coordinates the processing of different statement item types
by delegating to the appropriate processor based on the item type.</p>
<p>Initialize the processor manager with all available processors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_resolver</code></strong></dt>
<dd>ID resolver for mapping statement IDs to graph node IDs.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph to add nodes to.</dd>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure being processed.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.ItemProcessorManager.process_item"><code class="name flex">
<span>def <span class="ident">process_item</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>,<br>is_retry:Â boolÂ =Â False) â€‘>Â <a title="fin_statement_model.statements.population.item_processors.ProcessorResult" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ProcessorResult">ProcessorResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_item(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
    &#34;&#34;&#34;Process a statement item using the appropriate processor.

    Args:
        item: The statement item to process.
        is_retry: Whether this is a retry attempt.

    Returns:
        ProcessorResult from the appropriate processor, or a success result
        if no processor handles the item type (e.g., for LineItem).
    &#34;&#34;&#34;
    for processor in self.processors:
        if processor.can_process(item):
            return processor.process(item, is_retry)

    # No processor found - this is OK for non-calculation items like LineItem
    logger.debug(
        &#34;No processor for item type %s with ID &#39;%s&#39;. This is expected for non-calculation items.&#34;,
        type(item).__name__,
        item.id,
    )
    return ProcessorResult(success=True, node_added=False)</code></pre>
</details>
<div class="desc"><p>Process a statement item using the appropriate processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>The statement item to process.</dd>
<dt><strong><code>is_retry</code></strong></dt>
<dd>Whether this is a retry attempt.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ProcessorResult from the appropriate processor, or a success result
if no processor handles the item type (e.g., for LineItem).</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.LineItem"><code class="flex name class">
<span>class <span class="ident">LineItem</span></span>
<span>(</span><span>id:Â str,<br>name:Â str,<br>node_id:Â strÂ |Â NoneÂ =Â None,<br>standard_node_ref:Â strÂ |Â NoneÂ =Â None,<br>description:Â strÂ =Â '',<br>sign_convention:Â intÂ =Â 1,<br>metadata:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None,<br>default_adjustment_filter:Â typing.AnyÂ |Â NoneÂ =Â None,<br>display_format:Â strÂ |Â NoneÂ =Â None,<br>hide_if_all_zero:Â boolÂ =Â False,<br>css_class:Â strÂ |Â NoneÂ =Â None,<br>notes_references:Â list[str]Â |Â NoneÂ =Â None,<br>units:Â strÂ |Â NoneÂ =Â None,<br>display_scale_factor:Â floatÂ |Â NoneÂ =Â None,<br>is_contra:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineItem(StatementItem):
    &#34;&#34;&#34;Represents a basic line item in a financial statement.

    Args:
      id: Unique ID for the line item
      name: Display name for the line item
      node_id: ID of the core graph node that holds values (optional if standard_node_ref provided)
      standard_node_ref: Reference to a standard node name from the registry (optional if node_id provided)
      description: Optional explanatory text
      sign_convention: 1 for normal values, -1 for inverted
      metadata: Optional additional attributes
      default_adjustment_filter: Optional default adjustment filter for this item
      display_format: Optional specific number format string
      hide_if_all_zero: Whether to hide this item if all values are zero
      css_class: Optional CSS class name for HTML/web outputs
      notes_references: List of footnote/note IDs referenced by this item
      units: Optional unit description
      display_scale_factor: Factor to scale values for display
      is_contra: Whether this is a contra item for special display formatting

    Raises:
      StatementError: If inputs are invalid
    &#34;&#34;&#34;

    def __init__(
        self,
        id: str,
        name: str,
        node_id: str | None = None,
        standard_node_ref: str | None = None,
        description: str = &#34;&#34;,
        sign_convention: int = 1,
        metadata: dict[str, Any] | None = None,
        default_adjustment_filter: Any | None = None,
        display_format: str | None = None,
        hide_if_all_zero: bool = False,
        css_class: str | None = None,
        notes_references: list[str] | None = None,
        units: str | None = None,
        display_scale_factor: float | None = None,
        is_contra: bool = False,
    ):
        &#34;&#34;&#34;Initialize a basic LineItem.

        Args:
            id: Unique ID for the line item.
            name: Display name for the line item.
            node_id: ID of the core graph node holding values (optional if standard_node_ref provided).
            standard_node_ref: Reference to a standard node name (optional if node_id provided).
            description: Optional explanatory text.
            sign_convention: Sign convention (1 for positive, -1 for negative).
            metadata: Optional additional attributes.
            default_adjustment_filter: Optional default adjustment filter for this item.
            display_format: Optional specific number format string (e.g., &#34;,.2f&#34;).
            hide_if_all_zero: Whether to hide this item if all values are zero.
            css_class: Optional CSS class name for HTML/web outputs.
            notes_references: List of footnote/note IDs referenced by this item.
            units: Optional unit description (e.g., &#34;USD Thousands&#34;).
            display_scale_factor: Factor to scale values for display (e.g., 0.001 for thousands).
                                If not provided, uses config default from display.scale_factor.
            is_contra: Whether this is a contra item for special display formatting.

        Raises:
            StatementError: If inputs are invalid.
        &#34;&#34;&#34;
        if not id or not isinstance(id, str):
            raise StatementError(f&#34;Invalid line item ID: {id}&#34;)
        if not name or not isinstance(name, str):
            raise StatementError(f&#34;Invalid line item name: {name} for ID: {id}&#34;)

        # Validate that exactly one of node_id or standard_node_ref is provided
        if not node_id and not standard_node_ref:
            raise StatementError(f&#34;Must provide either &#39;node_id&#39; or &#39;standard_node_ref&#39; for line item: {id}&#34;)
        if node_id and standard_node_ref:
            raise StatementError(f&#34;Cannot provide both &#39;node_id&#39; and &#39;standard_node_ref&#39; for line item: {id}&#34;)

        if sign_convention not in (1, -1):
            raise StatementError(f&#34;Invalid sign convention {sign_convention} for item: {id}&#34;)

        # Use config default if not provided (import only when needed)
        display_scale_factor = cfg_or_param(&#34;display.scale_factor&#34;, display_scale_factor)

        if display_scale_factor is None or display_scale_factor &lt;= 0:
            raise StatementError(f&#34;display_scale_factor must be positive for item: {id}&#34;)

        self._id = id
        self._name = name
        self._node_id = node_id
        self._standard_node_ref = standard_node_ref
        self._description = description
        self._sign_convention = sign_convention
        self._metadata = metadata or {}
        self._default_adjustment_filter = default_adjustment_filter
        self._display_format = display_format
        self._hide_if_all_zero = hide_if_all_zero
        self._css_class = css_class
        self._notes_references = notes_references or []
        self._units = units
        self._display_scale_factor = display_scale_factor
        self._is_contra = is_contra

    @property
    def id(self) -&gt; str:
        &#34;&#34;&#34;Get the unique identifier of the line item.&#34;&#34;&#34;
        return self._id

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Get the display name of the line item.&#34;&#34;&#34;
        return self._name

    @property
    def node_id(self) -&gt; str | None:
        &#34;&#34;&#34;Get the core graph node ID for this line item (if provided directly).&#34;&#34;&#34;
        return self._node_id

    @property
    def standard_node_ref(self) -&gt; str | None:
        &#34;&#34;&#34;Get the standard node reference for this line item (if provided).&#34;&#34;&#34;
        return self._standard_node_ref

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Get the description for this line item.&#34;&#34;&#34;
        return self._description

    @property
    def sign_convention(self) -&gt; int:
        &#34;&#34;&#34;Get the sign convention (1 or -1).&#34;&#34;&#34;
        return self._sign_convention

    @property
    def metadata(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get custom metadata associated with this item.&#34;&#34;&#34;
        return self._metadata

    @property
    def default_adjustment_filter(self) -&gt; Any | None:
        &#34;&#34;&#34;Get the default adjustment filter for this item.&#34;&#34;&#34;
        return self._default_adjustment_filter

    @property
    def display_format(self) -&gt; str | None:
        &#34;&#34;&#34;Get the display format string for this item.&#34;&#34;&#34;
        return self._display_format

    @property
    def hide_if_all_zero(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to hide this item if all values are zero.&#34;&#34;&#34;
        return self._hide_if_all_zero

    @property
    def css_class(self) -&gt; str | None:
        &#34;&#34;&#34;Get the CSS class for this item.&#34;&#34;&#34;
        return self._css_class

    @property
    def notes_references(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the list of note references for this item.&#34;&#34;&#34;
        return list(self._notes_references)

    @property
    def units(self) -&gt; str | None:
        &#34;&#34;&#34;Get the unit description for this item.&#34;&#34;&#34;
        return self._units

    @property
    def display_scale_factor(self) -&gt; float:
        &#34;&#34;&#34;Get the display scale factor for this item.&#34;&#34;&#34;
        return self._display_scale_factor

    @property
    def is_contra(self) -&gt; bool:
        &#34;&#34;&#34;Get whether this is a contra item for special display formatting.&#34;&#34;&#34;
        return self._is_contra

    @property
    def item_type(self) -&gt; StatementItemType:
        &#34;&#34;&#34;Get the type of this item (LINE_ITEM).&#34;&#34;&#34;
        return StatementItemType.LINE_ITEM

    def get_resolved_node_id(self, registry: StandardNodeRegistry) -&gt; str | None:
        &#34;&#34;&#34;Get the resolved node ID, handling both direct node_id and standard_node_ref.

        Args:
            registry: Standard node registry for resolving references.

        Returns:
            The resolved node ID, or None if no node ID could be resolved.
        &#34;&#34;&#34;
        if self._node_id:
            return self._node_id

        if self._standard_node_ref:
            # Try to get the standard name (handles alternate names too)
            return registry.get_standard_name(self._standard_node_ref)

        return None</code></pre>
</details>
<div class="desc"><p>Represents a basic line item in a financial statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique ID for the line item</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name for the line item</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>ID of the core graph node that holds values (optional if standard_node_ref provided)</dd>
<dt><strong><code>standard_node_ref</code></strong></dt>
<dd>Reference to a standard node name from the registry (optional if node_id provided)</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional explanatory text</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>1 for normal values, -1 for inverted</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional additional attributes</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display</dd>
<dt><strong><code>is_contra</code></strong></dt>
<dd>Whether this is a contra item for special display formatting</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If inputs are invalid</dd>
</dl>
<p>Initialize a basic LineItem.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique ID for the line item.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name for the line item.</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>ID of the core graph node holding values (optional if standard_node_ref provided).</dd>
<dt><strong><code>standard_node_ref</code></strong></dt>
<dd>Reference to a standard node name (optional if node_id provided).</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional explanatory text.</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>Sign convention (1 for positive, -1 for negative).</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional additional attributes.</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item.</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string (e.g., ",.2f").</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero.</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs.</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description (e.g., "USD Thousands").</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display (e.g., 0.001 for thousands).
If not provided, uses config default from display.scale_factor.</dd>
<dt><strong><code>is_contra</code></strong></dt>
<dd>Whether this is a contra item for special display formatting.</dd>
</dl>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If inputs are invalid.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.structure.items.CalculatedLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem">CalculatedLineItem</a></li>
<li><a title="fin_statement_model.statements.structure.items.MetricLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.MetricLineItem">MetricLineItem</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.LineItem.description"><code class="name">prop <span class="ident">description</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Get the description for this line item.&#34;&#34;&#34;
    return self._description</code></pre>
</details>
<div class="desc"><p>Get the description for this line item.</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.id"><code class="name">prop <span class="ident">id</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    &#34;&#34;&#34;Get the unique identifier of the line item.&#34;&#34;&#34;
    return self._id</code></pre>
</details>
<div class="desc"><p>Get the unique identifier of the line item.</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.item_type"><code class="name">prop <span class="ident">item_type</span> :Â <a title="fin_statement_model.statements.structure.items.StatementItemType" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItemType">StatementItemType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item_type(self) -&gt; StatementItemType:
    &#34;&#34;&#34;Get the type of this item (LINE_ITEM).&#34;&#34;&#34;
    return StatementItemType.LINE_ITEM</code></pre>
</details>
<div class="desc"><p>Get the type of this item (LINE_ITEM).</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.metadata"><code class="name">prop <span class="ident">metadata</span> :Â dict[str,Â typing.Any]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get custom metadata associated with this item.&#34;&#34;&#34;
    return self._metadata</code></pre>
</details>
<div class="desc"><p>Get custom metadata associated with this item.</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.name"><code class="name">prop <span class="ident">name</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Get the display name of the line item.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
<div class="desc"><p>Get the display name of the line item.</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.node_id"><code class="name">prop <span class="ident">node_id</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node_id(self) -&gt; str | None:
    &#34;&#34;&#34;Get the core graph node ID for this line item (if provided directly).&#34;&#34;&#34;
    return self._node_id</code></pre>
</details>
<div class="desc"><p>Get the core graph node ID for this line item (if provided directly).</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.sign_convention"><code class="name">prop <span class="ident">sign_convention</span> :Â int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sign_convention(self) -&gt; int:
    &#34;&#34;&#34;Get the sign convention (1 or -1).&#34;&#34;&#34;
    return self._sign_convention</code></pre>
</details>
<div class="desc"><p>Get the sign convention (1 or -1).</p></div>
</dd>
<dt id="fin_statement_model.statements.LineItem.standard_node_ref"><code class="name">prop <span class="ident">standard_node_ref</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def standard_node_ref(self) -&gt; str | None:
    &#34;&#34;&#34;Get the standard node reference for this line item (if provided).&#34;&#34;&#34;
    return self._standard_node_ref</code></pre>
</details>
<div class="desc"><p>Get the standard node reference for this line item (if provided).</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.LineItem.get_resolved_node_id"><code class="name flex">
<span>def <span class="ident">get_resolved_node_id</span></span>(<span>self,<br>registry:Â <a title="fin_statement_model.core.nodes.standard_registry.StandardNodeRegistry" href="../core/nodes/standard_registry.html#fin_statement_model.core.nodes.standard_registry.StandardNodeRegistry">StandardNodeRegistry</a>) â€‘>Â strÂ |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resolved_node_id(self, registry: StandardNodeRegistry) -&gt; str | None:
    &#34;&#34;&#34;Get the resolved node ID, handling both direct node_id and standard_node_ref.

    Args:
        registry: Standard node registry for resolving references.

    Returns:
        The resolved node ID, or None if no node ID could be resolved.
    &#34;&#34;&#34;
    if self._node_id:
        return self._node_id

    if self._standard_node_ref:
        # Try to get the standard name (handles alternate names too)
        return registry.get_standard_name(self._standard_node_ref)

    return None</code></pre>
</details>
<div class="desc"><p>Get the resolved node ID, handling both direct node_id and standard_node_ref.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>registry</code></strong></dt>
<dd>Standard node registry for resolving references.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resolved node ID, or None if no node ID could be resolved.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.css_class" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.css_class">css_class</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.default_adjustment_filter" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.default_adjustment_filter">default_adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.display_format" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.display_format">display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.display_scale_factor" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.hide_if_all_zero" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.hide_if_all_zero">hide_if_all_zero</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.is_contra" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.is_contra">is_contra</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.notes_references" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.notes_references">notes_references</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.StatementItem.units" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.units">units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.LinearBackoff"><code class="flex name class">
<span>class <span class="ident">LinearBackoff</span></span>
<span>(</span><span>base_delay:Â floatÂ =Â 1.0, increment:Â floatÂ =Â 1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearBackoff(BackoffStrategy):
    &#34;&#34;&#34;Linear backoff strategy.&#34;&#34;&#34;

    def __init__(self, base_delay: float = 1.0, increment: float = 1.0):
        &#34;&#34;&#34;Initialize linear backoff.

        Args:
            base_delay: Initial delay in seconds
            increment: Increment for each retry
        &#34;&#34;&#34;
        self.base_delay = base_delay
        self.increment = increment

    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Calculate linear backoff delay.&#34;&#34;&#34;
        return self.base_delay + (attempt - 1) * self.increment</code></pre>
</details>
<div class="desc"><p>Linear backoff strategy.</p>
<p>Initialize linear backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_delay</code></strong></dt>
<dd>Initial delay in seconds</dd>
<dt><strong><code>increment</code></strong></dt>
<dd>Increment for each retry</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.LinearBackoff.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt:Â int) â€‘>Â float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Calculate linear backoff delay.&#34;&#34;&#34;
    return self.base_delay + (attempt - 1) * self.increment</code></pre>
</details>
<div class="desc"><p>Calculate linear backoff delay.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.MetricItemProcessor"><code class="flex name class">
<span>class <span class="ident">MetricItemProcessor</span></span>
<span>(</span><span>id_resolver:Â <a title="fin_statement_model.statements.population.id_resolver.IDResolver" href="population/id_resolver.html#fin_statement_model.statements.population.id_resolver.IDResolver">IDResolver</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricItemProcessor(ItemProcessor):
    &#34;&#34;&#34;Processor for MetricLineItem objects.

    Handles the creation of metric-based calculation nodes by:
    1. Looking up the metric in the registry
    2. Validating input mappings
    3. Resolving input IDs to graph nodes
    4. Adding the metric node to the graph
    &#34;&#34;&#34;

    def can_process(self, item: StatementItem) -&gt; bool:
        &#34;&#34;&#34;Check if item is a MetricLineItem.&#34;&#34;&#34;
        return isinstance(item, MetricLineItem)

    def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
        &#34;&#34;&#34;Process a MetricLineItem and add it to the graph.&#34;&#34;&#34;
        # Early validation
        if not isinstance(item, MetricLineItem):
            return ProcessorResult(success=False, error_message=&#34;Invalid item type&#34;)

        # Check if node already exists
        if self.graph.has_node(item.id):
            return ProcessorResult(success=True, node_added=False)

        # Initialize result variables
        error_message = None
        node_added = False

        # Get metric from registry
        try:
            metric = metric_registry.get(item.metric_id)
        except MetricError as e:
            logger.exception(&#34;Cannot populate item &#39;%s&#39;: Metric &#39;%s&#39; not found in registry&#34;, item.id, item.metric_id)
            error_message = f&#34;Metric &#39;{item.metric_id}&#39; not found: {e}&#34;

        # Validate input mappings if no error yet
        if not error_message:
            error_message = self._validate_metric_inputs(metric, item)

        # Resolve metric inputs if no error yet
        if not error_message:
            resolved_map, missing = self._resolve_metric_inputs(metric, item)
            if missing:
                return self._handle_missing_inputs(item, missing, is_retry)

            # Add to graph
            try:
                self.graph.add_metric(
                    metric_name=item.metric_id,
                    node_name=item.id,
                    input_node_map=resolved_map,
                )
                node_added = True
            except Exception as e:
                logger.exception(&#34;Failed to add metric node &#39;%s&#39;&#34;, item.id)
                error_message = f&#34;Failed to add metric node: {e}&#34;

        # Single exit point
        if error_message:
            return ProcessorResult(success=False, error_message=error_message)
        return ProcessorResult(success=True, node_added=node_added)

    def _validate_metric_inputs(self, metric: Any, item: MetricLineItem) -&gt; str | None:
        &#34;&#34;&#34;Validate that the item provides all required metric inputs.&#34;&#34;&#34;
        provided_inputs = set(item.inputs.keys())
        required_inputs = set(metric.inputs)

        if provided_inputs != required_inputs:
            missing_req = required_inputs - provided_inputs
            extra_prov = provided_inputs - required_inputs
            error_msg = f&#34;Input mapping mismatch for metric &#39;{item.metric_id}&#39; in item &#39;{item.id}&#39;.&#34;

            if missing_req:
                error_msg += f&#34; Missing required metric inputs: {missing_req}.&#34;
            if extra_prov:
                error_msg += f&#34; Unexpected inputs provided: {extra_prov}.&#34;

            logger.error(error_msg)
            return error_msg

        return None

    def _resolve_metric_inputs(
        self, metric: Any, item: MetricLineItem
    ) -&gt; tuple[dict[str, str], list[tuple[str, str | None]]]:
        &#34;&#34;&#34;Resolve metric input mappings to graph node IDs.&#34;&#34;&#34;
        resolved_map = {}
        missing = []

        for metric_input_name in metric.inputs:
            input_item_id = item.inputs[metric_input_name]
            node_id = self.id_resolver.resolve(input_item_id, self.graph)

            if node_id and self.graph.has_node(node_id):
                resolved_map[metric_input_name] = node_id
            else:
                missing.append((input_item_id, node_id))

        return resolved_map, missing</code></pre>
</details>
<div class="desc"><p>Processor for MetricLineItem objects.</p>
<p>Handles the creation of metric-based calculation nodes by:
1. Looking up the metric in the registry
2. Validating input mappings
3. Resolving input IDs to graph nodes
4. Adding the metric node to the graph</p>
<p>Initialize the processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_resolver</code></strong></dt>
<dd>ID resolver for mapping statement IDs to graph node IDs.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph to add nodes to.</dd>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure being processed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.population.item_processors.ItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor">ItemProcessor</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.MetricItemProcessor.can_process"><code class="name flex">
<span>def <span class="ident">can_process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_process(self, item: StatementItem) -&gt; bool:
    &#34;&#34;&#34;Check if item is a MetricLineItem.&#34;&#34;&#34;
    return isinstance(item, MetricLineItem)</code></pre>
</details>
<div class="desc"><p>Check if item is a MetricLineItem.</p></div>
</dd>
<dt id="fin_statement_model.statements.MetricItemProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>,<br>is_retry:Â boolÂ =Â False) â€‘>Â <a title="fin_statement_model.statements.population.item_processors.ProcessorResult" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ProcessorResult">ProcessorResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
    &#34;&#34;&#34;Process a MetricLineItem and add it to the graph.&#34;&#34;&#34;
    # Early validation
    if not isinstance(item, MetricLineItem):
        return ProcessorResult(success=False, error_message=&#34;Invalid item type&#34;)

    # Check if node already exists
    if self.graph.has_node(item.id):
        return ProcessorResult(success=True, node_added=False)

    # Initialize result variables
    error_message = None
    node_added = False

    # Get metric from registry
    try:
        metric = metric_registry.get(item.metric_id)
    except MetricError as e:
        logger.exception(&#34;Cannot populate item &#39;%s&#39;: Metric &#39;%s&#39; not found in registry&#34;, item.id, item.metric_id)
        error_message = f&#34;Metric &#39;{item.metric_id}&#39; not found: {e}&#34;

    # Validate input mappings if no error yet
    if not error_message:
        error_message = self._validate_metric_inputs(metric, item)

    # Resolve metric inputs if no error yet
    if not error_message:
        resolved_map, missing = self._resolve_metric_inputs(metric, item)
        if missing:
            return self._handle_missing_inputs(item, missing, is_retry)

        # Add to graph
        try:
            self.graph.add_metric(
                metric_name=item.metric_id,
                node_name=item.id,
                input_node_map=resolved_map,
            )
            node_added = True
        except Exception as e:
            logger.exception(&#34;Failed to add metric node &#39;%s&#39;&#34;, item.id)
            error_message = f&#34;Failed to add metric node: {e}&#34;

    # Single exit point
    if error_message:
        return ProcessorResult(success=False, error_message=error_message)
    return ProcessorResult(success=True, node_added=node_added)</code></pre>
</details>
<div class="desc"><p>Process a MetricLineItem and add it to the graph.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.population.item_processors.ItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor">ItemProcessor</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.population.item_processors.ItemProcessor.resolve_inputs" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor.resolve_inputs">resolve_inputs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.NodeData"><code class="flex name class">
<span>class <span class="ident">NodeData</span></span>
<span>(</span><span>node_id:Â str,<br>values:Â dict[str,Â float],<br>is_adjusted:Â dict[str,Â bool],<br>errors:Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class NodeData:
    &#34;&#34;&#34;Data for a single node across all periods.

    Attributes:
        node_id: The graph node ID
        values: Dict mapping period to value
        is_adjusted: Dict mapping period to bool indicating if adjusted
        errors: Any errors encountered during fetching
    &#34;&#34;&#34;

    node_id: str
    values: dict[str, float]
    is_adjusted: dict[str, bool]
    errors: list[ErrorDetail]

    @property
    def has_data(self) -&gt; bool:
        &#34;&#34;&#34;Check if any non-NaN values exist.&#34;&#34;&#34;
        return any(pd.notna(v) for v in self.values.values())</code></pre>
</details>
<div class="desc"><p>Data for a single node across all periods.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>The graph node ID</dd>
<dt><strong><code>values</code></strong></dt>
<dd>Dict mapping period to value</dd>
<dt><strong><code>is_adjusted</code></strong></dt>
<dd>Dict mapping period to bool indicating if adjusted</dd>
<dt><strong><code>errors</code></strong></dt>
<dd>Any errors encountered during fetching</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.NodeData.errors"><code class="name">var <span class="ident">errors</span> :Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.NodeData.has_data"><code class="name">prop <span class="ident">has_data</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_data(self) -&gt; bool:
    &#34;&#34;&#34;Check if any non-NaN values exist.&#34;&#34;&#34;
    return any(pd.notna(v) for v in self.values.values())</code></pre>
</details>
<div class="desc"><p>Check if any non-NaN values exist.</p></div>
</dd>
<dt id="fin_statement_model.statements.NodeData.is_adjusted"><code class="name">var <span class="ident">is_adjusted</span> :Â dict[str,Â bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.NodeData.node_id"><code class="name">var <span class="ident">node_id</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.NodeData.values"><code class="name">var <span class="ident">values</span> :Â dict[str,Â float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.ProcessorResult"><code class="flex name class">
<span>class <span class="ident">ProcessorResult</span></span>
<span>(</span><span>success:Â bool,<br>node_added:Â boolÂ =Â False,<br>error_message:Â strÂ |Â NoneÂ =Â None,<br>missing_inputs:Â list[tuple[str,Â strÂ |Â None]]Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProcessorResult:
    &#34;&#34;&#34;Result of processing a statement item.

    Attributes:
        success: Whether the processing was successful.
        node_added: Whether a new node was added to the graph.
        error_message: Error message if processing failed.
        missing_inputs: List of missing input details (item_id, resolved_node_id).
    &#34;&#34;&#34;

    success: bool
    node_added: bool = False
    error_message: str | None = None
    missing_inputs: list[tuple[str, str | None]] | None = None

    def to_result(self) -&gt; Result[bool]:
        &#34;&#34;&#34;Convert to the new Result type.&#34;&#34;&#34;
        if self.success:
            return Success(value=self.node_added)

        errors = []
        if self.error_message:
            errors.append(
                ErrorDetail(
                    code=&#34;processing_error&#34;,
                    message=self.error_message,
                    severity=ErrorSeverity.ERROR,
                )
            )

        if self.missing_inputs:
            for item_id, node_id in self.missing_inputs:
                msg = (
                    f&#34;Missing input: item &#39;{item_id}&#39; needs node &#39;{node_id}&#39;&#34;
                    if node_id
                    else f&#34;Missing input: item &#39;{item_id}&#39; not found/mappable&#34;
                )
                errors.append(
                    ErrorDetail(
                        code=&#34;missing_input&#34;,
                        message=msg,
                        context=f&#34;item_id={item_id}, node_id={node_id}&#34;,
                        severity=ErrorSeverity.ERROR,
                    )
                )

        return Failure(errors=errors)</code></pre>
</details>
<div class="desc"><p>Result of processing a statement item.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>success</code></strong></dt>
<dd>Whether the processing was successful.</dd>
<dt><strong><code>node_added</code></strong></dt>
<dd>Whether a new node was added to the graph.</dd>
<dt><strong><code>error_message</code></strong></dt>
<dd>Error message if processing failed.</dd>
<dt><strong><code>missing_inputs</code></strong></dt>
<dd>List of missing input details (item_id, resolved_node_id).</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.ProcessorResult.error_message"><code class="name">var <span class="ident">error_message</span> :Â strÂ |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ProcessorResult.missing_inputs"><code class="name">var <span class="ident">missing_inputs</span> :Â list[tuple[str,Â strÂ |Â None]]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ProcessorResult.node_added"><code class="name">var <span class="ident">node_added</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.ProcessorResult.success"><code class="name">var <span class="ident">success</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.ProcessorResult.to_result"><code class="name flex">
<span>def <span class="ident">to_result</span></span>(<span>self) â€‘>Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[bool]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_result(self) -&gt; Result[bool]:
    &#34;&#34;&#34;Convert to the new Result type.&#34;&#34;&#34;
    if self.success:
        return Success(value=self.node_added)

    errors = []
    if self.error_message:
        errors.append(
            ErrorDetail(
                code=&#34;processing_error&#34;,
                message=self.error_message,
                severity=ErrorSeverity.ERROR,
            )
        )

    if self.missing_inputs:
        for item_id, node_id in self.missing_inputs:
            msg = (
                f&#34;Missing input: item &#39;{item_id}&#39; needs node &#39;{node_id}&#39;&#34;
                if node_id
                else f&#34;Missing input: item &#39;{item_id}&#39; not found/mappable&#34;
            )
            errors.append(
                ErrorDetail(
                    code=&#34;missing_input&#34;,
                    message=msg,
                    context=f&#34;item_id={item_id}, node_id={node_id}&#34;,
                    severity=ErrorSeverity.ERROR,
                )
            )

    return Failure(errors=errors)</code></pre>
</details>
<div class="desc"><p>Convert to the new Result type.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result(ABC, Generic[T]):
    &#34;&#34;&#34;Abstract base class for operation results.

    Provides a functional approach to error handling, allowing
    operations to return either success or failure without exceptions.
    &#34;&#34;&#34;

    @abstractmethod
    def is_success(self) -&gt; bool:
        &#34;&#34;&#34;Check if the result represents success.&#34;&#34;&#34;

    @abstractmethod
    def is_failure(self) -&gt; bool:
        &#34;&#34;&#34;Check if the result represents failure.&#34;&#34;&#34;

    @abstractmethod
    def get_value(self) -&gt; T | None:
        &#34;&#34;&#34;Get the success value if available.&#34;&#34;&#34;

    @abstractmethod
    def get_errors(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Get error details if this is a failure.&#34;&#34;&#34;

    def unwrap(self) -&gt; T:
        &#34;&#34;&#34;Get the value or raise an exception if failed.

        Raises:
            ValueError: If the result is a failure.
        &#34;&#34;&#34;
        if self.is_failure():
            errors_str = &#34;\n&#34;.join(str(e) for e in self.get_errors())
            raise ValueError(f&#34;Cannot unwrap failed result:\n{errors_str}&#34;)
        return cast(&#34;T&#34;, self.get_value())

    def unwrap_or(self, default: T) -&gt; T:
        &#34;&#34;&#34;Get the value or return a default if failed.&#34;&#34;&#34;
        return cast(&#34;T&#34;, self.get_value()) if self.is_success() else default</code></pre>
</details>
<div class="desc"><p>Abstract base class for operation results.</p>
<p>Provides a functional approach to error handling, allowing
operations to return either success or failure without exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.result_types.Failure" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Failure">Failure</a></li>
<li><a title="fin_statement_model.statements.utilities.result_types.Success" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Success">Success</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.Result.get_errors"><code class="name flex">
<span>def <span class="ident">get_errors</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_errors(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Get error details if this is a failure.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get error details if this is a failure.</p></div>
</dd>
<dt id="fin_statement_model.statements.Result.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self) â€‘>Â ~TÂ |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_value(self) -&gt; T | None:
    &#34;&#34;&#34;Get the success value if available.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the success value if available.</p></div>
</dd>
<dt id="fin_statement_model.statements.Result.is_failure"><code class="name flex">
<span>def <span class="ident">is_failure</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def is_failure(self) -&gt; bool:
    &#34;&#34;&#34;Check if the result represents failure.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Check if the result represents failure.</p></div>
</dd>
<dt id="fin_statement_model.statements.Result.is_success"><code class="name flex">
<span>def <span class="ident">is_success</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def is_success(self) -&gt; bool:
    &#34;&#34;&#34;Check if the result represents success.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Check if the result represents success.</p></div>
</dd>
<dt id="fin_statement_model.statements.Result.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>self) â€‘>Â ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(self) -&gt; T:
    &#34;&#34;&#34;Get the value or raise an exception if failed.

    Raises:
        ValueError: If the result is a failure.
    &#34;&#34;&#34;
    if self.is_failure():
        errors_str = &#34;\n&#34;.join(str(e) for e in self.get_errors())
        raise ValueError(f&#34;Cannot unwrap failed result:\n{errors_str}&#34;)
    return cast(&#34;T&#34;, self.get_value())</code></pre>
</details>
<div class="desc"><p>Get the value or raise an exception if failed.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the result is a failure.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.Result.unwrap_or"><code class="name flex">
<span>def <span class="ident">unwrap_or</span></span>(<span>self, default:Â ~T) â€‘>Â ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_or(self, default: T) -&gt; T:
    &#34;&#34;&#34;Get the value or return a default if failed.&#34;&#34;&#34;
    return cast(&#34;T&#34;, self.get_value()) if self.is_success() else default</code></pre>
</details>
<div class="desc"><p>Get the value or return a default if failed.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.RetryConfig"><code class="flex name class">
<span>class <span class="ident">RetryConfig</span></span>
<span>(</span><span>max_attempts:Â intÂ |Â NoneÂ =Â None,<br>strategy:Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryStrategy">RetryStrategy</a>Â =Â RetryStrategy.BACKOFF,<br>backoff:Â ForwardRef('<a title="fin_statement_model.statements.BackoffStrategy" href="#fin_statement_model.statements.BackoffStrategy">BackoffStrategy</a>')Â |Â NoneÂ =Â None,<br>retryable_errors:Â set[str]Â |Â NoneÂ =Â None,<br>log_retries:Â boolÂ =Â True,<br>collect_all_errors:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RetryConfig:
    &#34;&#34;&#34;Configuration for retry behavior.

    Attributes:
        max_attempts: Maximum number of attempts (including initial).
                     If not provided, uses config default from api.api_retry_count
        strategy: Retry strategy to use
        backoff: Optional backoff strategy for delays
        retryable_errors: Set of error codes that are retryable
        log_retries: Whether to log retry attempts
        collect_all_errors: Whether to collect errors from all attempts
    &#34;&#34;&#34;

    max_attempts: int | None = None
    strategy: RetryStrategy = RetryStrategy.BACKOFF
    backoff: Optional[&#34;BackoffStrategy&#34;] = None
    retryable_errors: set[str] | None = None
    log_retries: bool = True
    collect_all_errors: bool = False

    def __post_init__(self) -&gt; None:
        &#34;&#34;&#34;Validate configuration and set defaults.&#34;&#34;&#34;
        # Use config default if not provided
        if self.max_attempts is None:
            self.max_attempts = cfg_or_param(&#34;api.api_retry_count&#34;, None)

        if self.max_attempts &lt; 1:
            raise ValueError(&#34;max_attempts must be at least 1&#34;)

        if self.strategy == RetryStrategy.BACKOFF and not self.backoff:
            # Default to exponential backoff
            self.backoff = ExponentialBackoff()

        if self.retryable_errors is None:
            # Default retryable errors
            self.retryable_errors = {
                &#34;timeout&#34;,
                &#34;connection_error&#34;,
                &#34;rate_limit&#34;,
                &#34;temporary_failure&#34;,
                &#34;calculation_error&#34;,  # For graph calculations
                &#34;node_not_ready&#34;,  # For dependency issues
            }</code></pre>
</details>
<div class="desc"><p>Configuration for retry behavior.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>max_attempts</code></strong></dt>
<dd>Maximum number of attempts (including initial).
If not provided, uses config default from api.api_retry_count</dd>
<dt><strong><code>strategy</code></strong></dt>
<dd>Retry strategy to use</dd>
<dt><strong><code>backoff</code></strong></dt>
<dd>Optional backoff strategy for delays</dd>
<dt><strong><code>retryable_errors</code></strong></dt>
<dd>Set of error codes that are retryable</dd>
<dt><strong><code>log_retries</code></strong></dt>
<dd>Whether to log retry attempts</dd>
<dt><strong><code>collect_all_errors</code></strong></dt>
<dd>Whether to collect errors from all attempts</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.RetryConfig.backoff"><code class="name">var <span class="ident">backoff</span> :Â <a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a>Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryConfig.collect_all_errors"><code class="name">var <span class="ident">collect_all_errors</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryConfig.log_retries"><code class="name">var <span class="ident">log_retries</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryConfig.max_attempts"><code class="name">var <span class="ident">max_attempts</span> :Â intÂ |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryConfig.retryable_errors"><code class="name">var <span class="ident">retryable_errors</span> :Â set[str]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryConfig.strategy"><code class="name">var <span class="ident">strategy</span> :Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryStrategy">RetryStrategy</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.RetryHandler"><code class="flex name class">
<span>class <span class="ident">RetryHandler</span></span>
<span>(</span><span>config:Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryConfig">RetryConfig</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RetryHandler:
    &#34;&#34;&#34;Handles retry logic for operations that may fail transiently.&#34;&#34;&#34;

    def __init__(self, config: RetryConfig | None = None):
        &#34;&#34;&#34;Initialize retry handler.

        Args:
            config: Retry configuration, uses defaults if not provided
        &#34;&#34;&#34;
        self.config = config or RetryConfig()

    def retry(
        self,
        operation: Callable[[], Result[T]],
        operation_name: str | None = None,
    ) -&gt; RetryResult[T]:
        &#34;&#34;&#34;Execute an operation with retry logic.

        Args:
            operation: Callable that returns a Result
            operation_name: Optional name for logging

        Returns:
            RetryResult containing the final result and metadata
        &#34;&#34;&#34;
        error_collector = ErrorCollector() if self.config.collect_all_errors else None
        total_delay = 0.0
        # Ensure max_attempts is int
        max_attempts = cast(&#34;int&#34;, self.config.max_attempts)
        op_name = operation_name or operation.__name__

        for attempt in range(1, max_attempts + 1):
            if attempt &gt; 1 and self.config.log_retries:
                logger.info(&#34;Retrying %s (attempt %s/%s)&#34;, op_name, attempt, max_attempts)

            # Execute the operation
            try:
                result = operation()
            except Exception as e:  # noqa: BLE001 - convert any exception into Failure for retry logic
                # Convert exception to Result
                result = Failure.from_exception(e)

            # Check if successful
            if result.is_success():
                return RetryResult(
                    result=result,
                    attempts=attempt,
                    total_delay=total_delay,
                    all_errors=error_collector.get_all() if error_collector else None,
                )

            # Handle failure
            errors = result.get_errors()

            # Collect errors if configured
            if error_collector:
                for error in errors:
                    error_collector.add_error(
                        code=error.code,
                        message=f&#34;Attempt {attempt}: {error.message}&#34;,
                        context=error.context,
                        source=error.source,
                    )

            # Check if we should retry
            if attempt &gt;= max_attempts:
                # No more retries
                if self.config.log_retries:
                    logger.warning(
                        &#34;%s failed after %s attempts. Final error: %s&#34;,
                        op_name,
                        attempt,
                        errors[0].message if errors else &#34;Unknown&#34;,
                    )
                break

            # Check if errors are retryable
            if self.config.strategy == RetryStrategy.CONDITIONAL:
                # Safe cast retryable_errors to non-nullable set
                retryable_errors = cast(&#34;set[str]&#34;, self.config.retryable_errors)
                retryable = any(is_retryable_error(error, retryable_errors) for error in errors)
                if not retryable:
                    if self.config.log_retries:
                        logger.debug(
                            &#34;%s failed with non-retryable error: %s&#34;,
                            op_name,
                            errors[0].code if errors else &#34;Unknown&#34;,
                        )
                    break

            # Calculate delay
            if self.config.strategy == RetryStrategy.BACKOFF and self.config.backoff:
                delay = self.config.backoff.get_delay(attempt)
                if self.config.log_retries:
                    logger.debug(&#34;Waiting %.2fs before retry&#34;, delay)
                time.sleep(delay)
                total_delay += delay

        # Return final result
        return RetryResult(
            result=result,
            attempts=attempt,
            total_delay=total_delay,
            all_errors=error_collector.get_all() if error_collector else None,
        )

    def retry_async(
        self,
        operation: Callable[[], Result[T]],
        operation_name: str | None = None,
    ) -&gt; RetryResult[T]:
        &#34;&#34;&#34;Execute an async operation with retry logic.

        Note: This is a placeholder for future async support.
        Currently just delegates to sync retry.

        Args:
            operation: Callable that returns a Result
            operation_name: Optional name for logging

        Returns:
            RetryResult containing the final result and metadata
        &#34;&#34;&#34;
        # TODO: Implement proper async support when needed
        return self.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Handles retry logic for operations that may fail transiently.</p>
<p>Initialize retry handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Retry configuration, uses defaults if not provided</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.RetryHandler.retry"><code class="name flex">
<span>def <span class="ident">retry</span></span>(<span>self,<br>operation:Â Callable[[],Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>operation_name:Â strÂ |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry(
    self,
    operation: Callable[[], Result[T]],
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Execute an operation with retry logic.

    Args:
        operation: Callable that returns a Result
        operation_name: Optional name for logging

    Returns:
        RetryResult containing the final result and metadata
    &#34;&#34;&#34;
    error_collector = ErrorCollector() if self.config.collect_all_errors else None
    total_delay = 0.0
    # Ensure max_attempts is int
    max_attempts = cast(&#34;int&#34;, self.config.max_attempts)
    op_name = operation_name or operation.__name__

    for attempt in range(1, max_attempts + 1):
        if attempt &gt; 1 and self.config.log_retries:
            logger.info(&#34;Retrying %s (attempt %s/%s)&#34;, op_name, attempt, max_attempts)

        # Execute the operation
        try:
            result = operation()
        except Exception as e:  # noqa: BLE001 - convert any exception into Failure for retry logic
            # Convert exception to Result
            result = Failure.from_exception(e)

        # Check if successful
        if result.is_success():
            return RetryResult(
                result=result,
                attempts=attempt,
                total_delay=total_delay,
                all_errors=error_collector.get_all() if error_collector else None,
            )

        # Handle failure
        errors = result.get_errors()

        # Collect errors if configured
        if error_collector:
            for error in errors:
                error_collector.add_error(
                    code=error.code,
                    message=f&#34;Attempt {attempt}: {error.message}&#34;,
                    context=error.context,
                    source=error.source,
                )

        # Check if we should retry
        if attempt &gt;= max_attempts:
            # No more retries
            if self.config.log_retries:
                logger.warning(
                    &#34;%s failed after %s attempts. Final error: %s&#34;,
                    op_name,
                    attempt,
                    errors[0].message if errors else &#34;Unknown&#34;,
                )
            break

        # Check if errors are retryable
        if self.config.strategy == RetryStrategy.CONDITIONAL:
            # Safe cast retryable_errors to non-nullable set
            retryable_errors = cast(&#34;set[str]&#34;, self.config.retryable_errors)
            retryable = any(is_retryable_error(error, retryable_errors) for error in errors)
            if not retryable:
                if self.config.log_retries:
                    logger.debug(
                        &#34;%s failed with non-retryable error: %s&#34;,
                        op_name,
                        errors[0].code if errors else &#34;Unknown&#34;,
                    )
                break

        # Calculate delay
        if self.config.strategy == RetryStrategy.BACKOFF and self.config.backoff:
            delay = self.config.backoff.get_delay(attempt)
            if self.config.log_retries:
                logger.debug(&#34;Waiting %.2fs before retry&#34;, delay)
            time.sleep(delay)
            total_delay += delay

    # Return final result
    return RetryResult(
        result=result,
        attempts=attempt,
        total_delay=total_delay,
        all_errors=error_collector.get_all() if error_collector else None,
    )</code></pre>
</details>
<div class="desc"><p>Execute an operation with retry logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>Callable that returns a Result</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult containing the final result and metadata</p></div>
</dd>
<dt id="fin_statement_model.statements.RetryHandler.retry_async"><code class="name flex">
<span>def <span class="ident">retry_async</span></span>(<span>self,<br>operation:Â Callable[[],Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>operation_name:Â strÂ |Â NoneÂ =Â None) â€‘>Â <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="utilities/retry_handler.html#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_async(
    self,
    operation: Callable[[], Result[T]],
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Execute an async operation with retry logic.

    Note: This is a placeholder for future async support.
    Currently just delegates to sync retry.

    Args:
        operation: Callable that returns a Result
        operation_name: Optional name for logging

    Returns:
        RetryResult containing the final result and metadata
    &#34;&#34;&#34;
    # TODO: Implement proper async support when needed
    return self.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Execute an async operation with retry logic.</p>
<p>Note: This is a placeholder for future async support.
Currently just delegates to sync retry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>Callable that returns a Result</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult containing the final result and metadata</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.RetryResult"><code class="flex name class">
<span>class <span class="ident">RetryResult</span></span>
<span>(</span><span>result:Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T],<br>attempts:Â int,<br>total_delay:Â float,<br>all_errors:Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RetryResult(Generic[T]):
    &#34;&#34;&#34;Result of a retry operation.

    Attributes:
        result: The final result (success or failure)
        attempts: Number of attempts made
        total_delay: Total delay time in seconds
        all_errors: All errors collected if configured
    &#34;&#34;&#34;

    result: Result[T]
    attempts: int
    total_delay: float
    all_errors: list[ErrorDetail] | None = None

    @property
    def success(self) -&gt; bool:
        &#34;&#34;&#34;Check if the operation eventually succeeded.&#34;&#34;&#34;
        return self.result.is_success()

    def unwrap(self) -&gt; T:
        &#34;&#34;&#34;Get the value or raise an exception.&#34;&#34;&#34;
        return self.result.unwrap()

    def unwrap_or(self, default: T) -&gt; T:
        &#34;&#34;&#34;Get the value or return default.&#34;&#34;&#34;
        return self.result.unwrap_or(default)</code></pre>
</details>
<div class="desc"><p>Result of a retry operation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>result</code></strong></dt>
<dd>The final result (success or failure)</dd>
<dt><strong><code>attempts</code></strong></dt>
<dd>Number of attempts made</dd>
<dt><strong><code>total_delay</code></strong></dt>
<dd>Total delay time in seconds</dd>
<dt><strong><code>all_errors</code></strong></dt>
<dd>All errors collected if configured</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.RetryResult.all_errors"><code class="name">var <span class="ident">all_errors</span> :Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryResult.attempts"><code class="name">var <span class="ident">attempts</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryResult.result"><code class="name">var <span class="ident">result</span> :Â <a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryResult.success"><code class="name">prop <span class="ident">success</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def success(self) -&gt; bool:
    &#34;&#34;&#34;Check if the operation eventually succeeded.&#34;&#34;&#34;
    return self.result.is_success()</code></pre>
</details>
<div class="desc"><p>Check if the operation eventually succeeded.</p></div>
</dd>
<dt id="fin_statement_model.statements.RetryResult.total_delay"><code class="name">var <span class="ident">total_delay</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.RetryResult.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>self) â€‘>Â ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(self) -&gt; T:
    &#34;&#34;&#34;Get the value or raise an exception.&#34;&#34;&#34;
    return self.result.unwrap()</code></pre>
</details>
<div class="desc"><p>Get the value or raise an exception.</p></div>
</dd>
<dt id="fin_statement_model.statements.RetryResult.unwrap_or"><code class="name flex">
<span>def <span class="ident">unwrap_or</span></span>(<span>self, default:Â ~T) â€‘>Â ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_or(self, default: T) -&gt; T:
    &#34;&#34;&#34;Get the value or return default.&#34;&#34;&#34;
    return self.result.unwrap_or(default)</code></pre>
</details>
<div class="desc"><p>Get the value or return default.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.RetryStrategy"><code class="flex name class">
<span>class <span class="ident">RetryStrategy</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RetryStrategy(Enum):
    &#34;&#34;&#34;Strategy for determining when to retry.&#34;&#34;&#34;

    IMMEDIATE = &#34;immediate&#34;  # Retry immediately on failure
    BACKOFF = &#34;backoff&#34;  # Use backoff strategy between retries
    CONDITIONAL = &#34;conditional&#34;  # Retry only for specific error types</code></pre>
</details>
<div class="desc"><p>Strategy for determining when to retry.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.RetryStrategy.BACKOFF"><code class="name">var <span class="ident">BACKOFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryStrategy.CONDITIONAL"><code class="name">var <span class="ident">CONDITIONAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.RetryStrategy.IMMEDIATE"><code class="name">var <span class="ident">IMMEDIATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.Section"><code class="flex name class">
<span>class <span class="ident">Section</span></span>
<span>(</span><span>id:Â str,<br>name:Â str,<br>description:Â strÂ =Â '',<br>metadata:Â dict[str,Â Any]Â |Â NoneÂ =Â None,<br>default_adjustment_filter:Â AnyÂ |Â NoneÂ =Â None,<br>display_format:Â strÂ |Â NoneÂ =Â None,<br>hide_if_all_zero:Â boolÂ =Â False,<br>css_class:Â strÂ |Â NoneÂ =Â None,<br>notes_references:Â list[str]Â |Â NoneÂ =Â None,<br>units:Â strÂ |Â NoneÂ =Â None,<br>display_scale_factor:Â floatÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Section:
    &#34;&#34;&#34;Represents a section in a financial statement.

    Sections group related items and subsections into a hierarchical container
    with enhanced display control and units metadata.
    &#34;&#34;&#34;

    def __init__(
        self,
        id: str,
        name: str,
        description: str = &#34;&#34;,
        metadata: dict[str, Any] | None = None,
        default_adjustment_filter: Any | None = None,
        display_format: str | None = None,
        hide_if_all_zero: bool = False,
        css_class: str | None = None,
        notes_references: list[str] | None = None,
        units: str | None = None,
        display_scale_factor: float | None = None,
    ):
        &#34;&#34;&#34;Initialize a section.

        Args:
            id: Unique identifier for the section.
            name: Display name for the section.
            description: Optional description text.
            metadata: Optional additional metadata.
            default_adjustment_filter: Optional default adjustment filter for this section.
            display_format: Optional specific number format string for section items.
            hide_if_all_zero: Whether to hide this section if all values are zero.
            css_class: Optional CSS class name for HTML/web outputs.
            notes_references: List of footnote/note IDs referenced by this section.
            units: Optional unit description for this section.
            display_scale_factor: Factor to scale values for display in this section.
                                If not provided, uses config default from display.scale_factor.

        Raises:
            StatementError: If id or name is invalid.
        &#34;&#34;&#34;
        if not id or not isinstance(id, str):
            raise StatementError(f&#34;Invalid section ID: {id}&#34;)
        if not name or not isinstance(name, str):
            raise StatementError(f&#34;Invalid section name: {name} for ID: {id}&#34;)

        # Use config default if not provided (import only when needed)
        from fin_statement_model.config.access import cfg_or_param

        display_scale_factor = cfg_or_param(&#34;display.scale_factor&#34;, display_scale_factor)

        if display_scale_factor is None or display_scale_factor &lt;= 0:
            raise StatementError(f&#34;display_scale_factor must be positive for section: {id}&#34;)

        self._id = id
        self._name = name
        self._description = description
        self._metadata = metadata or {}
        self._default_adjustment_filter = default_adjustment_filter
        self._display_format = display_format
        self._hide_if_all_zero = hide_if_all_zero
        self._css_class = css_class
        self._notes_references = notes_references or []
        self._units = units
        self._display_scale_factor = display_scale_factor
        self._items: list[Section | StatementItem] = []
        # Optional subtotal for this section (may be set by builder)
        self.subtotal: StatementItem | None = None

    @property
    def id(self) -&gt; str:
        &#34;&#34;&#34;Get the section identifier.&#34;&#34;&#34;
        return self._id

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Get the section display name.&#34;&#34;&#34;
        return self._name

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Get the section description.&#34;&#34;&#34;
        return self._description

    @property
    def metadata(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get the section metadata.&#34;&#34;&#34;
        return self._metadata

    @property
    def default_adjustment_filter(self) -&gt; Any | None:
        &#34;&#34;&#34;Get the default adjustment filter for this section.&#34;&#34;&#34;
        return self._default_adjustment_filter

    @property
    def display_format(self) -&gt; str | None:
        &#34;&#34;&#34;Get the display format string for this section.&#34;&#34;&#34;
        return self._display_format

    @property
    def hide_if_all_zero(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to hide this section if all values are zero.&#34;&#34;&#34;
        return self._hide_if_all_zero

    @property
    def css_class(self) -&gt; str | None:
        &#34;&#34;&#34;Get the CSS class for this section.&#34;&#34;&#34;
        return self._css_class

    @property
    def notes_references(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the list of note references for this section.&#34;&#34;&#34;
        return list(self._notes_references)

    @property
    def units(self) -&gt; str | None:
        &#34;&#34;&#34;Get the unit description for this section.&#34;&#34;&#34;
        return self._units

    @property
    def display_scale_factor(self) -&gt; float:
        &#34;&#34;&#34;Get the display scale factor for this section.&#34;&#34;&#34;
        return self._display_scale_factor

    @property
    def items(self) -&gt; list[Section | StatementItem]:
        &#34;&#34;&#34;Get the child items and subsections.&#34;&#34;&#34;
        return list(self._items)

    @property
    def item_type(self) -&gt; StatementItemType:
        &#34;&#34;&#34;Get the item type (SECTION).&#34;&#34;&#34;
        return StatementItemType.SECTION

    def add_item(self, item: Section | StatementItem) -&gt; None:
        &#34;&#34;&#34;Add a child item or subsection to this section.

        Args:
            item: The Section or StatementItem to add.

        Raises:
            StatementError: If an item with the same id already exists.
        &#34;&#34;&#34;
        if any(existing.id == item.id for existing in self._items):
            raise StatementError(f&#34;Duplicate item ID: {item.id} in section: {self.id}&#34;)
        self._items.append(item)

    def find_item_by_id(self, item_id: str) -&gt; Section | StatementItem | None:
        &#34;&#34;&#34;Recursively find an item by its identifier within this section.

        Args:
            item_id: Identifier of the item to search for.

        Returns:
            The found Section or StatementItem, or None if not found.
        &#34;&#34;&#34;
        if self.id == item_id:
            return self
        for child in self._items:
            if child.id == item_id:
                return child
            if isinstance(child, Section):
                found = child.find_item_by_id(item_id)
                if found:
                    return found
        if hasattr(self, &#34;subtotal&#34;) and self.subtotal and self.subtotal.id == item_id:
            return self.subtotal
        return None</code></pre>
</details>
<div class="desc"><p>Represents a section in a financial statement.</p>
<p>Sections group related items and subsections into a hierarchical container
with enhanced display control and units metadata.</p>
<p>Initialize a section.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the section.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name for the section.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description text.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional additional metadata.</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this section.</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string for section items.</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this section if all values are zero.</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs.</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this section.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description for this section.</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display in this section.
If not provided, uses config default from display.scale_factor.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If id or name is invalid.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.Section.css_class"><code class="name">prop <span class="ident">css_class</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def css_class(self) -&gt; str | None:
    &#34;&#34;&#34;Get the CSS class for this section.&#34;&#34;&#34;
    return self._css_class</code></pre>
</details>
<div class="desc"><p>Get the CSS class for this section.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.default_adjustment_filter"><code class="name">prop <span class="ident">default_adjustment_filter</span> :Â AnyÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_adjustment_filter(self) -&gt; Any | None:
    &#34;&#34;&#34;Get the default adjustment filter for this section.&#34;&#34;&#34;
    return self._default_adjustment_filter</code></pre>
</details>
<div class="desc"><p>Get the default adjustment filter for this section.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.description"><code class="name">prop <span class="ident">description</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Get the section description.&#34;&#34;&#34;
    return self._description</code></pre>
</details>
<div class="desc"><p>Get the section description.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.display_format"><code class="name">prop <span class="ident">display_format</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def display_format(self) -&gt; str | None:
    &#34;&#34;&#34;Get the display format string for this section.&#34;&#34;&#34;
    return self._display_format</code></pre>
</details>
<div class="desc"><p>Get the display format string for this section.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.display_scale_factor"><code class="name">prop <span class="ident">display_scale_factor</span> :Â float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def display_scale_factor(self) -&gt; float:
    &#34;&#34;&#34;Get the display scale factor for this section.&#34;&#34;&#34;
    return self._display_scale_factor</code></pre>
</details>
<div class="desc"><p>Get the display scale factor for this section.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.hide_if_all_zero"><code class="name">prop <span class="ident">hide_if_all_zero</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hide_if_all_zero(self) -&gt; bool:
    &#34;&#34;&#34;Get whether to hide this section if all values are zero.&#34;&#34;&#34;
    return self._hide_if_all_zero</code></pre>
</details>
<div class="desc"><p>Get whether to hide this section if all values are zero.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.id"><code class="name">prop <span class="ident">id</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    &#34;&#34;&#34;Get the section identifier.&#34;&#34;&#34;
    return self._id</code></pre>
</details>
<div class="desc"><p>Get the section identifier.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.item_type"><code class="name">prop <span class="ident">item_type</span> :Â <a title="fin_statement_model.statements.StatementItemType" href="#fin_statement_model.statements.StatementItemType">StatementItemType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item_type(self) -&gt; StatementItemType:
    &#34;&#34;&#34;Get the item type (SECTION).&#34;&#34;&#34;
    return StatementItemType.SECTION</code></pre>
</details>
<div class="desc"><p>Get the item type (SECTION).</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.items"><code class="name">prop <span class="ident">items</span> :Â list[<a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a>Â |Â <a title="fin_statement_model.statements.StatementItem" href="#fin_statement_model.statements.StatementItem">StatementItem</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def items(self) -&gt; list[Section | StatementItem]:
    &#34;&#34;&#34;Get the child items and subsections.&#34;&#34;&#34;
    return list(self._items)</code></pre>
</details>
<div class="desc"><p>Get the child items and subsections.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.metadata"><code class="name">prop <span class="ident">metadata</span> :Â dict[str,Â Any]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get the section metadata.&#34;&#34;&#34;
    return self._metadata</code></pre>
</details>
<div class="desc"><p>Get the section metadata.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.name"><code class="name">prop <span class="ident">name</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Get the section display name.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
<div class="desc"><p>Get the section display name.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.notes_references"><code class="name">prop <span class="ident">notes_references</span> :Â list[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def notes_references(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the list of note references for this section.&#34;&#34;&#34;
    return list(self._notes_references)</code></pre>
</details>
<div class="desc"><p>Get the list of note references for this section.</p></div>
</dd>
<dt id="fin_statement_model.statements.Section.units"><code class="name">prop <span class="ident">units</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def units(self) -&gt; str | None:
    &#34;&#34;&#34;Get the unit description for this section.&#34;&#34;&#34;
    return self._units</code></pre>
</details>
<div class="desc"><p>Get the unit description for this section.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.Section.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a>Â |Â <a title="fin_statement_model.statements.StatementItem" href="#fin_statement_model.statements.StatementItem">StatementItem</a>) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_item(self, item: Section | StatementItem) -&gt; None:
    &#34;&#34;&#34;Add a child item or subsection to this section.

    Args:
        item: The Section or StatementItem to add.

    Raises:
        StatementError: If an item with the same id already exists.
    &#34;&#34;&#34;
    if any(existing.id == item.id for existing in self._items):
        raise StatementError(f&#34;Duplicate item ID: {item.id} in section: {self.id}&#34;)
    self._items.append(item)</code></pre>
</details>
<div class="desc"><p>Add a child item or subsection to this section.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>The Section or StatementItem to add.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If an item with the same id already exists.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.Section.find_item_by_id"><code class="name flex">
<span>def <span class="ident">find_item_by_id</span></span>(<span>self, item_id:Â str) â€‘>Â <a title="fin_statement_model.statements.structure.containers.Section" href="structure/containers.html#fin_statement_model.statements.structure.containers.Section">Section</a>Â |Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>Â |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_item_by_id(self, item_id: str) -&gt; Section | StatementItem | None:
    &#34;&#34;&#34;Recursively find an item by its identifier within this section.

    Args:
        item_id: Identifier of the item to search for.

    Returns:
        The found Section or StatementItem, or None if not found.
    &#34;&#34;&#34;
    if self.id == item_id:
        return self
    for child in self._items:
        if child.id == item_id:
            return child
        if isinstance(child, Section):
            found = child.find_item_by_id(item_id)
            if found:
                return found
    if hasattr(self, &#34;subtotal&#34;) and self.subtotal and self.subtotal.id == item_id:
        return self.subtotal
    return None</code></pre>
</details>
<div class="desc"><p>Recursively find an item by its identifier within this section.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>Identifier of the item to search for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The found Section or StatementItem, or None if not found.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementConfig"><code class="flex name class">
<span>class <span class="ident">StatementConfig</span></span>
<span>(</span><span>config_data:Â dict[str,Â typing.Any],<br>enable_node_validation:Â boolÂ =Â False,<br>node_validation_strict:Â boolÂ =Â False,<br>node_validator:Â <a title="fin_statement_model.statements.validation.UnifiedNodeValidator" href="validation.html#fin_statement_model.statements.validation.UnifiedNodeValidator">UnifiedNodeValidator</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementConfig:
    &#34;&#34;&#34;Manages configuration parsing and building for financial statement structures.

    This class handles validating statement configuration data (provided as a dictionary)
    and building StatementStructure objects from these configurations.
    It does NOT handle file loading.
    &#34;&#34;&#34;

    def __init__(
        self,
        config_data: dict[str, Any],
        enable_node_validation: bool = False,
        node_validation_strict: bool = False,
        node_validator: UnifiedNodeValidator | None = None,
    ):
        &#34;&#34;&#34;Initialize a statement configuration processor.

        Args:
            config_data: Dictionary containing the raw configuration data.
            enable_node_validation: If True, validates node IDs using UnifiedNodeValidator.
            node_validation_strict: If True, treats node validation failures as errors.
                                   If False, treats them as warnings.
            node_validator: Optional pre-configured UnifiedNodeValidator instance.
                           If None and enable_node_validation is True, creates a default instance.

        Raises:
            ValueError: If config_data is not a non-empty dictionary.
        &#34;&#34;&#34;
        if not config_data or not isinstance(config_data, dict):
            raise ValueError(&#34;config_data must be a non-empty dictionary.&#34;)

        self.config_data = config_data
        self.model: StatementModel | None = None  # Store validated model

        # Node validation configuration
        self.enable_node_validation = enable_node_validation
        self.node_validation_strict = node_validation_strict

        # Initialize node_validator attribute
        self.node_validator: UnifiedNodeValidator | None = None
        if enable_node_validation:
            if node_validator is not None:
                self.node_validator = node_validator
            else:
                # Create default validator
                self.node_validator = UnifiedNodeValidator(
                    standard_node_registry,
                    strict_mode=node_validation_strict,
                    auto_standardize=True,
                    warn_on_non_standard=True,
                    enable_patterns=True,
                )

    def validate_config(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Validate the configuration data using Pydantic models and optional node validation.

        Returns:
            list[ErrorDetail]: List of validation errors, or empty list if valid.
                     Stores the validated model in self.model on success.
        &#34;&#34;&#34;
        error_collector = ErrorCollector()

        try:
            # First perform Pydantic validation
            self.model = StatementModel.model_validate(self.config_data)

            # If node validation is enabled, perform additional validation
            if self.enable_node_validation and self.node_validator:
                self._validate_node_ids(self.model, error_collector)

            # Collect structured errors (always include errors)
            errors: list[ErrorDetail] = error_collector.get_errors()
            warnings: list[ErrorDetail] = error_collector.get_warnings()

            if self.node_validation_strict:
                result: list[ErrorDetail] = errors + warnings
            else:
                # Log warnings but exclude from returned errors
                for warning in warnings:
                    logger.warning(&#34;Node validation warning: %s&#34;, warning)
                result = errors

        except ValidationError as ve:
            # Convert Pydantic errors to structured ErrorDetail list
            error_details: list[ErrorDetail] = []
            for err in ve.errors():
                loc = &#34;.&#34;.join(str(x) for x in err.get(&#34;loc&#34;, []))
                msg = err.get(&#34;msg&#34;, &#34;&#34;)
                error_details.append(
                    ErrorDetail(
                        code=&#34;pydantic_validation&#34;,
                        message=msg,
                        context=loc,
                        severity=ErrorSeverity.ERROR,
                    )
                )
            self.model = None  # Ensure model is not set on validation error
            return error_details
        except Exception as e:
            # Catch other potential validation issues
            logger.exception(&#34;Unexpected error during configuration validation&#34;)
            self.model = None
            return [
                ErrorDetail(
                    code=&#34;unexpected_validation_error&#34;,
                    message=str(e),
                    severity=ErrorSeverity.ERROR,
                )
            ]
        else:
            return result

    def _validate_node_ids(self, model: StatementModel, error_collector: ErrorCollector) -&gt; None:
        &#34;&#34;&#34;Validate all node IDs in the statement model using UnifiedNodeValidator.

        Args:
            model: The validated StatementModel to check.
            error_collector: ErrorCollector to accumulate validation issues.
        &#34;&#34;&#34;
        logger.debug(&#34;Starting node ID validation for statement &#39;%s&#39;&#34;, model.id)

        # Validate statement ID itself
        self._validate_single_node_id(model.id, &#34;statement&#34;, &#34;statement.id&#34;, error_collector)

        # Validate all sections recursively
        for section in model.sections:
            self._validate_section_node_ids(section, error_collector, f&#34;statement.{model.id}&#34;)

    def _validate_section_node_ids(
        self,
        section: SectionModel,
        error_collector: ErrorCollector,
        parent_context: str,
    ) -&gt; None:
        &#34;&#34;&#34;Validate node IDs within a section and its items.

        Args:
            section: The section model to validate.
            error_collector: ErrorCollector to accumulate validation issues.
            parent_context: Context string for error reporting.
        &#34;&#34;&#34;
        section_context = f&#34;{parent_context}.section.{section.id}&#34;

        # Validate section ID
        self._validate_single_node_id(section.id, &#34;section&#34;, f&#34;{section_context}.id&#34;, error_collector)

        # Validate all items in the section
        for item in section.items:
            self._validate_item_node_ids(item, error_collector, section_context)

        # Validate subsections recursively
        for subsection in section.subsections:
            self._validate_section_node_ids(subsection, error_collector, section_context)

        # Validate section subtotal if present
        if section.subtotal:
            self._validate_item_node_ids(section.subtotal, error_collector, section_context)

    def _validate_item_node_ids(
        self, item: BaseItemModel, error_collector: ErrorCollector, parent_context: str
    ) -&gt; None:
        &#34;&#34;&#34;Validate node IDs within a specific item.

        Args:
            item: The item model to validate.
            error_collector: ErrorCollector to accumulate validation issues.
            parent_context: Context string for error reporting.
        &#34;&#34;&#34;
        item_context = f&#34;{parent_context}.item.{item.id}&#34;

        # Validate the item ID itself
        self._validate_single_node_id(item.id, &#34;item&#34;, f&#34;{item_context}.id&#34;, error_collector)

        # Type-specific validation
        if isinstance(item, LineItemModel):
            # Validate node_id if present
            if item.node_id:
                self._validate_single_node_id(item.node_id, &#34;node&#34;, f&#34;{item_context}.node_id&#34;, error_collector)

            # Validate standard_node_ref if present
            if item.standard_node_ref:
                self._validate_single_node_id(
                    item.standard_node_ref,
                    &#34;standard_node&#34;,
                    f&#34;{item_context}.standard_node_ref&#34;,
                    error_collector,
                )

        elif isinstance(item, CalculatedItemModel):
            # Validate calculation inputs
            self._validate_calculation_inputs(item.calculation, error_collector, item_context)

        elif isinstance(item, MetricItemModel):
            # Validate metric inputs (the values, not the keys)
            for input_key, input_id in item.inputs.items():
                self._validate_single_node_id(
                    input_id,
                    &#34;metric_input&#34;,
                    f&#34;{item_context}.inputs.{input_key}&#34;,
                    error_collector,
                )

        elif isinstance(item, SubtotalModel):
            # Validate items_to_sum if present
            if item.items_to_sum:
                for i, input_id in enumerate(item.items_to_sum):
                    self._validate_single_node_id(
                        input_id,
                        &#34;subtotal_input&#34;,
                        f&#34;{item_context}.items_to_sum[{i}]&#34;,
                        error_collector,
                    )

            # Validate calculation inputs if present
            if item.calculation:
                self._validate_calculation_inputs(item.calculation, error_collector, item_context)

        elif isinstance(item, SectionModel):
            # Recursive validation for nested sections
            self._validate_section_node_ids(item, error_collector, parent_context)

    def _validate_calculation_inputs(
        self,
        calculation: CalculationSpec,
        error_collector: ErrorCollector,
        parent_context: str,
    ) -&gt; None:
        &#34;&#34;&#34;Validate inputs within a calculation specification.

        Args:
            calculation: The calculation specification to validate.
            error_collector: ErrorCollector to accumulate validation issues.
            parent_context: Context string for error reporting.
        &#34;&#34;&#34;
        for i, input_id in enumerate(calculation.inputs):
            self._validate_single_node_id(
                input_id,
                &#34;calculation_input&#34;,
                f&#34;{parent_context}.calculation.inputs[{i}]&#34;,
                error_collector,
            )

    def _validate_single_node_id(
        self,
        node_id: str,
        node_type: str,
        context: str,
        error_collector: ErrorCollector,
    ) -&gt; None:
        &#34;&#34;&#34;Validate a single node ID using the UnifiedNodeValidator.

        Args:
            node_id: The node ID to validate.
            node_type: Type description for error messages.
            context: Context string for error reporting.
            error_collector: ErrorCollector to accumulate validation issues.
        &#34;&#34;&#34;
        if not self.node_validator:
            return

        try:
            validation_result = self.node_validator.validate(
                node_id,
                node_type=node_type,
                parent_nodes=None,  # Could be enhanced to track parent context
                use_cache=True,
            )

            # Determine severity based on validation result and configuration
            if not validation_result.is_valid:
                severity = ErrorSeverity.ERROR if self.node_validation_strict else ErrorSeverity.WARNING
                message = f&#34;Invalid {node_type} ID &#39;{node_id}&#39;: {validation_result.message}&#34;
                if severity == ErrorSeverity.ERROR:
                    error_collector.add_error(
                        code=&#34;invalid_node_id&#34;,
                        message=message,
                        context=context,
                        source=node_id,
                    )
                else:
                    error_collector.add_warning(
                        code=&#34;invalid_node_id&#34;,
                        message=message,
                        context=context,
                        source=node_id,
                    )

            elif validation_result.category in [
                &#34;alternate&#34;,
                &#34;subnode_nonstandard&#34;,
                &#34;custom&#34;,
            ]:
                # These are valid but could be improved
                error_collector.add_warning(
                    code=&#34;non_standard_node_id&#34;,
                    message=f&#34;Non-standard {node_type} ID &#39;{node_id}&#39;: {validation_result.message}&#34;,
                    context=context,
                    source=node_id,
                )

            # Add suggestions if available
            if validation_result.suggestions:
                suggestion_msg = (
                    f&#34;Suggestions for {node_type} ID &#39;{node_id}&#39;: {&#39;; &#39;.join(validation_result.suggestions)}&#34;
                )
                error_collector.add_warning(
                    code=&#34;node_id_suggestions&#34;,
                    message=suggestion_msg,
                    context=context,
                    source=node_id,
                )

        except Exception as e:
            logger.exception(&#34;Error validating node ID &#39;%s&#39; in context &#39;%s&#39;&#34;, node_id, context)
            error_collector.add_warning(
                code=&#34;node_validation_error&#34;,
                message=f&#34;Failed to validate {node_type} ID &#39;{node_id}&#39;: {e}&#34;,
                context=context,
                source=node_id,
            )</code></pre>
</details>
<div class="desc"><p>Manages configuration parsing and building for financial statement structures.</p>
<p>This class handles validating statement configuration data (provided as a dictionary)
and building StatementStructure objects from these configurations.
It does NOT handle file loading.</p>
<p>Initialize a statement configuration processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_data</code></strong></dt>
<dd>Dictionary containing the raw configuration data.</dd>
<dt><strong><code>enable_node_validation</code></strong></dt>
<dd>If True, validates node IDs using UnifiedNodeValidator.</dd>
<dt><strong><code>node_validation_strict</code></strong></dt>
<dd>If True, treats node validation failures as errors.
If False, treats them as warnings.</dd>
<dt><strong><code>node_validator</code></strong></dt>
<dd>Optional pre-configured UnifiedNodeValidator instance.
If None and enable_node_validation is True, creates a default instance.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If config_data is not a non-empty dictionary.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.StatementConfig.validate_config"><code class="name flex">
<span>def <span class="ident">validate_config</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_config(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Validate the configuration data using Pydantic models and optional node validation.

    Returns:
        list[ErrorDetail]: List of validation errors, or empty list if valid.
                 Stores the validated model in self.model on success.
    &#34;&#34;&#34;
    error_collector = ErrorCollector()

    try:
        # First perform Pydantic validation
        self.model = StatementModel.model_validate(self.config_data)

        # If node validation is enabled, perform additional validation
        if self.enable_node_validation and self.node_validator:
            self._validate_node_ids(self.model, error_collector)

        # Collect structured errors (always include errors)
        errors: list[ErrorDetail] = error_collector.get_errors()
        warnings: list[ErrorDetail] = error_collector.get_warnings()

        if self.node_validation_strict:
            result: list[ErrorDetail] = errors + warnings
        else:
            # Log warnings but exclude from returned errors
            for warning in warnings:
                logger.warning(&#34;Node validation warning: %s&#34;, warning)
            result = errors

    except ValidationError as ve:
        # Convert Pydantic errors to structured ErrorDetail list
        error_details: list[ErrorDetail] = []
        for err in ve.errors():
            loc = &#34;.&#34;.join(str(x) for x in err.get(&#34;loc&#34;, []))
            msg = err.get(&#34;msg&#34;, &#34;&#34;)
            error_details.append(
                ErrorDetail(
                    code=&#34;pydantic_validation&#34;,
                    message=msg,
                    context=loc,
                    severity=ErrorSeverity.ERROR,
                )
            )
        self.model = None  # Ensure model is not set on validation error
        return error_details
    except Exception as e:
        # Catch other potential validation issues
        logger.exception(&#34;Unexpected error during configuration validation&#34;)
        self.model = None
        return [
            ErrorDetail(
                code=&#34;unexpected_validation_error&#34;,
                message=str(e),
                severity=ErrorSeverity.ERROR,
            )
        ]
    else:
        return result</code></pre>
</details>
<div class="desc"><p>Validate the configuration data using Pydantic models and optional node validation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="fin_statement_model.statements.ErrorDetail" href="#fin_statement_model.statements.ErrorDetail">ErrorDetail</a>]</code></dt>
<dd>List of validation errors, or empty list if valid.
Stores the validated model in self.model on success.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementError"><code class="flex name class">
<span>class <span class="ident">StatementError</span></span>
<span>(</span><span>message:Â str, statement_id:Â strÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementError(FinancialModelError):
    &#34;&#34;&#34;Error raised for issues related to financial statements.

    Used for errors specific to the structure, definition, or
    processing of financial statements (e.g., Balance Sheet, P&amp;L).

    Examples:
        &gt;&gt;&gt; raise StatementError(&#34;Balance sheet does not balance&#34;, statement_id=&#34;BS_2023&#34;)
        &gt;&gt;&gt; raise StatementError(&#34;Required account missing from P&amp;L&#34;, statement_id=&#34;PnL_Q1&#34;)
    &#34;&#34;&#34;

    def __init__(self, message: str, statement_id: str | None = None):
        &#34;&#34;&#34;Initialize the StatementError.

        Args:
            message: The base error message.
            statement_id: Optional ID or name of the statement involved.
        &#34;&#34;&#34;
        self.statement_id = statement_id

        full_message = f&#34;{message} for statement &#39;{statement_id}&#39;&#34; if statement_id else message

        super().__init__(full_message)</code></pre>
</details>
<div class="desc"><p>Error raised for issues related to financial statements.</p>
<p>Used for errors specific to the structure, definition, or
processing of financial statements (e.g., Balance Sheet, P&amp;L).</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; raise StatementError(&quot;Balance sheet does not balance&quot;, statement_id=&quot;BS_2023&quot;)
&gt;&gt;&gt; raise StatementError(&quot;Required account missing from P&amp;L&quot;, statement_id=&quot;PnL_Q1&quot;)
</code></pre>
<p>Initialize the StatementError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The base error message.</dd>
<dt><strong><code>statement_id</code></strong></dt>
<dd>Optional ID or name of the statement involved.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.core.errors.FinancialModelError" href="../core/errors.html#fin_statement_model.core.errors.FinancialModelError">FinancialModelError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.errors.StatementBuilderError" href="errors.html#fin_statement_model.statements.errors.StatementBuilderError">StatementBuilderError</a></li>
<li><a title="fin_statement_model.statements.errors.StatementValidationError" href="errors.html#fin_statement_model.statements.errors.StatementValidationError">StatementValidationError</a></li>
</ul>
</dd>
<dt id="fin_statement_model.statements.StatementFormatter"><code class="flex name class">
<span>class <span class="ident">StatementFormatter</span></span>
<span>(</span><span>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementFormatter:
    &#34;&#34;&#34;Formats financial statements for display or reporting.

    This class provides methods to transform raw financial data into
    formatted financial statements with proper headers, indentation,
    subtotals, sign conventions, and enhanced display control.
    &#34;&#34;&#34;

    def __init__(self, statement: StatementStructure):
        &#34;&#34;&#34;Initialize a statement formatter.

        Args:
            statement: The statement structure to format
        &#34;&#34;&#34;
        self.statement = statement

        # --- Build default display formats from global config ---
        from fin_statement_model import get_config  # Local import to avoid circular dep

        cfg_display = get_config().display
        num_format = cfg_display.default_number_format or &#34;,.2f&#34;
        # Detect precision from format string like &#39;,.2f&#39; or &#39;.3f&#39;
        precision_match = re.search(r&#34;\.([0-9]+)f$&#34;, num_format)
        precision = int(precision_match.group(1)) if precision_match else 2
        use_thousands_sep = &#34;,&#34; in num_format.split(&#34;.&#34;)[0]

        self.default_formats = {
            &#34;precision&#34;: precision,
            &#34;use_thousands_separator&#34;: use_thousands_sep,
            &#34;show_zero_values&#34;: not cfg_display.hide_zero_rows,
            &#34;show_negative_sign&#34;: cfg_display.show_negative_sign,
            &#34;indent_character&#34;: cfg_display.indent_character,
            &#34;subtotal_style&#34;: cfg_display.subtotal_style,
            &#34;total_style&#34;: cfg_display.total_style,
            &#34;header_style&#34;: cfg_display.header_style,
            # Contra item display options
            &#34;contra_display_style&#34;: cfg_display.contra_display_style,
            &#34;contra_css_class&#34;: cfg_display.contra_css_class,
        }

    def _resolve_hierarchical_attribute(
        self,
        item: StatementItem | Section,
        attribute_name: str,
        default_value: Any = None,
        config_path: str | None = None,
        skip_default_check: Callable[[Any], bool] | None = None,
    ) -&gt; Any:
        &#34;&#34;&#34;Resolve an attribute value using hierarchical lookup.

        Precedence: Item &gt; Parent Section &gt; Statement &gt; Config/Default

        Args:
            item: The item or section to resolve the attribute for
            attribute_name: Name of the attribute to look up
            default_value: Default value if not found anywhere
            config_path: Optional config path to check before using default_value
            skip_default_check: Optional function to determine if a value should be
                              considered &#34;default&#34; and skipped (e.g., scale_factor == 1.0)

        Returns:
            The resolved attribute value
        &#34;&#34;&#34;
        # Check item-specific attribute
        if hasattr(item, attribute_name):
            item_value = getattr(item, attribute_name)
            if skip_default_check is None or not skip_default_check(item_value):
                return item_value

        # Check if item is part of a section with the attribute
        if isinstance(item, StatementItem):
            parent_section = self._find_parent_section_for_item(item)
            if parent_section and hasattr(parent_section, attribute_name):
                section_value = getattr(parent_section, attribute_name)
                if skip_default_check is None or not skip_default_check(section_value):
                    return section_value

        # Check statement-level attribute
        if hasattr(self.statement, attribute_name):
            statement_value = getattr(self.statement, attribute_name)
            if skip_default_check is None or not skip_default_check(statement_value):
                return statement_value

        # Check config if path provided
        if config_path:
            from fin_statement_model.config.access import cfg

            return cfg(config_path, default_value)

        # Return default value
        return default_value

    def _resolve_display_scale_factor(self, item: StatementItem | Section) -&gt; float:
        &#34;&#34;&#34;Resolve the display scale factor for an item, considering hierarchy.

        Precedence: Item &gt; Section &gt; Statement &gt; Default (from config)

        Args:
            item: The item or section to get the scale factor for

        Returns:
            The resolved scale factor
        &#34;&#34;&#34;
        result = self._resolve_hierarchical_attribute(
            item=item,
            attribute_name=&#34;display_scale_factor&#34;,
            default_value=1.0,
            config_path=&#34;display.scale_factor&#34;,
            skip_default_check=lambda x: x == 1.0,
        )
        return float(result)

    def _resolve_units(self, item: StatementItem | Section) -&gt; str | None:
        &#34;&#34;&#34;Resolve the unit description for an item, considering hierarchy.

        Precedence: Item &gt; Section &gt; Statement &gt; None

        Args:
            item: The item or section to get the units for

        Returns:
            The resolved unit description or None
        &#34;&#34;&#34;
        result = self._resolve_hierarchical_attribute(
            item=item,
            attribute_name=&#34;units&#34;,
            default_value=None,
            skip_default_check=lambda x: not x,  # Skip empty strings/None
        )
        return result if result is not None else None

    def _find_parent_section_for_item(self, target_item: StatementItem) -&gt; Section | None:
        &#34;&#34;&#34;Find the parent section that contains the given item.

        Args:
            target_item: The item to find the parent section for.

        Returns:
            The parent Section object, or None if not found.
        &#34;&#34;&#34;

        def search_in_section(section: Section) -&gt; Section | None:
            # Check direct items
            for item in section.items:
                if item is target_item or (
                    hasattr(item, &#34;id&#34;) and hasattr(target_item, &#34;id&#34;) and item.id == target_item.id
                ):
                    return section
                # Check nested sections
                if isinstance(item, Section):
                    result = search_in_section(item)
                    if result:
                        return result

            # Check subtotal
            if hasattr(section, &#34;subtotal&#34;) and section.subtotal is target_item:
                return section

            return None

        # Search through all top-level sections
        for section in self.statement.sections:
            result = search_in_section(section)
            if result:
                return result

        return None

    def _should_hide_item(self, item: StatementItem | Section, values: dict[str, float]) -&gt; bool:
        &#34;&#34;&#34;Check if an item should be hidden based on hide_if_all_zero setting.

        Args:
            item: The item to check
            values: Dictionary of period values for the item

        Returns:
            True if the item should be hidden
        &#34;&#34;&#34;
        # Check if the item has hide_if_all_zero enabled
        hide_if_zero = getattr(item, &#34;hide_if_all_zero&#34;, False)
        if not hide_if_zero:
            return False

        # Check if all values are zero or NaN
        return all(not (pd.notna(value) and value != 0) for value in values.values())

    def _apply_item_scaling(self, values: dict[str, float], scale_factor: float) -&gt; dict[str, float]:
        &#34;&#34;&#34;Apply scaling to item values.

        Args:
            values: Dictionary of period values
            scale_factor: Factor to scale by

        Returns:
            Dictionary of scaled values
        &#34;&#34;&#34;
        if scale_factor == 1.0:
            return values

        scaled_values = {}
        for period, value in values.items():
            if pd.notna(value):
                scaled_values[period] = value * scale_factor
            else:
                scaled_values[period] = value

        return scaled_values

    def _format_item_values(
        self,
        item: StatementItem | Section,
        values: dict[str, float],
        period_columns: list[str],
    ) -&gt; dict[str, str]:
        &#34;&#34;&#34;Format values for an item using its specific display format if available.

        Args:
            item: The item to format values for
            values: Dictionary of period values
            period_columns: List of period column names

        Returns:
            Dictionary of formatted values
        &#34;&#34;&#34;
        # Get item-specific display format
        item_format = getattr(item, &#34;display_format&#34;, None)

        formatted_values = {}
        for period in period_columns:
            value = values.get(period, np.nan)

            if pd.notna(value):
                if item_format:
                    try:
                        formatted_values[period] = f&#34;{value:{item_format}}&#34;
                    except (ValueError, TypeError):
                        # Fall back to default if format is invalid
                        logger.warning(
                            &#34;Invalid display format &#39;%s&#39; for item &#39;%s&#39;, using default&#34;,
                            item_format,
                            getattr(item, &#34;id&#34;, &#34;unknown&#34;),
                        )
                        formatted_values[period] = str(value)  # Convert to string for consistency
                else:
                    formatted_values[period] = str(value)  # Convert to string for consistency
            else:
                formatted_values[period] = &#34;&#34;

        return formatted_values

    def _format_contra_value(self, value: float, display_style: str | None = None) -&gt; str:
        &#34;&#34;&#34;Format a contra item value according to the specified display style.

        Args:
            value: The numeric value to format
            display_style: Style for contra display (&#34;parentheses&#34;, &#34;negative_sign&#34;, &#34;brackets&#34;)

        Returns:
            Formatted string representation of the contra value
        &#34;&#34;&#34;
        if pd.isna(value) or value == 0:
            return &#34;&#34;

        # For contra items, we typically want to show the absolute value with special formatting
        # regardless of the underlying sign, since sign_convention handles calculation logic
        from fin_statement_model.config.access import cfg

        style = display_style or self.default_formats.get(
            &#34;contra_display_style&#34;, cfg(&#34;display.contra_display_style&#34;, &#34;parentheses&#34;)
        )
        abs_value = abs(value)

        # Use dictionary for style formatting
        style_formats = {
            &#34;parentheses&#34;: f&#34;({abs_value:,.2f})&#34;,
            &#34;negative_sign&#34;: f&#34;-{abs_value:,.2f}&#34;,
            &#34;brackets&#34;: f&#34;[{abs_value:,.2f}]&#34;,
        }

        if style and isinstance(style, str) and style in style_formats:
            return style_formats[style]
        return f&#34;({abs_value:,.2f})&#34;  # Default fallback

    def _apply_contra_formatting(
        self,
        item: StatementItem | Section,
        values: dict[str, float],
        period_columns: list[str],
        display_style: str | None = None,
    ) -&gt; dict[str, str]:
        &#34;&#34;&#34;Apply contra-specific formatting to item values.

        Args:
            item: The item to format
            values: Dictionary of period values
            period_columns: List of period column names
            display_style: Optional override for contra display style

        Returns:
            Dictionary of formatted contra values
        &#34;&#34;&#34;
        _ = item  # Parameter intentionally unused in current implementation
        contra_formatted = {}
        for period in period_columns:
            value = values.get(period, np.nan)
            contra_formatted[period] = self._format_contra_value(value, display_style)

        return contra_formatted

    def _prepare_formatting_context(self, **kwargs: Any) -&gt; FormattingContext:
        &#34;&#34;&#34;Prepare formatting context with config defaults.

        Args:
            **kwargs: All formatting parameters passed to generate_dataframe (overrides config)

        Returns:
            FormattingContext: Configured context object
        &#34;&#34;&#34;
        from fin_statement_model import get_config

        config = get_config()

        # Create context with provided kwargs
        context = FormattingContext(
            should_apply_signs=kwargs.get(&#34;should_apply_signs&#34;, config.display.apply_sign_conventions),
            include_empty_items=kwargs.get(&#34;include_empty_items&#34;, config.display.include_empty_items),
            number_format=kwargs.get(&#34;number_format&#34;),
            include_metadata_cols=kwargs.get(&#34;include_metadata_cols&#34;, config.display.include_metadata_cols),
            adjustment_filter=kwargs.get(&#34;adjustment_filter&#34;),
            add_is_adjusted_column=kwargs.get(&#34;add_is_adjusted_column&#34;, config.display.add_is_adjusted_column),
            include_units_column=kwargs.get(&#34;include_units_column&#34;, config.display.include_units_column),
            include_css_classes=kwargs.get(&#34;include_css_classes&#34;, config.display.include_css_classes),
            include_notes_column=kwargs.get(&#34;include_notes_column&#34;, config.display.include_notes_column),
            apply_item_scaling=kwargs.get(&#34;apply_item_scaling&#34;, config.display.apply_item_scaling),
            apply_item_formatting=kwargs.get(&#34;apply_item_formatting&#34;, config.display.apply_item_formatting),
            respect_hide_flags=kwargs.get(&#34;respect_hide_flags&#34;),
            contra_display_style=kwargs.get(&#34;contra_display_style&#34;),
            apply_contra_formatting=kwargs.get(&#34;apply_contra_formatting&#34;, config.display.apply_contra_formatting),
            add_contra_indicator_column=kwargs.get(
                &#34;add_contra_indicator_column&#34;,
                config.display.add_contra_indicator_column,
            ),
        )

        # Apply config defaults for None values
        if context.should_apply_signs is None:
            context.should_apply_signs = True  # This is a calculation default, not display
        if context.include_empty_items is None:
            context.include_empty_items = False  # Preserve historical default
        if context.respect_hide_flags is None:
            context.respect_hide_flags = config.display.hide_zero_rows
        if context.contra_display_style is None:
            context.contra_display_style = config.display.contra_display_style
        if context.number_format is None:
            context.number_format = config.display.default_number_format

        # Set default formats
        context.default_formats = self.default_formats

        return context

    def _fetch_statement_data(
        self, graph: Graph, context: FormattingContext
    ) -&gt; tuple[dict[str, dict[str, float]], Any]:
        &#34;&#34;&#34;Fetch data from graph using DataFetcher.

        Args:
            graph: The core.graph.Graph instance containing the data
            context: Formatting context with fetch parameters

        Returns:
            Tuple of (data dictionary, fetch errors)
        &#34;&#34;&#34;
        data_fetcher = DataFetcher(self.statement, graph)
        fetch_result = data_fetcher.fetch_all_data(
            adjustment_filter=context.adjustment_filter,
            include_missing=context.include_empty_items,
        )

        # Log any warnings/errors
        if fetch_result.errors.has_warnings() or fetch_result.errors.has_errors():
            fetch_result.errors.log_all(prefix=f&#34;Statement &#39;{self.statement.id}&#39; data fetch: &#34;)

        # Update context with periods from graph
        context.all_periods = graph.periods

        return fetch_result.data, fetch_result.errors

    def _create_empty_dataframe(self, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Create an empty DataFrame with appropriate columns.

        Args:
            context: Formatting context with column configuration

        Returns:
            Empty DataFrame with proper column structure
        &#34;&#34;&#34;
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;, *context.all_periods]
        if context.include_units_column:
            base_cols.append(&#34;units&#34;)
        return pd.DataFrame(columns=base_cols)

    def _build_row_data(
        self,
        graph: Graph,
        data: dict[str, dict[str, float]],
        context: FormattingContext,
    ) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Build row data recursively from statement structure.

        Args:
            graph: The core.graph.Graph instance
            data: Fetched data dictionary
            context: Formatting context

        Returns:
            List of row dictionaries
        &#34;&#34;&#34;
        rows: list[dict[str, Any]] = []
        id_resolver = IDResolver(self.statement, standard_node_registry)

        # Process all sections
        self._process_items_recursive(
            items=list(self.statement.sections),
            depth=0,
            data=data,
            rows=rows,
            context=context,
            id_resolver=id_resolver,
            graph=graph,
        )

        # Filter hidden items if needed
        if context.respect_hide_flags:
            rows = [row for row in rows if row[&#34;ID&#34;] not in context.items_to_hide]

        return rows

    def _process_items_recursive(
        self,
        items: list[Section | StatementItem],
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Recursively process items and sections.

        Args:
            items: List of items or sections to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        for item in items:
            if isinstance(item, Section):
                self._process_section(item, depth, data, rows, context, id_resolver, graph)
            elif isinstance(item, StatementItem):
                self._process_item(item, depth, data, rows, context, id_resolver, graph)

    def _process_section(
        self,
        section: Section,
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Process a section and its items.

        Args:
            section: Section to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        # Process section items first to collect data for hide check
        self._process_items_recursive(section.items, depth + 1, data, rows, context, id_resolver, graph)

        # Process subtotal if it exists
        if hasattr(section, &#34;subtotal&#34;) and section.subtotal:
            self._process_items_recursive([section.subtotal], depth + 1, data, rows, context, id_resolver, graph)

        # Check if section should be hidden
        if context.respect_hide_flags and getattr(section, &#34;hide_if_all_zero&#34;, False):
            # For sections, check if all contained items are hidden or zero
            section_has_data = False
            for section_item in section.items:
                node_id = id_resolver.resolve(section_item.id, graph)
                if node_id and node_id in data:
                    item_data = data[node_id]
                    if any(pd.notna(v) and v != 0 for v in item_data.values()):
                        section_has_data = True
                        break
            if not section_has_data:
                context.items_to_hide.add(section.id)

    def _process_item(
        self,
        item: StatementItem,
        depth: int,
        data: dict[str, dict[str, float]],
        rows: list[dict[str, Any]],
        context: FormattingContext,
        id_resolver: IDResolver,
        graph: Graph,
    ) -&gt; None:
        &#34;&#34;&#34;Process a single statement item.

        Args:
            item: Statement item to process
            depth: Current indentation depth
            data: Fetched data dictionary
            rows: List to append row data to
            context: Formatting context
            id_resolver: ID resolver instance
            graph: Graph instance
        &#34;&#34;&#34;
        # Use ID resolver to get the correct node ID
        node_id = id_resolver.resolve(item.id, graph)
        if not node_id:
            return

        item_data = data.get(node_id, {})
        numeric_values: dict[str, float] = {p: item_data.get(p, np.nan) for p in context.all_periods}

        # Apply item-specific scaling if enabled
        if context.apply_item_scaling:
            numeric_values = self._apply_scaling(numeric_values, context, item)

        # Check if item should be hidden
        if context.respect_hide_flags and self._should_hide_item(item, numeric_values):
            context.items_to_hide.add(item.id)
            return

        # Start with numeric values and add formatted strings as needed
        row_values: dict[str, float | str] = dict(numeric_values)

        # Apply item-specific formatting if enabled (but only if not using global format)
        if context.apply_item_formatting and not context.number_format:
            formatted_values = self._format_item_values(item, numeric_values, context.all_periods)
            # Only apply if we got actual formatted strings
            if any(isinstance(v, str) for v in formatted_values.values()):
                for period in context.all_periods:
                    if period in formatted_values and isinstance(formatted_values[period], str):
                        # Keep numeric value for calculations, store formatted for display
                        row_values[f&#34;{period}_formatted&#34;] = formatted_values[period]

        # Apply contra formatting if enabled and item is marked as contra
        if context.apply_contra_formatting and getattr(item, &#34;is_contra&#34;, False):
            contra_formatted = self._apply_contra_formatting(
                item, numeric_values, context.all_periods, context.contra_display_style
            )
            # Store contra formatted values for later use
            for period in context.all_periods:
                if contra_formatted.get(period):
                    row_values[f&#34;{period}_contra&#34;] = contra_formatted[period]

        if context.include_empty_items or any(pd.notna(v) for v in row_values.values()):
            row = self._create_row_dict(item, node_id, row_values, depth, context)
            rows.append(row)

    def _create_row_dict(
        self,
        item: StatementItem,
        node_id: str,
        row_values: dict[str, float | str],
        depth: int,
        context: FormattingContext,
    ) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Create a row dictionary for a statement item.

        Args:
            item: Statement item
            node_id: Resolved node ID
            row_values: Period values for the item
            depth: Indentation depth
            context: Formatting context

        Returns:
            Row dictionary
        &#34;&#34;&#34;
        indent_char = context.default_formats[&#34;indent_character&#34;]

        row = {
            &#34;Line Item&#34;: indent_char * depth + item.name,
            &#34;ID&#34;: item.id,
            **row_values,
            # Metadata
            &#34;line_type&#34;: self._get_item_type(item),
            &#34;node_id&#34;: node_id,
            &#34;sign_convention&#34;: getattr(item, &#34;sign_convention&#34;, 1),
            &#34;is_subtotal&#34;: isinstance(item, SubtotalLineItem),
            &#34;is_calculated&#34;: isinstance(item, CalculatedLineItem),
            &#34;is_contra&#34;: getattr(item, &#34;is_contra&#34;, False),
        }

        # Add enhanced metadata columns if requested
        if context.include_units_column:
            row[&#34;units&#34;] = self._resolve_units(item)

        if context.include_css_classes:
            # Get item&#39;s CSS class and add contra class if applicable
            item_css_class = getattr(item, &#34;css_class&#34;, None)
            if getattr(item, &#34;is_contra&#34;, False):
                contra_css = context.default_formats.get(&#34;contra_css_class&#34;, &#34;contra-item&#34;)
                if item_css_class:
                    row[&#34;css_class&#34;] = f&#34;{item_css_class} {contra_css}&#34;
                else:
                    row[&#34;css_class&#34;] = contra_css
            else:
                row[&#34;css_class&#34;] = item_css_class

        if context.include_notes_column:
            notes = getattr(item, &#34;notes_references&#34;, [])
            row[&#34;notes&#34;] = &#34;; &#34;.join(notes) if notes else &#34;&#34;

        return row

    def _apply_scaling(
        self, values: dict[str, float], context: FormattingContext, item: StatementItem
    ) -&gt; dict[str, float]:
        &#34;&#34;&#34;Apply item-specific scaling if enabled.

        Args:
            values: Dictionary of period values
            context: Formatting context
            item: Statement item

        Returns:
            Dictionary of scaled values
        &#34;&#34;&#34;
        if not context.apply_item_scaling:
            return values

        scale_factor = self._resolve_display_scale_factor(item)
        return self._apply_item_scaling(values, scale_factor)

    def _organize_dataframe_columns(self, df: pd.DataFrame, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Organize DataFrame columns in the correct order.

        Args:
            df: DataFrame to organize
            context: Formatting context

        Returns:
            DataFrame with organized columns
        &#34;&#34;&#34;
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;]
        metadata_cols = [
            &#34;line_type&#34;,
            &#34;node_id&#34;,
            &#34;sign_convention&#34;,
            &#34;is_subtotal&#34;,
            &#34;is_calculated&#34;,
            &#34;is_contra&#34;,
        ]

        # Enhanced metadata columns
        enhanced_cols = []
        if context.include_units_column:
            enhanced_cols.append(&#34;units&#34;)
        if context.include_css_classes:
            enhanced_cols.append(&#34;css_class&#34;)
        if context.include_notes_column:
            enhanced_cols.append(&#34;notes&#34;)
        if context.add_contra_indicator_column:
            enhanced_cols.append(&#34;is_contra&#34;)

        # Add adjustment columns if they exist
        adjusted_flag_cols = []
        if context.add_is_adjusted_column:
            adjusted_flag_cols = [f&#34;{period}_is_adjusted&#34; for period in context.all_periods]

        final_cols = base_cols + context.all_periods
        if adjusted_flag_cols:
            final_cols += adjusted_flag_cols
        if enhanced_cols:
            final_cols += enhanced_cols
        if context.include_metadata_cols:
            # Add metadata cols (excluding adjustment flags if they are already added)
            final_cols += [m_col for m_col in metadata_cols if m_col not in adjusted_flag_cols]

        # Ensure contra formatting columns are available temporarily (will be removed later)
        all_available_cols = final_cols.copy()
        if context.apply_contra_formatting:
            contra_formatted_cols = [f&#34;{period}_contra&#34; for period in context.all_periods]
            all_available_cols += contra_formatted_cols

        for col in all_available_cols:
            if col not in df.columns:
                df[col] = np.nan if col in context.all_periods else (&#34;&#34; if col == &#34;Line Item&#34; else None)

        return df[all_available_cols]

    def _add_adjustment_columns(self, df: pd.DataFrame, graph: Graph, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Add adjustment status columns to the DataFrame.

        Args:
            df: DataFrame to add columns to
            graph: Graph instance
            context: Formatting context

        Returns:
            DataFrame with adjustment columns added
        &#34;&#34;&#34;
        if not context.add_is_adjusted_column or not context.all_periods:
            return df

        # Get node IDs from the dataframe
        node_ids_to_check = []
        for _, row in df.iterrows():
            node_id = row.get(&#34;node_id&#34;)
            is_calc_or_subtotal = row.get(&#34;is_calculated&#34;, False) or row.get(&#34;is_subtotal&#34;, False)
            if node_id and not is_calc_or_subtotal:
                node_ids_to_check.append(node_id)

        # Use DataFetcher to check adjustments
        if node_ids_to_check:
            data_fetcher = DataFetcher(self.statement, graph)
            adjustment_status = data_fetcher.check_adjustments(
                node_ids_to_check, context.all_periods, context.adjustment_filter
            )
        else:
            adjustment_status = {}

        # Build adjustment columns
        is_adjusted_data = []
        for _, row in df.iterrows():
            node_id = row.get(&#34;node_id&#34;)
            is_calc_or_subtotal = row.get(&#34;is_calculated&#34;, False) or row.get(&#34;is_subtotal&#34;, False)

            if node_id and not is_calc_or_subtotal and node_id in adjustment_status:
                row_adj_flags = {
                    f&#34;{period}_is_adjusted&#34;: adjustment_status[node_id].get(period, False)
                    for period in context.all_periods
                }
            else:
                # For calculated/subtotal items or missing nodes, flags are False
                row_adj_flags = {f&#34;{period}_is_adjusted&#34;: False for period in context.all_periods}
            is_adjusted_data.append(row_adj_flags)

        if is_adjusted_data:
            adj_df = pd.DataFrame(is_adjusted_data, index=df.index)
            df = pd.concat([df, adj_df], axis=1)

        return df

    def _cleanup_temporary_columns(self, df: pd.DataFrame, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Clean up temporary columns from the dataframe.

        Args:
            df: DataFrame to clean up
            context: Formatting context

        Returns:
            DataFrame with temporary columns removed
        &#34;&#34;&#34;
        # Remove the contra formatting columns from the final output
        if context.apply_contra_formatting:
            contra_cols_to_remove = [f&#34;{period}_contra&#34; for period in context.all_periods]
            df = df.drop(columns=[col for col in contra_cols_to_remove if col in df.columns])

        # Build final column list
        base_cols = [&#34;Line Item&#34;, &#34;ID&#34;]
        metadata_cols = [
            &#34;line_type&#34;,
            &#34;node_id&#34;,
            &#34;sign_convention&#34;,
            &#34;is_subtotal&#34;,
            &#34;is_calculated&#34;,
            &#34;is_contra&#34;,
        ]

        enhanced_cols = []
        if context.include_units_column:
            enhanced_cols.append(&#34;units&#34;)
        if context.include_css_classes:
            enhanced_cols.append(&#34;css_class&#34;)
        if context.include_notes_column:
            enhanced_cols.append(&#34;notes&#34;)
        if context.add_contra_indicator_column:
            enhanced_cols.append(&#34;is_contra&#34;)

        adjusted_flag_cols = []
        if context.add_is_adjusted_column:
            adjusted_flag_cols = [f&#34;{period}_is_adjusted&#34; for period in context.all_periods]

        final_cols = base_cols + context.all_periods
        if context.add_is_adjusted_column:
            final_cols += adjusted_flag_cols
        if enhanced_cols:
            final_cols += enhanced_cols
        if context.include_metadata_cols:
            # Add metadata cols (excluding adjustment flags if they are already added)
            final_cols += [m_col for m_col in metadata_cols if m_col not in adjusted_flag_cols]

        # Select only the final columns for output
        return df[final_cols]

    def _apply_all_formatting(self, df: pd.DataFrame, context: FormattingContext) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Apply consolidated formatting in a single vectorized pass.&#34;&#34;&#34;
        # Combined sign, contra, and number formatting
        df = render_values(
            df=df,
            period_columns=context.all_periods,
            default_formats=context.default_formats,
            number_format=context.number_format,
            contra_display_style=context.contra_display_style,
        )
        # Clean up temporary columns
        df = self._cleanup_temporary_columns(df, context)
        return df

    def generate_dataframe(
        self,
        graph: Graph,
        context: FormattingContext | None = None,
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Generate a formatted DataFrame for the statement.

        Args:
            graph: Graph instance containing the data to render.
            context: FormattingContext object containing all display / formatting
                configuration. If *None*, a context will be created from project
                configuration.

        Returns:
            A fully-formatted ``pandas.DataFrame`` representing the statement.
        &#34;&#34;&#34;
        if context is None:
            # Build context purely from project defaults (no legacy kwargs path).
            context = self._prepare_formatting_context()

        # 2. Fetch statement data -------------------------------------------------------------------
        data, _ = self._fetch_statement_data(graph, context)

        # 3. Build row dictionaries -----------------------------------------------------------------
        rows = self._build_row_data(graph, data, context)

        # 4. Assemble DataFrame ---------------------------------------------------------------------
        if not rows:
            return self._create_empty_dataframe(context)

        df = pd.DataFrame(rows)

        # 5. Adjustment columns (must precede column organisation)
        if context.add_is_adjusted_column:
            df = self._add_adjustment_columns(df, graph, context)

        # 6. Column ordering / injection ------------------------------------------------------------
        df = self._organize_dataframe_columns(df, context)

        # 7. Post-processing formatting -------------------------------------------------------------
        df = self._apply_all_formatting(df, context)

        return df

    def _get_item_type(self, item: StatementItem) -&gt; str:
        &#34;&#34;&#34;Get the type of a statement item.

        Args:
            item: Statement item to get type for

        Returns:
            str: Item type identifier
        &#34;&#34;&#34;
        if isinstance(item, Section):
            return &#34;section&#34;
        elif isinstance(item, SubtotalLineItem):
            return &#34;subtotal&#34;
        elif isinstance(item, CalculatedLineItem):
            return &#34;calculated&#34;
        else:
            return &#34;item&#34;

    def format_html(
        self,
        graph: Graph,
        should_apply_signs: bool | None = None,
        include_empty_items: bool | None = None,
        css_styles: dict[str, str] | None = None,
        use_item_css_classes: bool | None = None,
        **kwargs: Any,
    ) -&gt; str:
        &#34;&#34;&#34;Format the statement data as HTML with enhanced styling support.

        Args:
            graph: The core.graph.Graph instance containing the data.
            should_apply_signs: Whether to apply sign conventions (override config).
            include_empty_items: Whether to include items with no data (override config).
            css_styles: Optional dict of CSS styles for the HTML.
            use_item_css_classes: Whether to use item-specific CSS classes (override config).
            **kwargs: Additional arguments passed to generate_dataframe.

        Returns:
            str: HTML string representing the statement with enhanced styling.
        &#34;&#34;&#34;
        # Determine defaults for unspecified parameters -------------------------------------------
        from fin_statement_model import get_config

        cfg = get_config()

        should_apply_signs = (
            should_apply_signs if should_apply_signs is not None else cfg.display.apply_sign_conventions
        )
        include_empty_items = (
            include_empty_items if include_empty_items is not None else cfg.display.include_empty_items
        )
        use_item_css_classes = (
            use_item_css_classes if use_item_css_classes is not None else cfg.display.include_css_classes
        )

        # Ensure the correct flag for CSS class inclusion is propagated
        if use_item_css_classes:
            kwargs[&#34;include_css_classes&#34;] = True

        # Build a FormattingContext with the specified overrides and any additional
        # keyword arguments provided by the caller.
        context = self._prepare_formatting_context(
            should_apply_signs=should_apply_signs,
            include_empty_items=include_empty_items,
            **kwargs,
        )

        df = self.generate_dataframe(graph=graph, context=context)

        html: str = df.to_html(index=False, classes=&#34;statement-table&#34;, table_id=&#34;financial-statement&#34;)

        if css_styles or use_item_css_classes:
            style_str = &#34;&lt;style&gt;\n&#34;

            # Add default styles for statement tables
            style_str += &#34;&#34;&#34;
            .statement-table { border-collapse: collapse; width: 100%; }
            .statement-table th, .statement-table td { padding: 8px; text-align: right; border: 1px solid #ddd; }
            .statement-table th { background-color: #f2f2f2; font-weight: bold; }
            .statement-table .Line.Item { text-align: left; }
            .contra-item { font-style: italic; color: #666; }
            &#34;&#34;&#34;

            # Add custom styles
            if css_styles:
                for selector, style in css_styles.items():
                    style_str += f&#34;{selector} {{ {style} }}\n&#34;

            style_str += &#34;&lt;/style&gt;\n&#34;
            html = style_str + html

        return html</code></pre>
</details>
<div class="desc"><p>Formats financial statements for display or reporting.</p>
<p>This class provides methods to transform raw financial data into
formatted financial statements with proper headers, indentation,
subtotals, sign conventions, and enhanced display control.</p>
<p>Initialize a statement formatter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure to format</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.StatementFormatter.format_html"><code class="name flex">
<span>def <span class="ident">format_html</span></span>(<span>self,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>should_apply_signs:Â boolÂ |Â NoneÂ =Â None,<br>include_empty_items:Â boolÂ |Â NoneÂ =Â None,<br>css_styles:Â dict[str,Â str]Â |Â NoneÂ =Â None,<br>use_item_css_classes:Â boolÂ |Â NoneÂ =Â None,<br>**kwargs:Â Any) â€‘>Â str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_html(
    self,
    graph: Graph,
    should_apply_signs: bool | None = None,
    include_empty_items: bool | None = None,
    css_styles: dict[str, str] | None = None,
    use_item_css_classes: bool | None = None,
    **kwargs: Any,
) -&gt; str:
    &#34;&#34;&#34;Format the statement data as HTML with enhanced styling support.

    Args:
        graph: The core.graph.Graph instance containing the data.
        should_apply_signs: Whether to apply sign conventions (override config).
        include_empty_items: Whether to include items with no data (override config).
        css_styles: Optional dict of CSS styles for the HTML.
        use_item_css_classes: Whether to use item-specific CSS classes (override config).
        **kwargs: Additional arguments passed to generate_dataframe.

    Returns:
        str: HTML string representing the statement with enhanced styling.
    &#34;&#34;&#34;
    # Determine defaults for unspecified parameters -------------------------------------------
    from fin_statement_model import get_config

    cfg = get_config()

    should_apply_signs = (
        should_apply_signs if should_apply_signs is not None else cfg.display.apply_sign_conventions
    )
    include_empty_items = (
        include_empty_items if include_empty_items is not None else cfg.display.include_empty_items
    )
    use_item_css_classes = (
        use_item_css_classes if use_item_css_classes is not None else cfg.display.include_css_classes
    )

    # Ensure the correct flag for CSS class inclusion is propagated
    if use_item_css_classes:
        kwargs[&#34;include_css_classes&#34;] = True

    # Build a FormattingContext with the specified overrides and any additional
    # keyword arguments provided by the caller.
    context = self._prepare_formatting_context(
        should_apply_signs=should_apply_signs,
        include_empty_items=include_empty_items,
        **kwargs,
    )

    df = self.generate_dataframe(graph=graph, context=context)

    html: str = df.to_html(index=False, classes=&#34;statement-table&#34;, table_id=&#34;financial-statement&#34;)

    if css_styles or use_item_css_classes:
        style_str = &#34;&lt;style&gt;\n&#34;

        # Add default styles for statement tables
        style_str += &#34;&#34;&#34;
        .statement-table { border-collapse: collapse; width: 100%; }
        .statement-table th, .statement-table td { padding: 8px; text-align: right; border: 1px solid #ddd; }
        .statement-table th { background-color: #f2f2f2; font-weight: bold; }
        .statement-table .Line.Item { text-align: left; }
        .contra-item { font-style: italic; color: #666; }
        &#34;&#34;&#34;

        # Add custom styles
        if css_styles:
            for selector, style in css_styles.items():
                style_str += f&#34;{selector} {{ {style} }}\n&#34;

        style_str += &#34;&lt;/style&gt;\n&#34;
        html = style_str + html

    return html</code></pre>
</details>
<div class="desc"><p>Format the statement data as HTML with enhanced styling support.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The core.graph.Graph instance containing the data.</dd>
<dt><strong><code>should_apply_signs</code></strong></dt>
<dd>Whether to apply sign conventions (override config).</dd>
<dt><strong><code>include_empty_items</code></strong></dt>
<dd>Whether to include items with no data (override config).</dd>
<dt><strong><code>css_styles</code></strong></dt>
<dd>Optional dict of CSS styles for the HTML.</dd>
<dt><strong><code>use_item_css_classes</code></strong></dt>
<dd>Whether to use item-specific CSS classes (override config).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to generate_dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>HTML string representing the statement with enhanced styling.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.StatementFormatter.generate_dataframe"><code class="name flex">
<span>def <span class="ident">generate_dataframe</span></span>(<span>self,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>context:Â <a title="fin_statement_model.statements.formatting.formatter.FormattingContext" href="formatting/formatter.html#fin_statement_model.statements.formatting.formatter.FormattingContext">FormattingContext</a>Â |Â NoneÂ =Â None) â€‘>Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_dataframe(
    self,
    graph: Graph,
    context: FormattingContext | None = None,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate a formatted DataFrame for the statement.

    Args:
        graph: Graph instance containing the data to render.
        context: FormattingContext object containing all display / formatting
            configuration. If *None*, a context will be created from project
            configuration.

    Returns:
        A fully-formatted ``pandas.DataFrame`` representing the statement.
    &#34;&#34;&#34;
    if context is None:
        # Build context purely from project defaults (no legacy kwargs path).
        context = self._prepare_formatting_context()

    # 2. Fetch statement data -------------------------------------------------------------------
    data, _ = self._fetch_statement_data(graph, context)

    # 3. Build row dictionaries -----------------------------------------------------------------
    rows = self._build_row_data(graph, data, context)

    # 4. Assemble DataFrame ---------------------------------------------------------------------
    if not rows:
        return self._create_empty_dataframe(context)

    df = pd.DataFrame(rows)

    # 5. Adjustment columns (must precede column organisation)
    if context.add_is_adjusted_column:
        df = self._add_adjustment_columns(df, graph, context)

    # 6. Column ordering / injection ------------------------------------------------------------
    df = self._organize_dataframe_columns(df, context)

    # 7. Post-processing formatting -------------------------------------------------------------
    df = self._apply_all_formatting(df, context)

    return df</code></pre>
</details>
<div class="desc"><p>Generate a formatted DataFrame for the statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>Graph instance containing the data to render.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>FormattingContext object containing all display / formatting
configuration. If <em>None</em>, a context will be created from project
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A fully-formatted <code>pandas.DataFrame</code> representing the statement.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementItem"><code class="flex name class">
<span>class <span class="ident">StatementItem</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementItem(ABC):
    &#34;&#34;&#34;Abstract base class for all statement structure items.

    Defines a common interface: id, name, item_type, default_adjustment_filter,
    and enhanced display control and units metadata.
    &#34;&#34;&#34;

    @property
    @abstractmethod
    def id(self) -&gt; str:
        &#34;&#34;&#34;Get the unique identifier of the item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def name(self) -&gt; str:
        &#34;&#34;&#34;Get the display name of the item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def item_type(self) -&gt; StatementItemType:
        &#34;&#34;&#34;Get the type of this statement item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def default_adjustment_filter(self) -&gt; Any | None:
        &#34;&#34;&#34;Get the default adjustment filter for this item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def display_format(self) -&gt; str | None:
        &#34;&#34;&#34;Get the display format string for this item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def hide_if_all_zero(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to hide this item if all values are zero.&#34;&#34;&#34;

    @property
    @abstractmethod
    def css_class(self) -&gt; str | None:
        &#34;&#34;&#34;Get the CSS class for this item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def notes_references(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the list of note references for this item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def units(self) -&gt; str | None:
        &#34;&#34;&#34;Get the unit description for this item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def display_scale_factor(self) -&gt; float:
        &#34;&#34;&#34;Get the display scale factor for this item.&#34;&#34;&#34;

    @property
    @abstractmethod
    def is_contra(self) -&gt; bool:
        &#34;&#34;&#34;Get whether this is a contra item for special display formatting.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Abstract base class for all statement structure items.</p>
<p>Defines a common interface: id, name, item_type, default_adjustment_filter,
and enhanced display control and units metadata.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.structure.items.LineItem" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem">LineItem</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.StatementItem.css_class"><code class="name">prop <span class="ident">css_class</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def css_class(self) -&gt; str | None:
    &#34;&#34;&#34;Get the CSS class for this item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the CSS class for this item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.default_adjustment_filter"><code class="name">prop <span class="ident">default_adjustment_filter</span> :Â typing.AnyÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def default_adjustment_filter(self) -&gt; Any | None:
    &#34;&#34;&#34;Get the default adjustment filter for this item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the default adjustment filter for this item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.display_format"><code class="name">prop <span class="ident">display_format</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def display_format(self) -&gt; str | None:
    &#34;&#34;&#34;Get the display format string for this item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the display format string for this item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.display_scale_factor"><code class="name">prop <span class="ident">display_scale_factor</span> :Â float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def display_scale_factor(self) -&gt; float:
    &#34;&#34;&#34;Get the display scale factor for this item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the display scale factor for this item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.hide_if_all_zero"><code class="name">prop <span class="ident">hide_if_all_zero</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def hide_if_all_zero(self) -&gt; bool:
    &#34;&#34;&#34;Get whether to hide this item if all values are zero.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get whether to hide this item if all values are zero.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.id"><code class="name">prop <span class="ident">id</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def id(self) -&gt; str:
    &#34;&#34;&#34;Get the unique identifier of the item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the unique identifier of the item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.is_contra"><code class="name">prop <span class="ident">is_contra</span> :Â bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def is_contra(self) -&gt; bool:
    &#34;&#34;&#34;Get whether this is a contra item for special display formatting.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get whether this is a contra item for special display formatting.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.item_type"><code class="name">prop <span class="ident">item_type</span> :Â <a title="fin_statement_model.statements.structure.items.StatementItemType" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItemType">StatementItemType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def item_type(self) -&gt; StatementItemType:
    &#34;&#34;&#34;Get the type of this statement item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the type of this statement item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.name"><code class="name">prop <span class="ident">name</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def name(self) -&gt; str:
    &#34;&#34;&#34;Get the display name of the item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the display name of the item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.notes_references"><code class="name">prop <span class="ident">notes_references</span> :Â list[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def notes_references(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the list of note references for this item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the list of note references for this item.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementItem.units"><code class="name">prop <span class="ident">units</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def units(self) -&gt; str | None:
    &#34;&#34;&#34;Get the unit description for this item.&#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get the unit description for this item.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementItemType"><code class="flex name class">
<span>class <span class="ident">StatementItemType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementItemType(Enum):
    &#34;&#34;&#34;Types of statement structure items.

    Attributes:
      SECTION: Section container
      LINE_ITEM: Basic financial line item
      SUBTOTAL: Subtotal of multiple items
      CALCULATED: Derived calculation item
      METRIC: Derived metric item from registry
    &#34;&#34;&#34;

    SECTION = &#34;section&#34;
    LINE_ITEM = &#34;line_item&#34;
    SUBTOTAL = &#34;subtotal&#34;
    CALCULATED = &#34;calculated&#34;
    METRIC = &#34;metric&#34;</code></pre>
</details>
<div class="desc"><p>Types of statement structure items.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>SECTION</code></strong></dt>
<dd>Section container</dd>
<dt><strong><code>LINE_ITEM</code></strong></dt>
<dd>Basic financial line item</dd>
<dt><strong><code>SUBTOTAL</code></strong></dt>
<dd>Subtotal of multiple items</dd>
<dt><strong><code>CALCULATED</code></strong></dt>
<dd>Derived calculation item</dd>
<dt><strong><code>METRIC</code></strong></dt>
<dd>Derived metric item from registry</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.StatementItemType.CALCULATED"><code class="name">var <span class="ident">CALCULATED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.StatementItemType.LINE_ITEM"><code class="name">var <span class="ident">LINE_ITEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.StatementItemType.METRIC"><code class="name">var <span class="ident">METRIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.StatementItemType.SECTION"><code class="name">var <span class="ident">SECTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.StatementItemType.SUBTOTAL"><code class="name">var <span class="ident">SUBTOTAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementRegistry"><code class="flex name class">
<span>class <span class="ident">StatementRegistry</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementRegistry:
    &#34;&#34;&#34;Manages a collection of loaded financial statement structures.

    This registry holds instances of `StatementStructure`, keyed by their unique
    IDs. It prevents duplicate registrations and provides methods to access
    registered statements individually or collectively.

    Attributes:
        _statements: A dictionary mapping statement IDs (str) to their
                     corresponding `StatementStructure` objects.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize an empty statement registry.&#34;&#34;&#34;
        self._statements: dict[str, StatementStructure] = {}
        logger.debug(&#34;StatementRegistry initialized.&#34;)

    def register(self, statement: StatementStructure) -&gt; None:
        &#34;&#34;&#34;Register a statement structure with the registry.

        Ensures the provided object is a `StatementStructure` with a valid ID
        and that the ID is not already present in the registry.

        Args:
            statement: The `StatementStructure` instance to register.

        Raises:
            TypeError: If the `statement` argument is not an instance of
                `StatementStructure`.
            ValueError: If the `statement` has an invalid or empty ID.
            StatementError: If a statement with the same ID (`statement.id`) is
                already registered.
        &#34;&#34;&#34;
        if not isinstance(statement, StatementStructure):
            raise TypeError(&#34;Only StatementStructure objects can be registered.&#34;)

        statement_id = statement.id
        if not statement_id:
            raise ValueError(&#34;StatementStructure must have a valid non-empty id to be registered.&#34;)

        if statement_id in self._statements:
            # Policy: Raise error on conflict
            logger.error(&#34;Attempted to register duplicate statement ID: &#39;%s&#39;&#34;, statement_id)
            raise StatementError(message=f&#34;Statement with ID &#39;{statement_id}&#39; is already registered.&#34;)

        self._statements[statement_id] = statement
        logger.info(&#34;Registered statement &#39;%s&#39; with ID &#39;%s&#39;&#34;, statement.name, statement_id)

    def get(self, statement_id: str) -&gt; StatementStructure | None:
        &#34;&#34;&#34;Get a registered statement by its ID.

        Returns:
            The `StatementStructure` instance associated with the given ID if
            it exists, otherwise returns `None`.

        Example:
            &gt;&gt;&gt; registry = StatementRegistry()
            &gt;&gt;&gt; # Assume &#39;income_statement&#39; is a valid StatementStructure instance
            &gt;&gt;&gt; # registry.register(income_statement)
            &gt;&gt;&gt; retrieved_statement = registry.get(&#34;income_statement_id&#34;)
            &gt;&gt;&gt; if retrieved_statement:
            ...     logger.info(&#34;Found: %s&#34;, retrieved_statement.name)
            ... else:
            ...     logger.info(&#34;Statement not found.&#34;)
        &#34;&#34;&#34;
        return self._statements.get(statement_id)

    def get_all_ids(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the IDs of all registered statements.

        Returns:
            A list containing the unique IDs of all statements currently held
            in the registry.
        &#34;&#34;&#34;
        return list(self._statements.keys())

    def get_all_statements(self) -&gt; list[StatementStructure]:
        &#34;&#34;&#34;Get all registered statement structure objects.

        Returns:
            A list containing all `StatementStructure` objects currently held
            in the registry.
        &#34;&#34;&#34;
        return list(self._statements.values())

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Remove all statement structures from the registry.

        Resets the registry to an empty state.
        &#34;&#34;&#34;
        self._statements = {}
        logger.info(&#34;StatementRegistry cleared.&#34;)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of registered statements.&#34;&#34;&#34;
        return len(self._statements)

    def __contains__(self, statement_id: str) -&gt; bool:
        &#34;&#34;&#34;Check if a statement ID exists in the registry.

        Allows using the `in` operator with the registry.

        Args:
            statement_id: The statement ID to check for.

        Returns:
            `True` if a statement with the given ID is registered, `False` otherwise.

        Example:
            &gt;&gt;&gt; registry = StatementRegistry()
            &gt;&gt;&gt; # Assume &#39;income_statement&#39; is registered with ID &#39;IS_2023&#39;
            &gt;&gt;&gt; # registry.register(income_statement)
            &gt;&gt;&gt; print(&#34;IS_2023&#34; in registry)  # Output: True
            &gt;&gt;&gt; print(&#34;BS_2023&#34; in registry)  # Output: False
        &#34;&#34;&#34;
        return statement_id in self._statements</code></pre>
</details>
<div class="desc"><p>Manages a collection of loaded financial statement structures.</p>
<p>This registry holds instances of <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code>, keyed by their unique
IDs. It prevents duplicate registrations and provides methods to access
registered statements individually or collectively.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_statements</code></strong></dt>
<dd>A dictionary mapping statement IDs (str) to their
corresponding <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> objects.</dd>
</dl>
<p>Initialize an empty statement registry.</p></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.StatementRegistry.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Remove all statement structures from the registry.

    Resets the registry to an empty state.
    &#34;&#34;&#34;
    self._statements = {}
    logger.info(&#34;StatementRegistry cleared.&#34;)</code></pre>
</details>
<div class="desc"><p>Remove all statement structures from the registry.</p>
<p>Resets the registry to an empty state.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementRegistry.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, statement_id:Â str) â€‘>Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>Â |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, statement_id: str) -&gt; StatementStructure | None:
    &#34;&#34;&#34;Get a registered statement by its ID.

    Returns:
        The `StatementStructure` instance associated with the given ID if
        it exists, otherwise returns `None`.

    Example:
        &gt;&gt;&gt; registry = StatementRegistry()
        &gt;&gt;&gt; # Assume &#39;income_statement&#39; is a valid StatementStructure instance
        &gt;&gt;&gt; # registry.register(income_statement)
        &gt;&gt;&gt; retrieved_statement = registry.get(&#34;income_statement_id&#34;)
        &gt;&gt;&gt; if retrieved_statement:
        ...     logger.info(&#34;Found: %s&#34;, retrieved_statement.name)
        ... else:
        ...     logger.info(&#34;Statement not found.&#34;)
    &#34;&#34;&#34;
    return self._statements.get(statement_id)</code></pre>
</details>
<div class="desc"><p>Get a registered statement by its ID.</p>
<h2 id="returns">Returns</h2>
<p>The <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> instance associated with the given ID if
it exists, otherwise returns <code>None</code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; registry = StatementRegistry()
&gt;&gt;&gt; # Assume 'income_statement' is a valid StatementStructure instance
&gt;&gt;&gt; # registry.register(income_statement)
&gt;&gt;&gt; retrieved_statement = registry.get(&quot;income_statement_id&quot;)
&gt;&gt;&gt; if retrieved_statement:
...     logger.info(&quot;Found: %s&quot;, retrieved_statement.name)
... else:
...     logger.info(&quot;Statement not found.&quot;)
</code></pre></div>
</dd>
<dt id="fin_statement_model.statements.StatementRegistry.get_all_ids"><code class="name flex">
<span>def <span class="ident">get_all_ids</span></span>(<span>self) â€‘>Â list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_ids(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the IDs of all registered statements.

    Returns:
        A list containing the unique IDs of all statements currently held
        in the registry.
    &#34;&#34;&#34;
    return list(self._statements.keys())</code></pre>
</details>
<div class="desc"><p>Get the IDs of all registered statements.</p>
<h2 id="returns">Returns</h2>
<p>A list containing the unique IDs of all statements currently held
in the registry.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementRegistry.get_all_statements"><code class="name flex">
<span>def <span class="ident">get_all_statements</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_statements(self) -&gt; list[StatementStructure]:
    &#34;&#34;&#34;Get all registered statement structure objects.

    Returns:
        A list containing all `StatementStructure` objects currently held
        in the registry.
    &#34;&#34;&#34;
    return list(self._statements.values())</code></pre>
</details>
<div class="desc"><p>Get all registered statement structure objects.</p>
<h2 id="returns">Returns</h2>
<p>A list containing all <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> objects currently held
in the registry.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementRegistry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self,<br>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, statement: StatementStructure) -&gt; None:
    &#34;&#34;&#34;Register a statement structure with the registry.

    Ensures the provided object is a `StatementStructure` with a valid ID
    and that the ID is not already present in the registry.

    Args:
        statement: The `StatementStructure` instance to register.

    Raises:
        TypeError: If the `statement` argument is not an instance of
            `StatementStructure`.
        ValueError: If the `statement` has an invalid or empty ID.
        StatementError: If a statement with the same ID (`statement.id`) is
            already registered.
    &#34;&#34;&#34;
    if not isinstance(statement, StatementStructure):
        raise TypeError(&#34;Only StatementStructure objects can be registered.&#34;)

    statement_id = statement.id
    if not statement_id:
        raise ValueError(&#34;StatementStructure must have a valid non-empty id to be registered.&#34;)

    if statement_id in self._statements:
        # Policy: Raise error on conflict
        logger.error(&#34;Attempted to register duplicate statement ID: &#39;%s&#39;&#34;, statement_id)
        raise StatementError(message=f&#34;Statement with ID &#39;{statement_id}&#39; is already registered.&#34;)

    self._statements[statement_id] = statement
    logger.info(&#34;Registered statement &#39;%s&#39; with ID &#39;%s&#39;&#34;, statement.name, statement_id)</code></pre>
</details>
<div class="desc"><p>Register a statement structure with the registry.</p>
<p>Ensures the provided object is a <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> with a valid ID
and that the ID is not already present in the registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> instance to register.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the <code>statement</code> argument is not an instance of
<code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code>.</dd>
<dt><code>ValueError</code></dt>
<dd>If the <code>statement</code> has an invalid or empty ID.</dd>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If a statement with the same ID (<code>statement.id</code>) is
already registered.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementStructure"><code class="flex name class">
<span>class <span class="ident">StatementStructure</span></span>
<span>(</span><span>id:Â str,<br>name:Â str,<br>description:Â strÂ =Â '',<br>metadata:Â dict[str,Â Any]Â |Â NoneÂ =Â None,<br>units:Â strÂ |Â NoneÂ =Â None,<br>display_scale_factor:Â floatÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementStructure:
    &#34;&#34;&#34;Top-level container for a financial statement structure.

    Manages a hierarchy of Section objects with statement-level display
    and units metadata.
    &#34;&#34;&#34;

    def __init__(
        self,
        id: str,
        name: str,
        description: str = &#34;&#34;,
        metadata: dict[str, Any] | None = None,
        units: str | None = None,
        display_scale_factor: float | None = None,
    ):
        &#34;&#34;&#34;Initialize a statement structure.

        Args:
            id: Unique identifier for the statement.
            name: Display name for the statement.
            description: Optional description text.
            metadata: Optional additional metadata.
            units: Optional default unit description for the statement.
            display_scale_factor: Default scale factor for displaying values.
                                If not provided, uses config default from display.scale_factor.

        Raises:
            StatementError: If id or name is invalid.
        &#34;&#34;&#34;
        if not id or not isinstance(id, str):
            raise StatementError(f&#34;Invalid statement ID: {id}&#34;)
        if not name or not isinstance(name, str):
            raise StatementError(f&#34;Invalid statement name: {name} for ID: {id}&#34;)

        # Use config default if not provided (import only when needed)
        from fin_statement_model.config.access import cfg_or_param

        display_scale_factor = cfg_or_param(&#34;display.scale_factor&#34;, display_scale_factor)

        if display_scale_factor is None or display_scale_factor &lt;= 0:
            raise StatementError(f&#34;display_scale_factor must be positive for statement: {id}&#34;)

        self._id = id
        self._name = name
        self._description = description
        self._metadata = metadata or {}
        self._units = units
        self._display_scale_factor = display_scale_factor
        self._sections: list[Section] = []

    @property
    def id(self) -&gt; str:
        &#34;&#34;&#34;Get the statement identifier.&#34;&#34;&#34;
        return self._id

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Get the statement display name.&#34;&#34;&#34;
        return self._name

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Get the statement description.&#34;&#34;&#34;
        return self._description

    @property
    def metadata(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Get the statement metadata.&#34;&#34;&#34;
        return self._metadata

    @property
    def units(self) -&gt; str | None:
        &#34;&#34;&#34;Get the default unit description for the statement.&#34;&#34;&#34;
        return self._units

    @property
    def display_scale_factor(self) -&gt; float:
        &#34;&#34;&#34;Get the default display scale factor for the statement.&#34;&#34;&#34;
        return self._display_scale_factor

    @property
    def sections(self) -&gt; list[Section]:
        &#34;&#34;&#34;Get the top-level sections.&#34;&#34;&#34;
        return list(self._sections)

    @property
    def items(self) -&gt; list[Section]:
        &#34;&#34;&#34;Alias for sections to ease iteration.&#34;&#34;&#34;
        return self.sections

    def add_section(self, section: Section) -&gt; None:
        &#34;&#34;&#34;Add a section to the statement.

        Args:
            section: Section to add.

        Raises:
            StatementError: If a section with the same id already exists.
        &#34;&#34;&#34;
        if any(s.id == section.id for s in self._sections):
            raise StatementError(f&#34;Duplicate section ID: {section.id} in statement: {self.id}&#34;)
        self._sections.append(section)

    def find_item_by_id(self, item_id: str) -&gt; Section | StatementItem | None:
        &#34;&#34;&#34;Find an item by its ID in the statement structure.

        Args:
            item_id: The ID of the item to find.

        Returns:
            Optional[Union[Section, StatementItem]]: The found item or None if not found.
        &#34;&#34;&#34;
        for section in self._sections:
            item = section.find_item_by_id(item_id)
            if item:
                return item
        return None

    def get_calculation_items(
        self,
    ) -&gt; list[CalculatedLineItem | SubtotalLineItem]:
        &#34;&#34;&#34;Get all calculation items from the statement structure.

        Returns:
            List[Union[CalculatedLineItem, SubtotalLineItem]]: List of calculation items.
        &#34;&#34;&#34;
        calculation_items = []

        def collect_calculation_items(
            items: Sequence[Section | StatementItem],
        ) -&gt; None:
            for item in items:
                if isinstance(item, CalculatedLineItem | SubtotalLineItem):
                    calculation_items.append(item)
                elif isinstance(item, Section):
                    collect_calculation_items(item.items)
                    if hasattr(item, &#34;subtotal&#34;) and item.subtotal:
                        if isinstance(item.subtotal, SubtotalLineItem):
                            calculation_items.append(item.subtotal)
                        else:
                            pass

        collect_calculation_items(self._sections)
        return calculation_items

    def get_metric_items(self) -&gt; list[MetricLineItem]:
        &#34;&#34;&#34;Get all metric items from the statement structure.

        Returns:
            List[MetricLineItem]: List of metric items.
        &#34;&#34;&#34;
        metric_items = []

        def collect_metric_items(
            items: Sequence[Section | StatementItem],
        ) -&gt; None:
            for item in items:
                if isinstance(item, MetricLineItem):
                    metric_items.append(item)
                elif isinstance(item, Section):
                    collect_metric_items(item.items)
                    # Subtotals are handled by get_calculation_items, not relevant here

        collect_metric_items(self._sections)
        return metric_items

    def get_all_items(self) -&gt; list[StatementItem]:
        &#34;&#34;&#34;Get all StatementItem instances recursively from the structure.

        Traverses all sections and nested sections, collecting only objects that
        are subclasses of StatementItem (e.g., LineItem, CalculatedLineItem),
        excluding Section objects themselves.

        Returns:
            List[StatementItem]: A flat list of all statement items found.
        &#34;&#34;&#34;
        all_statement_items: list[StatementItem] = []

        def _collect_items_recursive(
            items_or_sections: Sequence[Section | StatementItem],
        ) -&gt; None:
            for item in items_or_sections:
                if isinstance(item, Section):
                    _collect_items_recursive(item.items)
                    # Also collect the section&#39;s subtotal if it exists and is a StatementItem
                    if hasattr(item, &#34;subtotal&#34;) and isinstance(item.subtotal, StatementItem):
                        all_statement_items.append(item.subtotal)
                elif isinstance(item, StatementItem):
                    all_statement_items.append(item)

        _collect_items_recursive(self._sections)

        return all_statement_items</code></pre>
</details>
<div class="desc"><p>Top-level container for a financial statement structure.</p>
<p>Manages a hierarchy of Section objects with statement-level display
and units metadata.</p>
<p>Initialize a statement structure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique identifier for the statement.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name for the statement.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description text.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional additional metadata.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional default unit description for the statement.</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Default scale factor for displaying values.
If not provided, uses config default from display.scale_factor.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If id or name is invalid.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.StatementStructure.description"><code class="name">prop <span class="ident">description</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Get the statement description.&#34;&#34;&#34;
    return self._description</code></pre>
</details>
<div class="desc"><p>Get the statement description.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.display_scale_factor"><code class="name">prop <span class="ident">display_scale_factor</span> :Â float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def display_scale_factor(self) -&gt; float:
    &#34;&#34;&#34;Get the default display scale factor for the statement.&#34;&#34;&#34;
    return self._display_scale_factor</code></pre>
</details>
<div class="desc"><p>Get the default display scale factor for the statement.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.id"><code class="name">prop <span class="ident">id</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    &#34;&#34;&#34;Get the statement identifier.&#34;&#34;&#34;
    return self._id</code></pre>
</details>
<div class="desc"><p>Get the statement identifier.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.items"><code class="name">prop <span class="ident">items</span> :Â list[<a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def items(self) -&gt; list[Section]:
    &#34;&#34;&#34;Alias for sections to ease iteration.&#34;&#34;&#34;
    return self.sections</code></pre>
</details>
<div class="desc"><p>Alias for sections to ease iteration.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.metadata"><code class="name">prop <span class="ident">metadata</span> :Â dict[str,Â Any]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Get the statement metadata.&#34;&#34;&#34;
    return self._metadata</code></pre>
</details>
<div class="desc"><p>Get the statement metadata.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.name"><code class="name">prop <span class="ident">name</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Get the statement display name.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
<div class="desc"><p>Get the statement display name.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.sections"><code class="name">prop <span class="ident">sections</span> :Â list[<a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a>]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sections(self) -&gt; list[Section]:
    &#34;&#34;&#34;Get the top-level sections.&#34;&#34;&#34;
    return list(self._sections)</code></pre>
</details>
<div class="desc"><p>Get the top-level sections.</p></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.units"><code class="name">prop <span class="ident">units</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def units(self) -&gt; str | None:
    &#34;&#34;&#34;Get the default unit description for the statement.&#34;&#34;&#34;
    return self._units</code></pre>
</details>
<div class="desc"><p>Get the default unit description for the statement.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.StatementStructure.add_section"><code class="name flex">
<span>def <span class="ident">add_section</span></span>(<span>self,<br>section:Â <a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a>) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_section(self, section: Section) -&gt; None:
    &#34;&#34;&#34;Add a section to the statement.

    Args:
        section: Section to add.

    Raises:
        StatementError: If a section with the same id already exists.
    &#34;&#34;&#34;
    if any(s.id == section.id for s in self._sections):
        raise StatementError(f&#34;Duplicate section ID: {section.id} in statement: {self.id}&#34;)
    self._sections.append(section)</code></pre>
</details>
<div class="desc"><p>Add a section to the statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>section</code></strong></dt>
<dd>Section to add.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If a section with the same id already exists.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.find_item_by_id"><code class="name flex">
<span>def <span class="ident">find_item_by_id</span></span>(<span>self, item_id:Â str) â€‘>Â <a title="fin_statement_model.statements.structure.containers.Section" href="structure/containers.html#fin_statement_model.statements.structure.containers.Section">Section</a>Â |Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>Â |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_item_by_id(self, item_id: str) -&gt; Section | StatementItem | None:
    &#34;&#34;&#34;Find an item by its ID in the statement structure.

    Args:
        item_id: The ID of the item to find.

    Returns:
        Optional[Union[Section, StatementItem]]: The found item or None if not found.
    &#34;&#34;&#34;
    for section in self._sections:
        item = section.find_item_by_id(item_id)
        if item:
            return item
    return None</code></pre>
</details>
<div class="desc"><p>Find an item by its ID in the statement structure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_id</code></strong></dt>
<dd>The ID of the item to find.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[Union[<a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a>, <a title="fin_statement_model.statements.StatementItem" href="#fin_statement_model.statements.StatementItem">StatementItem</a>]]</code></dt>
<dd>The found item or None if not found.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.get_all_items"><code class="name flex">
<span>def <span class="ident">get_all_items</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_items(self) -&gt; list[StatementItem]:
    &#34;&#34;&#34;Get all StatementItem instances recursively from the structure.

    Traverses all sections and nested sections, collecting only objects that
    are subclasses of StatementItem (e.g., LineItem, CalculatedLineItem),
    excluding Section objects themselves.

    Returns:
        List[StatementItem]: A flat list of all statement items found.
    &#34;&#34;&#34;
    all_statement_items: list[StatementItem] = []

    def _collect_items_recursive(
        items_or_sections: Sequence[Section | StatementItem],
    ) -&gt; None:
        for item in items_or_sections:
            if isinstance(item, Section):
                _collect_items_recursive(item.items)
                # Also collect the section&#39;s subtotal if it exists and is a StatementItem
                if hasattr(item, &#34;subtotal&#34;) and isinstance(item.subtotal, StatementItem):
                    all_statement_items.append(item.subtotal)
            elif isinstance(item, StatementItem):
                all_statement_items.append(item)

    _collect_items_recursive(self._sections)

    return all_statement_items</code></pre>
</details>
<div class="desc"><p>Get all StatementItem instances recursively from the structure.</p>
<p>Traverses all sections and nested sections, collecting only objects that
are subclasses of StatementItem (e.g., LineItem, CalculatedLineItem),
excluding Section objects themselves.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="fin_statement_model.statements.StatementItem" href="#fin_statement_model.statements.StatementItem">StatementItem</a>]</code></dt>
<dd>A flat list of all statement items found.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.get_calculation_items"><code class="name flex">
<span>def <span class="ident">get_calculation_items</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.structure.items.CalculatedLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem">CalculatedLineItem</a>Â |Â <a title="fin_statement_model.statements.structure.items.SubtotalLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.SubtotalLineItem">SubtotalLineItem</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calculation_items(
    self,
) -&gt; list[CalculatedLineItem | SubtotalLineItem]:
    &#34;&#34;&#34;Get all calculation items from the statement structure.

    Returns:
        List[Union[CalculatedLineItem, SubtotalLineItem]]: List of calculation items.
    &#34;&#34;&#34;
    calculation_items = []

    def collect_calculation_items(
        items: Sequence[Section | StatementItem],
    ) -&gt; None:
        for item in items:
            if isinstance(item, CalculatedLineItem | SubtotalLineItem):
                calculation_items.append(item)
            elif isinstance(item, Section):
                collect_calculation_items(item.items)
                if hasattr(item, &#34;subtotal&#34;) and item.subtotal:
                    if isinstance(item.subtotal, SubtotalLineItem):
                        calculation_items.append(item.subtotal)
                    else:
                        pass

    collect_calculation_items(self._sections)
    return calculation_items</code></pre>
</details>
<div class="desc"><p>Get all calculation items from the statement structure.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Union[<a title="fin_statement_model.statements.CalculatedLineItem" href="#fin_statement_model.statements.CalculatedLineItem">CalculatedLineItem</a>, <a title="fin_statement_model.statements.SubtotalLineItem" href="#fin_statement_model.statements.SubtotalLineItem">SubtotalLineItem</a>]]</code></dt>
<dd>List of calculation items.</dd>
</dl></div>
</dd>
<dt id="fin_statement_model.statements.StatementStructure.get_metric_items"><code class="name flex">
<span>def <span class="ident">get_metric_items</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.structure.items.MetricLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.MetricLineItem">MetricLineItem</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metric_items(self) -&gt; list[MetricLineItem]:
    &#34;&#34;&#34;Get all metric items from the statement structure.

    Returns:
        List[MetricLineItem]: List of metric items.
    &#34;&#34;&#34;
    metric_items = []

    def collect_metric_items(
        items: Sequence[Section | StatementItem],
    ) -&gt; None:
        for item in items:
            if isinstance(item, MetricLineItem):
                metric_items.append(item)
            elif isinstance(item, Section):
                collect_metric_items(item.items)
                # Subtotals are handled by get_calculation_items, not relevant here

    collect_metric_items(self._sections)
    return metric_items</code></pre>
</details>
<div class="desc"><p>Get all metric items from the statement structure.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[MetricLineItem]</code></dt>
<dd>List of metric items.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.StatementStructureBuilder"><code class="flex name class">
<span>class <span class="ident">StatementStructureBuilder</span></span>
<span>(</span><span>enable_node_validation:Â boolÂ |Â NoneÂ =Â None,<br>node_validation_strict:Â boolÂ |Â NoneÂ =Â None,<br>node_validator:Â <a title="fin_statement_model.statements.validation.UnifiedNodeValidator" href="validation.html#fin_statement_model.statements.validation.UnifiedNodeValidator">UnifiedNodeValidator</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatementStructureBuilder:
    &#34;&#34;&#34;Constructs a `StatementStructure` object from a validated configuration.

    Takes a `StatementConfig` instance (which should have successfully passed
    validation, populating its `.model` attribute) and recursively builds the
    corresponding `StatementStructure`, including its sections, line items,
    calculated items, subtotals, and nested sections.
    &#34;&#34;&#34;

    def __init__(
        self,
        enable_node_validation: bool | None = None,
        node_validation_strict: bool | None = None,
        node_validator: UnifiedNodeValidator | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the StatementStructureBuilder.

        Defaults for validation flags come from the global statements config, but can be overridden locally.

        Args:
            enable_node_validation: If True, validates node IDs during build.
            node_validation_strict: If True, treats validation failures as errors.
            node_validator: Optional pre-configured UnifiedNodeValidator instance.
        &#34;&#34;&#34;
        # Pull defaults from global config if not provided
        if enable_node_validation is None:
            enable_node_validation = cfg(&#34;statements.enable_node_validation&#34;)
        if node_validation_strict is None:
            node_validation_strict = cfg(&#34;statements.node_validation_strict&#34;)
        self.enable_node_validation = enable_node_validation
        self.node_validation_strict = node_validation_strict

        # Initialize node_validator
        self.node_validator: UnifiedNodeValidator | None = None
        if self.enable_node_validation:
            if node_validator is not None:
                self.node_validator = node_validator
            else:
                # Create default validator using strict flag
                self.node_validator = UnifiedNodeValidator(
                    standard_node_registry,
                    strict_mode=self.node_validation_strict,
                    auto_standardize=True,
                    warn_on_non_standard=True,
                    enable_patterns=True,
                )
        else:
            self.node_validator = None

    def _convert_adjustment_filter(self, filter_input: AdjustmentFilterSpec | list[str] | None) -&gt; Any | None:
        &#34;&#34;&#34;Convert configuration adjustment filter to core AdjustmentFilter or tag set.

        Args:
            filter_input: The filter specification from configuration.

        Returns:
            AdjustmentFilter instance, set of tags, or None.
        &#34;&#34;&#34;
        # Use global default adjustment filter if none provided
        if filter_input is None:
            default_filter = cfg(&#34;statements.default_adjustment_filter&#34;)
            if default_filter is None:
                return None
            filter_input = default_filter
        # Simple list of tags - convert to set
        elif isinstance(filter_input, list):
            return set(filter_input)
        # Configuration spec to core filter conversion
        elif isinstance(filter_input, AdjustmentFilterSpec):
            # Convert AdjustmentFilterSpec to AdjustmentFilter
            kwargs: dict[str, Any] = {}

            # Convert list fields to sets
            if filter_input.include_scenarios:
                kwargs[&#34;include_scenarios&#34;] = set(filter_input.include_scenarios)
            if filter_input.exclude_scenarios:
                kwargs[&#34;exclude_scenarios&#34;] = set(filter_input.exclude_scenarios)
            if filter_input.include_tags:
                kwargs[&#34;include_tags&#34;] = set(filter_input.include_tags)
            if filter_input.exclude_tags:
                kwargs[&#34;exclude_tags&#34;] = set(filter_input.exclude_tags)
            if filter_input.require_all_tags:
                kwargs[&#34;require_all_tags&#34;] = set(filter_input.require_all_tags)

            # Convert string types to AdjustmentType enums
            if filter_input.include_types:
                kwargs[&#34;include_types&#34;] = cast(
                    &#34;set[AdjustmentType]&#34;,
                    {AdjustmentType(type_str) for type_str in filter_input.include_types},
                )
            if filter_input.exclude_types:
                kwargs[&#34;exclude_types&#34;] = cast(
                    &#34;set[AdjustmentType]&#34;,
                    {AdjustmentType(type_str) for type_str in filter_input.exclude_types},
                )

            # Pass through period
            if filter_input.period:
                kwargs[&#34;period&#34;] = filter_input.period

            # Create AdjustmentFilter from kwargs
            return AdjustmentFilter(**kwargs)

        # Unknown type - log warning and return None
        logger.warning(&#34;Unknown adjustment filter type: %s&#34;, type(filter_input))
        return None

    def build(self, config: StatementConfig) -&gt; StatementStructure:
        &#34;&#34;&#34;Build a `StatementStructure` from a validated `StatementConfig`.

        This is the main public method of the builder. It orchestrates the
        conversion process, calling internal helper methods to build sections
        and items.

        Args:
            config: A `StatementConfig` instance whose `.validate_config()`
                method has been successfully called, populating `config.model`.

        Returns:
            The fully constructed `StatementStructure` object, ready to be
            registered or used.

        Raises:
            ValueError: If the provided `config` object has not been validated
                (i.e., `config.model` is `None`).
            ConfigurationError: If an unexpected error occurs during the building
                process, potentially indicating an issue not caught by the
                initial Pydantic validation or an internal inconsistency.
        &#34;&#34;&#34;
        if config.model is None:
            # Ensure validation has run successfully before building
            raise ValueError(
                &#34;StatementConfig must be validated (config.model must be set) before building the structure.&#34;
            )

        # Build from the validated Pydantic model stored in config.model
        try:
            stmt_model = config.model  # Use validated model from config

            # Optional node validation during build
            if self.enable_node_validation and self.node_validator:
                error_collector = ErrorCollector()
                self._validate_structure_node_ids(stmt_model, error_collector)

                # Handle validation results
                if error_collector.has_errors() and self.node_validation_strict:
                    # Fail build on validation errors in strict mode
                    error_messages = [str(error) for error in error_collector.get_errors()]
                    raise ConfigurationError(
                        message=f&#34;Node validation failed for statement &#39;{stmt_model.id}&#39;&#34;,
                        errors=error_messages,
                    )
                elif error_collector.has_warnings() or error_collector.has_errors():
                    # Log warnings and non-strict errors
                    for warning in error_collector.get_warnings():
                        logger.warning(&#34;Build-time node validation: %s&#34;, warning)
                    if not self.node_validation_strict:
                        for error in error_collector.get_errors():
                            logger.warning(&#34;Build-time node validation: %s&#34;, error)

            statement = StatementStructure(
                id=stmt_model.id,
                name=stmt_model.name,
                description=cast(&#34;str&#34;, stmt_model.description),
                metadata=stmt_model.metadata,
                units=stmt_model.units,
                display_scale_factor=stmt_model.display_scale_factor,
            )
            for sec_model in stmt_model.sections:
                section = self._build_section_model(sec_model)
                statement.add_section(section)
            logger.info(&#34;Successfully built StatementStructure for ID &#39;%s&#39;&#34;, statement.id)
        except Exception as e:
            # Catch potential errors during the building process itself
            logger.exception(
                &#34;Error building statement structure from validated model for ID &#39;%s&#39;&#34;,
                config.model.id,
            )
            raise ConfigurationError(
                message=f&#34;Failed to build statement structure from validated config: {e}&#34;,
                errors=[str(e)],
            ) from e
        else:
            return statement

    def _validate_structure_node_ids(self, stmt_model: StatementModel, error_collector: ErrorCollector) -&gt; None:
        &#34;&#34;&#34;Validate node IDs in the statement structure during build.

        This is a simpler validation focused on the final structure,
        complementing the config-level validation.

        Args:
            stmt_model: The StatementModel to validate.
            error_collector: ErrorCollector to accumulate validation issues.
        &#34;&#34;&#34;
        logger.debug(&#34;Build-time node validation for statement &#39;%s&#39;&#34;, stmt_model.id)

        # Validate key node references that will be used in the built structure
        collected_node_refs = set()

        # Collect all node references from the structure
        def collect_node_refs(items: list[Any]) -&gt; None:
            for item in items:
                if isinstance(item, LineItemModel):
                    if item.node_id:
                        collected_node_refs.add((item.node_id, &#34;line_item_node&#34;, f&#34;item.{item.id}.node_id&#34;))
                    if item.standard_node_ref:
                        collected_node_refs.add((
                            item.standard_node_ref,
                            &#34;standard_node&#34;,
                            f&#34;item.{item.id}.standard_node_ref&#34;,
                        ))
                elif isinstance(item, CalculatedItemModel):
                    collected_node_refs.add((item.id, &#34;calculated_node&#34;, f&#34;item.{item.id}.id&#34;))
                elif isinstance(item, MetricItemModel):
                    collected_node_refs.add((item.id, &#34;metric_node&#34;, f&#34;item.{item.id}.id&#34;))
                elif isinstance(item, SubtotalModel):
                    collected_node_refs.add((item.id, &#34;subtotal_node&#34;, f&#34;item.{item.id}.id&#34;))
                elif isinstance(item, SectionModel):
                    collect_node_refs(item.items)
                    collect_node_refs(item.subsections)
                    if item.subtotal:
                        collected_node_refs.add((
                            item.subtotal.id,
                            &#34;subtotal_node&#34;,
                            f&#34;section.{item.id}.subtotal.id&#34;,
                        ))

        # Collect all node references
        for section in stmt_model.sections:
            collect_node_refs([section, *section.items, *section.subsections])

        # Validate collected references
        for node_id, node_type, context in collected_node_refs:
            self._validate_single_build_node_id(node_id, node_type, context, error_collector)

    def _validate_single_build_node_id(
        self,
        node_id: str,
        node_type: str,
        context: str,
        error_collector: ErrorCollector,
    ) -&gt; None:
        &#34;&#34;&#34;Validate a single node ID during build process.

        Args:
            node_id: The node ID to validate.
            node_type: Type description for error messages.
            context: Context string for error reporting.
            error_collector: ErrorCollector to accumulate validation issues.
        &#34;&#34;&#34;
        if not self.node_validator:
            return

        try:
            validation_result = self.node_validator.validate(
                node_id,
                node_type=node_type,
                use_cache=True,
            )

            # Only report significant issues during build
            if not validation_result.is_valid:
                severity = ErrorSeverity.ERROR if self.node_validation_strict else ErrorSeverity.WARNING
                message = f&#34;Build validation: Invalid {node_type} &#39;{node_id}&#39;: {validation_result.message}&#34;

                if severity == ErrorSeverity.ERROR:
                    error_collector.add_error(
                        code=&#34;build_invalid_node_id&#34;,
                        message=message,
                        context=context,
                        source=node_id,
                    )
                else:
                    error_collector.add_warning(
                        code=&#34;build_invalid_node_id&#34;,
                        message=message,
                        context=context,
                        source=node_id,
                    )

        except Exception as e:
            logger.exception(&#34;Error during build-time validation of node ID &#39;%s&#39;&#34;, node_id)
            error_collector.add_warning(
                code=&#34;build_node_validation_error&#34;,
                message=f&#34;Build validation error for {node_type} &#39;{node_id}&#39;: {e}&#34;,
                context=context,
                source=node_id,
            )

    def _build_section_model(self, section_model: SectionModel) -&gt; Section:
        &#34;&#34;&#34;Build a `Section` object from a `SectionModel`.

        Recursively builds the items and subsections within this section.

        Args:
            section_model: The Pydantic model representing the section configuration.

        Returns:
            A `Section` instance corresponding to the model.
        &#34;&#34;&#34;
        # Convert adjustment filter
        adjustment_filter = self._convert_adjustment_filter(section_model.default_adjustment_filter)

        section = Section(
            id=section_model.id,
            name=section_model.name,
            description=cast(&#34;str&#34;, section_model.description),
            metadata=section_model.metadata,
            default_adjustment_filter=adjustment_filter,
            display_format=section_model.display_format,
            hide_if_all_zero=section_model.hide_if_all_zero,
            css_class=section_model.css_class,
            notes_references=section_model.notes_references,
            units=section_model.units,
            display_scale_factor=section_model.display_scale_factor,
        )
        for item in section_model.items:
            section.add_item(self._build_item_model(item))
        for sub in section_model.subsections:
            # Recursively build subsections
            section.add_item(self._build_section_model(sub))
        if section_model.subtotal:
            section.subtotal = self._build_subtotal_model(section_model.subtotal)
        return section

    def _build_item_model(
        self, item_model: BaseItemModel
    ) -&gt; LineItem | CalculatedLineItem | MetricLineItem | SubtotalLineItem | Section:
        &#34;&#34;&#34;Build a statement item object from its corresponding Pydantic model.

        Dispatches the building process based on the specific type of the input
        model (`LineItemModel`, `CalculatedItemModel`, `MetricItemModel`,
        `SubtotalModel`, or `SectionModel` for nested sections).

        Args:
            item_model: The Pydantic model representing a line item, calculated
                item, metric item, subtotal, or nested section.

        Returns:
            The corresponding `StatementStructure` component (`LineItem`,
            `CalculatedLineItem`, `MetricLineItem`, `SubtotalLineItem`, or `Section`).

        Raises:
            TypeError: If an unexpected model type is encountered.
        &#34;&#34;&#34;
        # Convert adjustment filter for all item types
        adjustment_filter = self._convert_adjustment_filter(item_model.default_adjustment_filter)

        # Dispatch by model instance type
        if isinstance(item_model, SectionModel):
            # Handle nested sections directly
            return self._build_section_model(item_model)
        if isinstance(item_model, LineItemModel):
            return LineItem(
                id=item_model.id,
                name=item_model.name,
                node_id=item_model.node_id,
                standard_node_ref=item_model.standard_node_ref,
                description=cast(&#34;str&#34;, item_model.description),
                sign_convention=item_model.sign_convention,
                metadata=item_model.metadata,
                default_adjustment_filter=adjustment_filter,
                display_format=item_model.display_format,
                hide_if_all_zero=item_model.hide_if_all_zero,
                css_class=item_model.css_class,
                notes_references=item_model.notes_references,
                units=item_model.units,
                display_scale_factor=item_model.display_scale_factor,
                is_contra=item_model.is_contra,
            )
        if isinstance(item_model, CalculatedItemModel):
            # Pass the calculation model directly or its dict representation
            return CalculatedLineItem(
                id=item_model.id,
                name=item_model.name,
                # Pass the nested Pydantic model if structure expects dict
                calculation=item_model.calculation.model_dump(),
                description=cast(&#34;str&#34;, item_model.description),
                sign_convention=item_model.sign_convention,
                metadata=item_model.metadata,
                default_adjustment_filter=adjustment_filter,
                display_format=item_model.display_format,
                hide_if_all_zero=item_model.hide_if_all_zero,
                css_class=item_model.css_class,
                notes_references=item_model.notes_references,
                units=item_model.units,
                display_scale_factor=item_model.display_scale_factor,
                is_contra=item_model.is_contra,
            )
        if isinstance(item_model, MetricItemModel):
            return MetricLineItem(
                id=item_model.id,
                name=item_model.name,
                metric_id=item_model.metric_id,
                inputs=item_model.inputs,
                description=cast(&#34;str&#34;, item_model.description),
                sign_convention=item_model.sign_convention,
                metadata=item_model.metadata,
                default_adjustment_filter=adjustment_filter,
                display_format=item_model.display_format,
                hide_if_all_zero=item_model.hide_if_all_zero,
                css_class=item_model.css_class,
                notes_references=item_model.notes_references,
                units=item_model.units,
                display_scale_factor=item_model.display_scale_factor,
                is_contra=item_model.is_contra,
            )
        if isinstance(item_model, SubtotalModel):
            return self._build_subtotal_model(item_model)

        # Should be unreachable if Pydantic validation works
        raise TypeError(f&#34;Unhandled type: {type(item_model)}&#34;)

    def _build_subtotal_model(self, subtotal_model: SubtotalModel) -&gt; SubtotalLineItem:
        &#34;&#34;&#34;Build a `SubtotalLineItem` object from a `SubtotalModel`.

        Extracts the relevant item IDs to be summed, either from the explicit
        `items_to_sum` list or from the `calculation.inputs` if provided.

        Args:
            subtotal_model: The Pydantic model representing the subtotal configuration.

        Returns:
            A `SubtotalLineItem` instance.
        &#34;&#34;&#34;
        # Convert adjustment filter
        adjustment_filter = self._convert_adjustment_filter(subtotal_model.default_adjustment_filter)

        # Consolidate logic for getting item IDs
        item_ids = (
            subtotal_model.calculation.inputs
            if subtotal_model.calculation and subtotal_model.calculation.inputs
            else subtotal_model.items_to_sum
        )
        if not item_ids:
            logger.warning(&#34;Subtotal &#39;%s&#39; has no items_to_sum or calculation inputs defined.&#34;, subtotal_model.id)
            # Decide handling: error or allow empty subtotal?
            # Allowing for now, may need adjustment based on desired behavior.

        return SubtotalLineItem(
            id=subtotal_model.id,
            name=subtotal_model.name,
            item_ids=item_ids or [],  # Ensure it&#39;s a list
            description=cast(&#34;str&#34;, subtotal_model.description),
            sign_convention=subtotal_model.sign_convention,
            metadata=subtotal_model.metadata,
            default_adjustment_filter=adjustment_filter,
            display_format=subtotal_model.display_format,
            hide_if_all_zero=subtotal_model.hide_if_all_zero,
            css_class=subtotal_model.css_class,
            notes_references=subtotal_model.notes_references,
            units=subtotal_model.units,
            display_scale_factor=subtotal_model.display_scale_factor,
            is_contra=subtotal_model.is_contra,
        )</code></pre>
</details>
<div class="desc"><p>Constructs a <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> object from a validated configuration.</p>
<p>Takes a <code><a title="fin_statement_model.statements.StatementConfig" href="#fin_statement_model.statements.StatementConfig">StatementConfig</a></code> instance (which should have successfully passed
validation, populating its <code>.model</code> attribute) and recursively builds the
corresponding <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code>, including its sections, line items,
calculated items, subtotals, and nested sections.</p>
<p>Initialize the StatementStructureBuilder.</p>
<p>Defaults for validation flags come from the global statements config, but can be overridden locally.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable_node_validation</code></strong></dt>
<dd>If True, validates node IDs during build.</dd>
<dt><strong><code>node_validation_strict</code></strong></dt>
<dd>If True, treats validation failures as errors.</dd>
<dt><strong><code>node_validator</code></strong></dt>
<dd>Optional pre-configured UnifiedNodeValidator instance.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.StatementStructureBuilder.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self,<br>config:Â <a title="fin_statement_model.statements.configs.validator.StatementConfig" href="configs/validator.html#fin_statement_model.statements.configs.validator.StatementConfig">StatementConfig</a>) â€‘>Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, config: StatementConfig) -&gt; StatementStructure:
    &#34;&#34;&#34;Build a `StatementStructure` from a validated `StatementConfig`.

    This is the main public method of the builder. It orchestrates the
    conversion process, calling internal helper methods to build sections
    and items.

    Args:
        config: A `StatementConfig` instance whose `.validate_config()`
            method has been successfully called, populating `config.model`.

    Returns:
        The fully constructed `StatementStructure` object, ready to be
        registered or used.

    Raises:
        ValueError: If the provided `config` object has not been validated
            (i.e., `config.model` is `None`).
        ConfigurationError: If an unexpected error occurs during the building
            process, potentially indicating an issue not caught by the
            initial Pydantic validation or an internal inconsistency.
    &#34;&#34;&#34;
    if config.model is None:
        # Ensure validation has run successfully before building
        raise ValueError(
            &#34;StatementConfig must be validated (config.model must be set) before building the structure.&#34;
        )

    # Build from the validated Pydantic model stored in config.model
    try:
        stmt_model = config.model  # Use validated model from config

        # Optional node validation during build
        if self.enable_node_validation and self.node_validator:
            error_collector = ErrorCollector()
            self._validate_structure_node_ids(stmt_model, error_collector)

            # Handle validation results
            if error_collector.has_errors() and self.node_validation_strict:
                # Fail build on validation errors in strict mode
                error_messages = [str(error) for error in error_collector.get_errors()]
                raise ConfigurationError(
                    message=f&#34;Node validation failed for statement &#39;{stmt_model.id}&#39;&#34;,
                    errors=error_messages,
                )
            elif error_collector.has_warnings() or error_collector.has_errors():
                # Log warnings and non-strict errors
                for warning in error_collector.get_warnings():
                    logger.warning(&#34;Build-time node validation: %s&#34;, warning)
                if not self.node_validation_strict:
                    for error in error_collector.get_errors():
                        logger.warning(&#34;Build-time node validation: %s&#34;, error)

        statement = StatementStructure(
            id=stmt_model.id,
            name=stmt_model.name,
            description=cast(&#34;str&#34;, stmt_model.description),
            metadata=stmt_model.metadata,
            units=stmt_model.units,
            display_scale_factor=stmt_model.display_scale_factor,
        )
        for sec_model in stmt_model.sections:
            section = self._build_section_model(sec_model)
            statement.add_section(section)
        logger.info(&#34;Successfully built StatementStructure for ID &#39;%s&#39;&#34;, statement.id)
    except Exception as e:
        # Catch potential errors during the building process itself
        logger.exception(
            &#34;Error building statement structure from validated model for ID &#39;%s&#39;&#34;,
            config.model.id,
        )
        raise ConfigurationError(
            message=f&#34;Failed to build statement structure from validated config: {e}&#34;,
            errors=[str(e)],
        ) from e
    else:
        return statement</code></pre>
</details>
<div class="desc"><p>Build a <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> from a validated <code><a title="fin_statement_model.statements.StatementConfig" href="#fin_statement_model.statements.StatementConfig">StatementConfig</a></code>.</p>
<p>This is the main public method of the builder. It orchestrates the
conversion process, calling internal helper methods to build sections
and items.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>A <code><a title="fin_statement_model.statements.StatementConfig" href="#fin_statement_model.statements.StatementConfig">StatementConfig</a></code> instance whose <code>.validate_config()</code>
method has been successfully called, populating <code>config.model</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The fully constructed <code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code> object, ready to be
registered or used.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the provided <code>config</code> object has not been validated
(i.e., <code>config.model</code> is <code>None</code>).</dd>
<dt><code><a title="fin_statement_model.statements.ConfigurationError" href="#fin_statement_model.statements.ConfigurationError">ConfigurationError</a></code></dt>
<dd>If an unexpected error occurs during the building
process, potentially indicating an issue not caught by the
initial Pydantic validation or an internal inconsistency.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.SubtotalItemProcessor"><code class="flex name class">
<span>class <span class="ident">SubtotalItemProcessor</span></span>
<span>(</span><span>id_resolver:Â <a title="fin_statement_model.statements.population.id_resolver.IDResolver" href="population/id_resolver.html#fin_statement_model.statements.population.id_resolver.IDResolver">IDResolver</a>,<br>graph:Â <a title="fin_statement_model.core.graph.graph.Graph" href="../core/graph/graph.html#fin_statement_model.core.graph.graph.Graph">Graph</a>,<br>statement:Â <a title="fin_statement_model.statements.structure.containers.StatementStructure" href="structure/containers.html#fin_statement_model.statements.structure.containers.StatementStructure">StatementStructure</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubtotalItemProcessor(ItemProcessor):
    &#34;&#34;&#34;Processor for SubtotalLineItem objects.

    Handles the creation of subtotal (addition) nodes by:
    1. Resolving input IDs to graph nodes
    2. Adding an addition calculation node
    &#34;&#34;&#34;

    def can_process(self, item: StatementItem) -&gt; bool:
        &#34;&#34;&#34;Check if item is a SubtotalLineItem.&#34;&#34;&#34;
        return isinstance(item, SubtotalLineItem)

    def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
        &#34;&#34;&#34;Process a SubtotalLineItem and add it to the graph.&#34;&#34;&#34;
        if not isinstance(item, SubtotalLineItem):
            return ProcessorResult(success=False, error_message=&#34;Invalid item type&#34;)

        # Check if node already exists
        if self.graph.has_node(item.id):
            return ProcessorResult(success=True, node_added=False)

        # Handle empty subtotals
        if not item.item_ids:
            logger.debug(&#34;Subtotal item &#39;%s&#39; has no input items&#34;, item.id)
            return ProcessorResult(success=True, node_added=False)

        # Resolve inputs
        resolved, missing = self.resolve_inputs(item.item_ids)
        if missing:
            return self._handle_missing_inputs(item, missing, is_retry)

        # Add subtotal as addition calculation
        error_message = None
        try:
            self.graph.add_calculation(name=item.id, input_names=resolved, operation_type=&#34;addition&#34;)
        except (
            NodeError,
            CircularDependencyError,
            CalculationError,
            ConfigurationError,
        ) as e:
            error_msg = f&#34;Failed to add subtotal node &#39;{item.id}&#39;: {e}&#34;
            logger.exception(error_msg)
            error_message = str(e)
        except Exception as e:
            error_msg = f&#34;Unexpected error adding subtotal node &#39;{item.id}&#39;: {e}&#34;
            logger.exception(error_msg)
            error_message = f&#34;Unexpected error: {e}&#34;

        if error_message:
            return ProcessorResult(success=False, error_message=error_message)
        return ProcessorResult(success=True, node_added=True)</code></pre>
</details>
<div class="desc"><p>Processor for SubtotalLineItem objects.</p>
<p>Handles the creation of subtotal (addition) nodes by:
1. Resolving input IDs to graph nodes
2. Adding an addition calculation node</p>
<p>Initialize the processor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_resolver</code></strong></dt>
<dd>ID resolver for mapping statement IDs to graph node IDs.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>The graph to add nodes to.</dd>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement structure being processed.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.population.item_processors.ItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor">ItemProcessor</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.SubtotalItemProcessor.can_process"><code class="name flex">
<span>def <span class="ident">can_process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_process(self, item: StatementItem) -&gt; bool:
    &#34;&#34;&#34;Check if item is a SubtotalLineItem.&#34;&#34;&#34;
    return isinstance(item, SubtotalLineItem)</code></pre>
</details>
<div class="desc"><p>Check if item is a SubtotalLineItem.</p></div>
</dd>
<dt id="fin_statement_model.statements.SubtotalItemProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self,<br>item:Â <a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a>,<br>is_retry:Â boolÂ =Â False) â€‘>Â <a title="fin_statement_model.statements.population.item_processors.ProcessorResult" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ProcessorResult">ProcessorResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, item: StatementItem, is_retry: bool = False) -&gt; ProcessorResult:
    &#34;&#34;&#34;Process a SubtotalLineItem and add it to the graph.&#34;&#34;&#34;
    if not isinstance(item, SubtotalLineItem):
        return ProcessorResult(success=False, error_message=&#34;Invalid item type&#34;)

    # Check if node already exists
    if self.graph.has_node(item.id):
        return ProcessorResult(success=True, node_added=False)

    # Handle empty subtotals
    if not item.item_ids:
        logger.debug(&#34;Subtotal item &#39;%s&#39; has no input items&#34;, item.id)
        return ProcessorResult(success=True, node_added=False)

    # Resolve inputs
    resolved, missing = self.resolve_inputs(item.item_ids)
    if missing:
        return self._handle_missing_inputs(item, missing, is_retry)

    # Add subtotal as addition calculation
    error_message = None
    try:
        self.graph.add_calculation(name=item.id, input_names=resolved, operation_type=&#34;addition&#34;)
    except (
        NodeError,
        CircularDependencyError,
        CalculationError,
        ConfigurationError,
    ) as e:
        error_msg = f&#34;Failed to add subtotal node &#39;{item.id}&#39;: {e}&#34;
        logger.exception(error_msg)
        error_message = str(e)
    except Exception as e:
        error_msg = f&#34;Unexpected error adding subtotal node &#39;{item.id}&#39;: {e}&#34;
        logger.exception(error_msg)
        error_message = f&#34;Unexpected error: {e}&#34;

    if error_message:
        return ProcessorResult(success=False, error_message=error_message)
    return ProcessorResult(success=True, node_added=True)</code></pre>
</details>
<div class="desc"><p>Process a SubtotalLineItem and add it to the graph.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.population.item_processors.ItemProcessor" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor">ItemProcessor</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.population.item_processors.ItemProcessor.resolve_inputs" href="population/item_processors.html#fin_statement_model.statements.population.item_processors.ItemProcessor.resolve_inputs">resolve_inputs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.SubtotalLineItem"><code class="flex name class">
<span>class <span class="ident">SubtotalLineItem</span></span>
<span>(</span><span>id:Â str,<br>name:Â str,<br>item_ids:Â list[str],<br>description:Â strÂ =Â '',<br>sign_convention:Â intÂ =Â 1,<br>metadata:Â dict[str,Â typing.Any]Â |Â NoneÂ =Â None,<br>default_adjustment_filter:Â typing.AnyÂ |Â NoneÂ =Â None,<br>display_format:Â strÂ |Â NoneÂ =Â None,<br>hide_if_all_zero:Â boolÂ =Â False,<br>css_class:Â strÂ |Â NoneÂ =Â None,<br>notes_references:Â list[str]Â |Â NoneÂ =Â None,<br>units:Â strÂ |Â NoneÂ =Â None,<br>display_scale_factor:Â floatÂ |Â NoneÂ =Â None,<br>is_contra:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubtotalLineItem(CalculatedLineItem):
    &#34;&#34;&#34;Represents a subtotal line item summing multiple other items.

    Args:
      id: Unique ID (also used as node_id)
      name: Display name
      item_ids: List of IDs to sum
      description: Optional description
      sign_convention: 1 or -1
      metadata: Optional metadata
      default_adjustment_filter: Optional default adjustment filter for this item
      display_format: Optional specific number format string
      hide_if_all_zero: Whether to hide this item if all values are zero
      css_class: Optional CSS class name for HTML/web outputs
      notes_references: List of footnote/note IDs referenced by this item
      units: Optional unit description
      display_scale_factor: Factor to scale values for display

    Raises:
      StatementError: If item_ids is empty or not a list
    &#34;&#34;&#34;

    def __init__(
        self,
        id: str,
        name: str,
        item_ids: list[str],
        description: str = &#34;&#34;,
        sign_convention: int = 1,
        metadata: dict[str, Any] | None = None,
        default_adjustment_filter: Any | None = None,
        display_format: str | None = None,
        hide_if_all_zero: bool = False,
        css_class: str | None = None,
        notes_references: list[str] | None = None,
        units: str | None = None,
        display_scale_factor: float | None = None,
        is_contra: bool = False,
    ):
        &#34;&#34;&#34;Initialize a SubtotalLineItem summing multiple items.

        Args:
            id: Unique ID (also used as node_id).
            name: Display name.
            item_ids: List of IDs to sum.
            description: Optional description.
            sign_convention: Sign convention (1 or -1).
            metadata: Optional metadata.
            default_adjustment_filter: Optional default adjustment filter for this item.
            display_format: Optional specific number format string.
            hide_if_all_zero: Whether to hide this item if all values are zero.
            css_class: Optional CSS class name for HTML/web outputs.
            notes_references: List of footnote/note IDs referenced by this item.
            units: Optional unit description.
            display_scale_factor: Factor to scale values for display.
                                If not provided, uses config default from display.scale_factor.
            is_contra: Whether this is a contra item for special display formatting.

        Raises:
            StatementError: If item_ids is empty or not a list.
        &#34;&#34;&#34;
        if not isinstance(item_ids, list) or not item_ids:
            raise StatementError(f&#34;Invalid or empty item IDs for subtotal: {id}&#34;)
        calculation = {&#34;type&#34;: &#34;addition&#34;, &#34;inputs&#34;: item_ids, &#34;parameters&#34;: {}}
        super().__init__(
            id=id,
            name=name,
            calculation=calculation,
            description=description,
            sign_convention=sign_convention,
            metadata=metadata,
            default_adjustment_filter=default_adjustment_filter,
            display_format=display_format,
            hide_if_all_zero=hide_if_all_zero,
            css_class=css_class,
            notes_references=notes_references,
            units=units,
            display_scale_factor=display_scale_factor,
            is_contra=is_contra,
        )
        self._item_ids = item_ids

    @property
    def item_ids(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the IDs of items summed by this subtotal.&#34;&#34;&#34;
        return self._item_ids

    @property
    def item_type(self) -&gt; StatementItemType:
        &#34;&#34;&#34;Get the type of this item (SUBTOTAL).&#34;&#34;&#34;
        return StatementItemType.SUBTOTAL</code></pre>
</details>
<div class="desc"><p>Represents a subtotal line item summing multiple other items.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique ID (also used as node_id)</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name</dd>
<dt><strong><code>item_ids</code></strong></dt>
<dd>List of IDs to sum</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>1 or -1</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If item_ids is empty or not a list</dd>
</dl>
<p>Initialize a SubtotalLineItem summing multiple items.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Unique ID (also used as node_id).</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Display name.</dd>
<dt><strong><code>item_ids</code></strong></dt>
<dd>List of IDs to sum.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Optional description.</dd>
<dt><strong><code>sign_convention</code></strong></dt>
<dd>Sign convention (1 or -1).</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional metadata.</dd>
<dt><strong><code>default_adjustment_filter</code></strong></dt>
<dd>Optional default adjustment filter for this item.</dd>
<dt><strong><code>display_format</code></strong></dt>
<dd>Optional specific number format string.</dd>
<dt><strong><code>hide_if_all_zero</code></strong></dt>
<dd>Whether to hide this item if all values are zero.</dd>
<dt><strong><code>css_class</code></strong></dt>
<dd>Optional CSS class name for HTML/web outputs.</dd>
<dt><strong><code>notes_references</code></strong></dt>
<dd>List of footnote/note IDs referenced by this item.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Optional unit description.</dd>
<dt><strong><code>display_scale_factor</code></strong></dt>
<dd>Factor to scale values for display.
If not provided, uses config default from display.scale_factor.</dd>
<dt><strong><code>is_contra</code></strong></dt>
<dd>Whether this is a contra item for special display formatting.</dd>
</dl>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></dt>
<dd>If item_ids is empty or not a list.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.structure.items.CalculatedLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem">CalculatedLineItem</a></li>
<li><a title="fin_statement_model.statements.structure.items.LineItem" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem">LineItem</a></li>
<li><a title="fin_statement_model.statements.structure.items.StatementItem" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem">StatementItem</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.SubtotalLineItem.item_ids"><code class="name">prop <span class="ident">item_ids</span> :Â list[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item_ids(self) -&gt; list[str]:
    &#34;&#34;&#34;Get the IDs of items summed by this subtotal.&#34;&#34;&#34;
    return self._item_ids</code></pre>
</details>
<div class="desc"><p>Get the IDs of items summed by this subtotal.</p></div>
</dd>
<dt id="fin_statement_model.statements.SubtotalLineItem.item_type"><code class="name">prop <span class="ident">item_type</span> :Â <a title="fin_statement_model.statements.structure.items.StatementItemType" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItemType">StatementItemType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item_type(self) -&gt; StatementItemType:
    &#34;&#34;&#34;Get the type of this item (SUBTOTAL).&#34;&#34;&#34;
    return StatementItemType.SUBTOTAL</code></pre>
</details>
<div class="desc"><p>Get the type of this item (SUBTOTAL).</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.structure.items.CalculatedLineItem" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem">CalculatedLineItem</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.calculation_type" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem.calculation_type">calculation_type</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.css_class" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.css_class">css_class</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.default_adjustment_filter" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.default_adjustment_filter">default_adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.description" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.display_format" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.display_format">display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.display_scale_factor" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.get_resolved_node_id" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.get_resolved_node_id">get_resolved_node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.hide_if_all_zero" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.hide_if_all_zero">hide_if_all_zero</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.id" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.input_ids" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem.input_ids">input_ids</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.is_contra" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.is_contra">is_contra</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.metadata" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.name" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.node_id" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.node_id">node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.notes_references" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.notes_references">notes_references</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.parameters" href="structure/items.html#fin_statement_model.statements.structure.items.CalculatedLineItem.parameters">parameters</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.sign_convention" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.sign_convention">sign_convention</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.standard_node_ref" href="structure/items.html#fin_statement_model.statements.structure.items.LineItem.standard_node_ref">standard_node_ref</a></code></li>
<li><code><a title="fin_statement_model.statements.structure.items.CalculatedLineItem.units" href="structure/items.html#fin_statement_model.statements.structure.items.StatementItem.units">units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.Success"><code class="flex name class">
<span>class <span class="ident">Success</span></span>
<span>(</span><span>value:Â ~T)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Success(Result[T]):
    &#34;&#34;&#34;Represents a successful operation result.&#34;&#34;&#34;

    value: T

    def is_success(self) -&gt; bool:
        &#34;&#34;&#34;Always returns True for Success.&#34;&#34;&#34;
        return True

    def is_failure(self) -&gt; bool:
        &#34;&#34;&#34;Always returns False for Success.&#34;&#34;&#34;
        return False

    def get_value(self) -&gt; T | None:
        &#34;&#34;&#34;Return the success value.&#34;&#34;&#34;
        return self.value

    def get_errors(self) -&gt; list[ErrorDetail]:
        &#34;&#34;&#34;Return empty list for Success.&#34;&#34;&#34;
        return []</code></pre>
</details>
<div class="desc"><p>Represents a successful operation result.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.Success.value"><code class="name">var <span class="ident">value</span> :Â ~T</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.Success.get_errors"><code class="name flex">
<span>def <span class="ident">get_errors</span></span>(<span>self) â€‘>Â list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_errors(self) -&gt; list[ErrorDetail]:
    &#34;&#34;&#34;Return empty list for Success.&#34;&#34;&#34;
    return []</code></pre>
</details>
<div class="desc"><p>Return empty list for Success.</p></div>
</dd>
<dt id="fin_statement_model.statements.Success.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self) â€‘>Â ~TÂ |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self) -&gt; T | None:
    &#34;&#34;&#34;Return the success value.&#34;&#34;&#34;
    return self.value</code></pre>
</details>
<div class="desc"><p>Return the success value.</p></div>
</dd>
<dt id="fin_statement_model.statements.Success.is_failure"><code class="name flex">
<span>def <span class="ident">is_failure</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_failure(self) -&gt; bool:
    &#34;&#34;&#34;Always returns False for Success.&#34;&#34;&#34;
    return False</code></pre>
</details>
<div class="desc"><p>Always returns False for Success.</p></div>
</dd>
<dt id="fin_statement_model.statements.Success.is_success"><code class="name flex">
<span>def <span class="ident">is_success</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_success(self) -&gt; bool:
    &#34;&#34;&#34;Always returns True for Success.&#34;&#34;&#34;
    return True</code></pre>
</details>
<div class="desc"><p>Always returns True for Success.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fin_statement_model.statements.utilities.result_types.Result" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a></b></code>:
<ul class="hlist">
<li><code><a title="fin_statement_model.statements.utilities.result_types.Result.unwrap" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result.unwrap">unwrap</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.result_types.Result.unwrap_or" href="utilities/result_types.html#fin_statement_model.statements.utilities.result_types.Result.unwrap_or">unwrap_or</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fin_statement_model.statements.UnifiedNodeValidator"><code class="flex name class">
<span>class <span class="ident">UnifiedNodeValidator</span></span>
<span>(</span><span>registry:Â <a title="fin_statement_model.core.nodes.standard_registry.StandardNodeRegistry" href="../core/nodes/standard_registry.html#fin_statement_model.core.nodes.standard_registry.StandardNodeRegistry">StandardNodeRegistry</a>,<br>strict_mode:Â boolÂ |Â NoneÂ =Â None,<br>auto_standardize:Â boolÂ |Â NoneÂ =Â None,<br>warn_on_non_standard:Â boolÂ |Â NoneÂ =Â None,<br>enable_patterns:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnifiedNodeValidator:
    &#34;&#34;&#34;Unified validator for node names with pattern recognition and standardization.

    This validator combines the functionality of NodeNameValidator and
    ContextAwareNodeValidator into a single, more efficient implementation.
    &#34;&#34;&#34;

    # Common sub-node patterns
    SUBNODE_PATTERNS: ClassVar[list[tuple[str, str]]] = [
        (r&#34;^(.+)_(q[1-4])$&#34;, &#34;quarterly&#34;),
        (r&#34;^(.+)_(fy\d{4})$&#34;, &#34;fiscal_year&#34;),
        (r&#34;^(.+)_(\d{4})$&#34;, &#34;annual&#34;),
        (r&#34;^(.+)_(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$&#34;, &#34;monthly&#34;),
        (r&#34;^(.+)_(actual|budget|forecast)$&#34;, &#34;scenario&#34;),
    ]

    # Generic segment pattern - must be checked separately
    SEGMENT_PATTERN = r&#34;^(.+)_([a-z_]+)$&#34;

    # Formula patterns - check exact endings
    FORMULA_ENDINGS: ClassVar[list[str]] = [
        &#34;_margin&#34;,
        &#34;_ratio&#34;,
        &#34;_growth&#34;,
        &#34;_change&#34;,
        &#34;_pct&#34;,
    ]

    def __init__(
        self,
        registry: StandardNodeRegistry,
        strict_mode: bool | None = None,
        auto_standardize: bool | None = None,
        warn_on_non_standard: bool | None = None,
        enable_patterns: bool = True,
    ):
        &#34;&#34;&#34;Initialize the unified validator.

        Args:
            registry: The StandardNodeRegistry instance.
            strict_mode: If True, only standard names are allowed.
                        If None, uses config.validation.strict_mode.
            auto_standardize: If True, convert alternate names to standard.
                            If None, uses config.validation.auto_standardize_names.
            warn_on_non_standard: If True, log warnings for non-standard names.
                                If None, uses config.validation.warn_on_non_standard.
            enable_patterns: If True, recognize sub-node and formula patterns.
        &#34;&#34;&#34;
        from fin_statement_model import get_config

        config = get_config()

        self._registry = registry
        self.strict_mode = strict_mode if strict_mode is not None else config.validation.strict_mode
        self.auto_standardize = (
            auto_standardize if auto_standardize is not None else config.validation.auto_standardize_names
        )
        self.warn_on_non_standard = (
            warn_on_non_standard if warn_on_non_standard is not None else config.validation.warn_on_non_standard
        )
        self.enable_patterns = enable_patterns
        self._validation_cache: dict[str, ValidationResult] = {}

    def validate(
        self,
        name: str,
        node_type: str | None = None,
        parent_nodes: list[str] | None = None,
        use_cache: bool = True,
    ) -&gt; ValidationResult:
        &#34;&#34;&#34;Validate a node name with full context awareness.

        Args:
            name: The node name to validate.
            node_type: Optional node type hint.
            parent_nodes: Optional list of parent node names.
            use_cache: Whether to use cached results.

        Returns:
            ValidationResult with all validation details.
        &#34;&#34;&#34;
        # Check cache first
        cache_key = f&#34;{name}:{node_type}:{&#39;,&#39;.join(parent_nodes or [])}&#34;
        if use_cache and cache_key in self._validation_cache:
            return self._validation_cache[cache_key]

        # Start validation
        result = self._perform_validation(name, node_type, parent_nodes)

        # Cache result
        if use_cache:
            self._validation_cache[cache_key] = result

        # Log warnings if configured
        if self.warn_on_non_standard and result.category in [&#34;custom&#34;, &#34;invalid&#34;]:
            logger.warning(&#34;%s&#34;, result.message)
            if result.suggestions:
                logger.info(
                    &#34;Suggestions for &#39;%s&#39;: %s&#34;,
                    name,
                    &#34;; &#34;.join(result.suggestions),
                )

        return result

    def _perform_validation(
        self,
        name: str,
        node_type: str | None,
        parent_nodes: list[str] | None,
    ) -&gt; ValidationResult:
        &#34;&#34;&#34;Perform the actual validation logic.&#34;&#34;&#34;
        # Normalize name to lowercase for registry checks
        normalized_name = name.lower()

        # Check standard names first (using normalized name)
        if self._registry.is_standard_name(normalized_name):
            # If original name is different case, standardize to lowercase
            standardized = normalized_name if name != normalized_name else name
            return ValidationResult(
                original_name=name,
                standardized_name=standardized,
                is_valid=True,
                message=f&#34;Standard node: {normalized_name}&#34;,
                category=&#34;standard&#34;,
                confidence=1.0,
            )

        # Check alternate names (using normalized name)
        if self._registry.is_alternate_name(normalized_name):
            standard_name = self._registry.get_standard_name(normalized_name)
            return ValidationResult(
                original_name=name,
                standardized_name=standard_name if self.auto_standardize else name,
                is_valid=True,
                message=f&#34;{&#39;Standardized&#39; if self.auto_standardize else &#39;Alternate name for&#39;} &#39;{standard_name}&#39;&#34;,
                category=&#34;alternate&#34;,
                confidence=1.0,
            )

        # Pattern recognition if enabled
        if self.enable_patterns:
            pattern_result = self._check_pattern_validations(name, node_type, parent_nodes)
            if pattern_result:
                return pattern_result

        # Generate suggestions for unrecognized names
        suggestions = self._generate_suggestions(name)

        # Default to custom/invalid
        return ValidationResult(
            original_name=name,
            standardized_name=name,
            is_valid=not self.strict_mode,
            message=f&#34;{&#39;Non-standard&#39; if self.strict_mode else &#39;Custom&#39;} node: &#39;{name}&#39;&#34;,
            category=&#34;invalid&#34; if self.strict_mode else &#34;custom&#34;,
            confidence=0.5,
            suggestions=suggestions,
        )

    def _check_pattern_validations(
        self,
        name: str,
        node_type: str | None,
        parent_nodes: list[str] | None,
    ) -&gt; ValidationResult | None:
        _ = parent_nodes  # Parameter intentionally unused in current implementation
        &#34;&#34;&#34;Check all pattern-based validations.&#34;&#34;&#34;
        # Check formula patterns first (more specific)
        if node_type in [&#34;calculation&#34;, &#34;formula&#34;, None]:
            pattern_result = self._check_formula_ending(name)
            if pattern_result:
                base_name, formula_type = pattern_result

                return ValidationResult(
                    original_name=name,
                    standardized_name=name,
                    is_valid=True,
                    message=f&#34;Formula node: {formula_type} of &#39;{base_name}&#39;&#34;,
                    category=&#34;formula&#34;,
                    confidence=0.85,
                )

        # Check specific sub-node patterns
        subnode_match = self._check_patterns(name, self.SUBNODE_PATTERNS, &#34;subnode&#34;)
        if subnode_match:
            base_name, suffix, pattern_type = subnode_match
            # Normalize base name for registry check
            is_base_standard = self._registry.is_recognized_name(base_name.lower())

            return ValidationResult(
                original_name=name,
                standardized_name=name,
                is_valid=not self.strict_mode or is_base_standard,
                message=f&#34;{&#39;Valid&#39; if is_base_standard else &#39;Non-standard&#39;} sub-node of &#39;{base_name}&#39; ({pattern_type})&#34;,
                category=&#34;subnode&#34; if is_base_standard else &#34;subnode_nonstandard&#34;,
                confidence=0.9 if is_base_standard else 0.7,
            )

        # Check generic segment pattern last
        match = re.match(self.SEGMENT_PATTERN, name.lower())
        if match and &#34;_&#34; in name:
            base_name = match.group(1)
            suffix = match.group(2)

            # Only treat as segment if it doesn&#39;t match other patterns
            # and has a reasonable structure (geographic/business segment)
            segment_keywords = [
                &#34;america&#34;,
                &#34;europe&#34;,
                &#34;asia&#34;,
                &#34;pacific&#34;,
                &#34;africa&#34;,
                &#34;region&#34;,
                &#34;domestic&#34;,
                &#34;international&#34;,
                &#34;global&#34;,
                &#34;local&#34;,
                &#34;retail&#34;,
                &#34;wholesale&#34;,
                &#34;online&#34;,
                &#34;digital&#34;,
                &#34;services&#34;,
                &#34;products&#34;,
                &#34;solutions&#34;,
                &#34;segment&#34;,
                &#34;division&#34;,
                &#34;unit&#34;,
            ]

            if len(suffix) &gt;= MIN_SUFFIX_LENGTH and any(keyword in suffix.lower() for keyword in segment_keywords):
                # Normalize base name for registry check
                is_base_standard = self._registry.is_recognized_name(base_name.lower())

                return ValidationResult(
                    original_name=name,
                    standardized_name=name,
                    is_valid=not self.strict_mode or is_base_standard,
                    message=f&#34;{&#39;Valid&#39; if is_base_standard else &#39;Non-standard&#39;} sub-node of &#39;{base_name}&#39; (segment)&#34;,
                    category=&#34;subnode&#34; if is_base_standard else &#34;subnode_nonstandard&#34;,
                    confidence=0.85 if is_base_standard else 0.65,
                )

        return None

    def _check_formula_ending(self, name: str) -&gt; tuple[str, str] | None:
        &#34;&#34;&#34;Check if name ends with a formula pattern.&#34;&#34;&#34;
        name_lower = name.lower()

        for ending in self.FORMULA_ENDINGS:
            if name_lower.endswith(ending):
                base_name = name[: -len(ending)]
                formula_type = ending[1:]  # Remove underscore
                return base_name, formula_type

        return None

    def _check_patterns(
        self,
        name: str,
        patterns: list[tuple[str, str]],
        pattern_category: str,
    ) -&gt; tuple[str, str, str] | None:
        _ = pattern_category  # Parameter intentionally unused
        &#34;&#34;&#34;Check if name matches any pattern in the list.&#34;&#34;&#34;
        name_lower = name.lower()

        for pattern, pattern_type in patterns:
            match = re.match(pattern, name_lower)
            if match:
                base_name = match.group(1)
                suffix = match.group(2) if (match.lastindex is not None and match.lastindex &gt; 1) else &#34;&#34;
                return base_name, suffix, pattern_type

        return None

    def _generate_suggestions(self, name: str) -&gt; list[str]:
        &#34;&#34;&#34;Generate improvement suggestions for non-standard names.&#34;&#34;&#34;
        suggestions_with_scores = []
        name_lower = name.lower()

        # Find similar standard names
        for std_name in self._registry.list_standard_names():
            std_lower = std_name.lower()

            # Calculate similarity score
            score = 0.0

            # Exact prefix match gets highest score
            if std_lower.startswith(name_lower) or name_lower.startswith(std_lower):
                score = 0.9
            # Check character overlap
            elif self._is_similar(name_lower, std_lower):
                overlap = len(set(name_lower) &amp; set(std_lower))
                min_len = min(len(name_lower), len(std_lower))
                score = overlap / min_len * 0.8

            if score &gt; 0:
                suggestions_with_scores.append((score, f&#34;Consider using standard name: &#39;{std_name}&#39;&#34;))

        # Sort by score (highest first) and take top suggestions
        suggestions_with_scores.sort(key=lambda x: x[0], reverse=True)
        suggestions = [msg for _, msg in suggestions_with_scores[:SUGGESTION_LIMIT]]

        # Check for pattern improvements
        if &#34;_&#34; in name and len(suggestions) &lt; SUGGESTION_LIMIT:
            parts = name.split(&#34;_&#34;, 1)
            base = parts[0]

            # Suggest standardizing the base
            for std_name in self._registry.list_standard_names():
                if self._is_similar(base.lower(), std_name.lower()):
                    suggestions.append(f&#34;Consider using &#39;{std_name}_{parts[1]}&#39; for consistency&#34;)
                    break

        # Generic suggestions if nothing specific found
        if not suggestions:
            if any(suffix in name for suffix in [&#34;_margin&#34;, &#34;_ratio&#34;, &#34;_growth&#34;, &#34;_pct&#34;]):
                suggestions.append(&#34;Formula node detected - ensure base name follows standard conventions&#34;)
            else:
                suggestions.append(&#34;Consider using a standard node name for better metric compatibility&#34;)

        return suggestions[:SUGGESTION_LIMIT]  # Return top 3 suggestions

    def _is_similar(self, str1: str, str2: str, threshold: float = 0.6) -&gt; bool:
        &#34;&#34;&#34;Check if two strings are similar enough.&#34;&#34;&#34;
        if len(str1) &lt; MIN_STRING_SIMILARITY_LENGTH or len(str2) &lt; MIN_STRING_SIMILARITY_LENGTH:
            return False

        # Check if one is a prefix of the other
        if str1.startswith(str2) or str2.startswith(str1):
            return True

        # Check containment
        if str1 in str2 or str2 in str1:
            return True

        # Check character overlap
        overlap = len(set(str1) &amp; set(str2))
        min_len = min(len(str1), len(str2))

        return overlap / min_len &gt;= threshold

    def validate_batch(
        self,
        names: list[str],
        node_types: dict[str, str] | None = None,
        parent_map: dict[str, list[str]] | None = None,
    ) -&gt; dict[str, ValidationResult]:
        &#34;&#34;&#34;Validate multiple node names efficiently.

        Args:
            names: List of node names to validate.
            node_types: Optional mapping of names to node types.
            parent_map: Optional mapping of names to parent node lists.

        Returns:
            Dictionary mapping names to ValidationResults.
        &#34;&#34;&#34;
        results = {}
        node_types = node_types or {}
        parent_map = parent_map or {}

        for name in names:
            result = self.validate(
                name,
                node_type=node_types.get(name),
                parent_nodes=parent_map.get(name),
            )
            results[name] = result

        return results

    def validate_graph(self, nodes: list[Node]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Validate all nodes in a graph with full context.

        Args:
            nodes: List of Node objects from the graph.

        Returns:
            Comprehensive validation report.
        &#34;&#34;&#34;
        # Build context maps
        node_types = {}
        parent_map = {}

        for node in nodes:
            # Determine node type
            class_name = node.__class__.__name__
            if &#34;Formula&#34; in class_name:
                node_types[node.name] = &#34;formula&#34;
            elif &#34;Calculation&#34; in class_name:
                node_types[node.name] = &#34;calculation&#34;
            elif &#34;Forecast&#34; in class_name:
                node_types[node.name] = &#34;forecast&#34;
            else:
                node_types[node.name] = &#34;data&#34;

            # Extract parent nodes
            if hasattr(node, &#34;inputs&#34;):
                if isinstance(node.inputs, dict):
                    parent_map[node.name] = [p.name for p in node.inputs.values()]
                elif isinstance(node.inputs, list):
                    parent_map[node.name] = [p.name for p in node.inputs]

        # Validate all nodes
        node_names = [node.name for node in nodes]
        results = self.validate_batch(node_names, node_types, parent_map)

        # Build summarized report
        by_category: dict[str, list[str]] = {}
        by_validity: dict[str, int] = {&#34;valid&#34;: 0, &#34;invalid&#34;: 0}
        suggestions: dict[str, list[str]] = {}
        # Populate report sections
        for name, result in results.items():
            # Count by category
            cat = result.category
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(name)
            # Count by validity
            if result.is_valid:
                by_validity[&#34;valid&#34;] += 1
            else:
                by_validity[&#34;invalid&#34;] += 1
            # Collect suggestions
            if result.suggestions:
                suggestions[name] = result.suggestions
        return {
            &#34;total&#34;: len(results),
            &#34;by_category&#34;: by_category,
            &#34;by_validity&#34;: by_validity,
            &#34;suggestions&#34;: suggestions,
            &#34;details&#34;: results,
        }

    def clear_cache(self) -&gt; None:
        &#34;&#34;&#34;Clear the validation cache.&#34;&#34;&#34;
        self._validation_cache.clear()</code></pre>
</details>
<div class="desc"><p>Unified validator for node names with pattern recognition and standardization.</p>
<p>This validator combines the functionality of NodeNameValidator and
ContextAwareNodeValidator into a single, more efficient implementation.</p>
<p>Initialize the unified validator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>registry</code></strong></dt>
<dd>The StandardNodeRegistry instance.</dd>
<dt><strong><code>strict_mode</code></strong></dt>
<dd>If True, only standard names are allowed.
If None, uses config.validation.strict_mode.</dd>
<dt><strong><code>auto_standardize</code></strong></dt>
<dd>If True, convert alternate names to standard.
If None, uses config.validation.auto_standardize_names.</dd>
<dt><strong><code>warn_on_non_standard</code></strong></dt>
<dd>If True, log warnings for non-standard names.
If None, uses config.validation.warn_on_non_standard.</dd>
<dt><strong><code>enable_patterns</code></strong></dt>
<dd>If True, recognize sub-node and formula patterns.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.FORMULA_ENDINGS"><code class="name">var <span class="ident">FORMULA_ENDINGS</span> :Â ClassVar[list[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.SEGMENT_PATTERN"><code class="name">var <span class="ident">SEGMENT_PATTERN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.SUBNODE_PATTERNS"><code class="name">var <span class="ident">SUBNODE_PATTERNS</span> :Â ClassVar[list[tuple[str,Â str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self) -&gt; None:
    &#34;&#34;&#34;Clear the validation cache.&#34;&#34;&#34;
    self._validation_cache.clear()</code></pre>
</details>
<div class="desc"><p>Clear the validation cache.</p></div>
</dd>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self,<br>name:Â str,<br>node_type:Â strÂ |Â NoneÂ =Â None,<br>parent_nodes:Â list[str]Â |Â NoneÂ =Â None,<br>use_cache:Â boolÂ =Â True) â€‘>Â <a title="fin_statement_model.statements.validation.ValidationResult" href="validation.html#fin_statement_model.statements.validation.ValidationResult">ValidationResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(
    self,
    name: str,
    node_type: str | None = None,
    parent_nodes: list[str] | None = None,
    use_cache: bool = True,
) -&gt; ValidationResult:
    &#34;&#34;&#34;Validate a node name with full context awareness.

    Args:
        name: The node name to validate.
        node_type: Optional node type hint.
        parent_nodes: Optional list of parent node names.
        use_cache: Whether to use cached results.

    Returns:
        ValidationResult with all validation details.
    &#34;&#34;&#34;
    # Check cache first
    cache_key = f&#34;{name}:{node_type}:{&#39;,&#39;.join(parent_nodes or [])}&#34;
    if use_cache and cache_key in self._validation_cache:
        return self._validation_cache[cache_key]

    # Start validation
    result = self._perform_validation(name, node_type, parent_nodes)

    # Cache result
    if use_cache:
        self._validation_cache[cache_key] = result

    # Log warnings if configured
    if self.warn_on_non_standard and result.category in [&#34;custom&#34;, &#34;invalid&#34;]:
        logger.warning(&#34;%s&#34;, result.message)
        if result.suggestions:
            logger.info(
                &#34;Suggestions for &#39;%s&#39;: %s&#34;,
                name,
                &#34;; &#34;.join(result.suggestions),
            )

    return result</code></pre>
</details>
<div class="desc"><p>Validate a node name with full context awareness.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The node name to validate.</dd>
<dt><strong><code>node_type</code></strong></dt>
<dd>Optional node type hint.</dd>
<dt><strong><code>parent_nodes</code></strong></dt>
<dd>Optional list of parent node names.</dd>
<dt><strong><code>use_cache</code></strong></dt>
<dd>Whether to use cached results.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ValidationResult with all validation details.</p></div>
</dd>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.validate_batch"><code class="name flex">
<span>def <span class="ident">validate_batch</span></span>(<span>self,<br>names:Â list[str],<br>node_types:Â dict[str,Â str]Â |Â NoneÂ =Â None,<br>parent_map:Â dict[str,Â list[str]]Â |Â NoneÂ =Â None) â€‘>Â dict[str,Â <a title="fin_statement_model.statements.validation.ValidationResult" href="validation.html#fin_statement_model.statements.validation.ValidationResult">ValidationResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_batch(
    self,
    names: list[str],
    node_types: dict[str, str] | None = None,
    parent_map: dict[str, list[str]] | None = None,
) -&gt; dict[str, ValidationResult]:
    &#34;&#34;&#34;Validate multiple node names efficiently.

    Args:
        names: List of node names to validate.
        node_types: Optional mapping of names to node types.
        parent_map: Optional mapping of names to parent node lists.

    Returns:
        Dictionary mapping names to ValidationResults.
    &#34;&#34;&#34;
    results = {}
    node_types = node_types or {}
    parent_map = parent_map or {}

    for name in names:
        result = self.validate(
            name,
            node_type=node_types.get(name),
            parent_nodes=parent_map.get(name),
        )
        results[name] = result

    return results</code></pre>
</details>
<div class="desc"><p>Validate multiple node names efficiently.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>names</code></strong></dt>
<dd>List of node names to validate.</dd>
<dt><strong><code>node_types</code></strong></dt>
<dd>Optional mapping of names to node types.</dd>
<dt><strong><code>parent_map</code></strong></dt>
<dd>Optional mapping of names to parent node lists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping names to ValidationResults.</p></div>
</dd>
<dt id="fin_statement_model.statements.UnifiedNodeValidator.validate_graph"><code class="name flex">
<span>def <span class="ident">validate_graph</span></span>(<span>self,<br>nodes:Â list[<a title="fin_statement_model.core.nodes.base.Node" href="../core/nodes/base.html#fin_statement_model.core.nodes.base.Node">Node</a>]) â€‘>Â dict[str,Â typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_graph(self, nodes: list[Node]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Validate all nodes in a graph with full context.

    Args:
        nodes: List of Node objects from the graph.

    Returns:
        Comprehensive validation report.
    &#34;&#34;&#34;
    # Build context maps
    node_types = {}
    parent_map = {}

    for node in nodes:
        # Determine node type
        class_name = node.__class__.__name__
        if &#34;Formula&#34; in class_name:
            node_types[node.name] = &#34;formula&#34;
        elif &#34;Calculation&#34; in class_name:
            node_types[node.name] = &#34;calculation&#34;
        elif &#34;Forecast&#34; in class_name:
            node_types[node.name] = &#34;forecast&#34;
        else:
            node_types[node.name] = &#34;data&#34;

        # Extract parent nodes
        if hasattr(node, &#34;inputs&#34;):
            if isinstance(node.inputs, dict):
                parent_map[node.name] = [p.name for p in node.inputs.values()]
            elif isinstance(node.inputs, list):
                parent_map[node.name] = [p.name for p in node.inputs]

    # Validate all nodes
    node_names = [node.name for node in nodes]
    results = self.validate_batch(node_names, node_types, parent_map)

    # Build summarized report
    by_category: dict[str, list[str]] = {}
    by_validity: dict[str, int] = {&#34;valid&#34;: 0, &#34;invalid&#34;: 0}
    suggestions: dict[str, list[str]] = {}
    # Populate report sections
    for name, result in results.items():
        # Count by category
        cat = result.category
        if cat not in by_category:
            by_category[cat] = []
        by_category[cat].append(name)
        # Count by validity
        if result.is_valid:
            by_validity[&#34;valid&#34;] += 1
        else:
            by_validity[&#34;invalid&#34;] += 1
        # Collect suggestions
        if result.suggestions:
            suggestions[name] = result.suggestions
    return {
        &#34;total&#34;: len(results),
        &#34;by_category&#34;: by_category,
        &#34;by_validity&#34;: by_validity,
        &#34;suggestions&#34;: suggestions,
        &#34;details&#34;: results,
    }</code></pre>
</details>
<div class="desc"><p>Validate all nodes in a graph with full context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodes</code></strong></dt>
<dd>List of Node objects from the graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Comprehensive validation report.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model" href="../index.html">fin_statement_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fin_statement_model.statements.configs" href="configs/index.html">fin_statement_model.statements.configs</a></code></li>
<li><code><a title="fin_statement_model.statements.errors" href="errors.html">fin_statement_model.statements.errors</a></code></li>
<li><code><a title="fin_statement_model.statements.formatting" href="formatting/index.html">fin_statement_model.statements.formatting</a></code></li>
<li><code><a title="fin_statement_model.statements.orchestration" href="orchestration/index.html">fin_statement_model.statements.orchestration</a></code></li>
<li><code><a title="fin_statement_model.statements.population" href="population/index.html">fin_statement_model.statements.population</a></code></li>
<li><code><a title="fin_statement_model.statements.registry" href="registry.html">fin_statement_model.statements.registry</a></code></li>
<li><code><a title="fin_statement_model.statements.structure" href="structure/index.html">fin_statement_model.statements.structure</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities" href="utilities/index.html">fin_statement_model.statements.utilities</a></code></li>
<li><code><a title="fin_statement_model.statements.validation" href="validation.html">fin_statement_model.statements.validation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.statements.build_validated_statement_from_config" href="#fin_statement_model.statements.build_validated_statement_from_config">build_validated_statement_from_config</a></code></li>
<li><code><a title="fin_statement_model.statements.combine_results" href="#fin_statement_model.statements.combine_results">combine_results</a></code></li>
<li><code><a title="fin_statement_model.statements.create_statement_dataframe" href="#fin_statement_model.statements.create_statement_dataframe">create_statement_dataframe</a></code></li>
<li><code><a title="fin_statement_model.statements.create_validated_statement_builder" href="#fin_statement_model.statements.create_validated_statement_builder">create_validated_statement_builder</a></code></li>
<li><code><a title="fin_statement_model.statements.create_validated_statement_config" href="#fin_statement_model.statements.create_validated_statement_config">create_validated_statement_config</a></code></li>
<li><code><a title="fin_statement_model.statements.export_statements_to_excel" href="#fin_statement_model.statements.export_statements_to_excel">export_statements_to_excel</a></code></li>
<li><code><a title="fin_statement_model.statements.export_statements_to_json" href="#fin_statement_model.statements.export_statements_to_json">export_statements_to_json</a></code></li>
<li><code><a title="fin_statement_model.statements.list_available_builtin_configs" href="#fin_statement_model.statements.list_available_builtin_configs">list_available_builtin_configs</a></code></li>
<li><code><a title="fin_statement_model.statements.populate_graph_from_statement" href="#fin_statement_model.statements.populate_graph_from_statement">populate_graph_from_statement</a></code></li>
<li><code><a title="fin_statement_model.statements.pretty_print_errors" href="#fin_statement_model.statements.pretty_print_errors">pretty_print_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.retry_on_specific_errors" href="#fin_statement_model.statements.retry_on_specific_errors">retry_on_specific_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.retry_with_exponential_backoff" href="#fin_statement_model.statements.retry_with_exponential_backoff">retry_with_exponential_backoff</a></code></li>
<li><code><a title="fin_statement_model.statements.validate_statement_config_with_nodes" href="#fin_statement_model.statements.validate_statement_config_with_nodes">validate_statement_config_with_nodes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.statements.AdjustmentFilterSpec" href="#fin_statement_model.statements.AdjustmentFilterSpec">AdjustmentFilterSpec</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.exclude_scenarios" href="#fin_statement_model.statements.AdjustmentFilterSpec.exclude_scenarios">exclude_scenarios</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.exclude_tags" href="#fin_statement_model.statements.AdjustmentFilterSpec.exclude_tags">exclude_tags</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.exclude_types" href="#fin_statement_model.statements.AdjustmentFilterSpec.exclude_types">exclude_types</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.include_scenarios" href="#fin_statement_model.statements.AdjustmentFilterSpec.include_scenarios">include_scenarios</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.include_tags" href="#fin_statement_model.statements.AdjustmentFilterSpec.include_tags">include_tags</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.include_types" href="#fin_statement_model.statements.AdjustmentFilterSpec.include_types">include_types</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.model_config" href="#fin_statement_model.statements.AdjustmentFilterSpec.model_config">model_config</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.period" href="#fin_statement_model.statements.AdjustmentFilterSpec.period">period</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.require_all_tags" href="#fin_statement_model.statements.AdjustmentFilterSpec.require_all_tags">require_all_tags</a></code></li>
<li><code><a title="fin_statement_model.statements.AdjustmentFilterSpec.validate_adjustment_types" href="#fin_statement_model.statements.AdjustmentFilterSpec.validate_adjustment_types">validate_adjustment_types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.BackoffStrategy" href="#fin_statement_model.statements.BackoffStrategy">BackoffStrategy</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.BackoffStrategy.get_delay" href="#fin_statement_model.statements.BackoffStrategy.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.CalculatedItemProcessor" href="#fin_statement_model.statements.CalculatedItemProcessor">CalculatedItemProcessor</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.CalculatedItemProcessor.can_process" href="#fin_statement_model.statements.CalculatedItemProcessor.can_process">can_process</a></code></li>
<li><code><a title="fin_statement_model.statements.CalculatedItemProcessor.process" href="#fin_statement_model.statements.CalculatedItemProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.CalculatedLineItem" href="#fin_statement_model.statements.CalculatedLineItem">CalculatedLineItem</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.CalculatedLineItem.calculation_type" href="#fin_statement_model.statements.CalculatedLineItem.calculation_type">calculation_type</a></code></li>
<li><code><a title="fin_statement_model.statements.CalculatedLineItem.input_ids" href="#fin_statement_model.statements.CalculatedLineItem.input_ids">input_ids</a></code></li>
<li><code><a title="fin_statement_model.statements.CalculatedLineItem.item_type" href="#fin_statement_model.statements.CalculatedLineItem.item_type">item_type</a></code></li>
<li><code><a title="fin_statement_model.statements.CalculatedLineItem.parameters" href="#fin_statement_model.statements.CalculatedLineItem.parameters">parameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ConfigurationError" href="#fin_statement_model.statements.ConfigurationError">ConfigurationError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ConstantBackoff" href="#fin_statement_model.statements.ConstantBackoff">ConstantBackoff</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ConstantBackoff.get_delay" href="#fin_statement_model.statements.ConstantBackoff.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.DataFetcher" href="#fin_statement_model.statements.DataFetcher">DataFetcher</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.DataFetcher.check_adjustments" href="#fin_statement_model.statements.DataFetcher.check_adjustments">check_adjustments</a></code></li>
<li><code><a title="fin_statement_model.statements.DataFetcher.fetch_all_data" href="#fin_statement_model.statements.DataFetcher.fetch_all_data">fetch_all_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ErrorCollector" href="#fin_statement_model.statements.ErrorCollector">ErrorCollector</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.ErrorCollector.add_error" href="#fin_statement_model.statements.ErrorCollector.add_error">add_error</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.add_from_result" href="#fin_statement_model.statements.ErrorCollector.add_from_result">add_from_result</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.add_warning" href="#fin_statement_model.statements.ErrorCollector.add_warning">add_warning</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.get_all" href="#fin_statement_model.statements.ErrorCollector.get_all">get_all</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.get_errors" href="#fin_statement_model.statements.ErrorCollector.get_errors">get_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.get_warnings" href="#fin_statement_model.statements.ErrorCollector.get_warnings">get_warnings</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.has_errors" href="#fin_statement_model.statements.ErrorCollector.has_errors">has_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.has_warnings" href="#fin_statement_model.statements.ErrorCollector.has_warnings">has_warnings</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.log_all" href="#fin_statement_model.statements.ErrorCollector.log_all">log_all</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorCollector.to_result" href="#fin_statement_model.statements.ErrorCollector.to_result">to_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ErrorDetail" href="#fin_statement_model.statements.ErrorDetail">ErrorDetail</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ErrorDetail.code" href="#fin_statement_model.statements.ErrorDetail.code">code</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorDetail.context" href="#fin_statement_model.statements.ErrorDetail.context">context</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorDetail.message" href="#fin_statement_model.statements.ErrorDetail.message">message</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorDetail.severity" href="#fin_statement_model.statements.ErrorDetail.severity">severity</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorDetail.source" href="#fin_statement_model.statements.ErrorDetail.source">source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ErrorSeverity" href="#fin_statement_model.statements.ErrorSeverity">ErrorSeverity</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ErrorSeverity.CRITICAL" href="#fin_statement_model.statements.ErrorSeverity.CRITICAL">CRITICAL</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorSeverity.ERROR" href="#fin_statement_model.statements.ErrorSeverity.ERROR">ERROR</a></code></li>
<li><code><a title="fin_statement_model.statements.ErrorSeverity.WARNING" href="#fin_statement_model.statements.ErrorSeverity.WARNING">WARNING</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ExponentialBackoff" href="#fin_statement_model.statements.ExponentialBackoff">ExponentialBackoff</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ExponentialBackoff.get_delay" href="#fin_statement_model.statements.ExponentialBackoff.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.Failure" href="#fin_statement_model.statements.Failure">Failure</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.Failure.errors" href="#fin_statement_model.statements.Failure.errors">errors</a></code></li>
<li><code><a title="fin_statement_model.statements.Failure.from_exception" href="#fin_statement_model.statements.Failure.from_exception">from_exception</a></code></li>
<li><code><a title="fin_statement_model.statements.Failure.get_errors" href="#fin_statement_model.statements.Failure.get_errors">get_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.Failure.get_value" href="#fin_statement_model.statements.Failure.get_value">get_value</a></code></li>
<li><code><a title="fin_statement_model.statements.Failure.is_failure" href="#fin_statement_model.statements.Failure.is_failure">is_failure</a></code></li>
<li><code><a title="fin_statement_model.statements.Failure.is_success" href="#fin_statement_model.statements.Failure.is_success">is_success</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.FetchResult" href="#fin_statement_model.statements.FetchResult">FetchResult</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.FetchResult.data" href="#fin_statement_model.statements.FetchResult.data">data</a></code></li>
<li><code><a title="fin_statement_model.statements.FetchResult.errors" href="#fin_statement_model.statements.FetchResult.errors">errors</a></code></li>
<li><code><a title="fin_statement_model.statements.FetchResult.missing_nodes" href="#fin_statement_model.statements.FetchResult.missing_nodes">missing_nodes</a></code></li>
<li><code><a title="fin_statement_model.statements.FetchResult.node_count" href="#fin_statement_model.statements.FetchResult.node_count">node_count</a></code></li>
<li><code><a title="fin_statement_model.statements.FetchResult.to_result" href="#fin_statement_model.statements.FetchResult.to_result">to_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.IDResolver" href="#fin_statement_model.statements.IDResolver">IDResolver</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.IDResolver.get_all_mappings" href="#fin_statement_model.statements.IDResolver.get_all_mappings">get_all_mappings</a></code></li>
<li><code><a title="fin_statement_model.statements.IDResolver.get_items_for_node" href="#fin_statement_model.statements.IDResolver.get_items_for_node">get_items_for_node</a></code></li>
<li><code><a title="fin_statement_model.statements.IDResolver.invalidate_cache" href="#fin_statement_model.statements.IDResolver.invalidate_cache">invalidate_cache</a></code></li>
<li><code><a title="fin_statement_model.statements.IDResolver.refresh_cache" href="#fin_statement_model.statements.IDResolver.refresh_cache">refresh_cache</a></code></li>
<li><code><a title="fin_statement_model.statements.IDResolver.resolve" href="#fin_statement_model.statements.IDResolver.resolve">resolve</a></code></li>
<li><code><a title="fin_statement_model.statements.IDResolver.resolve_multiple" href="#fin_statement_model.statements.IDResolver.resolve_multiple">resolve_multiple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ItemProcessor" href="#fin_statement_model.statements.ItemProcessor">ItemProcessor</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ItemProcessor.can_process" href="#fin_statement_model.statements.ItemProcessor.can_process">can_process</a></code></li>
<li><code><a title="fin_statement_model.statements.ItemProcessor.process" href="#fin_statement_model.statements.ItemProcessor.process">process</a></code></li>
<li><code><a title="fin_statement_model.statements.ItemProcessor.resolve_inputs" href="#fin_statement_model.statements.ItemProcessor.resolve_inputs">resolve_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ItemProcessorManager" href="#fin_statement_model.statements.ItemProcessorManager">ItemProcessorManager</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ItemProcessorManager.process_item" href="#fin_statement_model.statements.ItemProcessorManager.process_item">process_item</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.LineItem" href="#fin_statement_model.statements.LineItem">LineItem</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.LineItem.description" href="#fin_statement_model.statements.LineItem.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.get_resolved_node_id" href="#fin_statement_model.statements.LineItem.get_resolved_node_id">get_resolved_node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.id" href="#fin_statement_model.statements.LineItem.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.item_type" href="#fin_statement_model.statements.LineItem.item_type">item_type</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.metadata" href="#fin_statement_model.statements.LineItem.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.name" href="#fin_statement_model.statements.LineItem.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.node_id" href="#fin_statement_model.statements.LineItem.node_id">node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.sign_convention" href="#fin_statement_model.statements.LineItem.sign_convention">sign_convention</a></code></li>
<li><code><a title="fin_statement_model.statements.LineItem.standard_node_ref" href="#fin_statement_model.statements.LineItem.standard_node_ref">standard_node_ref</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.LinearBackoff" href="#fin_statement_model.statements.LinearBackoff">LinearBackoff</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.LinearBackoff.get_delay" href="#fin_statement_model.statements.LinearBackoff.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.MetricItemProcessor" href="#fin_statement_model.statements.MetricItemProcessor">MetricItemProcessor</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.MetricItemProcessor.can_process" href="#fin_statement_model.statements.MetricItemProcessor.can_process">can_process</a></code></li>
<li><code><a title="fin_statement_model.statements.MetricItemProcessor.process" href="#fin_statement_model.statements.MetricItemProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.NodeData" href="#fin_statement_model.statements.NodeData">NodeData</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.NodeData.errors" href="#fin_statement_model.statements.NodeData.errors">errors</a></code></li>
<li><code><a title="fin_statement_model.statements.NodeData.has_data" href="#fin_statement_model.statements.NodeData.has_data">has_data</a></code></li>
<li><code><a title="fin_statement_model.statements.NodeData.is_adjusted" href="#fin_statement_model.statements.NodeData.is_adjusted">is_adjusted</a></code></li>
<li><code><a title="fin_statement_model.statements.NodeData.node_id" href="#fin_statement_model.statements.NodeData.node_id">node_id</a></code></li>
<li><code><a title="fin_statement_model.statements.NodeData.values" href="#fin_statement_model.statements.NodeData.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.ProcessorResult" href="#fin_statement_model.statements.ProcessorResult">ProcessorResult</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.ProcessorResult.error_message" href="#fin_statement_model.statements.ProcessorResult.error_message">error_message</a></code></li>
<li><code><a title="fin_statement_model.statements.ProcessorResult.missing_inputs" href="#fin_statement_model.statements.ProcessorResult.missing_inputs">missing_inputs</a></code></li>
<li><code><a title="fin_statement_model.statements.ProcessorResult.node_added" href="#fin_statement_model.statements.ProcessorResult.node_added">node_added</a></code></li>
<li><code><a title="fin_statement_model.statements.ProcessorResult.success" href="#fin_statement_model.statements.ProcessorResult.success">success</a></code></li>
<li><code><a title="fin_statement_model.statements.ProcessorResult.to_result" href="#fin_statement_model.statements.ProcessorResult.to_result">to_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.Result" href="#fin_statement_model.statements.Result">Result</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.Result.get_errors" href="#fin_statement_model.statements.Result.get_errors">get_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.Result.get_value" href="#fin_statement_model.statements.Result.get_value">get_value</a></code></li>
<li><code><a title="fin_statement_model.statements.Result.is_failure" href="#fin_statement_model.statements.Result.is_failure">is_failure</a></code></li>
<li><code><a title="fin_statement_model.statements.Result.is_success" href="#fin_statement_model.statements.Result.is_success">is_success</a></code></li>
<li><code><a title="fin_statement_model.statements.Result.unwrap" href="#fin_statement_model.statements.Result.unwrap">unwrap</a></code></li>
<li><code><a title="fin_statement_model.statements.Result.unwrap_or" href="#fin_statement_model.statements.Result.unwrap_or">unwrap_or</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.RetryConfig" href="#fin_statement_model.statements.RetryConfig">RetryConfig</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.RetryConfig.backoff" href="#fin_statement_model.statements.RetryConfig.backoff">backoff</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryConfig.collect_all_errors" href="#fin_statement_model.statements.RetryConfig.collect_all_errors">collect_all_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryConfig.log_retries" href="#fin_statement_model.statements.RetryConfig.log_retries">log_retries</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryConfig.max_attempts" href="#fin_statement_model.statements.RetryConfig.max_attempts">max_attempts</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryConfig.retryable_errors" href="#fin_statement_model.statements.RetryConfig.retryable_errors">retryable_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryConfig.strategy" href="#fin_statement_model.statements.RetryConfig.strategy">strategy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.RetryHandler" href="#fin_statement_model.statements.RetryHandler">RetryHandler</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.RetryHandler.retry" href="#fin_statement_model.statements.RetryHandler.retry">retry</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryHandler.retry_async" href="#fin_statement_model.statements.RetryHandler.retry_async">retry_async</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.RetryResult" href="#fin_statement_model.statements.RetryResult">RetryResult</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.RetryResult.all_errors" href="#fin_statement_model.statements.RetryResult.all_errors">all_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryResult.attempts" href="#fin_statement_model.statements.RetryResult.attempts">attempts</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryResult.result" href="#fin_statement_model.statements.RetryResult.result">result</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryResult.success" href="#fin_statement_model.statements.RetryResult.success">success</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryResult.total_delay" href="#fin_statement_model.statements.RetryResult.total_delay">total_delay</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryResult.unwrap" href="#fin_statement_model.statements.RetryResult.unwrap">unwrap</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryResult.unwrap_or" href="#fin_statement_model.statements.RetryResult.unwrap_or">unwrap_or</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.RetryStrategy" href="#fin_statement_model.statements.RetryStrategy">RetryStrategy</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.RetryStrategy.BACKOFF" href="#fin_statement_model.statements.RetryStrategy.BACKOFF">BACKOFF</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryStrategy.CONDITIONAL" href="#fin_statement_model.statements.RetryStrategy.CONDITIONAL">CONDITIONAL</a></code></li>
<li><code><a title="fin_statement_model.statements.RetryStrategy.IMMEDIATE" href="#fin_statement_model.statements.RetryStrategy.IMMEDIATE">IMMEDIATE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.Section" href="#fin_statement_model.statements.Section">Section</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.Section.add_item" href="#fin_statement_model.statements.Section.add_item">add_item</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.css_class" href="#fin_statement_model.statements.Section.css_class">css_class</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.default_adjustment_filter" href="#fin_statement_model.statements.Section.default_adjustment_filter">default_adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.description" href="#fin_statement_model.statements.Section.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.display_format" href="#fin_statement_model.statements.Section.display_format">display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.display_scale_factor" href="#fin_statement_model.statements.Section.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.find_item_by_id" href="#fin_statement_model.statements.Section.find_item_by_id">find_item_by_id</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.hide_if_all_zero" href="#fin_statement_model.statements.Section.hide_if_all_zero">hide_if_all_zero</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.id" href="#fin_statement_model.statements.Section.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.item_type" href="#fin_statement_model.statements.Section.item_type">item_type</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.items" href="#fin_statement_model.statements.Section.items">items</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.metadata" href="#fin_statement_model.statements.Section.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.name" href="#fin_statement_model.statements.Section.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.notes_references" href="#fin_statement_model.statements.Section.notes_references">notes_references</a></code></li>
<li><code><a title="fin_statement_model.statements.Section.units" href="#fin_statement_model.statements.Section.units">units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementConfig" href="#fin_statement_model.statements.StatementConfig">StatementConfig</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementConfig.validate_config" href="#fin_statement_model.statements.StatementConfig.validate_config">validate_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementError" href="#fin_statement_model.statements.StatementError">StatementError</a></code></h4>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementFormatter" href="#fin_statement_model.statements.StatementFormatter">StatementFormatter</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementFormatter.format_html" href="#fin_statement_model.statements.StatementFormatter.format_html">format_html</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementFormatter.generate_dataframe" href="#fin_statement_model.statements.StatementFormatter.generate_dataframe">generate_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementItem" href="#fin_statement_model.statements.StatementItem">StatementItem</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementItem.css_class" href="#fin_statement_model.statements.StatementItem.css_class">css_class</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.default_adjustment_filter" href="#fin_statement_model.statements.StatementItem.default_adjustment_filter">default_adjustment_filter</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.display_format" href="#fin_statement_model.statements.StatementItem.display_format">display_format</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.display_scale_factor" href="#fin_statement_model.statements.StatementItem.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.hide_if_all_zero" href="#fin_statement_model.statements.StatementItem.hide_if_all_zero">hide_if_all_zero</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.id" href="#fin_statement_model.statements.StatementItem.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.is_contra" href="#fin_statement_model.statements.StatementItem.is_contra">is_contra</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.item_type" href="#fin_statement_model.statements.StatementItem.item_type">item_type</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.name" href="#fin_statement_model.statements.StatementItem.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.notes_references" href="#fin_statement_model.statements.StatementItem.notes_references">notes_references</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItem.units" href="#fin_statement_model.statements.StatementItem.units">units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementItemType" href="#fin_statement_model.statements.StatementItemType">StatementItemType</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementItemType.CALCULATED" href="#fin_statement_model.statements.StatementItemType.CALCULATED">CALCULATED</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItemType.LINE_ITEM" href="#fin_statement_model.statements.StatementItemType.LINE_ITEM">LINE_ITEM</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItemType.METRIC" href="#fin_statement_model.statements.StatementItemType.METRIC">METRIC</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItemType.SECTION" href="#fin_statement_model.statements.StatementItemType.SECTION">SECTION</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementItemType.SUBTOTAL" href="#fin_statement_model.statements.StatementItemType.SUBTOTAL">SUBTOTAL</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementRegistry" href="#fin_statement_model.statements.StatementRegistry">StatementRegistry</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementRegistry.clear" href="#fin_statement_model.statements.StatementRegistry.clear">clear</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementRegistry.get" href="#fin_statement_model.statements.StatementRegistry.get">get</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementRegistry.get_all_ids" href="#fin_statement_model.statements.StatementRegistry.get_all_ids">get_all_ids</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementRegistry.get_all_statements" href="#fin_statement_model.statements.StatementRegistry.get_all_statements">get_all_statements</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementRegistry.register" href="#fin_statement_model.statements.StatementRegistry.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementStructure" href="#fin_statement_model.statements.StatementStructure">StatementStructure</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementStructure.add_section" href="#fin_statement_model.statements.StatementStructure.add_section">add_section</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.description" href="#fin_statement_model.statements.StatementStructure.description">description</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.display_scale_factor" href="#fin_statement_model.statements.StatementStructure.display_scale_factor">display_scale_factor</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.find_item_by_id" href="#fin_statement_model.statements.StatementStructure.find_item_by_id">find_item_by_id</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.get_all_items" href="#fin_statement_model.statements.StatementStructure.get_all_items">get_all_items</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.get_calculation_items" href="#fin_statement_model.statements.StatementStructure.get_calculation_items">get_calculation_items</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.get_metric_items" href="#fin_statement_model.statements.StatementStructure.get_metric_items">get_metric_items</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.id" href="#fin_statement_model.statements.StatementStructure.id">id</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.items" href="#fin_statement_model.statements.StatementStructure.items">items</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.metadata" href="#fin_statement_model.statements.StatementStructure.metadata">metadata</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.name" href="#fin_statement_model.statements.StatementStructure.name">name</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.sections" href="#fin_statement_model.statements.StatementStructure.sections">sections</a></code></li>
<li><code><a title="fin_statement_model.statements.StatementStructure.units" href="#fin_statement_model.statements.StatementStructure.units">units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.StatementStructureBuilder" href="#fin_statement_model.statements.StatementStructureBuilder">StatementStructureBuilder</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.StatementStructureBuilder.build" href="#fin_statement_model.statements.StatementStructureBuilder.build">build</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.SubtotalItemProcessor" href="#fin_statement_model.statements.SubtotalItemProcessor">SubtotalItemProcessor</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.SubtotalItemProcessor.can_process" href="#fin_statement_model.statements.SubtotalItemProcessor.can_process">can_process</a></code></li>
<li><code><a title="fin_statement_model.statements.SubtotalItemProcessor.process" href="#fin_statement_model.statements.SubtotalItemProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.SubtotalLineItem" href="#fin_statement_model.statements.SubtotalLineItem">SubtotalLineItem</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.SubtotalLineItem.item_ids" href="#fin_statement_model.statements.SubtotalLineItem.item_ids">item_ids</a></code></li>
<li><code><a title="fin_statement_model.statements.SubtotalLineItem.item_type" href="#fin_statement_model.statements.SubtotalLineItem.item_type">item_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.Success" href="#fin_statement_model.statements.Success">Success</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.Success.get_errors" href="#fin_statement_model.statements.Success.get_errors">get_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.Success.get_value" href="#fin_statement_model.statements.Success.get_value">get_value</a></code></li>
<li><code><a title="fin_statement_model.statements.Success.is_failure" href="#fin_statement_model.statements.Success.is_failure">is_failure</a></code></li>
<li><code><a title="fin_statement_model.statements.Success.is_success" href="#fin_statement_model.statements.Success.is_success">is_success</a></code></li>
<li><code><a title="fin_statement_model.statements.Success.value" href="#fin_statement_model.statements.Success.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.UnifiedNodeValidator" href="#fin_statement_model.statements.UnifiedNodeValidator">UnifiedNodeValidator</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.FORMULA_ENDINGS" href="#fin_statement_model.statements.UnifiedNodeValidator.FORMULA_ENDINGS">FORMULA_ENDINGS</a></code></li>
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.SEGMENT_PATTERN" href="#fin_statement_model.statements.UnifiedNodeValidator.SEGMENT_PATTERN">SEGMENT_PATTERN</a></code></li>
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.SUBNODE_PATTERNS" href="#fin_statement_model.statements.UnifiedNodeValidator.SUBNODE_PATTERNS">SUBNODE_PATTERNS</a></code></li>
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.clear_cache" href="#fin_statement_model.statements.UnifiedNodeValidator.clear_cache">clear_cache</a></code></li>
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.validate" href="#fin_statement_model.statements.UnifiedNodeValidator.validate">validate</a></code></li>
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.validate_batch" href="#fin_statement_model.statements.UnifiedNodeValidator.validate_batch">validate_batch</a></code></li>
<li><code><a title="fin_statement_model.statements.UnifiedNodeValidator.validate_graph" href="#fin_statement_model.statements.UnifiedNodeValidator.validate_graph">validate_graph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
