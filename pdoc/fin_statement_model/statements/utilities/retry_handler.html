<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fin_statement_model.statements.utilities.retry_handler API documentation</title>
<meta name="description" content="Retry handler for managing transient failures in statement operations …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fin_statement_model.statements.utilities.retry_handler</code></h1>
</header>
<section id="section-intro">
<p>Retry handler for managing transient failures in statement operations.</p>
<p>This module provides a flexible retry mechanism that can be used throughout
the statements package to handle transient failures gracefully. It supports
configurable retry strategies, backoff algorithms, and error classification.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.is_retryable_error"><code class="name flex">
<span>def <span class="ident">is_retryable_error</span></span>(<span>error: <a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>,<br>retryable_codes: set[str]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_retryable_error(error: ErrorDetail, retryable_codes: set[str]) -&gt; bool:
    &#34;&#34;&#34;Check if an error is retryable based on its code.

    Args:
        error: The error to check
        retryable_codes: Set of error codes that are retryable

    Returns:
        True if the error should be retried
    &#34;&#34;&#34;
    return error.code in retryable_codes</code></pre>
</details>
<div class="desc"><p>Check if an error is retryable based on its code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error</code></strong></dt>
<dd>The error to check</dd>
<dt><strong><code>retryable_codes</code></strong></dt>
<dd>Set of error codes that are retryable</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the error should be retried</p></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.retry_on_specific_errors"><code class="name flex">
<span>def <span class="ident">retry_on_specific_errors</span></span>(<span>operation: Callable[[], <a title="fin_statement_model.statements.utilities.result_types.Result" href="result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>retryable_errors: set[str],<br>max_attempts: int | None = None,<br>operation_name: str | None = None) ‑> <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_on_specific_errors(
    operation: Callable[[], Result[T]],
    retryable_errors: set[str],
    max_attempts: int | None = None,
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Retry an operation only for specific error codes.

    Args:
        operation: The operation to retry
        retryable_errors: Set of error codes that trigger retry
        max_attempts: Maximum number of attempts. If not provided, uses config default from api.api_retry_count
        operation_name: Optional name for logging

    Returns:
        RetryResult with the final outcome
    &#34;&#34;&#34;
    # Use config default if not provided
    max_attempts = cfg_or_param(&#34;api.api_retry_count&#34;, max_attempts)

    config = RetryConfig(
        max_attempts=max_attempts,
        strategy=RetryStrategy.CONDITIONAL,
        retryable_errors=retryable_errors,
        backoff=ExponentialBackoff(),
    )
    handler = RetryHandler(config)
    return handler.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Retry an operation only for specific error codes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>The operation to retry</dd>
<dt><strong><code>retryable_errors</code></strong></dt>
<dd>Set of error codes that trigger retry</dd>
<dt><strong><code>max_attempts</code></strong></dt>
<dd>Maximum number of attempts. If not provided, uses config default from api.api_retry_count</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult with the final outcome</p></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.retry_with_exponential_backoff"><code class="name flex">
<span>def <span class="ident">retry_with_exponential_backoff</span></span>(<span>operation: Callable[[], <a title="fin_statement_model.statements.utilities.result_types.Result" href="result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>max_attempts: int | None = None,<br>base_delay: float = 1.0,<br>operation_name: str | None = None) ‑> <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_with_exponential_backoff(
    operation: Callable[[], Result[T]],
    max_attempts: int | None = None,
    base_delay: float = 1.0,
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Retry an operation with exponential backoff.

    Args:
        operation: The operation to retry
        max_attempts: Maximum number of attempts. If not provided, uses config default from api.api_retry_count
        base_delay: Initial delay in seconds
        operation_name: Optional name for logging

    Returns:
        RetryResult with the final outcome
    &#34;&#34;&#34;
    # Use config default if not provided
    max_attempts = cfg_or_param(&#34;api.api_retry_count&#34;, max_attempts)

    config = RetryConfig(
        max_attempts=max_attempts,
        strategy=RetryStrategy.BACKOFF,
        backoff=ExponentialBackoff(base_delay=base_delay),
    )
    handler = RetryHandler(config)
    return handler.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Retry an operation with exponential backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>The operation to retry</dd>
<dt><strong><code>max_attempts</code></strong></dt>
<dd>Maximum number of attempts. If not provided, uses config default from api.api_retry_count</dd>
<dt><strong><code>base_delay</code></strong></dt>
<dd>Initial delay in seconds</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult with the final outcome</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy"><code class="flex name class">
<span>class <span class="ident">BackoffStrategy</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackoffStrategy(ABC):
    &#34;&#34;&#34;Abstract base class for backoff strategies.&#34;&#34;&#34;

    @abstractmethod
    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Get delay in seconds for the given attempt number.

        Args:
            attempt: The attempt number (1-based)

        Returns:
            Delay in seconds before the next retry
        &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Abstract base class for backoff strategies.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.ConstantBackoff" href="#fin_statement_model.statements.utilities.retry_handler.ConstantBackoff">ConstantBackoff</a></li>
<li><a title="fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff" href="#fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff">ExponentialBackoff</a></li>
<li><a title="fin_statement_model.statements.utilities.retry_handler.LinearBackoff" href="#fin_statement_model.statements.utilities.retry_handler.LinearBackoff">LinearBackoff</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt: int) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Get delay in seconds for the given attempt number.

    Args:
        attempt: The attempt number (1-based)

    Returns:
        Delay in seconds before the next retry
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Get delay in seconds for the given attempt number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attempt</code></strong></dt>
<dd>The attempt number (1-based)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Delay in seconds before the next retry</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.ConstantBackoff"><code class="flex name class">
<span>class <span class="ident">ConstantBackoff</span></span>
<span>(</span><span>delay: float = 1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstantBackoff(BackoffStrategy):
    &#34;&#34;&#34;Constant delay backoff strategy.&#34;&#34;&#34;

    def __init__(self, delay: float = 1.0):
        &#34;&#34;&#34;Initialize constant backoff.

        Args:
            delay: Constant delay in seconds
        &#34;&#34;&#34;
        self.delay = delay

    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Return constant delay.&#34;&#34;&#34;
        _ = attempt  # Parameter intentionally unused in constant backoff
        return self.delay</code></pre>
</details>
<div class="desc"><p>Constant delay backoff strategy.</p>
<p>Initialize constant backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delay</code></strong></dt>
<dd>Constant delay in seconds</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.ConstantBackoff.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt: int) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Return constant delay.&#34;&#34;&#34;
    _ = attempt  # Parameter intentionally unused in constant backoff
    return self.delay</code></pre>
</details>
<div class="desc"><p>Return constant delay.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff"><code class="flex name class">
<span>class <span class="ident">ExponentialBackoff</span></span>
<span>(</span><span>base_delay: float = 1.0,<br>max_delay: float = 60.0,<br>multiplier: float = 2.0,<br>jitter: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExponentialBackoff(BackoffStrategy):
    &#34;&#34;&#34;Exponential backoff strategy with optional jitter.&#34;&#34;&#34;

    def __init__(
        self,
        base_delay: float = 1.0,
        max_delay: float = 60.0,
        multiplier: float = 2.0,
        jitter: bool = True,
    ):
        &#34;&#34;&#34;Initialize exponential backoff.

        Args:
            base_delay: Initial delay in seconds
            max_delay: Maximum delay in seconds
            multiplier: Multiplier for each retry
            jitter: Whether to add random jitter
        &#34;&#34;&#34;
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.multiplier = multiplier
        self.jitter = jitter

    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Calculate exponential backoff delay.&#34;&#34;&#34;
        delay = min(self.base_delay * (self.multiplier ** (attempt - 1)), self.max_delay)

        if self.jitter:
            # Add up to 20% jitter (non-crypto randomness acceptable)
            jitter_factor = secrets.randbelow(10000) / 10000  # 0.0-0.9999
            jitter_amount = delay * 0.2 * jitter_factor
            delay += jitter_amount

        return delay</code></pre>
</details>
<div class="desc"><p>Exponential backoff strategy with optional jitter.</p>
<p>Initialize exponential backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_delay</code></strong></dt>
<dd>Initial delay in seconds</dd>
<dt><strong><code>max_delay</code></strong></dt>
<dd>Maximum delay in seconds</dd>
<dt><strong><code>multiplier</code></strong></dt>
<dd>Multiplier for each retry</dd>
<dt><strong><code>jitter</code></strong></dt>
<dd>Whether to add random jitter</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt: int) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Calculate exponential backoff delay.&#34;&#34;&#34;
    delay = min(self.base_delay * (self.multiplier ** (attempt - 1)), self.max_delay)

    if self.jitter:
        # Add up to 20% jitter (non-crypto randomness acceptable)
        jitter_factor = secrets.randbelow(10000) / 10000  # 0.0-0.9999
        jitter_amount = delay * 0.2 * jitter_factor
        delay += jitter_amount

    return delay</code></pre>
</details>
<div class="desc"><p>Calculate exponential backoff delay.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.LinearBackoff"><code class="flex name class">
<span>class <span class="ident">LinearBackoff</span></span>
<span>(</span><span>base_delay: float = 1.0, increment: float = 1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearBackoff(BackoffStrategy):
    &#34;&#34;&#34;Linear backoff strategy.&#34;&#34;&#34;

    def __init__(self, base_delay: float = 1.0, increment: float = 1.0):
        &#34;&#34;&#34;Initialize linear backoff.

        Args:
            base_delay: Initial delay in seconds
            increment: Increment for each retry
        &#34;&#34;&#34;
        self.base_delay = base_delay
        self.increment = increment

    def get_delay(self, attempt: int) -&gt; float:
        &#34;&#34;&#34;Calculate linear backoff delay.&#34;&#34;&#34;
        return self.base_delay + (attempt - 1) * self.increment</code></pre>
</details>
<div class="desc"><p>Linear backoff strategy.</p>
<p>Initialize linear backoff.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_delay</code></strong></dt>
<dd>Initial delay in seconds</dd>
<dt><strong><code>increment</code></strong></dt>
<dd>Increment for each retry</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.LinearBackoff.get_delay"><code class="name flex">
<span>def <span class="ident">get_delay</span></span>(<span>self, attempt: int) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delay(self, attempt: int) -&gt; float:
    &#34;&#34;&#34;Calculate linear backoff delay.&#34;&#34;&#34;
    return self.base_delay + (attempt - 1) * self.increment</code></pre>
</details>
<div class="desc"><p>Calculate linear backoff delay.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig"><code class="flex name class">
<span>class <span class="ident">RetryConfig</span></span>
<span>(</span><span>max_attempts: int | None = None,<br>strategy: <a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy" href="#fin_statement_model.statements.utilities.retry_handler.RetryStrategy">RetryStrategy</a> = RetryStrategy.BACKOFF,<br>backoff: ForwardRef('<a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a>') | None = None,<br>retryable_errors: set[str] | None = None,<br>log_retries: bool = True,<br>collect_all_errors: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RetryConfig:
    &#34;&#34;&#34;Configuration for retry behavior.

    Attributes:
        max_attempts: Maximum number of attempts (including initial).
                     If not provided, uses config default from api.api_retry_count
        strategy: Retry strategy to use
        backoff: Optional backoff strategy for delays
        retryable_errors: Set of error codes that are retryable
        log_retries: Whether to log retry attempts
        collect_all_errors: Whether to collect errors from all attempts
    &#34;&#34;&#34;

    max_attempts: int | None = None
    strategy: RetryStrategy = RetryStrategy.BACKOFF
    backoff: Optional[&#34;BackoffStrategy&#34;] = None
    retryable_errors: set[str] | None = None
    log_retries: bool = True
    collect_all_errors: bool = False

    def __post_init__(self) -&gt; None:
        &#34;&#34;&#34;Validate configuration and set defaults.&#34;&#34;&#34;
        # Use config default if not provided
        if self.max_attempts is None:
            self.max_attempts = cfg_or_param(&#34;api.api_retry_count&#34;, None)

        if self.max_attempts &lt; 1:
            raise ValueError(&#34;max_attempts must be at least 1&#34;)

        if self.strategy == RetryStrategy.BACKOFF and not self.backoff:
            # Default to exponential backoff
            self.backoff = ExponentialBackoff()

        if self.retryable_errors is None:
            # Default retryable errors
            self.retryable_errors = {
                &#34;timeout&#34;,
                &#34;connection_error&#34;,
                &#34;rate_limit&#34;,
                &#34;temporary_failure&#34;,
                &#34;calculation_error&#34;,  # For graph calculations
                &#34;node_not_ready&#34;,  # For dependency issues
            }</code></pre>
</details>
<div class="desc"><p>Configuration for retry behavior.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>max_attempts</code></strong></dt>
<dd>Maximum number of attempts (including initial).
If not provided, uses config default from api.api_retry_count</dd>
<dt><strong><code>strategy</code></strong></dt>
<dd>Retry strategy to use</dd>
<dt><strong><code>backoff</code></strong></dt>
<dd>Optional backoff strategy for delays</dd>
<dt><strong><code>retryable_errors</code></strong></dt>
<dd>Set of error codes that are retryable</dd>
<dt><strong><code>log_retries</code></strong></dt>
<dd>Whether to log retry attempts</dd>
<dt><strong><code>collect_all_errors</code></strong></dt>
<dd>Whether to collect errors from all attempts</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig.backoff"><code class="name">var <span class="ident">backoff</span> : <a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig.collect_all_errors"><code class="name">var <span class="ident">collect_all_errors</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig.log_retries"><code class="name">var <span class="ident">log_retries</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig.max_attempts"><code class="name">var <span class="ident">max_attempts</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig.retryable_errors"><code class="name">var <span class="ident">retryable_errors</span> : set[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryConfig.strategy"><code class="name">var <span class="ident">strategy</span> : <a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy" href="#fin_statement_model.statements.utilities.retry_handler.RetryStrategy">RetryStrategy</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryHandler"><code class="flex name class">
<span>class <span class="ident">RetryHandler</span></span>
<span>(</span><span>config: <a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig">RetryConfig</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RetryHandler:
    &#34;&#34;&#34;Handles retry logic for operations that may fail transiently.&#34;&#34;&#34;

    def __init__(self, config: RetryConfig | None = None):
        &#34;&#34;&#34;Initialize retry handler.

        Args:
            config: Retry configuration, uses defaults if not provided
        &#34;&#34;&#34;
        self.config = config or RetryConfig()

    def retry(
        self,
        operation: Callable[[], Result[T]],
        operation_name: str | None = None,
    ) -&gt; RetryResult[T]:
        &#34;&#34;&#34;Execute an operation with retry logic.

        Args:
            operation: Callable that returns a Result
            operation_name: Optional name for logging

        Returns:
            RetryResult containing the final result and metadata
        &#34;&#34;&#34;
        error_collector = ErrorCollector() if self.config.collect_all_errors else None
        total_delay = 0.0
        # Ensure max_attempts is int
        max_attempts = cast(&#34;int&#34;, self.config.max_attempts)
        op_name = operation_name or operation.__name__

        for attempt in range(1, max_attempts + 1):
            if attempt &gt; 1 and self.config.log_retries:
                logger.info(&#34;Retrying %s (attempt %s/%s)&#34;, op_name, attempt, max_attempts)

            # Execute the operation
            try:
                result = operation()
            except Exception as e:  # noqa: BLE001 - convert any exception into Failure for retry logic
                # Convert exception to Result
                result = Failure.from_exception(e)

            # Check if successful
            if result.is_success():
                return RetryResult(
                    result=result,
                    attempts=attempt,
                    total_delay=total_delay,
                    all_errors=error_collector.get_all() if error_collector else None,
                )

            # Handle failure
            errors = result.get_errors()

            # Collect errors if configured
            if error_collector:
                for error in errors:
                    error_collector.add_error(
                        code=error.code,
                        message=f&#34;Attempt {attempt}: {error.message}&#34;,
                        context=error.context,
                        source=error.source,
                    )

            # Check if we should retry
            if attempt &gt;= max_attempts:
                # No more retries
                if self.config.log_retries:
                    logger.warning(
                        &#34;%s failed after %s attempts. Final error: %s&#34;,
                        op_name,
                        attempt,
                        errors[0].message if errors else &#34;Unknown&#34;,
                    )
                break

            # Check if errors are retryable
            if self.config.strategy == RetryStrategy.CONDITIONAL:
                # Safe cast retryable_errors to non-nullable set
                retryable_errors = cast(&#34;set[str]&#34;, self.config.retryable_errors)
                retryable = any(is_retryable_error(error, retryable_errors) for error in errors)
                if not retryable:
                    if self.config.log_retries:
                        logger.debug(
                            &#34;%s failed with non-retryable error: %s&#34;,
                            op_name,
                            errors[0].code if errors else &#34;Unknown&#34;,
                        )
                    break

            # Calculate delay
            if self.config.strategy == RetryStrategy.BACKOFF and self.config.backoff:
                delay = self.config.backoff.get_delay(attempt)
                if self.config.log_retries:
                    logger.debug(&#34;Waiting %.2fs before retry&#34;, delay)
                time.sleep(delay)
                total_delay += delay

        # Return final result
        return RetryResult(
            result=result,
            attempts=attempt,
            total_delay=total_delay,
            all_errors=error_collector.get_all() if error_collector else None,
        )

    def retry_async(
        self,
        operation: Callable[[], Result[T]],
        operation_name: str | None = None,
    ) -&gt; RetryResult[T]:
        &#34;&#34;&#34;Execute an async operation with retry logic.

        Note: This is a placeholder for future async support.
        Currently just delegates to sync retry.

        Args:
            operation: Callable that returns a Result
            operation_name: Optional name for logging

        Returns:
            RetryResult containing the final result and metadata
        &#34;&#34;&#34;
        # TODO: Implement proper async support when needed
        return self.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Handles retry logic for operations that may fail transiently.</p>
<p>Initialize retry handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Retry configuration, uses defaults if not provided</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryHandler.retry"><code class="name flex">
<span>def <span class="ident">retry</span></span>(<span>self,<br>operation: Callable[[], <a title="fin_statement_model.statements.utilities.result_types.Result" href="result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>operation_name: str | None = None) ‑> <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry(
    self,
    operation: Callable[[], Result[T]],
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Execute an operation with retry logic.

    Args:
        operation: Callable that returns a Result
        operation_name: Optional name for logging

    Returns:
        RetryResult containing the final result and metadata
    &#34;&#34;&#34;
    error_collector = ErrorCollector() if self.config.collect_all_errors else None
    total_delay = 0.0
    # Ensure max_attempts is int
    max_attempts = cast(&#34;int&#34;, self.config.max_attempts)
    op_name = operation_name or operation.__name__

    for attempt in range(1, max_attempts + 1):
        if attempt &gt; 1 and self.config.log_retries:
            logger.info(&#34;Retrying %s (attempt %s/%s)&#34;, op_name, attempt, max_attempts)

        # Execute the operation
        try:
            result = operation()
        except Exception as e:  # noqa: BLE001 - convert any exception into Failure for retry logic
            # Convert exception to Result
            result = Failure.from_exception(e)

        # Check if successful
        if result.is_success():
            return RetryResult(
                result=result,
                attempts=attempt,
                total_delay=total_delay,
                all_errors=error_collector.get_all() if error_collector else None,
            )

        # Handle failure
        errors = result.get_errors()

        # Collect errors if configured
        if error_collector:
            for error in errors:
                error_collector.add_error(
                    code=error.code,
                    message=f&#34;Attempt {attempt}: {error.message}&#34;,
                    context=error.context,
                    source=error.source,
                )

        # Check if we should retry
        if attempt &gt;= max_attempts:
            # No more retries
            if self.config.log_retries:
                logger.warning(
                    &#34;%s failed after %s attempts. Final error: %s&#34;,
                    op_name,
                    attempt,
                    errors[0].message if errors else &#34;Unknown&#34;,
                )
            break

        # Check if errors are retryable
        if self.config.strategy == RetryStrategy.CONDITIONAL:
            # Safe cast retryable_errors to non-nullable set
            retryable_errors = cast(&#34;set[str]&#34;, self.config.retryable_errors)
            retryable = any(is_retryable_error(error, retryable_errors) for error in errors)
            if not retryable:
                if self.config.log_retries:
                    logger.debug(
                        &#34;%s failed with non-retryable error: %s&#34;,
                        op_name,
                        errors[0].code if errors else &#34;Unknown&#34;,
                    )
                break

        # Calculate delay
        if self.config.strategy == RetryStrategy.BACKOFF and self.config.backoff:
            delay = self.config.backoff.get_delay(attempt)
            if self.config.log_retries:
                logger.debug(&#34;Waiting %.2fs before retry&#34;, delay)
            time.sleep(delay)
            total_delay += delay

    # Return final result
    return RetryResult(
        result=result,
        attempts=attempt,
        total_delay=total_delay,
        all_errors=error_collector.get_all() if error_collector else None,
    )</code></pre>
</details>
<div class="desc"><p>Execute an operation with retry logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>Callable that returns a Result</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult containing the final result and metadata</p></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryHandler.retry_async"><code class="name flex">
<span>def <span class="ident">retry_async</span></span>(<span>self,<br>operation: Callable[[], <a title="fin_statement_model.statements.utilities.result_types.Result" href="result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]],<br>operation_name: str | None = None) ‑> <a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a>[~T]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_async(
    self,
    operation: Callable[[], Result[T]],
    operation_name: str | None = None,
) -&gt; RetryResult[T]:
    &#34;&#34;&#34;Execute an async operation with retry logic.

    Note: This is a placeholder for future async support.
    Currently just delegates to sync retry.

    Args:
        operation: Callable that returns a Result
        operation_name: Optional name for logging

    Returns:
        RetryResult containing the final result and metadata
    &#34;&#34;&#34;
    # TODO: Implement proper async support when needed
    return self.retry(operation, operation_name)</code></pre>
</details>
<div class="desc"><p>Execute an async operation with retry logic.</p>
<p>Note: This is a placeholder for future async support.
Currently just delegates to sync retry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>operation</code></strong></dt>
<dd>Callable that returns a Result</dd>
<dt><strong><code>operation_name</code></strong></dt>
<dd>Optional name for logging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>RetryResult containing the final result and metadata</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult"><code class="flex name class">
<span>class <span class="ident">RetryResult</span></span>
<span>(</span><span>result: <a title="fin_statement_model.statements.utilities.result_types.Result" href="result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T],<br>attempts: int,<br>total_delay: float,<br>all_errors: list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RetryResult(Generic[T]):
    &#34;&#34;&#34;Result of a retry operation.

    Attributes:
        result: The final result (success or failure)
        attempts: Number of attempts made
        total_delay: Total delay time in seconds
        all_errors: All errors collected if configured
    &#34;&#34;&#34;

    result: Result[T]
    attempts: int
    total_delay: float
    all_errors: list[ErrorDetail] | None = None

    @property
    def success(self) -&gt; bool:
        &#34;&#34;&#34;Check if the operation eventually succeeded.&#34;&#34;&#34;
        return self.result.is_success()

    def unwrap(self) -&gt; T:
        &#34;&#34;&#34;Get the value or raise an exception.&#34;&#34;&#34;
        return self.result.unwrap()

    def unwrap_or(self, default: T) -&gt; T:
        &#34;&#34;&#34;Get the value or return default.&#34;&#34;&#34;
        return self.result.unwrap_or(default)</code></pre>
</details>
<div class="desc"><p>Result of a retry operation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>result</code></strong></dt>
<dd>The final result (success or failure)</dd>
<dt><strong><code>attempts</code></strong></dt>
<dd>Number of attempts made</dd>
<dt><strong><code>total_delay</code></strong></dt>
<dd>Total delay time in seconds</dd>
<dt><strong><code>all_errors</code></strong></dt>
<dd>All errors collected if configured</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.all_errors"><code class="name">var <span class="ident">all_errors</span> : list[<a title="fin_statement_model.statements.utilities.result_types.ErrorDetail" href="result_types.html#fin_statement_model.statements.utilities.result_types.ErrorDetail">ErrorDetail</a>] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.attempts"><code class="name">var <span class="ident">attempts</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.result"><code class="name">var <span class="ident">result</span> : <a title="fin_statement_model.statements.utilities.result_types.Result" href="result_types.html#fin_statement_model.statements.utilities.result_types.Result">Result</a>[~T]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.success"><code class="name">prop <span class="ident">success</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def success(self) -&gt; bool:
    &#34;&#34;&#34;Check if the operation eventually succeeded.&#34;&#34;&#34;
    return self.result.is_success()</code></pre>
</details>
<div class="desc"><p>Check if the operation eventually succeeded.</p></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.total_delay"><code class="name">var <span class="ident">total_delay</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>self) ‑> ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(self) -&gt; T:
    &#34;&#34;&#34;Get the value or raise an exception.&#34;&#34;&#34;
    return self.result.unwrap()</code></pre>
</details>
<div class="desc"><p>Get the value or raise an exception.</p></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryResult.unwrap_or"><code class="name flex">
<span>def <span class="ident">unwrap_or</span></span>(<span>self, default: ~T) ‑> ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_or(self, default: T) -&gt; T:
    &#34;&#34;&#34;Get the value or return default.&#34;&#34;&#34;
    return self.result.unwrap_or(default)</code></pre>
</details>
<div class="desc"><p>Get the value or return default.</p></div>
</dd>
</dl>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryStrategy"><code class="flex name class">
<span>class <span class="ident">RetryStrategy</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RetryStrategy(Enum):
    &#34;&#34;&#34;Strategy for determining when to retry.&#34;&#34;&#34;

    IMMEDIATE = &#34;immediate&#34;  # Retry immediately on failure
    BACKOFF = &#34;backoff&#34;  # Use backoff strategy between retries
    CONDITIONAL = &#34;conditional&#34;  # Retry only for specific error types</code></pre>
</details>
<div class="desc"><p>Strategy for determining when to retry.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryStrategy.BACKOFF"><code class="name">var <span class="ident">BACKOFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryStrategy.CONDITIONAL"><code class="name">var <span class="ident">CONDITIONAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fin_statement_model.statements.utilities.retry_handler.RetryStrategy.IMMEDIATE"><code class="name">var <span class="ident">IMMEDIATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fin_statement_model.statements.utilities" href="index.html">fin_statement_model.statements.utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.is_retryable_error" href="#fin_statement_model.statements.utilities.retry_handler.is_retryable_error">is_retryable_error</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.retry_on_specific_errors" href="#fin_statement_model.statements.utilities.retry_handler.retry_on_specific_errors">retry_on_specific_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.retry_with_exponential_backoff" href="#fin_statement_model.statements.utilities.retry_handler.retry_with_exponential_backoff">retry_with_exponential_backoff</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy">BackoffStrategy</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.BackoffStrategy.get_delay" href="#fin_statement_model.statements.utilities.retry_handler.BackoffStrategy.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.ConstantBackoff" href="#fin_statement_model.statements.utilities.retry_handler.ConstantBackoff">ConstantBackoff</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.ConstantBackoff.get_delay" href="#fin_statement_model.statements.utilities.retry_handler.ConstantBackoff.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff" href="#fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff">ExponentialBackoff</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff.get_delay" href="#fin_statement_model.statements.utilities.retry_handler.ExponentialBackoff.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.LinearBackoff" href="#fin_statement_model.statements.utilities.retry_handler.LinearBackoff">LinearBackoff</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.LinearBackoff.get_delay" href="#fin_statement_model.statements.utilities.retry_handler.LinearBackoff.get_delay">get_delay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig">RetryConfig</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig.backoff" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig.backoff">backoff</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig.collect_all_errors" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig.collect_all_errors">collect_all_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig.log_retries" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig.log_retries">log_retries</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig.max_attempts" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig.max_attempts">max_attempts</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig.retryable_errors" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig.retryable_errors">retryable_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryConfig.strategy" href="#fin_statement_model.statements.utilities.retry_handler.RetryConfig.strategy">strategy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryHandler" href="#fin_statement_model.statements.utilities.retry_handler.RetryHandler">RetryHandler</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryHandler.retry" href="#fin_statement_model.statements.utilities.retry_handler.RetryHandler.retry">retry</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryHandler.retry_async" href="#fin_statement_model.statements.utilities.retry_handler.RetryHandler.retry_async">retry_async</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult">RetryResult</a></code></h4>
<ul class="two-column">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.all_errors" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.all_errors">all_errors</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.attempts" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.attempts">attempts</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.result" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.result">result</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.success" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.success">success</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.total_delay" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.total_delay">total_delay</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.unwrap" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.unwrap">unwrap</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryResult.unwrap_or" href="#fin_statement_model.statements.utilities.retry_handler.RetryResult.unwrap_or">unwrap_or</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy" href="#fin_statement_model.statements.utilities.retry_handler.RetryStrategy">RetryStrategy</a></code></h4>
<ul class="">
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy.BACKOFF" href="#fin_statement_model.statements.utilities.retry_handler.RetryStrategy.BACKOFF">BACKOFF</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy.CONDITIONAL" href="#fin_statement_model.statements.utilities.retry_handler.RetryStrategy.CONDITIONAL">CONDITIONAL</a></code></li>
<li><code><a title="fin_statement_model.statements.utilities.retry_handler.RetryStrategy.IMMEDIATE" href="#fin_statement_model.statements.utilities.retry_handler.RetryStrategy.IMMEDIATE">IMMEDIATE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
